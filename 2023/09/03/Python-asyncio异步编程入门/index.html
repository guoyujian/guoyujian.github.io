<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Python asyncio异步编程入门"><meta name="keywords" content="Python,asyncio,异步编程"><meta name="author" content="Met Guo"><meta name="copyright" content="Met Guo"><title>Python asyncio异步编程入门 | Gmet's Blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.8.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.8.2"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"LEZCUKXOU8","apiKey":"43c226e390cd280e256d1d7cc0e6cce4","indexName":"blogs","hits":{"per_page":10,"input_placeholder":"Search for Posts","hits_empty":"û���ҵ�����Ҫ�Ľ��: ${query}","hits_stats":"�ҵ�${hits}���������ʱ${time}���룩"},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.2'
} </script><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Gmet's Blog" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E6%96%87"><span class="toc-number">1.</span> <span class="toc-text">正文</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Met Guo</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">91</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">74</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">48</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://images7.alphacoders.com/550/thumb-1920-550739.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Gmet's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/slides">Slides</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">Python asyncio异步编程入门</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-09-03</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Python/">Python</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Python/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/">异步编程</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">3.8k</span><span class="post-meta__separator">|</span><span>阅读时长: 13 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><blockquote>
<p>针对<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1oa411b7c9/?spm_id_from=333.337.search-card.all.click&amp;vd_source=53d8e50bea64fe70bc50c86af86d28e1">该视频</a>的一篇笔记</p>
<p>先决条件：协程、并发</p>
</blockquote>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>这次讲的是asyncio最新的用法，然后是Python 3. 7 以上才支持的，也是推荐大家学新不学旧。</p>
<p>asyncio并不能提升你的运算速度，它比较适合处理那些需要等待的任务^（应用场景）^，最典型的就是网络的通讯</p>
<p>那 asyncio的<strong>运算核心</strong>其实就是一个event loop，它就像一个大脑，它面对着很多可以执行的任务，然后决定执行哪个任务。那在 Python 的asyncio里，同时执行的任务只能有一个，它不存在系统级的上下文切换，它跟线程不一样，它需要每一个任务主动告诉event loop，我这边结束了，你可以让别的任务开始了。因此它有一个<strong>好处</strong>，就是不存在竞争冒险这样的问题，你可以明确的知道我每一个任务什么时候停止运算了。</p>
<p>那想要使用asyncio第一件事就是理解什么叫coroutine，什么叫task。</p>
<p>coroutine在 Python 的语境里，我们一般会指两种东西，一个是coroutine function，一个是coroutine object。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>( <span class="string">&#x27;world&#x27;</span>)</span><br><span class="line"></span><br><span class="line">coro = main()</span><br></pre></td></tr></table></figure>
<p>这个 async def main 就是一个coroutine function。Python 里面所有async def main开头的东西都叫coroutine function，它定义了一个 coroutine 的过程。那 Python 一般的函数，当我们调用它的时候，它返回的是这个函数的返回值，对不对？但是所有的 coroutine function，当你调用的时候，它返回的是一个coroutine object，它的本质跟生成器函数有些像。</p>
<p>就是当你在调用main的时候，它并不会运行 main 里面的程序，它只会返回一个coroutine object。</p>
<p>好，那怎么运行coroutine的代码？我们需要<strong>两件事</strong>，第一是进入async的模式，也就是进入这个 event loop，开始控制整个程序的状态。第二就是把coroutine变成task。</p>
<p>我们先说如何进入 async 模式，那我们正常写Python代码运行的时候，如果我们管它叫 synchronized 模式的话，那么在 synchronize 模式下切换到 asynchronized 模式，切换到让这个 event loop 开始控制一切。基本上我们只用一个入口函数叫做asyncio.run，那 asyncio.run，它的参数是一个coroutine，它会做两件事儿，第一它会建立起这个 event loop，第二它会把这个 coroutine 变成这个 event loop 里面的一个task，那 event loop 建立之后，他就会去找哪个 task 可以执行，那当然只有一个task，所以它就会开始运行 run 给进来的这个coroutine。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>( <span class="string">&#x27;world&#x27;</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>
<p>我们试一下，大家可以看到它先 print 了hello，然后等了 1 秒钟，然后 print 了world，那这个asyncio.run就是我们从 synchronize 模式变到 asynchronize 模式的入口，它的参数是一个coroutine。</p>
<p>那只有一个 task 是没有什么意思的，对不对？我们刚才也说过， event loop 的核心是它有很多很多个task，然后它来决定哪个 task 要运行。所以我们很重要的一件事情是，当我们已经处于 async 模式下的时候，我们如何增加task？接下来我们就介绍几个把coroutine变成task，让它可以排队执行的方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">say_after</span>(<span class="params">delay, what</span>):</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(delay)</span><br><span class="line">    <span class="built_in">print</span>(what)</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;started at <span class="subst">&#123;time.strftime(<span class="string">&#x27;%x&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> say_after(<span class="number">1</span>, <span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> say_after(<span class="number">2</span>,<span class="string">&quot;world&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;finished at <span class="subst">&#123;time.strftime(<span class="string">&#x27;%x&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">        </span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>
<p>大家看，我们有一个 say_after 函数，它显然是一个coroutine，对不对？它前面是async def，那实际上asyncio.sleep，它返回的东西也是一个 core routine，那这里就涉及到了<strong>第一个把coroutine变成 task 的方法</strong>，就是用await。</p>
<p>那么当你 await 一个<strong>coroutine</strong>的时候（上述代码第8行），发生了如下几件事，第一，这个coroutine被包装成一个task，并且被告诉了 event loop，说这块儿有一个新的task。第二，它会告诉 event loop，我现在这个 task （main）需要等到say_after task 完成之后，我才能继续它，建立了这么一个依赖关系。第三，它会 yield 出去，也就是它会告诉 event loop，我这个 task 现在干不了了，你先让别的 task 干活去吧。最后当 event loop 再次安排它运行的时候，它会把 say after 这个say_after 里面真正的返回值拿出来保存起来。当然现在我们这里await前面没有写，因为我们的 say after 是没有返回值的，好，那我们运行一下这段程序，我们可以看到差不多间隔一秒 print 一个hello，然后在两秒钟之后 print 了一个world。</p>
<p>我们来还原一下整个过程发生了一个什么事情。首先 asyncio.run把这个main作为一个 task 给放到了 event loop 里。 event loop 寻找task，他发现只有一个 task main，然后他就开始让这个 task main运行。may 你在运行的时候，首先 print 了一个 start at，然后它运行了 say_after 这个coroutine function，得到了一个coroutine object。await 把这个coroutine object变成了一个task，放回了 event loop 里，同时告诉 event loop 我需要等待它，然后把控制权交还给了 event loop。</p>
<p>现在 event loop 里面有两个task，一个是main，一个是这个 say_after，但是main运行不了， main说我要等这个 say after，那event loop，就让这个say_after先运行。</p>
<p><code>await asyncio.sleep(delay)</code>​ 这里其实做了一个很相似的事情，也是把它变成了一个task，然后告诉 event loop 说我得等这个 sleep 完成了我才能运行。然后 await 又把这个控制权转回给了 event loop。</p>
<p>event loop 一看现在有三个 task 对不对？有一个main，有一个 say_after，还有一个sleep，那这个 sleep 会告诉 event loop 说我一秒钟之后我就好了，所以这个 event loop 就等了一秒钟。一秒钟之后这个 sleep 就完成了。然后 event loop 看现在有两个task，一个main，一个 say after，这个 main 要等 say_after，但是这个 say after 等的东西已经完成了，于是 event loop 就说 say_after 你来运行吧，然后 say_after printed 一个what，然后 say_after 也完成了。于是又把控制权交还给 event loop。</p>
<p>event loop 一看，哎，现在只有一个 task 了，就成 main 了，然后再把控制权给main，这个时候 main就把第一个 say_after 完成了，然后再做第二个 say_after 做同样的事，又等了 2 秒之后它完成，所以整个过程用了 3 秒。</p>
<p>那在这个过程中，所有控制权的返回都是显式的，就是<strong>​ event loop 并没有办法强行的从一个 task 里边拿回控制权，必须要这个 task 主动把控制权交回去。</strong>交回去的方式有两种，第一个是await，会交回，第二个，当这个函数运行完毕之后，它会交回。所以说如果你有一个 task 里面有一个死循环，你的整个 event loop 就卡死了。</p>
<p>好，那刚才的运行过程中你可能发现了一个问题，对不对？这个 hello 要等 1 秒，这个 world 要等 2 秒，它俩为啥不能一起等呢？这就应该是我们协程的意义，对不对？在你第一个 hello 等 1 秒的时候，为什么这个 event loop 不能直接让这个 world 运行，然后你俩一起等着， 2 秒之后不就结束了吗？那这个呢？就是我们直接用 await 把一个 cooutine 变成 task 可能遇到的问题，因为 await 需要做的事太多了，它要变成task，它变成 task 之后会主动把控制权交出去，还需要等，这样后面的代码必须要等到它完成之后才能变成一个task。  </p>
<p>那为了解决这个问题， asyncio给我们提供了 create task 函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">say_after</span>(<span class="params">delay, what</span>):</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(delay)</span><br><span class="line">    <span class="built_in">print</span>(what)</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    task1 = asyncio.create_task(say_after(<span class="number">1</span>,<span class="string">&quot;hello&quot;</span>))</span><br><span class="line">    task2 = asyncio.create_task(say_after(<span class="number">2</span>,<span class="string">&#x27;world&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;started at <span class="subst">&#123;time.strftime( <span class="string">&#x27;%x&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> task1</span><br><span class="line">    <span class="keyword">await</span> task2</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;finished at <span class="subst">&#123;time.strftime(<span class="string">&#x27;%x&#x27;</span>)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>我们看这里用到的 create_task 函数，这个函数的参数也是一个coroutine。依然记住这个 say_after 调用之后返回的是一个coroutine，它不会运行任何 coroutine 里面的代码，那这个 create_task 函数会把这个coroutine变成一个task，并且把这个 task 注册到 event loop 里面。也就是说它分担了刚才 await 的一部分功能，它把它包装成了一个task，然后告诉 event loop 说OK，这个 task 已经可以开始执行了，但是现在 event loop 并没有办法执行这个task，因为控制权还在 main 的手里，对不对？那这个时候 main 趁着自己有控制权，他就做了第二个task。</p>
<p>task 2 也是告诉 main 这还有一个新的task，这叫 say_after 2 也可以运行了，那在这儿之后他才开始 await task_1 await task_2 那我们之前说过 await 后面是一个coroutine的时候，它有那么多个功能对不对？把它变成一个task，然后把控制权交出去，等它拿返回值。那当 await 后面是一个 task 而不是一个coroutine 的时候，它就省略了把 coroutine变成 task 这一步，它就只是告诉 event loop 我需要这个 task 完成，我把控制权交还给你，并且在控制权回来的时候，从这个 task 里面提取所需要的返回值。</p>
<p>好，我们跑一下这个程序试一下。我们看这一次这个程序就只用了 2 秒钟，因为当它 await task 1的时候， event loop 里面实际上已经有了 3 个task，是 main、task 1和 task 2。当 task 1跟 event loop 说完说我要等一秒钟才能完成，之后 event loop 闲来无事就能发现，这有一个 task 2 还可以执行，于是他又执行了 task 2，再跟他说我要两秒钟之后才能结束，这样两个 task 就可以同时进行等待了。</p>
<p>这也就是为什么asyncio很适合解决一些网络通讯的问题，因为网络通讯很多时间是在等待上的，也就是我们所谓的IO task，就是我真正的运算挺少的，我就是等他的回复，那等待的这个时间就可以其他的任务去干活。那这个函数我们没有涉及coroutine的return，所以我们把这个函数稍微修改一下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">say_after</span>(<span class="params">delay, what</span>):</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(delay)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;(what) - (delay)&quot;</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    task1 = asyncio.create_task(say_after(<span class="number">1</span>, <span class="string">&quot;he11o&quot;</span>))</span><br><span class="line">    task2 = asyncio.create_task(say_after(<span class="number">2</span>, <span class="string">&quot;world&quot;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;started at <span class="subst">&#123;time.strftime( <span class="string">&#x27;%x&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">    ret1 = <span class="keyword">await</span> task1</span><br><span class="line">    ret2 = <span class="keyword">await</span> task2</span><br><span class="line">    <span class="built_in">print</span>(ret1)</span><br><span class="line">    <span class="built_in">print</span>(ret2)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;finished at <span class="subst">&#123;time.strftime( <span class="string">&#x27;%x&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>
<p>我们看我们把函数修改了一下，主要就是告诉大家怎么拿到coroutine的 return。那当你要拿这个返回值的时候，一定是一个 variable 等于 await task，而不是一个 variable 等于 task。我们之前强调过， await 有一个功能是把这个 task 或者coroutine的这个返回值拿出来，如果你不用 await 是拿不到这个值的。</p>
<p>那有的人看到这可能说了，那如果我有很多 task 呢？我有，比如说 10 个task，我就写 10 行 await task 吗？这是不是太蠢了？正因如此， asyncio给我们提供了一个函数叫做gather。我们看 gather 这个函数，它不是一个coroutine，但是它会返回一个叫做 future 的东西，这个 future 也是可以用 await 的，那 gather 这个函数作用，首先它的参数是若干个 coroutine或者task，这俩都可以，甚至可以是future，也就是 gather 的 return 值。它还可以接着gather，那如果是coroutine的话，它首先会把它包装成task，并且注册到 event loop 里，然后它会返回一个 future 值。当你 await 这个 future 的时候，你就相当于告诉 event loop，我要等待这里面每一个 task 都完成，我才可以继续，同时会把这些 task 的 return 值放到一个 list 里，然后返回来。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">say_after</span>(<span class="params">delay, what</span>):</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(delay)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;(what) - <span class="subst">&#123;delay&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;started at <span class="subst">&#123;time.strftime( <span class="string">&#x27;%x&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">    ret = <span class="keyword">await</span> asyncio.gather(say_after(<span class="number">1</span>, <span class="string">&#x27;hello&#x27;</span>),</span><br><span class="line">                               say_after(<span class="number">2</span>, <span class="string">&quot;world&quot;</span>))</span><br><span class="line">    <span class="built_in">print</span>(ret)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;finished at <span class="subst">&#123;time.strftime( <span class="string">&#x27;%x&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>
<p>我们看一下这程序的结果，可以看到这次的这个 return value 是一个list，里面分别是 hello和world，<strong>那么这个 list 顺序和里面 task 的顺序是一致的</strong>，这样呢，我们就不用一个个 task await 了。</p>
<p>那 gather 还有一个好处就是如果你给的是coroutine的话，它会把每一个coroutine首先都变成task，也就是说我们可以不用自己手动先去建立这些 task 了。我们看一下上述代码结果，可以看到这种方式在拿到了正确的返回值的同时，它也只用了 2 秒。因为 gather 首先把这两个 coroutine 都变成了task，然后在 main 做 await 的时候才把控制权交回给了 event loop，这样 event loop 在分配哪一个 task 可以工作的时候，它就有更多的 task 可以分配了。</p>
<p>尽管asyncio里面还有不少的功能，但是掌握了这几个，基本上你就理解了asyncio的核心理念了。那我再强调一下前面提到过的几个重点。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>要建立一个 event loop 的概念，上面儿有一个 event loop 作为大脑，下面是若干可执行的task。 task 是没有办法控制 event loop 去执行某一个 task 的，它只能告诉 event loop 说我在等这个task。最终是由 event loop 来决定下面要运行哪个task，而 event loop 一旦开始运行task，就必须要 task 显示的把控制权交还给 event loop。交还控制权的方式由 await 和函数运行完毕。所以尽管我们会说这种协程的方式是并发的，但是同时刻实际上只有一段代码在跑，它只是想办法再利用这些代码中间的等待时间。所以如果你的代码里面并没有等待这件事的话，协程对你的代码是没有帮助的。</li>
<li>务必分清什么是coroutine，什么是task。 coroutine 只有变成了 task 才开始被执行。要能知道什么时候 coroutine 被隐式的变成了task，在你直接await coroutine 的时候，给你放到 gather 里的时候，你放进去的都是coroutine，但是它们会偷偷把它变成 task 执行coroutine，不变成 task 是没有办法执行的。</li>
<li>最后拿到一个 coroutine 的返回值是需要用 await 的。一个变量等于 await xxx。</li>
</ol>
<p>‍</p>
<p>‍</p>
<p>‍</p>
<p>‍</p>
<p>‍</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Met Guo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://guoyujian.github.io/2023/09/03/Python-asyncio%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/">https://guoyujian.github.io/2023/09/03/Python-asyncio%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://guoyujian.github.io">Gmet's Blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Python/">Python</a><a class="post-meta__tags" href="/tags/asyncio/">asyncio</a><a class="post-meta__tags" href="/tags/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/">异步编程</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2023/09/04/%E4%BD%A0%E7%9A%84%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%9C%89%E4%BB%80%E4%B9%88%E4%BA%AE%E7%82%B9%EF%BC%9F%E5%A6%82%E4%BD%95%E5%9B%9E%E7%AD%94%E6%89%8D%E8%83%BD%E5%BE%97%E5%88%B0%E9%9D%A2%E8%AF%95%E5%AE%98%E7%9A%84%E5%A5%BD%E6%84%9F/"><i class="fa fa-chevron-left">  </i><span>你的项目中有什么亮点？如何回答才能得到面试官的好感</span></a></div><div class="next-post pull-right"><a href="/2023/02/28/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"><span>分布式系统学习资料</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://images7.alphacoders.com/550/thumb-1920-550739.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2021 - 2025 By Met Guo</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.8.2"></script><script src="/js/fancybox.js?version=1.8.2"></script><script src="/js/sidebar.js?version=1.8.2"></script><script src="/js/copy.js?version=1.8.2"></script><script src="/js/fireworks.js?version=1.8.2"></script><script src="/js/transition.js?version=1.8.2"></script><script src="/js/scroll.js?version=1.8.2"></script><script src="/js/head.js?version=1.8.2"></script><script src="/js/search/algolia.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>