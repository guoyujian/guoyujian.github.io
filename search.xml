<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Union-Find并查集算法（Python实现）</title>
      <link href="/2023/12/24/Union-Find%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%AE%97%E6%B3%95%EF%BC%88Python%E5%AE%9E%E7%8E%B0%EF%BC%89/"/>
      <url>/2023/12/24/Union-Find%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%AE%97%E6%B3%95%EF%BC%88Python%E5%AE%9E%E7%8E%B0%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>这是并查集算法的Python实现：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UF</span>:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    并查集算法</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        初始化数据结构</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 初始化连通分量数量</span></span><br><span class="line">        self._count = n</span><br><span class="line">        <span class="comment"># 初始化双亲节点</span></span><br><span class="line">        self._parent = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="comment"># self.size[x]表示以x为根节点的节点数量</span></span><br><span class="line">        self._size = [<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self, x : <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        find root of x</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">while</span> self._parent[x] != x:</span><br><span class="line">            <span class="comment"># 路经压缩，将当前节点的双亲节点设为其双亲节点的双亲节点</span></span><br><span class="line">            self._parent[x] = self._parent[self._parent[x]]</span><br><span class="line">            x = self._parent[x]</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">union</span>(<span class="params">self, p: <span class="built_in">int</span>, q: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        union p and q</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 找到p和q的根节点</span></span><br><span class="line">        rootP = self.find(p)</span><br><span class="line">        rootQ = self.find(q)</span><br><span class="line">        <span class="keyword">if</span> rootP == rootQ:</span><br><span class="line">            <span class="comment"># 如果根节点相等，则pq本就联通</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 将小集合合并到大集合中，平衡性优化</span></span><br><span class="line">        <span class="keyword">if</span> self._size[rootP] &gt; self._size[rootQ]:</span><br><span class="line"></span><br><span class="line">            self._parent[rootQ] = rootP</span><br><span class="line">            self._size[rootP] += self._size[rootQ]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self._parent[rootP] = rootQ</span><br><span class="line">            self._size[rootQ] += self._size[rootP]</span><br><span class="line">        self._count -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">count</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        返回联通数</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> self._count</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">connected</span>(<span class="params">self, p, q</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        判断pq是否联通</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> self.find(q) == self.find(p)</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>参考：<a href="https://zhuanlan.zhihu.com/p/98406740">https://zhuanlan.zhihu.com/p/98406740</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 并查集算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 算法 </tag>
            
            <tag> 并查集 </tag>
            
            <tag> UnionFind </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>subprocess执行java命令残留进程解决</title>
      <link href="/2023/12/07/subprocess%E6%89%A7%E8%A1%8Cjava%E5%91%BD%E4%BB%A4%E6%AE%8B%E7%95%99%E8%BF%9B%E7%A8%8B%E8%A7%A3%E5%86%B3/"/>
      <url>/2023/12/07/subprocess%E6%89%A7%E8%A1%8Cjava%E5%91%BD%E4%BB%A4%E6%AE%8B%E7%95%99%E8%BF%9B%E7%A8%8B%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="问题简述"><a href="#问题简述" class="headerlink" title="问题简述"></a>问题简述</h1><blockquote><p>需求是通过Python执行命令java -java springboot-demo.jar</p><p>于是，我使用subprocess.Popen()来启停。但是我发现在关闭子进程后，java进程并没有正确关闭。</p><p>这是由于上面的方法实际原理是另外开启一个cmd命令来运行java -jar命令，后面用popen.terminate()也只能关闭cmd的命令，cmd命令被kill掉后，java进程由系统来托管，从而导致java进程并没有正确关闭。</p></blockquote><h1 id="Bug复现"><a href="#Bug复现" class="headerlink" title="Bug复现"></a>Bug复现</h1><p>执行代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"><span class="comment"># 执行java -jar</span></span><br><span class="line">t = subprocess.Popen([<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;springboot-demo.jar&quot;</span>])</span><br><span class="line"><span class="comment"># Popen是异步的，所以需要等待几秒，再关闭</span></span><br><span class="line">time.sleep(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 关闭子进程</span></span><br><span class="line">t.terminate()</span><br><span class="line"><span class="comment"># 等待关闭结束</span></span><br><span class="line">t.wait()</span><br></pre></td></tr></table></figure><p>发现残留的java进程</p><p><img src="image.png" alt="image"></p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我的解决思路是，稍微修改java代码，在执行java -jar命令后，将java进程id（pid）暴露出来。</p><p>当需要关闭程序时，读取暴露出来的java进程id，使用kill命令，将进程杀死。</p><h2 id="详述"><a href="#详述" class="headerlink" title="详述"></a>详述</h2><p>首先修改java代码，我使用的代码框架是springboot，所以在springboot的启动类上修改如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringbootDemoApplication</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">SpringApplication</span> <span class="variable">application</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpringApplication</span>(SpringbootDemoApplication.class);</span><br><span class="line"><span class="comment">// 获取jar包执行的路径</span></span><br><span class="line"><span class="type">ApplicationHome</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ApplicationHome</span>(SpringbootDemoApplication.class);</span><br><span class="line"><span class="type">File</span> <span class="variable">source</span> <span class="operator">=</span> h.getSource();</span><br><span class="line">System.out.println(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt;&lt; jar 执行目录：&quot;</span> + source.getParentFile().toString() + <span class="string">&quot; &gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">app_pid_file</span> <span class="operator">=</span> source.getParentFile().toString() + <span class="string">&quot;\\app.pid&quot;</span>;</span><br><span class="line">application.addListeners(<span class="keyword">new</span> <span class="title class_">ApplicationPidFileWriter</span>(app_pid_file)); <span class="comment">// 把进程号放到这个文件中</span></span><br><span class="line">application.run();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，</p><ul><li>source.getParentFile().toString()可以获得jar包所在的目录。</li><li>application.addListeners(new ApplicationPidFileWriter(app_pid_file));将在jar包同级目录下生成app.pid的文件，该文件中写入了springboot运行的进程号</li></ul><p>然后修改Python代码</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">JAR_DIR = <span class="string">&#x27;XXX&#x27;</span> <span class="comment"># jar包所在目录</span></span><br><span class="line"><span class="comment"># 执行java -jar</span></span><br><span class="line">t = subprocess.Popen([<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, os.path.join(<span class="string">f&quot;<span class="subst">&#123;JAR_DIR&#125;</span>&quot;</span>, <span class="string">&quot;springboot-demo.jar&quot;</span>])</span><br><span class="line"><span class="comment"># Popen是异步的，所以需要等待几秒，再关闭</span></span><br><span class="line">time.sleep(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 关闭子进程</span></span><br><span class="line">t.terminate()</span><br><span class="line"><span class="comment"># 等待关闭结束</span></span><br><span class="line">t.wait()</span><br><span class="line"><span class="comment"># 关闭java进程</span></span><br><span class="line">app_pid_file_path = os.path.join(JAR_DIR, <span class="string">&quot;app.pid&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> os.path.exists(app_pid_file_path):</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(app_pid_file_path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">pid = f.read()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;正在关闭java 进程, pid： <span class="subst">&#123;<span class="built_in">int</span>(pid)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># 在windows系统下执行杀死进程的命令，其他系统可能命令不同</span></span><br><span class="line">subprocess.run([<span class="string">&quot;cmd&quot;</span>, <span class="string">&quot;/c&quot;</span>, <span class="string">&quot;taskkill&quot;</span>, <span class="string">&quot;/pid&quot;</span>, <span class="string">f&#x27;<span class="subst">&#123;<span class="built_in">int</span>(pid)&#125;</span>&#x27;</span>, <span class="string">&quot;-f&quot;</span>])</span><br><span class="line">os.remove(app_pid_file_path) <span class="comment"># 删除app.pid文件</span></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>无</p><h1 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h1><ol><li><a href="https://blog.csdn.net/skyli114/article/details/127324383">subprocess.Popen执行程序以及关闭进程</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CC+Open3d解决大型点云数据加载和计算问题</title>
      <link href="/2023/11/29/CC-Open3d%E8%A7%A3%E5%86%B3%E5%A4%A7%E5%9E%8B%E7%82%B9%E4%BA%91%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD%E5%92%8C%E8%AE%A1%E7%AE%97%E9%97%AE%E9%A2%98/"/>
      <url>/2023/11/29/CC-Open3d%E8%A7%A3%E5%86%B3%E5%A4%A7%E5%9E%8B%E7%82%B9%E4%BA%91%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD%E5%92%8C%E8%AE%A1%E7%AE%97%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>雷达扫描的点云数据量往往很大，而其中存在大量不需要的点。</p><p>例如我只需要某个小模型的点云，但雷达将周围的环境也一并扫描进来了，这些环境点云我并不需要。</p><p>现在我需要测量这个小模型的某些属性。（比如长宽）</p><p>此时如果直接在全部点云数据下进行测量，将这些点云加载出来都是一个很大的问题。在我的机器上，使用Cloud Compare载入1.3亿数量级的点云数据直接卡死。</p><p>通常情况下，可以通过体素降采样的方式（例如体素值为2dm）极大缩小点云的数量，但我的需求是希望计算小模型的长宽，其误差不超过5cm。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>因此我的做法如图所示：</p><p><img src="未命名绘图.drawio-20231129175149-u5ss8y9.png" alt="未命名绘图.drawio">​​</p><ol><li>首先为了能够将点云展示出来，我要极大的下采样点云，这里我取参数为0.2（2dm），得到下采样后的点云1</li><li>使用CC加载点云1，并可视化裁剪点云，得到裁剪立方体的参数，包括立方体的中心，长宽高，旋转等</li><li>使用上一步的得到的参数去裁剪原始点云，极大的减少了点云数量</li><li>将裁减后的点云下采样，为了保证精度，这次下采样率为0.01（1cm），得到点云2</li><li>可视化点云2，并进行测量，得到结果。</li></ol><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><h2 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h2><p>编写python脚本并导入到CC，执行该脚本，将点云1加载到CC中</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pycc</span><br><span class="line"><span class="keyword">import</span> cccorelib</span><br><span class="line"></span><br><span class="line">cc = pycc.GetInstance()</span><br><span class="line"><span class="keyword">import</span> open3d <span class="keyword">as</span> o3d</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># open PointCloud with 139032791 points.</span></span><br><span class="line">pcd: o3d.geometry.PointCloud = o3d.io.read_point_cloud(<span class="string">r&quot;origin.pcd&quot;</span>)</span><br><span class="line"><span class="comment"># 调整合适的降采样率</span></span><br><span class="line">pcd = pcd.voxel_down_sample(<span class="number">0.2</span>) <span class="comment">#</span></span><br><span class="line">points = np.asarray(pcd.points)</span><br><span class="line"></span><br><span class="line">xs = points[:, <span class="number">0</span>]</span><br><span class="line">ys = points[:, <span class="number">1</span>]</span><br><span class="line">zs = points[:, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">pc = pycc.ccPointCloud(xs, ys, zs)</span><br><span class="line"><span class="comment"># load</span></span><br><span class="line">cc.addToDB(pc)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h2><p>在CC中对点云进行切片，得到想要的部分点云的裁剪立方体参数。</p><p><img src="image-20231129175946-c305vb2.png" alt="裁剪前"></p><p><img src="image-20231129180213-3vc0ov2.png" alt="裁剪后">​</p><p>如图分别是裁剪前后的效果图，裁剪后的红框里是裁剪立方体的参数。复制下来后面要用到。</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">transformation matrix:</span><br><span class="line">0.987671196461 -0.156546846032 0.000000000000 3.480050563812</span><br><span class="line">0.156546846032 0.987671196461 0.000000000000 -3.573182106018</span><br><span class="line">0.000000000000 0.000000000000 1.000001311302 2.071678161621</span><br><span class="line">0.000000000000 0.000000000000 0.000000000000 1.000000000000</span><br><span class="line"></span><br><span class="line">长宽高：</span><br><span class="line">X: 6.21198273</span><br><span class="line">Y: 13.27857590</span><br><span class="line">Z: 9.57320881</span><br></pre></td></tr></table></figure><h2 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h2><p>由上述的参数可以知道该立方体的中心点是<code>(3.480050563812, -3.573182106018, 2.071678161621)</code>​，旋转矩阵为</p><script type="math/tex; mode=display">\begin{bmatrix}0.987671196461&-0.156546846032&0.000000000000\\0.156546846032&0.987671196461&0.000000000000\\0.000000000000&0.000000000000&1.000001311302\\\end{bmatrix}</script><p>长宽高为<code>(6.21198273, 13.27857590, 9.57320881)</code>​</p><p>因此可以写代码使用open3d来裁剪原始点云：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pcd: o3d.geometry.PointCloud = o3d.io.read_point_cloud(<span class="string">r&quot;origin.pcd&quot;</span>)</span><br><span class="line">   <span class="comment"># 画一个&quot;盒子&quot;，将盒子外的点云去掉，</span></span><br><span class="line">   obx = o3d.geometry.OrientedBoundingBox(</span><br><span class="line">       np.array([<span class="number">3.480050563812</span>, -<span class="number">3.573182106018</span>, <span class="number">2.071678161621</span>]), <span class="comment"># center</span></span><br><span class="line">       np.array([</span><br><span class="line">           [<span class="number">0.987671196461</span>, -<span class="number">0.156546846032</span>, <span class="number">0.000000000000</span>],</span><br><span class="line">           [<span class="number">0.156546846032</span>, <span class="number">0.987671196461</span>, <span class="number">0.000000000000</span>],</span><br><span class="line">           [<span class="number">0.000000000000</span>, <span class="number">0.000000000000</span>, <span class="number">1.000001311302</span>]</span><br><span class="line">       ]), <span class="comment"># rotation</span></span><br><span class="line">       np.array([<span class="number">6.21198273</span>, <span class="number">13.27857590</span>, <span class="number">9.57320881</span>]) <span class="comment"># width, depth, height</span></span><br><span class="line">   )</span><br><span class="line">   pcd_cropped = pcd.crop(obx) <span class="comment"># 裁剪后的点云</span></span><br><span class="line">pcd_cropped = pcd_cropped.voxel_down_sample(<span class="number">0.01</span>) <span class="comment"># 第二次降采样</span></span><br><span class="line">   o3d.io.write_point_cloud(<span class="string">&#x27;cropped.pcd&#x27;</span>, pcd_cropped) <span class="comment"># save </span></span><br></pre></td></tr></table></figure><h2 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h2><p>经过这些步骤后，点云数据量从1.3亿降到了840万。将这个<code>cropped.pcd</code>​拿到CC中打开，并测量。（图略）</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文方法既解决了大规模点云数据加载卡死、操作困难的问题，又能精确得到计算结果。</p><p>不过流程可以再优化，更自动化一些。</p><h1 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h1><p>无</p>]]></content>
      
      
      <categories>
          
          <category> 点云数据处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CloudCompare </tag>
            
            <tag> Point Cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CloudCompare常用操作及Python插件</title>
      <link href="/2023/11/28/CloudCompare%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%8F%8APython%E6%8F%92%E4%BB%B6/"/>
      <url>/2023/11/28/CloudCompare%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%8F%8APython%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>最近在做点云处理相关的工作，这里找到了一个非常好用的开源软件CloudCompare（下称CC）。这里对我的常用操作进行总结，并介绍CC的Python插件，该插件可以实现自定义的点云操作实现，极大地扩展了CC的功能。</p></blockquote><h1 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h1><h2 id="点云按高程赋色"><a href="#点云按高程赋色" class="headerlink" title="点云按高程赋色"></a>点云按高程赋色</h2><p>打开的点云没有颜色，很难看且很难操作，为了让点云更有立体感，可以按高程对点云进行赋色。</p><p><code>Edit -&gt; Colors -&gt; Height Ramp</code></p><p><img src="wps1-20231128113644-3f440qp.jpg" alt="img"></p><p>CC也可以按照其他轴进行赋色</p><p><code>Edit -&gt; Scalar fields -&gt; export coordinate to SF</code>， 选择x/y/z轴</p><p><img src="wps2-20231128113644-ecarnyw.jpg" alt="img"></p><p><img src="wps3-20231128113644-ibdm0ik.jpg" alt="img"></p><h2 id="使用多边形对点云裁剪"><a href="#使用多边形对点云裁剪" class="headerlink" title="使用多边形对点云裁剪"></a>使用多边形对点云裁剪</h2><p><a href="https://blog.csdn.net/qq_32867925/article/details/124187166">https://blog.csdn.net/qq_32867925/article/details/124187166</a></p><h2 id="计算点云中两个点之间的距离"><a href="#计算点云中两个点之间的距离" class="headerlink" title="计算点云中两个点之间的距离"></a>计算点云中两个点之间的距离</h2><p><a href="https://blog.csdn.net/qq_36686437/article/details/122224036">https://blog.csdn.net/qq_36686437/article/details/122224036</a></p><h2 id="下采样"><a href="#下采样" class="headerlink" title="下采样"></a>下采样</h2><p><a href="https://blog.csdn.net/qq_27353621/article/details/124008810">https://blog.csdn.net/qq_27353621/article/details/124008810</a></p><h2 id="统计滤波"><a href="#统计滤波" class="headerlink" title="统计滤波"></a>统计滤波</h2><p><a href="https://blog.csdn.net/qq_36686437/article/details/120011047">https://blog.csdn.net/qq_36686437/article/details/120011047</a></p><p>CC好像没有实现半径滤波，需要自行实现</p><h2 id="计算体积"><a href="#计算体积" class="headerlink" title="计算体积"></a>计算体积</h2><p><a href="https://www.cnblogs.com/codeAndlearn/p/12317673.html">https://www.cnblogs.com/codeAndlearn/p/12317673.html</a></p><p>CC计算的并非是点云的凸包体积，CC好像没有实现凸包体积计算，需要自行实现</p><h2 id="创建球并移动，计算球和球之间的距离"><a href="#创建球并移动，计算球和球之间的距离" class="headerlink" title="创建球并移动，计算球和球之间的距离"></a>创建球并移动，计算球和球之间的距离</h2><p>有时需要计算两点之间的距离，但是这两点虽然代表点云但并不在点云集合中，需要自定义位置。我们可以创建两个球，然后将它们拖动到指定位置，然后再计算距离。</p><p>首先，创建球</p><p><code>File -&gt; Primitive Factory</code>，选择sphere，确定位置和半径</p><p><img src="wps4-20231128113644-n938rmx.jpg?lastModify=1701152207" alt="img"></p><p>然后拖动球：选中球，并点选下图图标。鼠标右键拖动。</p><p><img src="wps5-20231128113644-mbw49ys.jpg" alt="img"></p><p>将两个球拖动到合适的位置，计算距离</p><p><img src="wps6-20231128113644-oc6tpfo.jpg?lastModify=1701152207" alt="img"></p><h2 id="更多操作"><a href="#更多操作" class="headerlink" title="更多操作"></a>更多操作</h2><p>这里有人总结了CC的操作，非常全面。</p><p><a href="https://blog.csdn.net/qq_36686437/article/details/120100839">https://blog.csdn.net/qq_36686437/article/details/120100839</a></p><h1 id="CC-Python插件"><a href="#CC-Python插件" class="headerlink" title="CC-Python插件"></a>CC-Python插件</h1><h2 id="前置条件-Win10"><a href="#前置条件-Win10" class="headerlink" title="前置条件(Win10)"></a>前置条件(Win10)</h2><p>使用该插件需要安装最新版的CC，我安装的版本是2.13</p><p><img src="image-20231128114621-bo1kz5e.png" alt="image"></p><p>在安装时，记得勾选</p><p><img src="image-20231128114706-bwwrkfk.png" alt="image"></p><blockquote><p>Windows是直接带有这个插件的，而MacOS下安装该插件需要自己去编译插件代码并安装。</p><p>这是插件代码的文档：<a href="https://tmontaigu.github.io/CloudCompare-PythonPlugin/">https://tmontaigu.github.io/CloudCompare-PythonPlugin/</a></p><p>包括如何编译源码&amp;Useage</p></blockquote><p>安装完成后，记得更新一下pip：</p><p>进入安装目录下<code>CloudCompare/plugins/Python</code>，执行<code>.\python.exe -m pip install --upgrade pip</code></p><h2 id="使用插件示例"><a href="#使用插件示例" class="headerlink" title="使用插件示例"></a>使用插件示例</h2><p>有些点云文件巨大，加载进来会很慢，我这里先将点云降采样之后才把他加载到CC中。</p><p>为了方便，我需要安装open3d</p><p>打开Python Manager： <code>Plugins -&gt; Python Plugins -&gt; Package Manager</code></p><p><img src="image-20231128120020-x27frq0.png" alt="image">点击install，输入open3d 进行安装。</p><p><img src="image-20231128120130-6obtvph.png" alt="image"></p><p>打开Show REPL： <code>Plugins -&gt; Python Plugins -&gt; Show REPL</code></p><p>红框输入指令</p><p><img src="image-20231128120448-c9cul9e.png" alt="image"></p><p>以下是我输入的指令</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pycc</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> cccorelib</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cc = pycc.GetInstance()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> open3d <span class="keyword">as</span> o3d</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pcd = o3d.io.read_point_cloud(<span class="string">&#x27;C:/Users/Administrator/Desktop/merged_room.pcd&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pcd = pcd.voxel_down_sample(<span class="number">0.5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>points = np.asarray(pcd.points)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>xs = points[:, <span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ys = points[:, <span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>zs = points[:, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pc = pycc.ccPointCloud(xs, ys, zs)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cc.addToDB(pc)</span><br></pre></td></tr></table></figure><p>至此可以看到CC场景中已经加载了点云</p><p><img src="image-20231128120849-90hz4hw.png" alt="image"></p><p>我们可以用插件实现前面CC未实现的诸多功能。更多用法可以参考前文提到的插件的官方文档。</p><h1 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h1>]]></content>
      
      
      <categories>
          
          <category> 点云数据处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CloudCompare </tag>
            
            <tag> Point Cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPU密集型任务的后端实现方法比较总结</title>
      <link href="/2023/10/19/CPU%E5%AF%86%E9%9B%86%E5%9E%8B%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%90%8E%E7%AB%AF%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E6%AF%94%E8%BE%83%E6%80%BB%E7%BB%93/"/>
      <url>/2023/10/19/CPU%E5%AF%86%E9%9B%86%E5%9E%8B%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%90%8E%E7%AB%AF%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E6%AF%94%E8%BE%83%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>先介绍下整体系统框架，系统分为前端和后端，二者通过websocket协议进行通信。通过请求数据中的code字段来响应不同的操作。</p><p><img src="前后端通信.png" alt="前后端通信"></p><p><img src="时序图.png" alt="时序图"></p><p><img src="后端处理一次请求的流程图.png" alt="后端处理一次请求的流程图"></p><p>以上介绍整体的软件逻辑。此外，后端使用Python的asyncio来实现异步编程。</p><p>例如，实现将数据插入到数据库并将数据发送到前端：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">insert_data2db(data)</span><br><span class="line">ws_send(websocket, data)</span><br></pre></td></tr></table></figure><p>此时程序是顺序执行的。异步版本如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> insert_data2db(data)</span><br><span class="line"><span class="keyword">await</span> ws_send(websocket, data)</span><br></pre></td></tr></table></figure><p>此时，程序不会等待insert_data2db完成，直接继续执行ws_send方法。两者区别如下草图：</p><p><img src="同步异步.png" alt="同步异步"></p><p>这种异步的方式在IO-Bound Task中好用。但是对于CPU-Bound Task优化效果不大（甚至会有反效果）</p><p>此外，如果后一个操作需要用到前一个操作的结果，这个代码实际是顺序执行的。</p><h1 id="主要代码结构（伪）"><a href="#主要代码结构（伪）" class="headerlink" title="主要代码结构（伪）"></a>主要代码结构（伪）</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">ws_send</span>(<span class="params">websocket, data</span>)</span><br><span class="line"><span class="keyword">await</span> websocket.send(data)</span><br></pre></td></tr></table></figure><p>首先是通过websocket连接将数据发送回前端的通用方法</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">dealPointCloudData</span>(<span class="params">websocket, request_data</span>):</span><br><span class="line">code = request_data[<span class="string">&#x27;code&#x27;</span>]</span><br><span class="line"><span class="keyword">if</span> code == <span class="number">0</span>:</span><br><span class="line"><span class="comment"># 心跳</span></span><br><span class="line"><span class="keyword">await</span> ws_send(websocket, response_heartbeat_data)</span><br><span class="line"><span class="keyword">elif</span> code == <span class="number">1</span>:</span><br><span class="line"><span class="keyword">await</span> func1()</span><br><span class="line"><span class="keyword">elif</span> code == <span class="number">2</span>:</span><br><span class="line"><span class="keyword">await</span> func2(websocket, request_data)</span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure><p>其次，是分发请求的方法dealPointCloudData，它有两个参数，websocket连接和request_data前端发来的数据。</p><p>最后，主程序中会起一个websocket服务器，服务器会将连接发送到dispatch方法，dispatch方法会轮询每一个websocket连接的消息，并交给dealPointCloudData处理。伪代码如下。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">server = websockets.serve(dispatch, ip, port)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">dispatch</span>(<span class="params">websocket_conn</span>):</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">for</span> message <span class="keyword">in</span> websocket:  <span class="comment"># recv message from a websocket client.</span></span><br><span class="line">msg_dict = parse_json(message)</span><br><span class="line"><span class="keyword">await</span> dealPointCloudData(websocket, msg_dict)</span><br></pre></td></tr></table></figure><h1 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h1><p>目前，当code==2时，需要处理一个计算任务。request_data参数中有一个文件夹路径，该计算任务是读取文件夹下的所有文件内容，将文件内容进行merge，最终生成一个完整的文件。流程如下：</p><p><img src="计算流程.png" alt="计算流程"></p><p>伪代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func2</span>(<span class="params">websocket, request_data</span>):</span><br><span class="line">total = init()</span><br><span class="line">file_list = get_file_list(request_data) <span class="comment"># 从request_data中取出文件夹，</span></span><br><span class="line"><span class="keyword">for</span> i, file_path <span class="keyword">in</span> <span class="built_in">enumerate</span>(file_list):</span><br><span class="line">obj = read_file_as_obj(file_path)</span><br><span class="line">total = merge(total, obj)</span><br><span class="line"><span class="keyword">await</span> ws_send(websocket, <span class="string">&#x27;进度：...&#x27;</span>) <span class="comment"># 本次merge结束后向前端发送进度</span></span><br><span class="line">save2file(total)</span><br><span class="line"><span class="keyword">await</span> ws_send(websocket, finish_flag)</span><br></pre></td></tr></table></figure><p>由于func2主要时间花费在一个for循环中， 每次for循环中都有一个耗时的计算任务merge。merge是一个同步方法</p><p>所以func2中虽然使用了await异步编程，但整体来看，还是个同步处理程序。</p><p>这就导致一个严重的问题，就是当单线程执行func2进行长时间计算的时候，新的心跳包请求-响应会被阻塞掉。如图</p><p><img src="心跳响应阻塞.png" alt="心跳响应阻塞"></p><p>如果阻塞的时间过长，前后端就会失去本次连接。</p><p>针对该问题，我尝试了几种解决方法。</p><h1 id="尝试"><a href="#尝试" class="headerlink" title="尝试"></a>尝试</h1><h2 id="1-开启线程执行计算（merge）"><a href="#1-开启线程执行计算（merge）" class="headerlink" title="1 开启线程执行计算（merge）"></a>1 开启线程执行计算（merge）</h2><p>func2函数中开启一个新的线程执行计算，并返回数据。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func2</span>(<span class="params">websocket, request_data</span>):</span><br><span class="line">    t = DealPcdsThread(websocket, other_params)</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure><p>DealPcdsThread线程类的实现如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DealPcdsThread</span>(threading.Thread):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    处理pcd文件夹的线程</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, websocket, request_data</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        file_list = get_file_list(request_data)</span><br><span class="line">        self.websocket = websocket</span><br><span class="line">        self.file_list = file_list </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        asyncio.run(self.merge()) <span class="comment"># 在线程中开启新的事件循环来执行协程函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">self</span>):</span><br><span class="line">        total = init()</span><br><span class="line">file_list = get_file_list(request_data) <span class="comment"># 从request_data中取出文件夹，</span></span><br><span class="line"><span class="keyword">for</span> i, file_path <span class="keyword">in</span> <span class="built_in">enumerate</span>(file_list):</span><br><span class="line">obj = read_file_as_obj(file_path)</span><br><span class="line">total = merge(total, obj)</span><br><span class="line">log.info(<span class="string">f&#x27;...&#x27;</span>)</span><br><span class="line"><span class="keyword">await</span> ws_send(websocket, <span class="string">&#x27;进度：...&#x27;</span>) <span class="comment"># 本次merge结束后向前端发送进度</span></span><br><span class="line">save2file(total)</span><br><span class="line"><span class="keyword">await</span> ws_send(websocket, finish_flag)</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>浏览器控制台日志如图：</p><p><img src="控制台日志.png" alt="控制台日志"></p><p>这说明在处理计算任务时，主线程没有阻塞，心跳包能够正常返回，和预期一致。</p><p>本来问题到这里就解决了，但是在实际测试中又发现了其他问题。</p><h3 id="问题1-前端显示不流畅"><a href="#问题1-前端显示不流畅" class="headerlink" title="问题1: 前端显示不流畅"></a>问题1: 前端显示不流畅</h3><p><img src="合成进度条.gif" alt="合成进度条"></p><p>如图可以看到进度条卡在2.21%后，过了几秒非常迅速的蹦到了40.79%。但是后台的日志打印是“流畅的”，即没有类似的停顿。</p><p>猜测可能是和异步有关，毕竟在<code>await ws_send()</code>​后直接返回了，事件循环选择了某个时间点统一发送这些请求。</p><p>一开始还以为是计算线程失去了CPU的控制权导致的，后来一想可能性不大，一方面占用时间应该在很短的时间，我应该感觉不到，另一方面，后台日志打印流畅。</p><h3 id="问题2-后台报错"><a href="#问题2-后台报错" class="headerlink" title="问题2: 后台报错"></a>问题2: 后台报错</h3><p>在执行计算的过程，出现报错如下图</p><p><img src="报错.png" alt="报错"></p><p>该报错我搜索了很久也没有找到解决方案，在加上该报错不会导致任务失败，也不会有其他影响。所以搁置了。</p><p>该方案是目前最好的解决方案，我也尝试了很多其他解决方案。这里也一并列出。</p><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p>方案2与方案1相同，同样是开启新线程执行合并，只是新的事件循环有主线程创建，而非在新线程中创建。测试这两种方法表现一致。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func2</span>(<span class="params">websocket, request_data</span>):</span><br><span class="line">new_loop: AbstractEventLoop = asyncio.new_event_loop()</span><br><span class="line">    <span class="comment"># 定义</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start_loop</span>(<span class="params">loop: AbstractEventLoop</span>):</span><br><span class="line">        asyncio.set_event_loop(loop)</span><br><span class="line">        loop.run_forever()</span><br><span class="line">    <span class="comment">#通过当前线程开启新的线程启动事件循环</span></span><br><span class="line">    t = threading.Thread(target=start_loop, args= (new_loop,))</span><br><span class="line">    t.start()</span><br><span class="line">    asyncio.run_coroutine_threadsafe(</span><br><span class="line">        DealPcdsThread(websocket, request_data).merge(),</span><br><span class="line">        new_loop</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><p>使用asyncio.run_in_executor将任务放到线程池中运行</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func2</span>(<span class="params">websocket, request_data</span>):</span><br><span class="line"><span class="comment"># 4.4 使用asyncio.run_in_executor将任务放到线程池中运行。效果和4.2一样</span></span><br><span class="line">loop: AbstractEventLoop = asyncio.get_event_loop()</span><br><span class="line"><span class="keyword">await</span> loop.run_in_executor(<span class="literal">None</span>, DealPcdsThread(websocket, request_data).run)</span><br><span class="line"><span class="comment"># await asyncio.to_thread(DealPcdsNoThread.run, loop) # new py3.9</span></span><br></pre></td></tr></table></figure><p>测试说明，这种方法会阻塞主线程，导致心跳包无法及时响应。。</p><h2 id="4"><a href="#4" class="headerlink" title="4"></a>4</h2><p>为了加快计算的速度，想到尝试开启新的进程执行计算。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Process(target=merge, args=(websocket, request_data)).start()</span><br></pre></td></tr></table></figure><p>但是没想到，进程之间传递的Python对象必须可以被序列化（pickle）才可以，而websocket对象不能被序列化，所以这种方法无效。</p><h2 id="5"><a href="#5" class="headerlink" title="5"></a>5</h2><p>最后一种，同样也是开启一个新的线程，不过target传入的是异步计算方法（虽然是异步的，但是内部确是同步的。。。）</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">threading.Thread(target=<span class="keyword">await</span> DealPcdsThread(websocket, request_data).merge()).start()</span><br></pre></td></tr></table></figure><p>这种方法也会阻塞主线程。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>在实验过程中，我发现凡是开启新线程并且新线程中使用新的事件循环来处理发送请求都可以让主线程不阻塞。例如方案1、2</p><p>但是如果只开新线程，而事件循环依然使用主线程loop的话，不能解决主线程阻塞的问题。例如方案3、5</p><h1 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h1><ol><li>用<code>concurrent.futures.ThreadPoolExecutor</code>​替换threading。<code>concurrent.futures.ThreadPoolExecutor</code>​提供了一个高层级接口用来向后台线程推送任务而不会阻塞调用方线程的执行，同时仍然能够在需要时获取任务的结果。</li><li>先读出所有的文件到内存中，放到一个数组里，再开启多进程对这个数组的点云数据进行reduce。利用多核加快合并速度？</li><li>其实我觉得最好的方式是，开启一个线程执行计算任务，线程类中有一个指示进度的变量。在主线程中使用一个协程每隔X秒获取一次进度并将其发送给前端。但是这种方式无法做到实时。</li><li>什么时候Python可以去掉GIL的限制，让这种计算密集型任务能够充分利用多核CPU。。。😢</li></ol>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> asyncio </tag>
            
            <tag> websocket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 面试题</title>
      <link href="/2023/10/07/Python-%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2023/10/07/Python-%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<blockquote><p>记一次Python面试被问到的题</p></blockquote><h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=&#123;<span class="number">1</span>:<span class="number">2</span>,<span class="number">2</span>:<span class="number">3</span>&#125;</span><br><span class="line">b=a</span><br><span class="line">b.pop(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><p>问：a的输出是什么？</p><p>答：<code>&#123;2:3&#125;</code>​</p><h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b=[[]]*<span class="number">2</span>; b[<span class="number">0</span>].append(<span class="number">1</span>); <span class="built_in">print</span>(b)</span><br><span class="line">a=[]; b=[a]*<span class="number">2</span>; b[<span class="number">0</span>].append(<span class="number">1</span>); <span class="built_in">print</span>(b)</span><br><span class="line">a=[]; b=[a, a]; b[<span class="number">0</span>].append(<span class="number">1</span>); <span class="built_in">print</span>(b)</span><br><span class="line">b=[[], []]; b[<span class="number">0</span>].append(<span class="number">1</span>); <span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure><p>问：这四个<code>b</code>​的输出是什么？</p><p>答：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[[1], [1]]</span><br><span class="line">[[1], [1]]</span><br><span class="line">[[1], [1]]</span><br><span class="line">[[1], []]</span><br></pre></td></tr></table></figure><h1 id="3"><a href="#3" class="headerlink" title="3"></a>3</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a=&quot;123&quot;; b=a; b=b[:-1]; </span><br><span class="line">print(a, b)</span><br></pre></td></tr></table></figure><p>问：输出？</p><p>答：<code>123 12</code>​</p><h1 id="4"><a href="#4" class="headerlink" title="4"></a>4</h1><p>比较以下两段代码的执行效率和内存开销</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">res = 1</span><br><span class="line">for num in [1,2,3,4]+[6,7,8,9]:</span><br><span class="line">    res *= num</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import itertools</span><br><span class="line">res = 1</span><br><span class="line">for num in itertools.chain([1,2,3,4], [6,7,8,9]):</span><br><span class="line">    res *= num</span><br></pre></td></tr></table></figure><p><a href="https://docs.python.org/3/library/itertools.html">https://docs.python.org/3/library/itertools.html</a></p><p>答：首先第一个代码需要将两个列表和并为一个列表，而第二段代码是直接遍历两个列表，其次itertools.chain返回的是一个生成器，所以第二个代码的执行效率高，内存开销小。</p><h1 id="5"><a href="#5" class="headerlink" title="5"></a>5</h1><p>What is the difference between tuple() and list[]？loop over tuple and list，which one is more effective？</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if var in [&quot;xxx&quot;, &quot;yyy&quot;]:</span><br><span class="line">if var in (&quot;xxx&quot;, &quot;yyy&quot;):</span><br><span class="line">if var in &#123;&quot;xxx&quot;, &quot;yyy&quot;&#125;:</span><br></pre></td></tr></table></figure><p>Which one above is more efficitive? Note: The value after ‘in’ is a constant.</p><p>时间复杂度：tuple O(?) list O(?) set O(?)</p><p>答：tuple是不可变对象，list是可变对象。由于tuple不可变，所以申请内存为连续定长内存，而list类似于一个链表。</p><p>所以在loop中，tuple is more effective.</p><p><code>if var in &#123;&quot;xxx&quot;, &quot;yyy&quot;&#125;</code>​ is more effective. 因为集合查询时间复杂度为O(1)，tuple和list为O(N)</p><h1 id="6"><a href="#6" class="headerlink" title="6"></a>6</h1><p>Python class中变量名和函数名前缀单下划线和双下划线(后缀没有下划线)分别是什么？For example,</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class A:</span><br><span class="line">   def _method1(): pass   // What&#x27;s the meaning of _</span><br><span class="line">   def __method2(): pass  // What&#x27;s the meaning of __</span><br></pre></td></tr></table></figure><p> What’s the difference among the concepts protected, public, and private?</p><p>答：变量前没有下划线的为public<br>变量前有单下划线为protected，这种变量只能在本类或者其子类中调用（如果你想在其他地方调用也可以，但是会有警告）<br>变量前有双下划线为private，这种变量只能在本类中调用（在其他地方调用会报错）</p><h1 id="7"><a href="#7" class="headerlink" title="7"></a>7</h1><p>在用mongo等非关系型数据库的时候，我们不希望把脏数据、空数据存进数据库，造成后面的混乱。写一个函数(Python3)，删除json dict里面的空数据，包括空dict，空list，空string，None。假设输入的Python dict从合法json读取, 即key必为string, value可以是number/string/list/dict。例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;a&quot;: [1,0,&quot;c&quot;, &#123;&quot;x&quot;:1&#125;]&#125; -&gt; &#123;&quot;a&quot;: [1,0,&quot;c&quot;, &#123;&quot;x&quot;:1&#125;]&#125;</span><br><span class="line">&#123;&quot;a&quot;:[1,None]&#125; -&gt; &#123;&quot;a&quot;: [1]&#125;</span><br><span class="line">&#123;&quot;a&quot;: &#123;&quot;a&quot;:[None, &quot;&quot;, &#123;&#125;,&#123;&quot;x&quot;:None&#125;]&#125;&#125; -&gt; None</span><br></pre></td></tr></table></figure><p>答：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">clean_json</span>(<span class="params">data: (<span class="params"><span class="built_in">dict</span>,<span class="built_in">list</span>,<span class="built_in">int</span>,<span class="built_in">float</span>,<span class="built_in">str</span>,<span class="literal">None</span></span>)</span>):</span><br><span class="line">    <span class="comment"># put your code here</span></span><br><span class="line">    <span class="keyword">if</span> data <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> data == <span class="string">&#x27;&#x27;</span> <span class="keyword">or</span> data == <span class="built_in">dict</span>() <span class="keyword">or</span> data == []:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(data) == <span class="built_in">list</span>:</span><br><span class="line">        data1 = [item <span class="keyword">for</span> item <span class="keyword">in</span> data <span class="keyword">if</span> clean_json(item) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>] <span class="comment"># 复制一份出来</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data1:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> data1</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(data) == <span class="built_in">dict</span>:</span><br><span class="line">        data1 = &#123;k: clean_json(v) <span class="keyword">for</span> k, v <span class="keyword">in</span> data.items() <span class="keyword">if</span> clean_json(v) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>&#125; <span class="comment"># 复制一份出来</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data1:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> data1</span><br><span class="line">    <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure><p>注意：不能直接对原数组or字典作删除操作，会报错！</p><p>例如</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> l:</span><br><span class="line">    <span class="keyword">if</span> l[i] == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">del</span> l[i] <span class="comment"># do not do this</span></span><br></pre></td></tr></table></figure><p>‍</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python open3d点云相关操作（持续更新）</title>
      <link href="/2023/09/16/Python-open3d%E7%82%B9%E4%BA%91%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/"/>
      <url>/2023/09/16/Python-open3d%E7%82%B9%E4%BA%91%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="Prerequisite"><a href="#Prerequisite" class="headerlink" title="Prerequisite"></a>Prerequisite</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">!pip install open3d</span><br><span class="line">!pip install scipy</span><br><span class="line"><span class="keyword">import</span> open3d <span class="keyword">as</span> o3d</span><br><span class="line"><span class="keyword">from</span> scipy.spatial.transform <span class="keyword">import</span> Rotation <span class="keyword">as</span> R</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><h2 id="读和写点云文件"><a href="#读和写点云文件" class="headerlink" title="读和写点云文件"></a>读和写点云文件</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">point_cloud = o3d.io.read_point_cloud(file_path) <span class="comment"># 支持的格式pcd、pts等</span></span><br><span class="line"><span class="comment"># type(point_cloud) == open3d.cpu.pybind.geometry.PointCloud</span></span><br><span class="line"></span><br><span class="line">o3d.io.write_point_cloud(point_cloud, file_path) </span><br></pre></td></tr></table></figure><h2 id="读取点云对象中点的坐标"><a href="#读取点云对象中点的坐标" class="headerlink" title="读取点云对象中点的坐标"></a>读取点云对象中点的坐标</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.asarray(point_cloud.points)</span><br></pre></td></tr></table></figure><h2 id="将点坐标赋值到点云对象"><a href="#将点坐标赋值到点云对象" class="headerlink" title="将点坐标赋值到点云对象"></a>将点坐标赋值到点云对象</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># points = np.array([[...]])</span></span><br><span class="line"></span><br><span class="line">point_cloud.points = o3d.utility.Vector3dVector(points)</span><br></pre></td></tr></table></figure><h2 id="创建点云对象"><a href="#创建点云对象" class="headerlink" title="创建点云对象"></a>创建点云对象</h2><p>创建一个空的点云对象</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pc = o3d.geometry.PointCloud()</span><br></pre></td></tr></table></figure><h2 id="合并点云对象"><a href="#合并点云对象" class="headerlink" title="合并点云对象"></a>合并点云对象</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 直接+</span></span><br><span class="line">pc += point_cloud</span><br></pre></td></tr></table></figure><h2 id="点云平移"><a href="#点云平移" class="headerlink" title="点云平移"></a>点云平移</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">point_cloud.translate(translation)  <span class="comment"># 应用平移,translation 是平移向量</span></span><br></pre></td></tr></table></figure><h2 id="点云旋转"><a href="#点云旋转" class="headerlink" title="点云旋转"></a>点云旋转</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">point_cloud.rotate(rotation_matrix, center = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>))  <span class="comment"># 应用旋转, rotation_matrix是旋转矩阵</span></span><br></pre></td></tr></table></figure><p>这里需要注意第二个参数center是指定旋转中心，如果不传，默认旋转中心是点云的质心。</p><p>而一般来说，旋转中心为原点</p><h2 id="点云上色"><a href="#点云上色" class="headerlink" title="点云上色"></a>点云上色</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">point_cloud.paint_uniform_color([<span class="number">0</span>, <span class="number">0</span>, <span class="number">1.0</span>]) <span class="comment"># 传入的三个值分别是rgb</span></span><br></pre></td></tr></table></figure><h2 id="点云展示"><a href="#点云展示" class="headerlink" title="点云展示"></a>点云展示</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">o3d.visualization.draw_geometries([point_cloud])</span><br></pre></td></tr></table></figure><h2 id="四元数转旋转矩阵"><a href="#四元数转旋转矩阵" class="headerlink" title="四元数转旋转矩阵"></a>四元数转旋转矩阵</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">quaternion = np.array([ori_x, ori_y, ori_z, ori_w])  <span class="comment"># 定义四元数</span></span><br><span class="line">rotation_matrix = R.from_quat(quaternion).as_matrix()</span><br></pre></td></tr></table></figure><p>注意四元数顺序是xyzw，在有些地方顺序是wxyz</p><h2 id="点云下采样"><a href="#点云下采样" class="headerlink" title="点云下采样"></a>点云下采样</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">point_cloud = point_cloud.voxel_down_sample()</span><br></pre></td></tr></table></figure><p>这里需要注意</p><ol><li>需要接收返回值</li><li>下采样是指只保留某一大小立方体内的一个点。voxel_down_sample方法有个默认值参数，为0.05。这个参数就表示立方体的大小，因此这个数越大，下采样的强度越强，保留的点就越少。</li></ol><h2 id="统计滤波"><a href="#统计滤波" class="headerlink" title="统计滤波"></a>统计滤波</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">point_cloud.remove_statistical_outlier(nb_neighbors=<span class="number">20</span>, std_ratio=<span class="number">2.0</span>)</span><br></pre></td></tr></table></figure><p>该方法可以去掉距离点云密集处很远的点。该方法有两个参数</p><ol><li>nb_neighbors允许指定要考虑多少个邻居，以便计算给定点的平均距离。</li><li>std_ratio允许基于跨点云的平均距离的标准偏差来设置阈值级别。此数字越低，过滤器将越具有攻击性。</li></ol><h2 id="筛选点云中的点"><a href="#筛选点云中的点" class="headerlink" title="筛选点云中的点"></a>筛选点云中的点</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># indices_to_keep =[0,1,2...] 点的索引</span></span><br><span class="line">point_cloud = point_cloud.select_by_index(indices_to_keep)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Python numpy对三维点的操作汇总（持续更新）</title>
      <link href="/2023/09/16/Python-numpy%E5%AF%B9%E4%B8%89%E7%BB%B4%E7%82%B9%E7%9A%84%E6%93%8D%E4%BD%9C%E6%B1%87%E6%80%BB%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/"/>
      <url>/2023/09/16/Python-numpy%E5%AF%B9%E4%B8%89%E7%BB%B4%E7%82%B9%E7%9A%84%E6%93%8D%E4%BD%9C%E6%B1%87%E6%80%BB%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="Prerequisite"><a href="#Prerequisite" class="headerlink" title="Prerequisite"></a>Prerequisite</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><h2 id="将一个列表中的点或者其他对象转换成一个numpy-ndarray对象"><a href="#将一个列表中的点或者其他对象转换成一个numpy-ndarray对象" class="headerlink" title="将一个列表中的点或者其他对象转换成一个numpy.ndarray对象"></a>将一个列表中的点或者其他对象转换成一个numpy.ndarray对象</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">points = np.asarray([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]])</span><br></pre></td></tr></table></figure><h2 id="查看numpy-ndarray的形状"><a href="#查看numpy-ndarray的形状" class="headerlink" title="查看numpy.ndarray的形状"></a>查看numpy.ndarray的形状</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">##  n : numpy.ndarray </span></span><br><span class="line">n.shape </span><br></pre></td></tr></table></figure><h2 id="计算点到原点的欧几里得距离"><a href="#计算点到原点的欧几里得距离" class="headerlink" title="计算点到原点的欧几里得距离"></a>计算点到原点的欧几里得距离</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># points like array([[x1,y1,z1],[x2,y2,z2],[x3,y3,z3]])</span></span><br><span class="line">distances = np.linalg.norm(points, axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><code>np.linalg.norm(x, ord=None, axis=None, keepdims=False)</code>​求范数</p><p>x：是输入的矩阵or向量</p><p>ord：计算的范数类型。ord=2计算L2范数，即欧几里得距离，ord=1计算L1范数。</p><p>axis：轴，axis=0按列计算，axis=1按行计算</p><h2 id="选择欧几里得距离符合一定范围内的点"><a href="#选择欧几里得距离符合一定范围内的点" class="headerlink" title="选择欧几里得距离符合一定范围内的点"></a>选择欧几里得距离符合一定范围内的点</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获得点距离原点的欧几里得距离大于0.1小于70的点索引</span></span><br><span class="line">np.where((distances &gt;= <span class="number">0.01</span>) &amp; (distances &lt;= <span class="number">70</span>))[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#筛选这些点</span></span><br><span class="line">points[np.where((distances &gt;= <span class="number">0.01</span>) &amp; (distances &lt;= <span class="number">70</span>))]</span><br></pre></td></tr></table></figure><p><a href="https://www.delftstack.com/zh/howto/numpy/python-numpy.where-multiple-conditions/#%e5%9c%a8-python-%e4%b8%ad%e4%bd%bf%e7%94%a8-numpylogical_or-%e5%87%bd%e6%95%b0%e5%ae%9e%e7%8e%b0-numpywhere-%e5%a4%9a%e4%b8%aa%e6%9d%a1%e4%bb%b6">https://www.delftstack.com/zh/howto/numpy/python-numpy.where-multiple-conditions/#%e5%9c%a8-python-%e4%b8%ad%e4%bd%bf%e7%94%a8-numpylogical_or-%e5%87%bd%e6%95%b0%e5%ae%9e%e7%8e%b0-numpywhere-%e5%a4%9a%e4%b8%aa%e6%9d%a1%e4%bb%b6</a></p><h2 id="对点进行旋转"><a href="#对点进行旋转" class="headerlink" title="对点进行旋转"></a>对点进行旋转</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 给定一个3*3的旋转矩阵 rotation_matrix， 对点points进行旋转，获得旋转后的点坐标。</span></span><br><span class="line">np.dot(points, rotation_matrix.T)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意这里需要对旋转矩阵做了转置，<strong><em>推导一下</em></strong>​<strong>。</strong></p><p>np.dot矩阵乘法，他的用法是？和np.<code>matmul</code>​的区别？</p><h2 id="对点进行平移"><a href="#对点进行平移" class="headerlink" title="对点进行平移"></a>对点进行平移</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 给定一个平移向量translation_vector， 对点points进行平移，获得旋转后的点坐标。</span></span><br><span class="line">points + translation_vector</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你的项目中有什么亮点？如何回答才能得到面试官的好感</title>
      <link href="/2023/09/04/%E4%BD%A0%E7%9A%84%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%9C%89%E4%BB%80%E4%B9%88%E4%BA%AE%E7%82%B9%EF%BC%9F%E5%A6%82%E4%BD%95%E5%9B%9E%E7%AD%94%E6%89%8D%E8%83%BD%E5%BE%97%E5%88%B0%E9%9D%A2%E8%AF%95%E5%AE%98%E7%9A%84%E5%A5%BD%E6%84%9F/"/>
      <url>/2023/09/04/%E4%BD%A0%E7%9A%84%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%9C%89%E4%BB%80%E4%B9%88%E4%BA%AE%E7%82%B9%EF%BC%9F%E5%A6%82%E4%BD%95%E5%9B%9E%E7%AD%94%E6%89%8D%E8%83%BD%E5%BE%97%E5%88%B0%E9%9D%A2%E8%AF%95%E5%AE%98%E7%9A%84%E5%A5%BD%E6%84%9F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>针对本<a href="https://www.bilibili.com/video/BV1DM4y1L7cL/?buvid=9aa5bffff7ad0aee7573c7ed265b7b41&amp;is_story_h5=false&amp;mid=KneIq6dZPkIx5y%2FvWilBwA%3D%3D&amp;p=1&amp;plat_id=116&amp;share_from=ugc&amp;share_medium=iphone&amp;share_plat=ios&amp;share_session_id=B0B2A8E9-DA79-44E5-ADF6-4ECC9B19D812&amp;share_source=WEIXIN&amp;share_tag=s_i&amp;timestamp=1693623913&amp;unique_k=A5vAgCl&amp;up_id=1031543543&amp;vd_source=53d8e50bea64fe70bc50c86af86d28e1">视频</a>做的笔记</p></blockquote><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>请你说一下你项目中的亮点。几乎每个准备去面试的同学都会被这个问题困扰，我羡慕。</p><p>很简单，就是 CRUD 没有亮点怎么办？没有做过分布式的项目，哪有什么亮点，我之前做的都是单体项目，实在想不出有什么亮点，大家对于这个问题的<strong>误解</strong>在于，一定要项目足够好才有亮点。其实面试官在问这个问题的时候是想了解你在项目中的成果和能力，我们可以从几个维度去准备。</p><ol><li>解决复杂问题的能力。你可以描述你在项目中解决过哪一些特别复杂或者有挑战性的问题，可以是技术问题，也可以是业务问题。比如说通过引入 Kafka 这个消息队列，优化了程序的效率，使得我们能够在高峰期处理百万级的消息。</li><li>做了一些提高效率的工作，比如说重构代码，优化数据库查询效率。引入异步线程，优化了代码的效率。开发了一个公共组件，提升了团队的开发效率。比如优化了一个复杂的 MySQL 语句，提高了数据库的查询效率，使得查询效率整体提升了 10 倍。</li><li>突出团队协作和沟通方面的能力。比如说在项目中承担的核心开发或者团队小组长的角色，通过一系列的管理手段，按时完成了项目交付和提高了质量保障等等。比如我带领我的团队完成了这个项目，我负责分配任务，协调团队的成员工作以及解决团队中出现的问题。在我的管理下，我们成功的按时完成了项目，得到了客户的高度评价。</li><li>最后，我们还可以突出学习能力，比如项目里面要用到一个新的技术，这个技术之前没有用过，但是项目交付的时间比较紧，所以我大概花了 3 天时间在网上找了各种资料学习，在实际落地的时候还遇到了一些自己解决不了的问题，后面在 GitHub 的 issue 上找到解决方案，最后按期完成了项目的交付。</li></ol><p>因此，对于项目中的亮点，你们可以从对业务设计的深度思考，问题解决的能力，或者对某个特定技术的深度理解，团队协作沟通等方面去准备，从而让面试官看到你在项目中的思考和总结，而不是一个只会 CRUD的工具人。以上就是我的理解。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python asyncio异步编程入门</title>
      <link href="/2023/09/03/Python-asyncio%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"/>
      <url>/2023/09/03/Python-asyncio%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>针对<a href="https://www.bilibili.com/video/BV1oa411b7c9/?spm_id_from=333.337.search-card.all.click&amp;vd_source=53d8e50bea64fe70bc50c86af86d28e1">该视频</a>的一篇笔记</p><p>先决条件：协程、并发</p></blockquote><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>这次讲的是asyncio最新的用法，然后是Python 3. 7 以上才支持的，也是推荐大家学新不学旧。</p><p>asyncio并不能提升你的运算速度，它比较适合处理那些需要等待的任务^（应用场景）^，最典型的就是网络的通讯</p><p>那 asyncio的<strong>运算核心</strong>其实就是一个event loop，它就像一个大脑，它面对着很多可以执行的任务，然后决定执行哪个任务。那在 Python 的asyncio里，同时执行的任务只能有一个，它不存在系统级的上下文切换，它跟线程不一样，它需要每一个任务主动告诉event loop，我这边结束了，你可以让别的任务开始了。因此它有一个<strong>好处</strong>，就是不存在竞争冒险这样的问题，你可以明确的知道我每一个任务什么时候停止运算了。</p><p>那想要使用asyncio第一件事就是理解什么叫coroutine，什么叫task。</p><p>coroutine在 Python 的语境里，我们一般会指两种东西，一个是coroutine function，一个是coroutine object。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>( <span class="string">&#x27;world&#x27;</span>)</span><br><span class="line"></span><br><span class="line">coro = main()</span><br></pre></td></tr></table></figure><p>这个 async def main 就是一个coroutine function。Python 里面所有async def main开头的东西都叫coroutine function，它定义了一个 coroutine 的过程。那 Python 一般的函数，当我们调用它的时候，它返回的是这个函数的返回值，对不对？但是所有的 coroutine function，当你调用的时候，它返回的是一个coroutine object，它的本质跟生成器函数有些像。</p><p>就是当你在调用main的时候，它并不会运行 main 里面的程序，它只会返回一个coroutine object。</p><p>好，那怎么运行coroutine的代码？我们需要<strong>两件事</strong>，第一是进入async的模式，也就是进入这个 event loop，开始控制整个程序的状态。第二就是把coroutine变成task。</p><p>我们先说如何进入 async 模式，那我们正常写Python代码运行的时候，如果我们管它叫 synchronized 模式的话，那么在 synchronize 模式下切换到 asynchronized 模式，切换到让这个 event loop 开始控制一切。基本上我们只用一个入口函数叫做asyncio.run，那 asyncio.run，它的参数是一个coroutine，它会做两件事儿，第一它会建立起这个 event loop，第二它会把这个 coroutine 变成这个 event loop 里面的一个task，那 event loop 建立之后，他就会去找哪个 task 可以执行，那当然只有一个task，所以它就会开始运行 run 给进来的这个coroutine。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>( <span class="string">&#x27;world&#x27;</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p>我们试一下，大家可以看到它先 print 了hello，然后等了 1 秒钟，然后 print 了world，那这个asyncio.run就是我们从 synchronize 模式变到 asynchronize 模式的入口，它的参数是一个coroutine。</p><p>那只有一个 task 是没有什么意思的，对不对？我们刚才也说过， event loop 的核心是它有很多很多个task，然后它来决定哪个 task 要运行。所以我们很重要的一件事情是，当我们已经处于 async 模式下的时候，我们如何增加task？接下来我们就介绍几个把coroutine变成task，让它可以排队执行的方法。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">say_after</span>(<span class="params">delay, what</span>):</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(delay)</span><br><span class="line">    <span class="built_in">print</span>(what)</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;started at <span class="subst">&#123;time.strftime(<span class="string">&#x27;%x&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> say_after(<span class="number">1</span>, <span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> say_after(<span class="number">2</span>,<span class="string">&quot;world&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;finished at <span class="subst">&#123;time.strftime(<span class="string">&#x27;%x&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">        </span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p>大家看，我们有一个 say_after 函数，它显然是一个coroutine，对不对？它前面是async def，那实际上asyncio.sleep，它返回的东西也是一个 core routine，那这里就涉及到了<strong>第一个把coroutine变成 task 的方法</strong>，就是用await。</p><p>那么当你 await 一个<strong>coroutine</strong>的时候（上述代码第8行），发生了如下几件事，第一，这个coroutine被包装成一个task，并且被告诉了 event loop，说这块儿有一个新的task。第二，它会告诉 event loop，我现在这个 task （main）需要等到say_after task 完成之后，我才能继续它，建立了这么一个依赖关系。第三，它会 yield 出去，也就是它会告诉 event loop，我这个 task 现在干不了了，你先让别的 task 干活去吧。最后当 event loop 再次安排它运行的时候，它会把 say after 这个say_after 里面真正的返回值拿出来保存起来。当然现在我们这里await前面没有写，因为我们的 say after 是没有返回值的，好，那我们运行一下这段程序，我们可以看到差不多间隔一秒 print 一个hello，然后在两秒钟之后 print 了一个world。</p><p>我们来还原一下整个过程发生了一个什么事情。首先 asyncio.run把这个main作为一个 task 给放到了 event loop 里。 event loop 寻找task，他发现只有一个 task main，然后他就开始让这个 task main运行。may 你在运行的时候，首先 print 了一个 start at，然后它运行了 say_after 这个coroutine function，得到了一个coroutine object。await 把这个coroutine object变成了一个task，放回了 event loop 里，同时告诉 event loop 我需要等待它，然后把控制权交还给了 event loop。</p><p>现在 event loop 里面有两个task，一个是main，一个是这个 say_after，但是main运行不了， main说我要等这个 say after，那event loop，就让这个say_after先运行。</p><p><code>await asyncio.sleep(delay)</code>​ 这里其实做了一个很相似的事情，也是把它变成了一个task，然后告诉 event loop 说我得等这个 sleep 完成了我才能运行。然后 await 又把这个控制权转回给了 event loop。</p><p>event loop 一看现在有三个 task 对不对？有一个main，有一个 say_after，还有一个sleep，那这个 sleep 会告诉 event loop 说我一秒钟之后我就好了，所以这个 event loop 就等了一秒钟。一秒钟之后这个 sleep 就完成了。然后 event loop 看现在有两个task，一个main，一个 say after，这个 main 要等 say_after，但是这个 say after 等的东西已经完成了，于是 event loop 就说 say_after 你来运行吧，然后 say_after printed 一个what，然后 say_after 也完成了。于是又把控制权交还给 event loop。</p><p>event loop 一看，哎，现在只有一个 task 了，就成 main 了，然后再把控制权给main，这个时候 main就把第一个 say_after 完成了，然后再做第二个 say_after 做同样的事，又等了 2 秒之后它完成，所以整个过程用了 3 秒。</p><p>那在这个过程中，所有控制权的返回都是显式的，就是<strong>​ event loop 并没有办法强行的从一个 task 里边拿回控制权，必须要这个 task 主动把控制权交回去。</strong>交回去的方式有两种，第一个是await，会交回，第二个，当这个函数运行完毕之后，它会交回。所以说如果你有一个 task 里面有一个死循环，你的整个 event loop 就卡死了。</p><p>好，那刚才的运行过程中你可能发现了一个问题，对不对？这个 hello 要等 1 秒，这个 world 要等 2 秒，它俩为啥不能一起等呢？这就应该是我们协程的意义，对不对？在你第一个 hello 等 1 秒的时候，为什么这个 event loop 不能直接让这个 world 运行，然后你俩一起等着， 2 秒之后不就结束了吗？那这个呢？就是我们直接用 await 把一个 cooutine 变成 task 可能遇到的问题，因为 await 需要做的事太多了，它要变成task，它变成 task 之后会主动把控制权交出去，还需要等，这样后面的代码必须要等到它完成之后才能变成一个task。  </p><p>那为了解决这个问题， asyncio给我们提供了 create task 函数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">say_after</span>(<span class="params">delay, what</span>):</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(delay)</span><br><span class="line">    <span class="built_in">print</span>(what)</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    task1 = asyncio.create_task(say_after(<span class="number">1</span>,<span class="string">&quot;hello&quot;</span>))</span><br><span class="line">    task2 = asyncio.create_task(say_after(<span class="number">2</span>,<span class="string">&#x27;world&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;started at <span class="subst">&#123;time.strftime( <span class="string">&#x27;%x&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> task1</span><br><span class="line">    <span class="keyword">await</span> task2</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;finished at <span class="subst">&#123;time.strftime(<span class="string">&#x27;%x&#x27;</span>)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>我们看这里用到的 create_task 函数，这个函数的参数也是一个coroutine。依然记住这个 say_after 调用之后返回的是一个coroutine，它不会运行任何 coroutine 里面的代码，那这个 create_task 函数会把这个coroutine变成一个task，并且把这个 task 注册到 event loop 里面。也就是说它分担了刚才 await 的一部分功能，它把它包装成了一个task，然后告诉 event loop 说OK，这个 task 已经可以开始执行了，但是现在 event loop 并没有办法执行这个task，因为控制权还在 main 的手里，对不对？那这个时候 main 趁着自己有控制权，他就做了第二个task。</p><p>task 2 也是告诉 main 这还有一个新的task，这叫 say_after 2 也可以运行了，那在这儿之后他才开始 await task_1 await task_2 那我们之前说过 await 后面是一个coroutine的时候，它有那么多个功能对不对？把它变成一个task，然后把控制权交出去，等它拿返回值。那当 await 后面是一个 task 而不是一个coroutine 的时候，它就省略了把 coroutine变成 task 这一步，它就只是告诉 event loop 我需要这个 task 完成，我把控制权交还给你，并且在控制权回来的时候，从这个 task 里面提取所需要的返回值。</p><p>好，我们跑一下这个程序试一下。我们看这一次这个程序就只用了 2 秒钟，因为当它 await task 1的时候， event loop 里面实际上已经有了 3 个task，是 main、task 1和 task 2。当 task 1跟 event loop 说完说我要等一秒钟才能完成，之后 event loop 闲来无事就能发现，这有一个 task 2 还可以执行，于是他又执行了 task 2，再跟他说我要两秒钟之后才能结束，这样两个 task 就可以同时进行等待了。</p><p>这也就是为什么asyncio很适合解决一些网络通讯的问题，因为网络通讯很多时间是在等待上的，也就是我们所谓的IO task，就是我真正的运算挺少的，我就是等他的回复，那等待的这个时间就可以其他的任务去干活。那这个函数我们没有涉及coroutine的return，所以我们把这个函数稍微修改一下。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">say_after</span>(<span class="params">delay, what</span>):</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(delay)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;(what) - (delay)&quot;</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    task1 = asyncio.create_task(say_after(<span class="number">1</span>, <span class="string">&quot;he11o&quot;</span>))</span><br><span class="line">    task2 = asyncio.create_task(say_after(<span class="number">2</span>, <span class="string">&quot;world&quot;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;started at <span class="subst">&#123;time.strftime( <span class="string">&#x27;%x&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">    ret1 = <span class="keyword">await</span> task1</span><br><span class="line">    ret2 = <span class="keyword">await</span> task2</span><br><span class="line">    <span class="built_in">print</span>(ret1)</span><br><span class="line">    <span class="built_in">print</span>(ret2)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;finished at <span class="subst">&#123;time.strftime( <span class="string">&#x27;%x&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p>我们看我们把函数修改了一下，主要就是告诉大家怎么拿到coroutine的 return。那当你要拿这个返回值的时候，一定是一个 variable 等于 await task，而不是一个 variable 等于 task。我们之前强调过， await 有一个功能是把这个 task 或者coroutine的这个返回值拿出来，如果你不用 await 是拿不到这个值的。</p><p>那有的人看到这可能说了，那如果我有很多 task 呢？我有，比如说 10 个task，我就写 10 行 await task 吗？这是不是太蠢了？正因如此， asyncio给我们提供了一个函数叫做gather。我们看 gather 这个函数，它不是一个coroutine，但是它会返回一个叫做 future 的东西，这个 future 也是可以用 await 的，那 gather 这个函数作用，首先它的参数是若干个 coroutine或者task，这俩都可以，甚至可以是future，也就是 gather 的 return 值。它还可以接着gather，那如果是coroutine的话，它首先会把它包装成task，并且注册到 event loop 里，然后它会返回一个 future 值。当你 await 这个 future 的时候，你就相当于告诉 event loop，我要等待这里面每一个 task 都完成，我才可以继续，同时会把这些 task 的 return 值放到一个 list 里，然后返回来。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">say_after</span>(<span class="params">delay, what</span>):</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(delay)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;(what) - <span class="subst">&#123;delay&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;started at <span class="subst">&#123;time.strftime( <span class="string">&#x27;%x&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">    ret = <span class="keyword">await</span> asyncio.gather(say_after(<span class="number">1</span>, <span class="string">&#x27;hello&#x27;</span>),</span><br><span class="line">                               say_after(<span class="number">2</span>, <span class="string">&quot;world&quot;</span>))</span><br><span class="line">    <span class="built_in">print</span>(ret)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;finished at <span class="subst">&#123;time.strftime( <span class="string">&#x27;%x&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p>我们看一下这程序的结果，可以看到这次的这个 return value 是一个list，里面分别是 hello和world，<strong>那么这个 list 顺序和里面 task 的顺序是一致的</strong>，这样呢，我们就不用一个个 task await 了。</p><p>那 gather 还有一个好处就是如果你给的是coroutine的话，它会把每一个coroutine首先都变成task，也就是说我们可以不用自己手动先去建立这些 task 了。我们看一下上述代码结果，可以看到这种方式在拿到了正确的返回值的同时，它也只用了 2 秒。因为 gather 首先把这两个 coroutine 都变成了task，然后在 main 做 await 的时候才把控制权交回给了 event loop，这样 event loop 在分配哪一个 task 可以工作的时候，它就有更多的 task 可以分配了。</p><p>尽管asyncio里面还有不少的功能，但是掌握了这几个，基本上你就理解了asyncio的核心理念了。那我再强调一下前面提到过的几个重点。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>要建立一个 event loop 的概念，上面儿有一个 event loop 作为大脑，下面是若干可执行的task。 task 是没有办法控制 event loop 去执行某一个 task 的，它只能告诉 event loop 说我在等这个task。最终是由 event loop 来决定下面要运行哪个task，而 event loop 一旦开始运行task，就必须要 task 显示的把控制权交还给 event loop。交还控制权的方式由 await 和函数运行完毕。所以尽管我们会说这种协程的方式是并发的，但是同时刻实际上只有一段代码在跑，它只是想办法再利用这些代码中间的等待时间。所以如果你的代码里面并没有等待这件事的话，协程对你的代码是没有帮助的。</li><li>务必分清什么是coroutine，什么是task。 coroutine 只有变成了 task 才开始被执行。要能知道什么时候 coroutine 被隐式的变成了task，在你直接await coroutine 的时候，给你放到 gather 里的时候，你放进去的都是coroutine，但是它们会偷偷把它变成 task 执行coroutine，不变成 task 是没有办法执行的。</li><li>最后拿到一个 coroutine 的返回值是需要用 await 的。一个变量等于 await xxx。</li></ol><p>‍</p><p>‍</p><p>‍</p><p>‍</p><p>‍</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 异步编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> asyncio </tag>
            
            <tag> 异步编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式系统学习资料</title>
      <link href="/2023/02/28/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"/>
      <url>/2023/02/28/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/</url>
      
        <content type="html"><![CDATA[<p>source:<a href="https://gist.github.com/ascrutae/7fbc3681ff6e7f68fc908e196eac980e">https://gist.github.com/ascrutae/7fbc3681ff6e7f68fc908e196eac980e</a></p><script src="https://gist.github.com/ascrutae/7fbc3681ff6e7f68fc908e196eac980e.js"></script><p>source2: <a href="https://zhuanlan.zhihu.com/p/372646991">https://zhuanlan.zhihu.com/p/372646991</a></p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习路线 </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>思源笔记基本使用</title>
      <link href="/2023/02/26/%E6%80%9D%E6%BA%90%E7%AC%94%E8%AE%B0%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/02/26/%E6%80%9D%E6%BA%90%E7%AC%94%E8%AE%B0%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>思源笔记是一款很好的管理知识库的软件。支持本地（免费）和云端（付费）两种模式。</p><p>不仅支持markdown语法，还有更多实用功能。这里进行基本的使用介绍。</p><h1 id="支持markdown语法"><a href="#支持markdown语法" class="headerlink" title="支持markdown语法"></a>支持markdown语法</h1><p>略</p><h1 id="支持新建多级文档"><a href="#支持新建多级文档" class="headerlink" title="支持新建多级文档"></a>支持新建多级文档</h1><p><img src="image-20230226161146934.png" alt="image-20230226161146934"></p><h1 id="设置标签、笔记图标和题头图"><a href="#设置标签、笔记图标和题头图" class="headerlink" title="设置标签、笔记图标和题头图"></a>设置标签、笔记图标和题头图</h1><p>将鼠标放置到笔记开头，出现的三个icon分别对应，添加标签，设置图标和设置题头图。</p><p><img src="image-20230226161241016.png" alt="image-20230226161241016"></p><p>设置之后的效果为：</p><p><img src="image-20230226161340368.png" alt="image-20230226161340368"></p><h1 id="内容块合并"><a href="#内容块合并" class="headerlink" title="内容块合并"></a>内容块合并</h1><p>内容块是思源的基础。块和块之间可以进行合并等操作。</p><p><img src="1.gif" alt="动画"></p><h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><p>思源笔记可以制作模板，导出导入模板。让笔记标准化。</p><h1 id="挂件"><a href="#挂件" class="headerlink" title="挂件"></a>挂件</h1><p>在【设置】-【集市】-【挂件】中进行下载。</p><p>目前看到比较好用的挂件有</p><ul><li>superdraw： 可以让实现随意涂写的挂件</li><li>drawio：实现画流程图的挂件</li><li>思维导图：可以插入思维导图的挂件</li></ul><p>其他的自行研究。这里以drawio为例。他的效果是这样的。</p><p><img src="image-20230226163445070.png" alt="image-20230226163445070"></p><h1 id="导入pdf并进行阅览"><a href="#导入pdf并进行阅览" class="headerlink" title="导入pdf并进行阅览"></a>导入pdf并进行阅览</h1><p>通过拖拽导入pdf，点击进行阅览</p><p><img src="image-20230226163828335.png" alt="image-20230226163828335"></p><p>不仅如此，在pdf中可以进行选中和标注。将标注作为“引用链接”复制回笔记。点击“引用链接”可以直接打开pdf，并跳转到标注的位置。</p><p><img src="image-20230226164254104.png" alt="image-20230226164254104"></p><h1 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h1><p>直接复制粘贴导出的是markdown格式的内容</p><p>也可以直接选择导出模式，导出不同平台的格式。目前支持知乎、微信公众号等。</p><p><img src="2.gif" alt="动画"></p><h1 id="剪藏"><a href="#剪藏" class="headerlink" title="剪藏"></a>剪藏</h1><p>通过chrome插件进行web页面的笔记剪藏</p><p>类似有道云笔记的功能。</p><p>这里需要对token进行配置。token在【设置】【关于】中查看</p><h1 id="网络图片转到本地"><a href="#网络图片转到本地" class="headerlink" title="网络图片转到本地"></a>网络图片转到本地</h1><p><img src="image-20230226164816361.png" alt="image-20230226164816361"></p><h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><p>当前块可以引用其他笔记的内容，输入两个左括号触发。</p><p>继续输入关键词，选中引用的内容即可。</p><p>鼠标悬浮在引用链接上，可以对引用的内容进行预览。</p><p>具体效果如下。</p><p><img src="3.gif" alt="动画"></p><p>链接分为正向链接和反向连接。</p><p>正向链接就是查看链接引用了哪些内容块</p><p>反向链接就是查看哪些内容块被引用了。</p><p>点击右下角的【反向链接】图标查看</p><p><img src="image-20230226165621640.png" alt="image-20230226165621640"></p><p>在连接中你可以右键输入锚文本修改引用链接的文本</p><p><img src="image-20230226165718183.png" alt="image-20230226165718183"></p><h1 id="闪卡"><a href="#闪卡" class="headerlink" title="闪卡"></a>闪卡</h1><h2 id="制作闪卡"><a href="#制作闪卡" class="headerlink" title="制作闪卡"></a>制作闪卡</h2><p>闪卡用于背诵某些内容。制作闪卡的流程如下。</p><p>标记需要背诵的内容，选择块【添加到卡包】，创建卡包并添加。</p><p><img src="image-20230226170647766.png" alt="image-20230226170647766"></p><p><img src="image-20230226170750105.png" alt="image-20230226170750105"></p><p><img src="image-20230226170852763.png" alt="image-20230226170852763"></p><h2 id="复习闪卡"><a href="#复习闪卡" class="headerlink" title="复习闪卡"></a>复习闪卡</h2><p>选择【闪卡】</p><p><img src="image-20230226170933812.png" alt="image-20230226170933812"></p><p>选择卡包就可以看到待复习的闪卡了。</p><p><img src="image-20230226171010071.png" alt="image-20230226171010071"></p><h1 id="图表"><a href="#图表" class="headerlink" title="图表"></a>图表</h1><p>输入<code>/</code>，选择插入Chart</p><p><img src="image-20230226171217053.png" alt="image-20230226171217053"></p><p>这里输入代码即可插入chart，其格式为echarts的json格式代码。</p><p>这里有两种方式</p><ol><li>使用JS编写图表</li><li>使用<a href="https://tushuo.baidu.com/">百度图说</a>，可视化制作图表，然后复制图表代码。</li></ol><p>这里使用第二种方式。</p><p>进入百度图说，创建图表，修改数据，点击【显示代码】</p><p><img src="image-20230226171700714.png" alt="image-20230226171700714"></p><p>复制代码后粘贴到思源的图标代码中，就可以看到图表啦</p><p><img src="image-20230226171753886.png" alt="image-20230226171753886"></p><h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><p>输入<code>/</code>，选择插入flowchart</p><p>这里支持两种语法格式：</p><ol><li>flowchart.js</li><li>plantUML</li></ol><h1 id="Graphviz"><a href="#Graphviz" class="headerlink" title="Graphviz"></a>Graphviz</h1><p>输入<code>/</code>，选择插入Graphviz</p><p>支持的语法格式为dot语法。具体可以参考<a href="">网站</a>进行绘制。在软件工程、数据库和机器学习方面用的多，效果如下。</p><p><img src="image-20230226172409698.png" alt="image-20230226172409698"></p><h1 id="Mermaid"><a href="#Mermaid" class="headerlink" title="Mermaid"></a>Mermaid</h1><p>输入<code>/</code>，选择插入Mermaid</p><p>Mermaid和Graphviz 类似。Mermaid可以绘制流程图等数十种图。</p><p>打开<a href="https://mermaid.js.org/">官网</a>，选择右上角的【live editor】进行实时编辑。</p><p><img src="image-20230226172909167.png" alt="image-20230226172909167"></p><p>复制代码即可在思源笔记中看到效果</p><p><img src="image-20230226172955029.png" alt="image-20230226172955029"></p><h1 id="MindMap"><a href="#MindMap" class="headerlink" title="MindMap"></a>MindMap</h1><p>mindmap是脑图。</p><p>输入<code>/</code>，选择插入MindMap</p><p>之后进行编辑</p><p><img src="image-20230226173129422.png" alt="image-20230226173129422"></p><h1 id="多媒体"><a href="#多媒体" class="headerlink" title="多媒体"></a>多媒体</h1><p>思源支持多媒体数据的插入，包括视频、链接、iframe</p><p>这里插入一个视频为例：</p><p>输入<code>/</code>，选择插入iframe链接，复制视频url链接。效果如下</p><p><img src="image-20230226173429042.png" alt="image-20230226173429042"></p><h1 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h1><ol><li><a href="https://www.bilibili.com/video/BV1bv4y1r7tA/?spm_id_from=333.788&amp;vd_source=53d8e50bea64fe70bc50c86af86d28e1">https://www.bilibili.com/video/BV1bv4y1r7tA/?spm_id_from=333.788&amp;vd_source=53d8e50bea64fe70bc50c86af86d28e1</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具箱 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> siyuan </tag>
            
            <tag> 思源 </tag>
            
            <tag> 教程 </tag>
            
            <tag> 知识库工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件行业就业方向调研</title>
      <link href="/2023/02/25/%E8%BD%AF%E4%BB%B6%E8%A1%8C%E4%B8%9A%E5%B0%B1%E4%B8%9A%E6%96%B9%E5%90%91%E8%B0%83%E7%A0%94/"/>
      <url>/2023/02/25/%E8%BD%AF%E4%BB%B6%E8%A1%8C%E4%B8%9A%E5%B0%B1%E4%B8%9A%E6%96%B9%E5%90%91%E8%B0%83%E7%A0%94/</url>
      
        <content type="html"><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>本文调研了目前软件行业的就业方向。用于个人选择合适的就业岗位使用。主要调研了软件行业有哪些就业方向，针对这些方向又调研了</p><ol><li>职位岗位</li><li>目前需求：多还是少，为什么</li><li>前景如何：好还是坏，还是不明；从国内和国外两个角度；未来发展评估</li><li>企业：有哪些企业在做，龙头企业有哪些，从国内外两方面</li><li>细分领域：比如自然语言处理有对话领域blabla</li><li>特点：难度，特点</li><li>技术路线：整理该方向的技术路线图，对该方向的技术栈进行简单介绍</li><li>职业规划：方向职业的前进路线，初级-中级，blabla</li><li>是否利于出国：国外的需求是否更旺盛，是否更容易出国</li></ol><h1 id="调研方式"><a href="#调研方式" class="headerlink" title="调研方式"></a>调研方式</h1><p>本文汇总的软件行业就业方向的调研方式是，通过知乎、bilibili、谷歌、YouTube、微信公众号、GitHub等平台，使用以下几组关键词：【就业、职业】【程序员、码农、软件行业】【方向、前景、规划、赛道】，时间选取近两年，进行搜索，总结相关视频、文章、评论等内容。</p><p>先搜集整理可能的软件行业方向，再根据将这些软件行业方向作为关键词，二次搜索。</p><p>PS由于国内广告太多，很多话都不太可信。。</p><h1 id="开发方向-前端"><a href="#开发方向-前端" class="headerlink" title="开发方向-前端"></a>开发方向-前端</h1><h2 id="职位岗位"><a href="#职位岗位" class="headerlink" title="职位岗位"></a>职位岗位</h2><p>无</p><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>和后端差不多。</p><h2 id="前景"><a href="#前景" class="headerlink" title="前景"></a>前景</h2><blockquote><p>Web这种还是挺有生命力的，但是，一切都是在变化，有可能若干年后一个技术变革，Web就丧失优势变得门可罗雀了，所以呢，各位同仁，要有心理准备。</p></blockquote><p>同质化</p><h2 id="企业"><a href="#企业" class="headerlink" title="企业"></a>企业</h2><p>不局限于互联网，但是互联网的技术更新，更有竞争力。</p><h2 id="应用领域"><a href="#应用领域" class="headerlink" title="应用领域"></a>应用领域</h2><p>主要是移动端、PC端的前端开发，还有游戏，后端（NodeJS）以及其他（桌面端）</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li>越来越工具化、工程化</li><li>知识琐碎，门槛低</li><li>出效果快、激励周期短</li></ol><h2 id="技术路线"><a href="#技术路线" class="headerlink" title="技术路线"></a>技术路线</h2><p><img src="png-FrontEnd-by-StuQ.png" alt="png-FrontEnd-by-StuQ.png"></p><p>前端发展经历了三个阶段:</p><ol><li>原生html、js、css</li><li>封装库、jquery</li><li>组件化开发：node</li></ol><h2 id="职业规划"><a href="#职业规划" class="headerlink" title="职业规划"></a>职业规划</h2><div class="table-container"><table><thead><tr><th>职称</th><th>职责</th><th>年限(仅供参考)</th></tr></thead><tbody><tr><td>初级工程师</td><td>能在导师的帮助(详细设计, 关键点实现)下完成简单任务</td><td>0</td></tr><tr><td>中级工程师(开发)</td><td>能在导师的协助(概要设计, 关键点说明)下<strong>独立完成</strong>复杂任务</td><td>1+</td></tr><tr><td>高级工程师(研发)</td><td><strong>能高质量高效率地独立完成任务</strong></td><td>5+</td></tr><tr><td>资深/首席/专家/架构</td><td>全局观, 既有广度又有深度, 在某个专业领域有一席之地</td><td>8+</td></tr></tbody></table></div><h2 id="出国"><a href="#出国" class="headerlink" title="出国"></a>出国</h2><p>无</p><h1 id="开发方向-后端"><a href="#开发方向-后端" class="headerlink" title="开发方向-后端"></a>开发方向-后端</h1><h2 id="职位岗位-1"><a href="#职位岗位-1" class="headerlink" title="职位岗位"></a>职位岗位</h2><p>根据语言不同分为很多，例如，Java、Go等。</p><p>去某公司做后端开发，不一定对他们用到的语言和框架很熟练，会其中一部分就够了，很多都是在工作中学的。</p><h2 id="需求-1"><a href="#需求-1" class="headerlink" title="需求"></a>需求</h2><p>前后端差不多。</p><h2 id="前景-1"><a href="#前景-1" class="headerlink" title="前景"></a>前景</h2><p>随时间变化很大。目前不明。</p><h2 id="企业-1"><a href="#企业-1" class="headerlink" title="企业"></a>企业</h2><p>不局限于互联网，但是互联网的技术更新，更有竞争力。</p><h2 id="应用领域-1"><a href="#应用领域-1" class="headerlink" title="应用领域"></a>应用领域</h2><p>领域广泛。</p><h2 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h2><ol><li>注重功能性和稳定性</li><li>门类分支多：业务、算法、架构。。。</li><li>难以学深，容易瓶颈。这主要是小公司业务量不够&amp;大公司构建技术壁垒，小公司的后端开发容易和大公司拉开差距</li><li>后端的工作范畴很广：设计api、架构、数据库、业务逻辑、高可用等</li><li>非常考验《系统设计》的能力</li></ol><h2 id="RoadMap"><a href="#RoadMap" class="headerlink" title="RoadMap"></a>RoadMap</h2><p>以Java为例</p><p>图片来源：<a href="https://github.com/s4kibs4mi/java-developer-roadmap/blob/master/i18n/zh-CN/ReadMe-zh-CN.md">https://github.com/s4kibs4mi/java-developer-roadmap/blob/master/i18n/zh-CN/ReadMe-zh-CN.md</a></p><p><img src="java-developer-roadmap-zh-CN.png" alt="Roadmap"></p><h2 id="出国-1"><a href="#出国-1" class="headerlink" title="出国"></a>出国</h2><p>无</p><h1 id="小结：前端后端对比"><a href="#小结：前端后端对比" class="headerlink" title="小结：前端后端对比"></a>小结：前端后端对比</h1><h2 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h2><p>需求、工资、前景都差不多</p><p>职业发展规划差不多</p><div class="table-container"><table><thead><tr><th>职称</th><th>职责</th><th>年限(仅供参考)</th></tr></thead><tbody><tr><td>初级工程师</td><td>能在导师的帮助(详细设计, 关键点实现)下完成简单任务</td><td>0</td></tr><tr><td>中级工程师(开发)</td><td>能在导师的协助(概要设计, 关键点说明)下<strong>独立完成</strong>复杂任务</td><td>1+</td></tr><tr><td>高级工程师(研发)</td><td><strong>能高质量高效率地独立完成任务</strong></td><td>5+</td></tr><tr><td>资深/首席/专家/架构</td><td>全局观, 既有广度又有深度, 在某个专业领域有一席之地</td><td>8+</td></tr></tbody></table></div><h2 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h2><blockquote><p><strong>后端要学的技术太多了</strong>，而前端相对来说就少多了，压力自然少很多，而且后端也需要学一些前端技术，有的公司就有这样的需求，考虑到地中海干涸问题，肯定选前端，而且对于后面的发展，比如<strong>转型走管理架构什么的，前端基本没有优势</strong>。但是由于<strong>前端技术难度和学习成本不是太大</strong>，而且随着经验积累，即便到了四十多岁也可以继续开发，而后端再继续撸代码就难多了，因为本来前端逻辑代码不是太多，即便是使用node做前后端分离，前端复杂逻辑也不是太多，而且前端现在有很多脚手架和插件，都可以直接拿来用。而后端就不一样了，性能，并发，算法，各种优化，服务器问题等等，都是后端考虑的，虽然随着各种技术的出现，现在后端也开发没有以前费劲了，但是要知道底层原理和源码你还是要去翻，各种问题还是主要在后端这解决的。</p></blockquote><p>评论：</p><p>前端四十多岁也可以继续开发，存疑。随着前端技术的发展，也可能技术难度up，四十多岁不能继续开发。</p><h2 id="怎么选"><a href="#怎么选" class="headerlink" title="怎么选"></a>怎么选</h2><ul><li>兴趣、现状：你了解哪个多一点就选哪个</li><li>职业背景</li><li>年龄</li></ul><h1 id="开发方向-全栈"><a href="#开发方向-全栈" class="headerlink" title="开发方向-全栈"></a>开发方向-全栈</h1><h2 id="RoadMap-1"><a href="#RoadMap-1" class="headerlink" title="RoadMap"></a>RoadMap</h2><p>来源：<a href="https://github.com/easychen/stack-roadmap">https://github.com/easychen/stack-roadmap</a></p><p><img src="方糖全栈路线图.jpg" alt="img"></p><h2 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h2><p>最大特点就是，<strong>难度高</strong></p><p>特点之二是，美国全栈岗位多，后面再根据个人细分领域。<strong>可能利于出国</strong>。</p><p><strong>不适合应届生</strong></p><p>依据是2019年stack-overflow的调查问卷，程序员岗位分布：</p><p><img src="image-20230223000029-erjot3z.png" alt="image"></p><h1 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h1><p>翻译过来叫质量保证，在国外主要指的是测试，tester。在国内还有另一种不同于测试的质量保证。这点需要注意，招聘时的QA究竟指的是质量保证还是测试工程师。</p><h2 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h2><ol><li>分成两种，手工测试和自动化测试。</li><li>自动化测试需要写代码，需要懂一两门自动化测试语言和框架。</li><li>手工测试，对开发能力和写代码能力没有要求，但是需要有开发的经验。这类岗位基本被淘汰掉了。</li></ol><h2 id="RoadMap-2"><a href="#RoadMap-2" class="headerlink" title="RoadMap"></a>RoadMap</h2><p><a href="https://github.com/yangzige/qa-roadmap/blob/main/roadmap/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF.md">https://github.com/yangzige/qa-roadmap/blob/main/roadmap/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF.md</a></p><h1 id="人工智能-CV方向"><a href="#人工智能-CV方向" class="headerlink" title="人工智能-CV方向"></a>人工智能-CV方向</h1><p>2015-2020是黄金期，找工作比较容易。2020以后赚钱的业务挖掘的差不多了，<strong>对学历和论文的要求高</strong>。</p><p>CV岗位比开发岗<strong>少很多</strong>。</p><h2 id="前景-2"><a href="#前景-2" class="headerlink" title="前景"></a>前景</h2><p>今后会走向“平衡”。人话就是不温不火</p><h2 id="应用领域-2"><a href="#应用领域-2" class="headerlink" title="应用领域"></a>应用领域</h2><p><img src="640.png" alt="图片"></p><ul><li>自动驾驶领域：比较火</li><li>工业视觉领域：应用潜力大</li><li>智慧医疗：有前景但比较困难</li></ul><h2 id="RoadMap-3"><a href="#RoadMap-3" class="headerlink" title="RoadMap"></a>RoadMap</h2><p>没找到比较好的。基本就是Python、PyTorch、数字图象处理，深度学习那一套。。</p><h1 id="人工智能-NLP方向"><a href="#人工智能-NLP方向" class="headerlink" title="人工智能-NLP方向"></a>人工智能-NLP方向</h1><blockquote><p>自然语言处理(<em>NLP</em>)是人工智能技术的王冠，它推动着当代科技的持续发展和重大突破，并越来越多地应用于各行各业；它有着十分重要的实用价值，也有着革命性的理论</p></blockquote><h2 id="前景-3"><a href="#前景-3" class="headerlink" title="前景"></a>前景</h2><p>前景广阔。之前比较卷，现在因为ChatGPT的出现，续了一口气</p><h2 id="应用领域-3"><a href="#应用领域-3" class="headerlink" title="应用领域"></a>应用领域</h2><p>对话、问答。</p><h2 id="RoadMap-4"><a href="#RoadMap-4" class="headerlink" title="RoadMap"></a>RoadMap</h2><p><a href="https://github.com/graykode/nlp-roadmap">https://github.com/graykode/nlp-roadmap</a></p><h1 id="人工智能-其他"><a href="#人工智能-其他" class="headerlink" title="人工智能-其他"></a>人工智能-其他</h1><p>人工智能还包括其他方向，例如推荐算法。</p><h1 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h1><h2 id="职位岗位-2"><a href="#职位岗位-2" class="headerlink" title="职位岗位"></a>职位岗位</h2><p>大数据是一个比较笼统的方向，既可以做大数据开发方向，也可以做数据挖掘等算法方向，也有商业智能BI。。。</p><p>具体方向有以下：</p><ol><li>ETL/数仓工程师：负责数仓建设，偏脚本开发以及SQL开发。</li><li>大数据开发工程师：负责数据计算，偏离线。实时代码开发。</li><li>大数据分析师：负责数据挖掘分析、偏业务分析/SQL</li><li>大数据算法工程师：算法建模、基于人工智能建模。往往是和推荐算法相关。</li><li>大数据BI工程师：偏报表和SQL开发。</li></ol><p>不同方向的学习路线和技能都有所不同。</p><h2 id="需求-2"><a href="#需求-2" class="headerlink" title="需求"></a>需求</h2><p>没有Java那么卷，但是岗位也没有那么多。</p><h2 id="前景-4"><a href="#前景-4" class="headerlink" title="前景"></a>前景</h2><h2 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h2><ol><li>大数据开发需要学习的组件非常多。也比较难。</li><li>ETL/数仓的工作比较基础。</li><li>大数据分析和算法主要偏算法相关。</li></ol><h2 id="RoadMap-5"><a href="#RoadMap-5" class="headerlink" title="RoadMap."></a>RoadMap.</h2><p>学习可以从SQL入手。</p><p><a href="https://github.com/TeamStuQ/skill-map/blob/master/data/map-BigDataEngineer.md">https://github.com/TeamStuQ/skill-map/blob/master/data/map-BigDataEngineer.md</a></p><h2 id="一篇有用的文章"><a href="#一篇有用的文章" class="headerlink" title="一篇有用的文章"></a>一篇有用的文章</h2><p>想学大数据，大数据开发以后的前景怎么样，家里人对这方面了解不深，不太同意转行？ - 云原生研习社的回答 - 知乎 <a href="https://www.zhihu.com/question/509912345/answer/2664371834">https://www.zhihu.com/question/509912345/answer/2664371834</a></p><h1 id="UX-UI"><a href="#UX-UI" class="headerlink" title="UX/UI"></a>UX/UI</h1><p>UX是User Experience（用户体验）的缩写，指的是围绕用户，以用户在使用过程中的主观感受为出发点，力求更简单高效地满足用户需求。 UX设计师的职责简单来说就是为用户设计友好的产品体验，他更关注产品的易用性、实用性、高效性及价值体现。</p><p>UI的全名是User Interface，中文是「使用者介面」的意思。介面指的是APP、網頁等，可以與使用者互動的媒介。如同字面上的意思，UI著重的是使用者介面的呈現，如：視覺美感、設計美學、便利性、風格呈現，細節更包含了字型、字體大小、顏色、標誌、按鍵、動畫效果等。UI的呈現，會影響到使用者的使用感受，以及順暢性。</p><p>其他略。</p><h1 id="数据采集"><a href="#数据采集" class="headerlink" title="数据采集"></a>数据采集</h1><p>爬虫方向。不想说。。</p><h1 id="数据挖掘"><a href="#数据挖掘" class="headerlink" title="数据挖掘"></a>数据挖掘</h1><blockquote><p>广义上说，任何从数据库中挖掘信息的过程都叫做数据挖掘。从这点看来，数据挖掘就是BI（商业智能）。但从技术术语上说，数据挖掘(Data Mining)特指的是：源数据经过清洗和转换等成为适合于挖掘的数据集。数据挖掘在这种具有固定形式的数据集上完成知识的提炼，最后以合适的知识模式用于进一步分析决策工作。从这种狭义的观点上，我们可以定义：数据挖掘是从特定形式的数据集中提炼知识的过程。数据挖掘往往针对特定的数据、特定的问题，选择一种或者多种挖掘算法，找到数据下面隐藏的规律，这些规律往往被用来预测、支持决策。</p></blockquote><p>可以放到大数据的数据挖掘的相关岗位来看。</p><h2 id="应用领域-4"><a href="#应用领域-4" class="headerlink" title="应用领域"></a>应用领域</h2><p>情报检索、数据分析、模式识别</p><h1 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h1><p>可以放到大数据的数据存储的相关岗位来看。</p><p>主要研究各种数据库存储。</p><h2 id="有用的文章"><a href="#有用的文章" class="headerlink" title="有用的文章"></a>有用的文章</h2><p><a href="https://github.com/wx-chevalier/Database-Series">https://github.com/wx-chevalier/Database-Series</a></p><h1 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h1><h2 id="前景-5"><a href="#前景-5" class="headerlink" title="前景"></a>前景</h2><p>前景很好。</p><h2 id="有用的文章-1"><a href="#有用的文章-1" class="headerlink" title="有用的文章"></a>有用的文章</h2><p><a href="https://github.com/LiuBoyu/blockchain">https://github.com/LiuBoyu/blockchain</a></p><p><a href="https://github.com/xianfeng92/Love-Ethereum">https://github.com/xianfeng92/Love-Ethereum</a></p><h2 id="应用领域-5"><a href="#应用领域-5" class="headerlink" title="应用领域"></a>应用领域</h2><p>区块链+物联网</p><h1 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h1><p>略，不感兴趣。但是和区块链息息相关。</p><h1 id="游戏开发"><a href="#游戏开发" class="headerlink" title="游戏开发"></a>游戏开发</h1><h1 id="VR"><a href="#VR" class="headerlink" title="VR"></a>VR</h1><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="素质要求"><a href="#素质要求" class="headerlink" title="素质要求"></a>素质要求</h2><p>这部分是除了细分方向之外的，对软件行业从业者的共同要求：</p><ol><li>涉猎其它领域的专业知识，丰富自己的知识体系、提高自己的综合素质，争取在自己的专业领域有所积累，然后再做扩展。<strong>不要把自己的知识体系局限于自己的岗位上</strong></li><li><strong>终身学习</strong></li><li>技术观：不要排斥其他技术</li><li>产品观：有产品常识</li><li>数据观：对数据敏感</li><li>知其然知其所以然，会使用轮子，也要研究轮子。</li></ol><h2 id="美国硕士博士CS专业分类"><a href="#美国硕士博士CS专业分类" class="headerlink" title="美国硕士博士CS专业分类"></a>美国硕士博士CS专业分类</h2><p><img src="image-20230223090322289.png" alt="image-20230223090322289"></p><p><img src="image-20230223090346670.png" alt="image-20230223090346670"></p><h2 id="计算机科学的主要分支"><a href="#计算机科学的主要分支" class="headerlink" title="计算机科学的主要分支"></a>计算机科学的主要分支</h2><p><img src="815c0d5aed01530b7cf11d0c9061ec70.png" alt="815c0d5aed01530b7cf11d0c9061ec70.png"></p><h1 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h1><p>这篇文章非常浅薄，没有仔细分析各个行业的现状和情况。只是罗列了一些资料。</p>]]></content>
      
      
      <categories>
          
          <category> 软件行业 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Visual Attention Network</title>
      <link href="/2023/02/04/Visual-Attention-Network/"/>
      <url>/2023/02/04/Visual-Attention-Network/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文是论文《Visual Attention Network》的学习笔记</p><p>我在该模型上执行一个分类任务，发现该模型的效果要优于我实验的其他模型（包括resnet50、densenet121、efficientNet-b0、swin-tiny）</p><p>所以在此记录一下，笔记大多是抄的，出处在Refs上表明，如有侵权请联系我。</p><p><a href="https://arxiv.org/abs/2202.09741">论文地址</a>   <a href="https://github.com/Visual-Attention-Network">代码地址</a></p></blockquote><p>‍</p><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="自注意力机制"><a href="#自注意力机制" class="headerlink" title="自注意力机制"></a>自注意力机制</h2><p><a href="https://zhuanlan.zhihu.com/p/265108616">Attention注意力机制与self-attention自注意力机制</a></p><p><a href="https://www.jiqizhixin.com/articles/100902">什么是自注意力机制？</a></p><h2 id="空间相关性和通道相关性1"><a href="#空间相关性和通道相关性1" class="headerlink" title="空间相关性和通道相关性1"></a>空间相关性和通道相关性<sup><a href="#fn_1" id="reffn_1">1</a></sup></h2><p>从维度的角度看，卷积核可以看成是一个空间维(宽和高)和通道维的组合，而<strong>卷积操作则可以视为空间相关性和通道相关性的联合映射</strong>。从inception的1x1卷积来看，<strong>卷积中的空间相关性和通道相关性是可以解耦的，将它们分开进行映射，可能会达到更好的效果。</strong></p><p>深度可分离卷积是在1x1卷积基础上的一种创新。主要包括两个部分：深度卷积和1x1卷积。深度卷积的目的在于对输入的每一个通道都单独使用一个卷积核对其进行卷积，也就是通道分离后再组合。1x1卷积的目的则在于加强深度。下面以一个例子来看一下深度可分离卷积。</p><p>假设我们用128个$3 \times3 \times3$的滤波器对一个 $7 \times7 \times3$的输入进行卷积，可得到$5 \times5 \times128$的输出,其计算量为$5 \times5 \times128 \times3 \times3 \times3=86400$。如下图所示：</p><p><img src="image-20230204110644-zz7yeyj.png" alt="image">​</p><p>现在看如何使用深度可分离卷积来实现同样的结果。深度可分离卷积的第一步是深度卷积。这里的深度卷积，就是分别用3个$3 \times3 \times1$的滤波器对输入的3个通道分别做卷积，也就是说要做3次卷积，每次卷积都有一个$5 \times5 \times1$的输出，组合在一起便是$5 \times5 \times3$的输出。现在为了拓展深度达到128，我们需要执行深度可分离卷积的第二步：1x1卷积。现在我们用128个$1 \times1 \times3$的滤波器对$5 \times5 \times3$进行卷积，就可以得到$5 \times5 \times128$的输出。完整过程如下图所示：</p><p><img src="image-20230204111234-3ia5cu3.png" alt="image">​</p><p>那么我们来看一下深度可分离卷积的计算量如何。第一步深度卷积的计算量：$5 \times5 \times1 \times3 \times3 \times1 \times3=675$。第二步1x1卷积的计算量：$5 \times5 \times128 \times1 \times1 \times3=9600$，合计计算量为10275次。可见，相同的卷积计算输出，深度可分离卷积要比常规卷积节省12倍的计算成本。</p><blockquote><p>典型的应用深度可分离卷积的网络模型包括xception和mobilenet等。本质上而言，xception就是应用了深度可分离卷积的inception网络。</p></blockquote><h1 id="正文2"><a href="#正文2" class="headerlink" title="正文2"></a>正文<sup><a href="#fn_2" id="reffn_2">2</a></sup></h1><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>图像的二维性质给在计算机视觉中应用自注意力带来了三个挑战：</p><ol><li>将图像处理为一维序列，忽略了其二维结构。</li><li>二次复杂度对于高分辨率的图像来说太贵了。</li><li>它只捕捉了空间适应性，而忽略了通道适应性</li></ol><p>在本文中，作者提出了一种新的大核注意(LKA)模块，以使自注意的自适应和长程相关，同时避免了上述问题。作者进一步介绍了一种基于LKA的新的神经网络，即视觉注意网络(VAN)。VAN虽然非常简单和高效，但在包括图像分类、目标检测、语义分割、实例分割等广泛的实验中，它以很大的优势优于最先进的transfomer和卷积神经网络。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="LCK"><a href="#LCK" class="headerlink" title="LCK"></a>LCK</h3><p>卷积神经网络(CNNs)利用局部上下文信息和平移不变性，大大提高了神经网络的效率。自AlexNet以来，cnn迅速成为计算机视觉的主要主流框架。为了进一步提高效率，研究人员投入了大量的精力，使cnn成为更深的和更轻的。作者的工作与MobileNet有相似之处，MobileNet将标准卷积解耦为两部分，即深度卷积和逐点卷积(也就是1×1Conv)。作者的方法将卷积分解为三个部分：深度卷积、深度空洞卷积和逐点卷积。得益于这种分解，作者的方法更适合于有效地分解大的核卷积。作者还在该方法中引入了注意机制来获得自适应特性。</p><p><img src="v2-467f001629900492069a79a14d2dc757_720w.webp" alt="img"></p><p>彩色网格表示卷积核的位置，黄色网格表示中心点。从图中可以看出，13×13卷积分解为5×5深度卷积，5×5深度空洞卷积，膨胀速率3和1×1卷积</p><p><img src="v2-d22b7728ed41dd3491530ad8a94fbe19_720w.webp" alt="img"></p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">class AttentionModule(nn.Module):</span><br><span class="line">    def __init__(self, dim):</span><br><span class="line">        super().__init__()</span><br><span class="line">        self.conv0 = nn.Conv2d(dim, dim, 5, padding=2, groups=dim)#深度卷积</span><br><span class="line">        self.conv_spatial = nn.Conv2d(dim, dim, 7, stride=1, padding=9, groups=dim, dilation=3)#深度空洞卷积</span><br><span class="line">        self.conv1 = nn.Conv2d(dim, dim, 1)#逐点卷积</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def forward(self, x):</span><br><span class="line">        u = x.clone()        </span><br><span class="line">        attn = self.conv0(x)</span><br><span class="line">        attn = self.conv_spatial(attn)</span><br><span class="line">        attn = self.conv1(attn)</span><br><span class="line"></span><br><span class="line">        return u * attn   #注意力操作</span><br><span class="line">     </span><br><span class="line">class SpatialAttention(nn.Module):</span><br><span class="line">    def __init__(self, d_model):</span><br><span class="line">        super().__init__()</span><br><span class="line"></span><br><span class="line">        self.proj_1 = nn.Conv2d(d_model, d_model, 1)</span><br><span class="line">        self.activation = nn.GELU()</span><br><span class="line">        self.spatial_gating_unit = AttentionModule(d_model)  #注意力操作</span><br><span class="line">        self.proj_2 = nn.Conv2d(d_model, d_model, 1)</span><br><span class="line"></span><br><span class="line">    def forward(self, x):</span><br><span class="line">        shorcut = x.clone()</span><br><span class="line">        x = self.proj_1(x)</span><br><span class="line">        x = self.activation(x)</span><br><span class="line">        x = self.spatial_gating_unit(x)  #注意力操作</span><br><span class="line">        x = self.proj_2(x)</span><br><span class="line">        x = x + shorcut   #残差连接</span><br><span class="line">        return x</span><br><span class="line"></span><br><span class="line">class Block(nn.Module):</span><br><span class="line">    def __init__(self, dim, mlp_ratio=4., drop=0.,drop_path=0., act_layer=nn.GELU):</span><br><span class="line">        super().__init__()</span><br><span class="line">        self.norm1 = nn.BatchNorm2d(dim)</span><br><span class="line">        self.attn = SpatialAttention(dim)</span><br><span class="line">        self.drop_path = DropPath(drop_path) if drop_path &gt; 0. else nn.Identity()</span><br><span class="line"></span><br><span class="line">        self.norm2 = nn.BatchNorm2d(dim)</span><br><span class="line">        mlp_hidden_dim = int(dim * mlp_ratio)</span><br><span class="line">        self.mlp = Mlp(in_features=dim, hidden_features=mlp_hidden_dim, act_layer=act_layer, drop=drop)</span><br><span class="line">        layer_scale_init_value = 1e-2            </span><br><span class="line">        self.layer_scale_1 = nn.Parameter(</span><br><span class="line">            layer_scale_init_value * torch.ones((dim)), requires_grad=True)</span><br><span class="line">        self.layer_scale_2 = nn.Parameter(</span><br><span class="line">            layer_scale_init_value * torch.ones((dim)), requires_grad=True)</span><br><span class="line"></span><br><span class="line">        self.apply(self._init_weights)</span><br><span class="line"></span><br><span class="line">    def _init_weights(self, m):</span><br><span class="line">        if isinstance(m, nn.Linear):</span><br><span class="line">            trunc_normal_(m.weight, std=.02)</span><br><span class="line">            if isinstance(m, nn.Linear) and m.bias is not None:</span><br><span class="line">                nn.init.constant_(m.bias, 0)</span><br><span class="line">        elif isinstance(m, nn.LayerNorm):</span><br><span class="line">            nn.init.constant_(m.bias, 0)</span><br><span class="line">            nn.init.constant_(m.weight, 1.0)</span><br><span class="line">        elif isinstance(m, nn.Conv2d):</span><br><span class="line">            fan_out = m.kernel_size[0] * m.kernel_size[1] * m.out_channels</span><br><span class="line">            fan_out //= m.groups</span><br><span class="line">            m.weight.data.normal_(0, math.sqrt(2.0 / fan_out))</span><br><span class="line">            if m.bias is not None:</span><br><span class="line">                m.bias.data.zero_()</span><br><span class="line"></span><br><span class="line">    def forward(self, x):</span><br><span class="line">        x = x + self.drop_path(self.layer_scale_1.unsqueeze(-1).unsqueeze(-1) * self.attn(self.norm1(x)))#drop_path分支中，每个batch有概率使样本在self.attn或者mlp不会”执行“，会以0直接传递。</span><br><span class="line">        x = x + self.drop_path(self.layer_scale_2.unsqueeze(-1).unsqueeze(-1) * self.mlp(self.norm2(x)))</span><br><span class="line">        return </span><br></pre></td></tr></table></figure><p>作者提出对大核卷积操作进行分解来捕获长程关系。大核卷积可分为三个部分：空间局部卷积（深度卷积）、空间远程卷积（深度空洞卷积）和通道卷积（1×1卷积）。所以，可以将K×K卷积分解为K/d×K/d的深度空洞卷积，(2d−1)×(2d−1)的深度卷积和1×1卷积。通过上述分解，可以用轻微的计算代价和参数来捕获长程关系。在得到长程关系后，可以估计一个点的重要性并生成注意力图。</p><p><img src="v2-f2a083b057051de4ae3a87fd77138a8e_720w.webp" alt="img"></p><p><img src="v2-6109ccc0466efee70bf7ac2324513a09_720w.webp" alt="img"></p><p>作者提出的LKA结合了卷积和自注意力的优点。它考虑了局部上下文信息、大的感受野和动态过程。此外，LKA不仅实现了空间维度的自适应性，而且还实现了通道维度的自适应性。值得注意的是，在深度神经网络中，不同的通道往往代表不同的对象，而通道维度的适应性对视觉任务也很重要。</p><h3 id="VAN"><a href="#VAN" class="headerlink" title="VAN"></a>VAN</h3><p>VAN具有简单的层次结构，即输出空间分辨率降低的四个阶段序列，分别为H/4×W/4、H/8×W/8、H/16×W/16和H/32×W/32。H和W是输入图像的高度和宽度。随着分辨率的降低，输出通道的数量也在不断增加。输出通道Ci的变化如下表所示。 首先对输入值进行下采样，并使用步幅数来控制下采样率。下采样后，一个stage中的所有层保持相同的输出大小，即空间分辨率和通道数量。然后，批量归一化、GELU激活函数、大核注意和卷积前馈网络依次堆叠，提取特征。最后，在每个阶段结束时应用一个层归一化。根据参数和计算成本，设计了 VAN-Tiny, VAN-Small, VAN-Base and VAN-Large四种结构。</p><p><img src="v2-9c29743630133af223ffb0b9d3c592f0_720w.webp" alt="img"></p><p><img src="v2-f3d5e05ccc5b5d1691c26fc3d8daafcd_720w.webp" alt="img"></p><p>对21×21卷积的不同方式参数的比较。X，Y和our分别提供了标准卷积，mobilenet]和van的分解。输入和输出具有相同大小的H×W×C</p><p><img src="v2-f39da3202b78c90cd02669ff5039e8a9_720w.webp" alt="img"></p><p>默认情况下，本文的LKA采用5×5深度卷积，7×7深度卷积与膨胀率为3的空洞卷积和1×1卷积来近似21×21卷积。在这种设置下，VAN可以有效地获取局部信息和长程联系。作者分别使用7×7和3×3步幅卷积进行4×和2×的降采样。</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>作者在ImageNet-1K图像分类数据集、COCO目标检测数据集和ADE20K语义分割数据集上进行了定量实验。此外，作者通过在ImageNet验证集上使用Grad-CAM来可视化类激活映射(CAM)。</p><h3 id="图像分类"><a href="#图像分类" class="headerlink" title="图像分类"></a>图像分类</h3><p><img src="https://pic2.zhimg.com/80/v2-2fefbe89e8e7da997c3683528fbb2535_720w.webp" alt="img"></p><p>VAN与其他mlp、cnn和ViTs的比较。VAN优于其他参数相似，计算成本相似的cnn(ResNet[29]，ResNeXt[90]，ConvNeXt[53]等)，ViTs(DeiT[74]、PVT[83]、Swin-Transformer[52]等)和MLPs(MLP-Mixer[72]，ResMLP[73]，gMLP[46]等)。作者在每个类别中选择了一个具有代表性的网络进行讨论。ConvNeXt[53]是一种特殊的CNN，它吸收了vit的一些优势，如大的感受野（7×7卷积）和先进的训练策略(300个epoch、数据增强等)。VAN和ConvNeXt[53]相比，VAN-base比CoNvNeXt-t多出0.7%(82.8%vs.82.1%)，因为VAN具有更大的感受域和自适应能力。Swin-Transformer是一种著名的ViT变体，采用局部注意力和移动窗口的方式。由于VAN对二维结构信息非常友好，具有较大的感受野，并在通道维度上实现了自适应性，VAN-Base超过Swin-T1.5%(82.8%vs.81.3%)。对于MLPs，选择gMLP[46]。VAN-Base超过gMLP-S[46]3.2%(82.8%vs.79.6%)。也可以看出，在小型模型上面VAN的表现更加出色。</p><h3 id="目标检测"><a href="#目标检测" class="headerlink" title="目标检测"></a>目标检测</h3><p><img src="v2-c04b7aef7af9212da50e947198ea0179_720w.webp" alt="img"></p><p><img src="v2-ac6fd9136c34fa6ebfce940f20b6a318_720w.webp" alt="img"></p><p><img src="v2-f0a76550ee33afe78ff4d4458f544c25_720w.webp" alt="img"></p><h3 id="语义分割"><a href="#语义分割" class="headerlink" title="语义分割"></a>语义分割</h3><p><img src="v2-5675289d453da40b8f33f28c1966aa44_720w.webp" alt="img"></p><h3 id="消融实验"><a href="#消融实验" class="headerlink" title="消融实验"></a>消融实验</h3><p><img src="v2-1f9970a60d196d053e6433e7bbcca814_720w.webp" alt="img"></p><p>DW-D-Conv提供了深度空洞卷积，这在捕获LKA中的长程依赖性中发挥了作用。</p><p>DW-Conv可以利用图像的局部上下文信息。</p><p>注意力机制的引入可以看作是使网络实现了自适应特性。受益于此，VAN-Tiny实现了约1.1%（74.3%对75.4%）的改善。</p><p>1×1Conv捕获了通道维度中的关系。结合注意机制，引入了通道维度的自适应性。提高了0.8%(74.1%vs.75.4%)，证明了通道维度自适应性的必要性。</p><h3 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h3><p><img src="v2-84a72be357178fade018043de0213190_720w.webp" alt="img"></p><p>可视化结果。所有的图像都来自于ImageNet验证集中的不同类别。CAM采用VAN-Base模型和Grad-CAM产生。左：原始图像，右：类激活图</p><p>结果显示，VAN-Base可以清晰地聚焦于目标对象。因此，可视化直观地证明了VAN的有效性。</p><p>‍</p><h1 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h1><blockquote id="fn_1"><sup>1</sup>. <a href="https://baidinghub.github.io/2020/04/03/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9F%A5%E8%AF%86%E7%B3%BB%E5%88%97%28%E4%BA%8C%29%20%E5%90%84%E7%A7%8D%E5%8D%B7%E7%A7%AF%E5%BD%A2%E5%BC%8F/">深度学习知识系列(二) 各种卷积形式</a><a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a></blockquote><blockquote id="fn_2 "><sup>2 </sup>. <a href="https://zhuanlan.zhihu.com/p/474526444">【ARXIV2202】Visual Attention Network</a><a href="#reffn_2 " title="Jump back to footnote [2 ] in the text."> &#8617;</a></blockquote>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 计算机视觉 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring AOP Demo</title>
      <link href="/2022/12/04/Spring-AOP-Demo/"/>
      <url>/2022/12/04/Spring-AOP-Demo/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文不涉及Spring AOP原理</p></blockquote><h1 id="Spring-AOP-简介"><a href="#Spring-AOP-简介" class="headerlink" title="Spring AOP 简介"></a>Spring AOP 简介</h1><p>面向切面编程（AOP）是 Spring 最为重要的功能之一了，在数据库事务中切面编程被广泛使用。</p><h2 id="AOP-即-Aspect-Oriented-Program-面向切面编程"><a href="#AOP-即-Aspect-Oriented-Program-面向切面编程" class="headerlink" title="AOP 即 Aspect Oriented Program 面向切面编程"></a>AOP 即 Aspect Oriented Program 面向切面编程</h2><p>首先，在面向切面编程的思想里面，把功能分为核心业务功能，和周边功能。</p><ul><li><strong>所谓的核心业务</strong>​，比如登陆，增加数据，删除数据都叫核心业务</li><li><strong>所谓的周边功能</strong>​，比如性能统计，日志，事务管理等等</li></ul><p>周边功能在 Spring 的面向切面编程AOP思想里，即被定义为切面</p><p>在面向切面编程AOP的思想里面，核心业务功能和切面功能分别独立进行开发，然后把切面功能和核心业务功能 “编织” 在一起，这就叫AOP</p><h2 id="AOP-的目的"><a href="#AOP-的目的" class="headerlink" title="AOP 的目的"></a>AOP 的目的</h2><p>AOP能够将那些与业务无关，​<strong>却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来</strong>​，便于​<strong>减少系统的重复代码</strong>​，​<strong>降低模块间的耦合度</strong>​，并​<strong>有利于未来的可拓展性和可维护性</strong>​。</p><h2 id="AOP-当中的概念："><a href="#AOP-当中的概念：" class="headerlink" title="AOP 当中的概念："></a>AOP 当中的概念：</h2><ul><li>切入点（Pointcut）<br>在哪些类，哪些方法上切入（​<strong>where</strong>​）</li><li>通知（Advice）<br>在方法执行的什么实际（<strong>when:</strong>方法前/方法后/方法前后）做什么（<strong>what:</strong>增强的功能）</li><li>切面（Aspect）<br>切面 = 切入点 + 通知，通俗点就是：<strong>在什么时机，什么地方，做什么增强！</strong></li><li>织入（Weaving）<br>把切面加入到对象，并创建出代理对象的过程。（由 Spring 来完成）</li></ul><h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><h2 id="需求说明"><a href="#需求说明" class="headerlink" title="需求说明"></a>需求说明</h2><p>为了更好的说明 AOP 的概念，我们来举一个实际中的例子来说明：</p><p><img src="image-20221204123653-p1e00ow.png" alt="image">​</p><p>在上面的例子中，包租婆的核心业务就是签合同，收房租，那么这就够了，灰色框起来的部分都是重复且边缘的事，交给中介商就好了，这就是 <strong>AOP 的一个思想：让关注点代码与业务代码分离！</strong></p><h2 id="代码实现（使用注解）"><a href="#代码实现（使用注解）" class="headerlink" title="代码实现（使用注解）"></a>代码实现（使用注解）</h2><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><p>Spring Boot使用AOP需要添加spring-boot-starter-aop依赖，如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>不需要再添加aspectjweaver的依赖了，因为spring-boot-starter-aop包含了aspectjweaver，并且版本是较新的版本，如果在添加老版本（如1.5.4）启动会报错。</p><h3 id="编写核心业务Bean"><a href="#编写核心业务Bean" class="headerlink" title="编写核心业务Bean"></a>编写核心业务Bean</h3><p>也就是连接点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.test_spring.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LandlordService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rent</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;房东：谈合同&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;房东：收房租&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="创建切面"><a href="#创建切面" class="headerlink" title="创建切面"></a>创建切面</h3><p>Spring采用@AspectJ注解对POJO进行标注，该注解表明该类不仅仅是一个POJO，还是一个切面。切面是切点和通知的结合，那么定义一个切面就需要编写切点和通知。在代码中，只需要添加@Aspect注解即可。</p><h3 id="定义切点"><a href="#定义切点" class="headerlink" title="定义切点"></a>定义切点</h3><p>切点是通过<strong>@Pointcut</strong>注解和切点表达式定义的。</p><p>@Pointcut注解可以在一个切面内定义<strong>可重用</strong>的切点。</p><p>由于Spring切面粒度最小是达到方法级别，而execution表达式可以用于明确指定方法返回类型，类名，方法名和参数名等与方法相关的部件，并且实际中，大部分需要使用AOP的业务场景也只需要达到方法级别即可，因而execution表达式的使用是最为广泛的。如图是execution表达式的语法：</p><p>execution表示在方法执行的时候触发。以“​<em>”开头，表明方法返回值类型为任意类型。然后是全限定的类名和方法名，“</em>​”可以表示任意类和任意方法。对于方法参数列表，可以使用“..”表示参数为任意类型。如果需要多个表达式，可以使用“&amp;&amp;”、“||”和“!”完成与、或、非的操作。</p><p><img src="image-20221204150048-bd0mj1f.png" alt="image">​</p><h3 id="定义通知"><a href="#定义通知" class="headerlink" title="定义通知"></a>定义通知</h3><blockquote><p>通知有五种类型，分别是：</p><p>前置通知（@Before）：在目标方法调用之前调用通知</p><p>后置通知（@After）：在目标方法完成之后调用通知</p><p>环绕通知（@Around）：在被通知的方法调用之前和调用之后执行自定义的方法</p><p>返回通知（@AfterReturning）：在目标方法成功执行之后调用通知</p><p>异常通知（@AfterThrowing）：在目标方法抛出异常之后调用通知</p></blockquote><p>本例中，分别使用前置通知实现“看房”和“谈价格”功能，使用后置通知实现“交钥匙”功能。这样一个切面就定义完成，下面是代码</p><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.test_spring.aspect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.After;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Broker</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.example.test_spring.service.LandlordService.rent())&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointCut</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;pointCut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beforeRent</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;中间商：带租客看房&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;中间商：谈价格&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After(&quot;pointCut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterRent</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;中间商：交钥匙&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSpringApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> SpringApplication.run(TestSpringApplication.class, args);</span><br><span class="line">        <span class="type">LandlordService</span> <span class="variable">bean</span> <span class="operator">=</span> context.getBean(LandlordService.class);</span><br><span class="line">        bean.rent();</span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="image-20221204150759-y1b4f1u.png" alt="image">​</p><h2 id="环绕通知"><a href="#环绕通知" class="headerlink" title="环绕通知"></a>环绕通知</h2><p>看到上述的需求也可以使用环绕通知，他会在方法执行前后执行。</p><p>改写<code>Broker.java</code>​代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.test_spring.aspect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.JoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Broker</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.example.test_spring.service.LandlordService.rent())&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointCut</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    @Before(&quot;pointCut()&quot;)</span></span><br><span class="line"><span class="comment">//    public void beforeRent() &#123;</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;中间商：带租客看房&quot;);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;中间商：谈价格&quot;);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    @After(&quot;pointCut()&quot;)</span></span><br><span class="line"><span class="comment">//    public void afterRent() &#123;</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;中间商：交钥匙&quot;);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;pointCut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">aroundRent</span><span class="params">(ProceedingJoinPoint point)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;中间商：带租客看房&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;中间商：谈价格&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            point.proceed();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;中间商：交钥匙&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行测试代码，结果依然正确</p><h1 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h1><ol><li><a href="https://www.jianshu.com/p/994027425b44">Spring(4)——面向切面编程（AOP模块）</a></li><li><a href="https://www.cnblogs.com/sgh1023/p/13363679.html">Spring Boot使用AOP的正确姿势</a>​</li></ol><p>‍</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
            <tag> 面向切面编程 </tag>
            
            <tag> AOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用docker部署redis并实现外部访问</title>
      <link href="/2022/11/23/%E4%BD%BF%E7%94%A8docker%E9%83%A8%E7%BD%B2redis%E5%B9%B6%E5%AE%9E%E7%8E%B0%E5%A4%96%E9%83%A8%E8%AE%BF%E9%97%AE/"/>
      <url>/2022/11/23/%E4%BD%BF%E7%94%A8docker%E9%83%A8%E7%BD%B2redis%E5%B9%B6%E5%AE%9E%E7%8E%B0%E5%A4%96%E9%83%A8%E8%AE%BF%E9%97%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="安装之前环境部署"><a href="#安装之前环境部署" class="headerlink" title="安装之前环境部署"></a>安装之前环境部署</h1><p>关闭linux防火墙</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure><p>如果你使用的是云服务器，务必进入云服务器,给6379端口放行</p><h1 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h1><h2 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull redis:latest</span><br></pre></td></tr></table></figure><h2 id="从官网下载redis配置文件"><a href="#从官网下载redis配置文件" class="headerlink" title="从官网下载redis配置文件"></a>从官网下载redis配置文件</h2><p><code>wget http://download.redis.io/redis-stable/redis.conf</code></p><h2 id="创建一个文件夹用于保存此文件"><a href="#创建一个文件夹用于保存此文件" class="headerlink" title="创建一个文件夹用于保存此文件"></a>创建一个文件夹用于保存此文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /root/redis</span><br><span class="line"><span class="built_in">mv</span> /root/redis.conf  /root/redis</span><br></pre></td></tr></table></figure><h2 id="更改redis-conf的配置"><a href="#更改redis-conf的配置" class="headerlink" title="更改redis.conf的配置"></a>更改redis.conf的配置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /root/redis/redis.conf</span><br></pre></td></tr></table></figure><p>将redis.conf文件下列参数更改</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#bind 127.0.0.1 #允许远程连接(注释或者改为bind 0.0.0.0) </span></span><br><span class="line">protected-mode no    <span class="comment">#保护模式</span></span><br><span class="line">appendonly <span class="built_in">yes</span> <span class="comment">#持久化</span></span><br></pre></td></tr></table></figure><h2 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -p 6379:6379 --name redis -v /root/redis/redis.conf:/etc/redis/redis.conf -v /root/redis/data:/data -d redis redis-server /etc/redis/redis.conf </span><br></pre></td></tr></table></figure><p>参数说明:</p><ul><li>-p 6379:6379：把容器内的6379端口映射到宿主机6379端口</li><li>–name redis：设置容器名称为redis</li><li>-v /root/redis/redis.conf:/etc/redis/redis.conf：把主机配置好的redis.conf放到容器内的这个位置中</li><li>-v /root/redis/data:/data：把redis持久化的数据在宿主机内显示，做数据备份</li><li>-d：redis后台运行</li><li>redis-server /etc/redis/redis.conf：这个是关键配置，让redis不是无配置启动，而是按照这个redis.conf的配置启动</li></ul><h2 id="完成测试"><a href="#完成测试" class="headerlink" title="完成测试"></a>完成测试</h2><p>查看容器是否启动：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p>进入容器，检查是否可以启动redis-cli</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@Met-Guo:~<span class="comment"># docker exec -it 56 bash # 56为容器id</span></span><br><span class="line">root@5601af5f1f67:/data<span class="comment"># redis-cli</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name 50</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line"><span class="string">&quot;50&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exit</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在宿主机安装Redis Desktop Manager客户端，并配置</p><p><img src="image-20221123222544338.png" alt="截图"></p><p>成功。</p><h1 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h1><ol><li><a href="https://blog.csdn.net/weixin_46186045/article/details/117387772">docker 部署redis外部访问该注意的地方你都知道吗</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis安装 </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSH三步解决免密登录</title>
      <link href="/2022/11/07/SSH%E4%B8%89%E6%AD%A5%E8%A7%A3%E5%86%B3%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/"/>
      <url>/2022/11/07/SSH%E4%B8%89%E6%AD%A5%E8%A7%A3%E5%86%B3%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h1><ol><li><a href="https://blog.csdn.net/jeikerxiao/article/details/84105529">SSH 三步解决免密登录</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FATE使用遇到的问题汇总</title>
      <link href="/2022/11/04/FATE%E4%BD%BF%E7%94%A8%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
      <url>/2022/11/04/FATE%E4%BD%BF%E7%94%A8%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<p>本文汇总在使用和开发FATE时遇到的各类问题，以及给出可能的解决方案。</p><h1 id="flow-init"><a href="#flow-init" class="headerlink" title="flow init"></a>flow init</h1><h2 id="问题状态"><a href="#问题状态" class="headerlink" title="问题状态"></a>问题状态</h2><p>已解决</p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>首次进入fate-client时，提示需要执行flow init，否则有关flow的命令都执行不了。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p><code>flow init --ip &lt;docker容器宿主机ip&gt; --port 9380</code></p><p>‍</p><h1 id="ModuleNotFoundError-No-module-named-‘-lzma’"><a href="#ModuleNotFoundError-No-module-named-‘-lzma’" class="headerlink" title="ModuleNotFoundError: No module named ‘_lzma’"></a>ModuleNotFoundError: No module named ‘_lzma’</h1><h2 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h2><p>执行任务时，nn模块报错：ModuleNotFoundError: No module named ‘_lzma’</p><p><img src="image-20220927210914-c8pbaiz.png" alt="image.png"></p><h2 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h2><p>在fate-flow container安装相关的包即可（guest、host和arbiter都要安装）。安装教程：<a href="https://github.com/ultralytics/yolov5/issues/1298">https://github.com/ultralytics/yolov5/issues/1298</a></p><p>这里需要修改路径</p><p><img src="image-20220928115429-n9l4hgw.png" alt="image.png"></p><h1 id="找不到文件：No-such-file-or-directory-‘-data-projects-fate-work-mnist-fed-mnist-train-part2-config-yaml’"><a href="#找不到文件：No-such-file-or-directory-‘-data-projects-fate-work-mnist-fed-mnist-train-part2-config-yaml’" class="headerlink" title="找不到文件：No such file or directory: ‘/data/projects/fate/work/mnist_fed/mnist_train_part2/config.yaml’"></a>找不到文件：<strong>No such file or directory: ‘/data/projects/fate/work/mnist_fed/mnist_train_part2/config.yaml’</strong></h1><h2 id="问题状态-1"><a href="#问题状态-1" class="headerlink" title="问题状态"></a>问题状态</h2><p>已解决</p><h2 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h2><p>在执行任务时，reader组件报错：</p><p><img src="image-20220927205925-34fvaot.png" alt="image.png"></p><p>这是由于我把数据保存在了fate-client，而fate读取数据是在fate-flow container导致的。</p><h2 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h2><p>由于fate-client和fate-flow两个容器中的examples文件夹挂载到docker底层同一处存储。所以把数据放到examples下，把配置修改为新的文件路径即可。</p><h1 id="开发新的FATE-FLOW-API"><a href="#开发新的FATE-FLOW-API" class="headerlink" title="开发新的FATE-FLOW API"></a>开发新的FATE-FLOW API</h1><p>这里是已有的API：<a href="https://federatedai.github.io/FATE-Flow/latest/zh/swagger/">https://federatedai.github.io/FATE-Flow/latest/zh/swagger/</a></p><p>FATE的HTTP接口都是基于flask框架编写的。</p><p>开发步骤如下：</p><ol><li>进入FATE-FLOW容器</li><li>cd /data/projects/fate/fateflow/python/fate_flow/apps</li><li>新建python文件，命名为xxx_app.py，编写新的接口。</li><li>重启FLOW容器</li></ol><h1 id="修改代码导致docker-container没起来"><a href="#修改代码导致docker-container没起来" class="headerlink" title="修改代码导致docker container没起来"></a>修改代码导致docker container没起来</h1><p>修改FATE-FLOW的代码后，由于代码有bug，导致容器起不来，又导致不能进入容器修改代码的死循环，怎么办？</p><p>查看docker容器的启动日志，确定出错的代码，docker cp拷贝出来需要修改的代码，再拷贝回去。</p><p>‍</p><h1 id="实际训练的epoch小于配置的max-iter"><a href="#实际训练的epoch小于配置的max-iter" class="headerlink" title="实际训练的epoch小于配置的max_iter"></a>实际训练的epoch小于配置的max_iter</h1><p>查看自己是否在配置文件中配置了：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;early_stop&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;early_stop&quot;</span><span class="punctuation">:</span> <span class="string">&quot;diff&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;eps&quot;</span><span class="punctuation">:</span> <span class="number">0.0001</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p>这里的意思是，如果两个epoch得到的loss之差小于0.0001时则停止训练。</p><h1 id="memory-error"><a href="#memory-error" class="headerlink" title="memory error"></a>memory error</h1><p>根据实践经验，memory error 还有dataloader worker pid之类的错误，均是由于内存不够引起的。调小batch size，或者增加硬件配置</p><p>‍</p>]]></content>
      
      
      <categories>
          
          <category> 联邦学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 联邦学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FATE横向联邦学习：肺炎的多模态任务的联邦学习</title>
      <link href="/2022/11/04/FATE%E6%A8%AA%E5%90%91%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0%EF%BC%9A%E8%82%BA%E7%82%8E%E7%9A%84%E5%A4%9A%E6%A8%A1%E6%80%81%E4%BB%BB%E5%8A%A1%E7%9A%84%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/11/04/FATE%E6%A8%AA%E5%90%91%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0%EF%BC%9A%E8%82%BA%E7%82%8E%E7%9A%84%E5%A4%9A%E6%A8%A1%E6%80%81%E4%BB%BB%E5%8A%A1%E7%9A%84%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>多模态最近比较火</p><p>多模态任务的input和算法FATE不支持，因此需要开发新的dataloader和算法组件。</p><p>本篇就以肺炎多模态任务为例，介绍如何开发新的FATE机器学习组件</p><p>官方文档在这里：<a href="https://fate.readthedocs.io/en/latest/develop/develop_guide/#develop-an-algorithm-component-of-fate">https://fate.readthedocs.io/en/latest/develop/develop_guide/#develop-an-algorithm-component-of-fate</a></p></blockquote><h1 id="baseline"><a href="#baseline" class="headerlink" title="baseline"></a>baseline</h1><p>本任务将开发基于肺部X光图像和描述文字正确判断是否患有肺炎的二分类算法。</p><p>数据集输入由两部分组成。一部分为肺部X光扫描图像，另一部分为对图像的描述文字。数据标签分为0和1，分别对应正常和患有肺炎两类标签。</p><h2 id="本地代码复现"><a href="#本地代码复现" class="headerlink" title="本地代码复现"></a>本地代码复现</h2><ol><li>baseline 代码在这里：<a href="https://github.com/AxelAllen/Multimodal-BERT-in-Medical-Image-and-Text-Classification">https://github.com/AxelAllen/Multimodal-BERT-in-Medical-Image-and-Text-Classification</a></li><li>将其clone到本地，按照README.md的提示，将NLMCXR_png_frontal图像文件夹放到data目录下。执行data/preparations.ipynb生成元数据。</li><li>执行run_mmbt.ipynb</li><li>执行完毕后，会在根目录下生成mmbt_output_findings_10epochs_n文件夹，里面保存有模型拟合后的梯度和评估结果。</li></ol><h2 id="阅读代码"><a href="#阅读代码" class="headerlink" title="阅读代码"></a>阅读代码</h2><p>这里要弄清楚代码的整套流程，主要是超参、使用的算法、训练、数据处理和加载，模型如何评估这几步。这里只展示核心代码</p><h3 id="超参"><a href="#超参" class="headerlink" title="超参"></a>超参</h3><div class="table-container"><table><thead><tr><th>参数</th><th>值</th></tr></thead><tbody><tr><td>Epoch</td><td>10</td></tr><tr><td>Bacth_size</td><td>16/32</td></tr><tr><td>Optimizer</td><td>AdamW</td></tr><tr><td>LR</td><td>5e-5</td></tr><tr><td>Loss</td><td>CrossEntropyLoss</td></tr><tr><td>Metrics</td><td>Accuracy</td></tr></tbody></table></div><blockquote><p>有趣的是，如果batch size = 4，模型无法训练处任何结果。</p></blockquote><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 部分code</span></span><br><span class="line"></span><br><span class="line">transformer_config = AutoConfig.from_pretrained(args.config_name <span class="keyword">if</span> args.config_name <span class="keyword">else</span> args.model_name, num_labels=num_labels)</span><br><span class="line">tokenizer = AutoTokenizer.from_pretrained(</span><br><span class="line">        args.tokenizer_name <span class="keyword">if</span> args.tokenizer_name <span class="keyword">else</span> args.model_name,</span><br><span class="line">        do_lower_case=<span class="literal">True</span>,</span><br><span class="line">        cache_dir=<span class="literal">None</span>,</span><br><span class="line">    )</span><br><span class="line">transformer = AutoModel.from_pretrained(args.model_name, config=transformer_config, cache_dir=<span class="literal">None</span>)</span><br><span class="line">img_encoder = ImageEncoderDenseNet(num_image_embeds=args.num_image_embeds)</span><br><span class="line">multimodal_config = MMBTConfig(transformer, img_encoder, num_labels=num_labels, modal_hidden_size=<span class="number">1024</span>)</span><br><span class="line">model = MMBTForClassification(transformer_config, multimodal_config)</span><br></pre></td></tr></table></figure><p>使用MMBT模型: 用于图像和文本分类的有监督多模态双向Transformer。</p><ul><li>图像编码器使用的ChexNet，这是一个针对X光胸片肺炎检测的模型；</li><li>文本编码器使用的预训练的BERT模型：bert-base-uncased。</li></ul><p>整体网络结构如图</p><p><img src="image-20221102150400-2suo5cw.png" alt="image">​</p><p>‍</p><h3 id="data-loader"><a href="#data-loader" class="headerlink" title="data loader"></a>data loader</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 部分code</span></span><br><span class="line">dataset = JsonlDataset(path, img_dir, tokenizer, img_transforms, labels, wandb_config.max_seq_length -</span><br><span class="line">                       wandb_config.num_image_embeds - <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">train_dataloader = DataLoader(</span><br><span class="line">    train_dataset,</span><br><span class="line">    sampler=train_sampler,</span><br><span class="line">    batch_size=args.train_batch_size,</span><br><span class="line">    collate_fn=collate_fn</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="train"><a href="#train" class="headerlink" title="train"></a>train</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 部分code</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> train_iterator:</span><br><span class="line">    epoch_iterator = tqdm(train_dataloader, desc=<span class="string">&quot;Training Batch Iteration&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> step, batch <span class="keyword">in</span> <span class="built_in">enumerate</span>(epoch_iterator):</span><br><span class="line"></span><br><span class="line">        batch = <span class="built_in">tuple</span>(t.to(args.device) <span class="keyword">for</span> t <span class="keyword">in</span> batch)</span><br><span class="line">        labels = batch[<span class="number">5</span>]</span><br><span class="line">        input_ids = batch[<span class="number">0</span>]</span><br><span class="line">        input_modal = batch[<span class="number">2</span>]</span><br><span class="line">        attention_mask = batch[<span class="number">1</span>]</span><br><span class="line">        modal_start_tokens = batch[<span class="number">3</span>]</span><br><span class="line">        modal_end_tokens = batch[<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">        outputs = model(</span><br><span class="line">            input_modal,</span><br><span class="line">            input_ids=input_ids,</span><br><span class="line">            modal_start_tokens=modal_start_tokens,</span><br><span class="line">            modal_end_tokens=modal_end_tokens,</span><br><span class="line">            attention_mask=attention_mask,</span><br><span class="line">            token_type_ids=<span class="literal">None</span>,</span><br><span class="line">            modal_token_type_ids=<span class="literal">None</span>,</span><br><span class="line">            position_ids=<span class="literal">None</span>,</span><br><span class="line">            modal_position_ids=<span class="literal">None</span>,</span><br><span class="line">            head_mask=<span class="literal">None</span>,</span><br><span class="line">            inputs_embeds=<span class="literal">None</span>,</span><br><span class="line">            labels=labels,</span><br><span class="line">            return_dict=<span class="literal">True</span></span><br><span class="line">        )</span><br><span class="line">        logits = outputs.logits</span><br><span class="line">        loss = outputs.loss</span><br><span class="line">        loss.backward()</span><br></pre></td></tr></table></figure><h3 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 部分代码</span></span><br><span class="line">result = evaluate(args, model, tokenizer, evaluate=<span class="literal">True</span>, test=<span class="literal">True</span>, prefix=prefix)</span><br></pre></td></tr></table></figure><h1 id="开发新组件"><a href="#开发新组件" class="headerlink" title="开发新组件"></a>开发新组件</h1><p>当我们已经在本地跑通代码，并明确算法之后，就可以开发新的组件，将算法联邦化。</p><p>这里官方文档写的很清楚，我大概复述一下</p><h3 id="Step-1-Define-the-python-parameter-object-to-be-used-by-this-component"><a href="#Step-1-Define-the-python-parameter-object-to-be-used-by-this-component" class="headerlink" title="Step 1. Define the python parameter object to be used by this component"></a>Step 1. Define the python parameter object to be used by this component</h3><ol><li>Open a new python file called <code>xxx_param.py</code>​, where xxx stands for your component’s name. Place this file in the folder <code>python/federatedm/param/</code>​. The class object defined in <code>xxx_param.py</code>​ should inherit the <code>BaseParam</code>​ class declared in <code>python/federatedml/param/base_param.py</code>​</li><li>The <code>__init__</code>​ method of your parameter class should specify all parameters that the component uses.</li><li>Override and implement the <code>check</code>​ interface method of BaseParam. The <code>check</code>​ method is used to validate the parameter variables.</li><li><code>python/federatedml/param/__init__.py</code>​列表<code>__all__</code>​增加你的组件名称，并导入。</li></ol><p>我这里组件名称叫homo_mm，所以创建的python文件名为homo_mm_param.py。由于和homo_nn很像，所以直接讲homo_nn_param.py复制过来，将里面的“nn”改成“mm”。</p><p>第四步增加了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> federatedml.param.homo_mm_param <span class="keyword">import</span> HomoMMParam</span><br><span class="line">...</span><br><span class="line">__all__ = [... <span class="string">&quot;HomoMMParam&quot;</span>, ...]</span><br></pre></td></tr></table></figure><p>python/federatedml/param/<strong>init</strong>.py</p><h3 id="Step-2-Define-the-meta-file-of-the-new-component"><a href="#Step-2-Define-the-meta-file-of-the-new-component" class="headerlink" title="Step 2. Define the meta file of the new component"></a>Step 2. Define the meta file of the new component</h3><ol><li>Define component meta python file under <code>python/federatedml/components/</code>​, name it as <code>xxx.py</code>​, where xxx stands for the algorithm component being developed.</li><li>Implement the meta file.</li></ol><p>我这里组件名称叫homo_mm，所以创建的python文件名为homo_mm.py。由于和homo_nn很像，所以直接讲homo_nn.py复制过来，将里面的“nn”改成“mm”。</p><h3 id="Step-3-Define-the-transfer-variable-object-of-this-module-Optional"><a href="#Step-3-Define-the-transfer-variable-object-of-this-module-Optional" class="headerlink" title="Step 3. Define the transfer variable object of this module. (Optional)"></a>Step 3. Define the transfer variable object of this module. (Optional)</h3><p>这里不需要</p><h3 id="Step-4-Create-the-component-which-inherits-the-class-model-base​"><a href="#Step-4-Create-the-component-which-inherits-the-class-model-base​" class="headerlink" title="Step 4. Create the component which inherits the class model_base​"></a>Step 4. Create the component which inherits the class <code>model_base</code>​</h3><p>现在就可以将<code>python/federatedml/nn/homo_nn</code>​复制一份，修改为homo_mm，修改_torch.py文件</p><p>详略。</p><h3 id="additional"><a href="#additional" class="headerlink" title="additional"></a>additional</h3><p>需要注意在<code>python/federatedml/nn/backend/pytorch/data.py</code>​新建新的dataset。并在_torch中的make_dataset创建，这里可以参照VisionDataSet</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MMDataSet</span>(<span class="title class_ inherited__">DatasetMixIn</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_num_labels</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_num_features</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_keys</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._keys</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">as_data_instance</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">from</span> federatedml.feature.instance <span class="keyword">import</span> Instance</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">_as_instance</span>(<span class="params">x</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(x, np.number):</span><br><span class="line">                <span class="keyword">return</span> Instance(label=x.tolist())</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> Instance(label=x)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> computing_session.parallelize(</span><br><span class="line">            data=<span class="built_in">zip</span>(self._keys, <span class="built_in">map</span>(_as_instance, self.targets)),</span><br><span class="line">            include_key=<span class="literal">True</span>,</span><br><span class="line">            partition=<span class="number">1</span>,</span><br><span class="line">        )</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,train_data_path, is_train=<span class="literal">True</span>, expected_label_type=np.float32,**kwargs</span>):</span><br><span class="line"><span class="comment"># 这里必须加上，否则会卡在标签对齐且不报错</span></span><br><span class="line">        <span class="keyword">if</span> is_train:</span><br><span class="line">            HomoLabelEncoderClient().label_alignment([<span class="string">&quot;fake&quot;</span>])</span><br><span class="line"></span><br><span class="line">        tokenizer = AutoTokenizer.from_pretrained(</span><br><span class="line">            <span class="string">&quot;bert-base-uncased&quot;</span>,</span><br><span class="line">            do_lower_case=<span class="literal">True</span>,</span><br><span class="line">            cache_dir=<span class="literal">None</span>,</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        labels = [<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">        labels2id = &#123;<span class="string">&#x27;0&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;1&#x27;</span>: <span class="number">1</span>&#125;</span><br><span class="line">        self.labels2id = labels2id</span><br><span class="line">        self.data = [json.loads(line) <span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">open</span>(os.path.join(train_data_path, <span class="string">&quot;meta.jsonl&quot;</span>))]</span><br><span class="line"></span><br><span class="line">        self.targets = [ item[<span class="string">&#x27;label&#x27;</span>] <span class="keyword">for</span> item <span class="keyword">in</span> self.data]</span><br><span class="line">        self.img_data_dir = os.path.join(train_data_path, <span class="string">&#x27;images&#x27;</span>)</span><br><span class="line">        self.tokenizer = tokenizer</span><br><span class="line">        self.labels = labels</span><br><span class="line">        self.n_classes = <span class="built_in">len</span>(labels)</span><br><span class="line">        self.max_seq_length = <span class="number">300</span> - <span class="number">3</span> - <span class="number">2</span></span><br><span class="line">        self.transforms = torchvision.transforms.Compose(</span><br><span class="line">            [</span><br><span class="line">                torchvision.transforms.Resize(<span class="number">256</span>),</span><br><span class="line">                torchvision.transforms.CenterCrop(<span class="number">224</span>),</span><br><span class="line">                torchvision.transforms.ToTensor(),</span><br><span class="line">                torchvision.transforms.Normalize(</span><br><span class="line">                    mean=[<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>],</span><br><span class="line">                    std=[<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>]</span><br><span class="line">                )</span><br><span class="line">            ]</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        key_dic = []</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">id</span> <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.data)):</span><br><span class="line">            key_dic.append(<span class="built_in">id</span>)</span><br><span class="line">        self._keys = key_dic</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, index</span>):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        sentence = torch.LongTensor(self.tokenizer.encode(self.data[index][<span class="string">&quot;text&quot;</span>], add_special_tokens=<span class="literal">True</span>))</span><br><span class="line">        start_token, sentence, end_token = sentence[<span class="number">0</span>], sentence[<span class="number">1</span>:-<span class="number">1</span>], sentence[-<span class="number">1</span>]</span><br><span class="line">        sentence = sentence[:self.max_seq_length]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.n_classes &gt; <span class="number">2</span>:</span><br><span class="line">            <span class="comment"># multiclass</span></span><br><span class="line">            label = torch.zeros(self.n_classes)</span><br><span class="line">            label[self.labels.index(self.data[index][<span class="string">&quot;label&quot;</span>])] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            label = torch.LongTensor([self.labels.index(self.data[index][<span class="string">&quot;label&quot;</span>])])</span><br><span class="line"></span><br><span class="line">        image = Image.<span class="built_in">open</span>(os.path.join(self.img_data_dir, self.data[index][<span class="string">&quot;img&quot;</span>])).convert(<span class="string">&quot;RGB&quot;</span>)</span><br><span class="line">        image = self.transforms(image)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="string">&quot;image_start_token&quot;</span>: start_token,</span><br><span class="line">            <span class="string">&quot;image_end_token&quot;</span>: end_token,</span><br><span class="line">            <span class="string">&quot;sentence&quot;</span>: sentence,</span><br><span class="line">            <span class="string">&quot;image&quot;</span>: image,</span><br><span class="line">            <span class="string">&quot;label&quot;</span>: label,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.data)</span><br><span class="line">    <span class="comment"># 标签名称和标签index的对应，例如&#123;&quot;阴性&quot;:0, &quot;阳性&quot;:1&#125;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_label_align_mapping</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.labels2id</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果Job仍然跑不起来，可以通过FATE-BOARD日志排错。</p><p>‍</p>]]></content>
      
      
      <categories>
          
          <category> 联邦学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 联邦学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FATE横向联邦学习：肠癌图像分类任务（下）——联邦化</title>
      <link href="/2022/11/04/FATE%E6%A8%AA%E5%90%91%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0%EF%BC%9A%E8%82%A0%E7%99%8C%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1%EF%BC%88%E4%B8%8B%EF%BC%89%E2%80%94%E2%80%94%E8%81%94%E9%82%A6%E5%8C%96/"/>
      <url>/2022/11/04/FATE%E6%A8%AA%E5%90%91%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0%EF%BC%9A%E8%82%A0%E7%99%8C%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1%EF%BC%88%E4%B8%8B%EF%BC%89%E2%80%94%E2%80%94%E8%81%94%E9%82%A6%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在上一篇已经在本地跑通了肠癌图像分类的整个流程，现在我们将它移植到FATE上，实现联邦学习。</p></blockquote><h1 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h1><p>仿照“手写数字识别”任务，将三份训练数据进行预处理。并新建配置文件，处理后的格式如图。</p><p><img src="image-20221101234910-nivm8sx.png" alt="image.png"></p><ul><li>code/： bind开头的文件是用于数据绑定；colon_conf是conf文件，colon_dsl是dsl文件</li><li>test/：500张测试数据</li><li>val/：500张验证集</li><li><p>train_pX/：第X份训练数据，每一份3000张</p><ul><li>images/：图片文件夹，存放所有图像</li><li>config.yaml：图片文件夹配置：通道数，格式等。</li><li>filenames：images目录下的所有文件名（去掉后缀），每个文件名占一行</li><li>targets：images目录下的所有文件名（去掉后缀）和label，逗号区分，每个文件名和类别占一行。</li></ul></li></ul><h1 id="修改源代码"><a href="#修改源代码" class="headerlink" title="修改源代码"></a>修改源代码</h1><p>之前在分析源码时，可以看到homo_nn的模型配置比较定制化，不够灵活，因此我们修改源码实现：</p><ol><li>修改数据加载</li><li>使用预训练的vgg16算法模型；</li><li>使用GPU</li><li>实现模型评估</li></ol><h2 id="修改数据加载"><a href="#修改数据加载" class="headerlink" title="修改数据加载"></a>修改数据加载</h2><p>我们知道vgg16传入的图像尺寸为$224<em>224</em>3$，而肠癌数据集的图像格式大小为$768<em>768</em>3$，所以需要先对数据加载进行修改：</p><p>修改FATE/python/federatedml/nn/backend/pytorch/data.py的<code>VisionDataSet</code>类的<strong>get_item</strong>方法：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, index</span>):</span><br><span class="line"></span><br><span class="line">    img = Image.<span class="built_in">open</span>(self.images[index]).convert(self._PIL_mode)</span><br><span class="line">    <span class="keyword">if</span> img.size[<span class="number">0</span>] &gt; <span class="number">224</span>:</span><br><span class="line">        resize_transform = torchvision.transforms.Compose(</span><br><span class="line">            [</span><br><span class="line">                torchvision.transforms.Resize(<span class="number">256</span>),</span><br><span class="line">                torchvision.transforms.CenterCrop(<span class="number">224</span>),</span><br><span class="line">            ]</span><br><span class="line">        )</span><br><span class="line">        img = resize_transform(img)</span><br><span class="line">    <span class="keyword">if</span> self.targets_is_image:</span><br><span class="line">        target = Image.<span class="built_in">open</span>(self.targets[index])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        target = self.targets[index]</span><br><span class="line">    <span class="keyword">return</span> self.transforms(img, target)</span><br></pre></td></tr></table></figure><h2 id="修改算法模型"><a href="#修改算法模型" class="headerlink" title="修改算法模型"></a>修改算法模型</h2><p>我们需要修改homo<em>nn组件下的<em>torch.py文件，<code>FedLightModule</code>类的__init</em></em>方法</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># --------- 修改前 ----------</span></span><br><span class="line"><span class="comment"># self.model = nn.Sequential(*layers)</span></span><br><span class="line"><span class="comment"># --------- 修改后 ----------</span></span><br><span class="line"><span class="comment"># 这里非常定制化，out_features=2是针对本二分类任务，如果需要更灵活的传参，可以读取配置文件的配置</span></span><br><span class="line">LOGGER.info(<span class="string">&quot;define vgg16&quot;</span>)</span><br><span class="line">self.model = models.vgg16(pretrained=<span class="literal">True</span>)</span><br><span class="line">self.model.classifier[<span class="number">6</span>] = nn.Linear(in_features=<span class="number">4096</span>, out_features=<span class="number">2</span>, bias=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h2 id="使用GPU"><a href="#使用GPU" class="headerlink" title="使用GPU"></a>使用GPU</h2><p>需要修改homo_nn组件下的_torch.py文件，<code>FedLightModule</code>类的training_step、validation_step以及do_convergence_check和encrypt方法。改动如下。</p><blockquote><p>do_convergence_check和encrypt要改动的原因并不清楚，大致来看，应该是在model聚合和加密的时候需要将其从GPU中取出。。不过可以肯定，如此改动就会生效。</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">validation_step</span>(<span class="params">self, batch, batch_idx</span>):</span><br><span class="line">    x, y = batch</span><br><span class="line">    <span class="comment"># -------------- add start ------------------</span></span><br><span class="line">    device = torch.device(<span class="string">&#x27;cuda&#x27;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&#x27;cpu&#x27;</span>)</span><br><span class="line">    <span class="comment"># LOGGER.info(f&#x27;device:&#123;device&#125;&#x27;)</span></span><br><span class="line">    x, y = x.to(device), y.to(device)</span><br><span class="line">    <span class="comment"># -------------- add end ------------------</span></span><br><span class="line">    y_hat = self.forward(x)</span><br><span class="line">    loss = self.loss_fn(y_hat, y)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> y_hat.shape[<span class="number">1</span>] &gt; <span class="number">1</span>:</span><br><span class="line">        accuracy = (y_hat.argmax(dim=<span class="number">1</span>) == y).<span class="built_in">sum</span>().<span class="built_in">float</span>() / <span class="built_in">float</span>(y.size(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        y_prob = y_hat[:, <span class="number">0</span>] &gt; <span class="number">0.5</span></span><br><span class="line">        accuracy = (y == y_prob).<span class="built_in">sum</span>().<span class="built_in">float</span>() / y.size(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;val_loss&quot;</span>: loss, <span class="string">&quot;val_accuracy&quot;</span>: accuracy&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">training_step</span>(<span class="params">self, batch, batch_idx</span>):</span><br><span class="line">    x, y = batch</span><br><span class="line">    <span class="comment"># -------------- add start ------------------</span></span><br><span class="line">    device = torch.device(<span class="string">&#x27;cuda&#x27;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&#x27;cpu&#x27;</span>)</span><br><span class="line">    x, y = x.to(device), y.to(device)</span><br><span class="line">    self.model = self.model.to(device)</span><br><span class="line">    <span class="comment"># -------------- add end ------------------</span></span><br><span class="line">    y_hat = self.model(x)</span><br><span class="line">    <span class="comment"># LOGGER.info(&#x27;y_hat: &#123;&#125;&#x27;.format(y_hat.detach().numpy()))</span></span><br><span class="line">    loss = self.loss_fn(y_hat, y)</span><br><span class="line">    self.log(<span class="string">&quot;train_loss&quot;</span>, loss)</span><br><span class="line">    <span class="keyword">return</span> loss</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">do_convergence_check</span>(<span class="params">self, weight, loss</span>):</span><br><span class="line">    <span class="comment"># loss_value = loss.detach().numpy().tolist()</span></span><br><span class="line">    loss_value = loss.detach().cpu().numpy().tolist()</span><br><span class="line"></span><br><span class="line">    self.loss_summary.append(loss_value)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># send loss to server</span></span><br><span class="line">    self.send_loss(loss_value, weight)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># recv convergence status</span></span><br><span class="line">    status = self.recv_loss()</span><br><span class="line">    <span class="keyword">return</span> status</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">self, tensor: torch.Tensor, weight</span>):</span><br><span class="line">    <span class="keyword">return</span> self.random_padding_cipher.encrypt(</span><br><span class="line"><span class="comment"># torch.clone(tensor).detach().mul_(weight)</span></span><br><span class="line">        torch.clone(tensor).detach().mul_(weight).cpu()</span><br><span class="line">    ).numpy()</span><br></pre></td></tr></table></figure><h2 id="模型评估"><a href="#模型评估" class="headerlink" title="模型评估"></a>模型评估</h2><p>以下是一个简单的模型评估代码，在homo_nn文件夹下新建evaluation.py，代码及注释如下</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入必要的库，注意这里需要导入homo_nn下的FedLightModule类</span></span><br><span class="line"><span class="comment"># 如果库不存在，需要在fate-flow容器下pip安装</span></span><br><span class="line"><span class="keyword">from</span> federatedml.nn.homo_nn._torch <span class="keyword">import</span> FedLightModule</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader, Dataset, random_split</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets, models, transforms</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">import</span> os </span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="comment"># import cv2</span></span><br><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line"></span><br><span class="line"><span class="comment"># dataset</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">My_Dataset</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, image_path, target</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.image_path = image_path</span><br><span class="line">        self.target = target</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.image_path)</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, index</span>):</span><br><span class="line">        path = self.image_path[index]</span><br><span class="line">        img = Image.<span class="built_in">open</span>(path).convert(<span class="string">&#x27;RGB&#x27;</span>)</span><br><span class="line">        resize_transform = transforms.Compose([</span><br><span class="line">            transforms.Resize(<span class="number">256</span>),</span><br><span class="line">            transforms.CenterCrop(<span class="number">224</span>),</span><br><span class="line">        ])</span><br><span class="line"></span><br><span class="line">        toTensor_transform = transforms.Compose([</span><br><span class="line">            transforms.ToTensor()</span><br><span class="line">        ])</span><br><span class="line">        label = self.target[index]</span><br><span class="line">        <span class="keyword">if</span> img.size[<span class="number">0</span>] &gt; <span class="number">224</span>:</span><br><span class="line">            img = resize_transform(img)</span><br><span class="line">        img = toTensor_transform(img)</span><br><span class="line">        <span class="keyword">return</span> img, label</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># test</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_model</span>(<span class="params">test_loader, model, criterion, device</span>):</span><br><span class="line">    model.<span class="built_in">eval</span>()</span><br><span class="line">  </span><br><span class="line">    true_labels = []</span><br><span class="line">    pred_labels = []</span><br><span class="line">    scores = []</span><br><span class="line"></span><br><span class="line">    size = <span class="built_in">len</span>(test_loader.dataset)</span><br><span class="line">    num_batches = <span class="built_in">len</span>(test_loader)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;size:<span class="subst">&#123;size&#125;</span>; num_batches:<span class="subst">&#123;num_batches&#125;</span>&#x27;</span>)</span><br><span class="line">    losses, correct = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="comment"># log_loss = 0</span></span><br><span class="line">    <span class="comment">################################# validation #################################</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> batch, (x, y) <span class="keyword">in</span> <span class="built_in">enumerate</span>(tqdm(test_loader)):</span><br><span class="line">            device = torch.device(device)</span><br><span class="line">            x, y = x.to(device), y.to(device)</span><br><span class="line">            pred = model(x)</span><br><span class="line">            loss = criterion(pred, y.long().squeeze()) </span><br><span class="line">            current = batch * <span class="built_in">len</span>(x)</span><br><span class="line">            scores += pred.tolist()</span><br><span class="line">            y_pred, y_true = torch.argmax(pred, axis=<span class="number">1</span>), y.long().squeeze()</span><br><span class="line">            correct += (y_pred == y_true).<span class="built_in">type</span>(torch.<span class="built_in">float</span>).<span class="built_in">sum</span>().item()</span><br><span class="line">            loss, current = np.<span class="built_in">round</span>(loss.item(), <span class="number">5</span>), batch * <span class="built_in">len</span>(x)</span><br><span class="line">            true_labels += y_true.detach().cpu().tolist()</span><br><span class="line">            pred_labels += y_pred.detach().cpu().tolist()</span><br><span class="line">            losses += loss</span><br><span class="line">    correct /= size</span><br><span class="line">    losses /= num_batches</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;losses:<span class="subst">&#123;losses&#125;</span>\n&#x27;</span>)</span><br><span class="line">    metrics = <span class="string">f&quot;Test: Accuracy: <span class="subst">&#123;(<span class="number">100</span>*correct):&gt;<span class="number">0.2</span>f&#125;</span>%, Avg loss: <span class="subst">&#123;losses:&gt;5f&#125;</span> \n&quot;</span></span><br><span class="line">    <span class="keyword">return</span> np.array(true_labels), np.array(pred_labels), np.array(scores), metrics</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">model_path: model path</span></span><br><span class="line"><span class="string">res_path: save csv path，保存预测的数据结果</span></span><br><span class="line"><span class="string">metric_path: mertic path，保存模型评估结果</span></span><br><span class="line"><span class="string">typ : predict or test，test是评估模型，需要输出模型的评估指标，predict是单纯的对未知label数据进行预测</span></span><br><span class="line"><span class="string">test_path: test data path，测试数据集path，默认和train是相同的组织形式</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">evaluation</span>(<span class="params">model_path, res_path, metric_path,  typ, test_path</span>):</span><br><span class="line">    model = FedLightModule.load_from_checkpoint(model_path)</span><br><span class="line">    test_images_over = []</span><br><span class="line">    test_labels_over = []</span><br><span class="line">    <span class="keyword">if</span> typ == <span class="string">&#x27;test&#x27;</span>:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(os.path.join(test_path, <span class="string">&#x27;targets&#x27;</span>), <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            line = f.readline()</span><br><span class="line">            <span class="keyword">while</span> line:</span><br><span class="line">                filename = line.split(<span class="string">&#x27;,&#x27;</span>)[<span class="number">0</span>] + <span class="string">&#x27;.jpg&#x27;</span></span><br><span class="line">                target = <span class="built_in">int</span>(line.split(<span class="string">&#x27;,&#x27;</span>)[-<span class="number">1</span>].replace(<span class="string">&#x27;\n&#x27;</span>,<span class="string">&#x27;&#x27;</span>))</span><br><span class="line">                test_images_over.append(os.path.join(test_path, <span class="string">&#x27;images&#x27;</span>, filename))</span><br><span class="line">                test_labels_over.append(target)</span><br><span class="line">                line = f.readline()</span><br><span class="line">    <span class="keyword">elif</span> typ == <span class="string">&#x27;predict&#x27;</span>:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(os.path.join(test_path, <span class="string">&#x27;filenames&#x27;</span>), <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            line = f.readline()</span><br><span class="line">            <span class="keyword">while</span> line:</span><br><span class="line">                filename = line.replace(<span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;&#x27;</span>) + <span class="string">&#x27;.jpg&#x27;</span></span><br><span class="line">                target = <span class="number">0</span></span><br><span class="line">                test_images_over.append(os.path.join(test_path, <span class="string">&#x27;images&#x27;</span>, filename))</span><br><span class="line">                test_labels_over.append(target)</span><br><span class="line">                line = f.readline()</span><br><span class="line">    test_dataset = My_Dataset(test_images_over, test_labels_over)</span><br><span class="line">    test_loader = DataLoader(test_dataset, batch_size=<span class="number">32</span>)</span><br><span class="line">    loss_fn = nn.CrossEntropyLoss()</span><br><span class="line">    <span class="comment"># device = torch.device(&#x27;cuda&#x27; if torch.cuda.is_available() else &#x27;cpu&#x27;)</span></span><br><span class="line">    device = <span class="string">&#x27;cpu&#x27;</span></span><br><span class="line">    true_labels, pred_labels, scores, metrics = test_model(test_loader, model, loss_fn, device)</span><br><span class="line"></span><br><span class="line">    l = <span class="built_in">len</span>(true_labels)</span><br><span class="line">    <span class="keyword">if</span> typ == <span class="string">&#x27;test&#x27;</span>:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(metric_path, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(<span class="string">f&#x27;<span class="subst">&#123;metrics&#125;</span>\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(res_path, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(<span class="string">&#x27;true_label,pred_label,score\n&#x27;</span>)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l):</span><br><span class="line">                true_label, pred_label, score = true_labels[i], pred_labels[i], scores[i]</span><br><span class="line">                f.write(<span class="string">f&#x27;<span class="subst">&#123;true_label&#125;</span>,<span class="subst">&#123;pred_label&#125;</span>,<span class="subst">&#123;score&#125;</span>\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> typ == <span class="string">&#x27;predict&#x27;</span>:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(res_path, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(<span class="string">&#x27;pred_label,score\n&#x27;</span>)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l):</span><br><span class="line">                true_label, pred_label, score = true_labels[i], pred_labels[i], scores[i]</span><br><span class="line">                f.write(<span class="string">f&#x27;<span class="subst">&#123;pred_label&#125;</span>,<span class="subst">&#123;score&#125;</span>\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    res_path = <span class="string">&quot;./123.csv&quot;</span></span><br><span class="line">    metric_path = <span class="string">&quot;./123.txt&quot;</span></span><br><span class="line">    typ = <span class="string">&quot;test&quot;</span></span><br><span class="line">    path = <span class="string">&quot;/data/projects/fate/examples/gwork/colon/test&quot;</span></span><br><span class="line">    model_path = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    evaluation(model_path, res_path, metric_path,  typ, path)</span><br></pre></td></tr></table></figure><p>代码修改完毕。下面进行训练。</p><h1 id="联邦学习"><a href="#联邦学习" class="headerlink" title="联邦学习"></a>联邦学习</h1><p>分别修改CONF和DSL配置</p><h2 id="colon-conf-json"><a href="#colon-conf-json" class="headerlink" title="colon_conf.json"></a>colon_conf.json</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;dsl_version&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&quot;initiator&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;role&quot;</span>: <span class="string">&quot;guest&quot;</span>,</span><br><span class="line">        <span class="string">&quot;party_id&quot;</span>: <span class="number">9999</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;role&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;arbiter&quot;</span>: [</span><br><span class="line">            <span class="number">10000</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&quot;host&quot;</span>: [</span><br><span class="line">            <span class="number">9998</span>,<span class="number">9997</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&quot;guest&quot;</span>: [</span><br><span class="line">            <span class="number">9999</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;component_parameters&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;common&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;homo_nn_0&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;api_version&quot;</span>: <span class="number">2</span>,</span><br><span class="line">                <span class="string">&quot;encode_label&quot;</span>: true,</span><br><span class="line">                <span class="string">&quot;max_iter&quot;</span>: <span class="number">2</span>,</span><br><span class="line">                <span class="string">&quot;batch_size&quot;</span>: <span class="number">32</span>,</span><br><span class="line">                <span class="string">&quot;optimizer&quot;</span>: &#123;</span><br><span class="line">                    <span class="string">&quot;lr&quot;</span>: <span class="number">0.000001</span>,</span><br><span class="line">                    <span class="string">&quot;optimizer&quot;</span>: <span class="string">&quot;Adam&quot;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">&quot;loss&quot;</span>: <span class="string">&quot;CrossEntropyLoss&quot;</span>,</span><br><span class="line">                <span class="string">&quot;metrics&quot;</span>: [</span><br><span class="line">                    <span class="string">&quot;accuracy&quot;</span></span><br><span class="line">                ],</span><br><span class="line">                <span class="string">&quot;nn_define&quot;</span>: [</span><br><span class="line">                ],</span><br><span class="line">                <span class="string">&quot;config_type&quot;</span>: <span class="string">&quot;pytorch&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;role&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;host&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;0&quot;</span>: &#123;</span><br><span class="line">                    <span class="string">&quot;reader_0&quot;</span>: &#123;</span><br><span class="line">                        <span class="string">&quot;table&quot;</span>: &#123;</span><br><span class="line">                            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;colon_images_0&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;namespace&quot;</span>: <span class="string">&quot;experiment&quot;</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">      <span class="string">&quot;1&quot;</span>: &#123;</span><br><span class="line">                    <span class="string">&quot;reader_0&quot;</span>: &#123;</span><br><span class="line">                        <span class="string">&quot;table&quot;</span>: &#123;</span><br><span class="line">                            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;colon_images_1&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;namespace&quot;</span>: <span class="string">&quot;experiment&quot;</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;guest&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;0&quot;</span>: &#123;</span><br><span class="line">                    <span class="string">&quot;reader_0&quot;</span>: &#123;</span><br><span class="line">                        <span class="string">&quot;table&quot;</span>: &#123;</span><br><span class="line">                            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;colon_images_2&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;namespace&quot;</span>: <span class="string">&quot;experiment&quot;</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="colon-dsl-json"><a href="#colon-dsl-json" class="headerlink" title="colon_dsl.json"></a>colon_dsl.json</h2><p>略</p><p>首先数据已经处理成FATE可以读取的格式。</p><p>然后将三份数据分发到集群的三台不同的机器上，分别是fate9999，fate9998，以及fate9997</p><p>进入三台机器的fate-client container，使用flow table bind -c 命令将文件夹绑定到table。</p><p>在发起方FATE9999的client容器中，进入code文件夹，执行<code>flow job submit -c colon_conf.json -d colon_dsl.json</code>启动任务</p><p>查看FATE-BOARD Job</p><p>他的homo_nn组件输出的日志如下：</p><p><img src="image-20221014121445-6gzta7m.png" alt="image.png"></p><h1 id="模型评估-1"><a href="#模型评估-1" class="headerlink" title="模型评估"></a>模型评估</h1><p>在job结束后，会保存check point，保存的容器为fate-flow container。</p><p>以fate9999为例，保存路径为：</p><p>/data/projects/fate/fateflow/jobs/202210131350059277200/guest/9999/homo_cv_0/202210131350059277200_homo_cv_0/0/task_executor/7f86f6064aff11edbd540242c0a70064/model.ckpt</p><blockquote><p>不同角色（guset、host）、不同party_id的机器上路径可能有所差异。</p></blockquote><p>将该路径复制到刚才的evaluation.py的model_path中，执行<code>python evaluation.py</code>，查看输出结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Accuracy: 99.20%, Avg loss: 0.022641</span><br></pre></td></tr></table></figure><h1 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h1><p>结合baseline的实验结果，可以得到下表。</p><div class="table-container"><table><thead><tr><th>使用的数据</th><th>训练类型</th><th>模型评估</th></tr></thead><tbody><tr><td>全部训练数据（Train_1+Train_2+Train_3）</td><td>本地（GPU）</td><td>Accuracy: 99.60%, Avg loss: 0.011775</td></tr><tr><td>Train_1</td><td>本地（GPU）</td><td>Accuracy: 73.20%, Avg loss: 0.641481</td></tr><tr><td>Train_2</td><td>本地（GPU）</td><td>Accuracy: 71.40%, Avg loss: 0.649055</td></tr><tr><td>Train_3</td><td>本地（GPU）</td><td>Accuracy: 56.80%, Avg loss: 0.654335</td></tr><tr><td>全部训练数据（Train_1+Train_2+Train_3）</td><td>联邦（GPU）</td><td>Accuracy: 99.20%, Avg loss: 0.022641</td></tr></tbody></table></div><p>在增加了部分读写日志，并加以分析可以得到训练的时间分布：</p><p><img src="image-20221102004157-5zhbj13.png" alt="image.png"></p><h1 id="实验分析"><a href="#实验分析" class="headerlink" title="实验分析"></a>实验分析</h1><ol><li><p>使用联邦学习的效果要优于分开训练的模型效果，证明了联邦学习的有效性。</p></li><li><p>做实验发现，使用CPU进行训练，每个epoch需要大约15分钟，而使用GPU之后，每个epoch仅需要29s左右。使用GPU的计算效率要远远大于使用CPU。</p></li><li><p>对日志进行分析发现，计算时间约为60s，模型参数加密、解密以及传输的时间约为比例约为600s，二者比例约为1:10。因此可以得出结论：结肠癌联邦学习的时间瓶颈不在于本地模型的训练时间，而是在于模型参数加密、解密以及传输时间。</p></li></ol><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>修改了homo_nn的源码，导致原有的homo_nn的功能失效，所以这里不推荐这样改，更推荐开发新的组件来完成。</p><p>‍</p>]]></content>
      
      
      <categories>
          
          <category> 联邦学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 联邦学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FATE横向联邦学习：肠癌图像分类任务（上）——baseline</title>
      <link href="/2022/11/04/FATE%E6%A8%AA%E5%90%91%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0%EF%BC%9A%E8%82%A0%E7%99%8C%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1%EF%BC%88%E4%B8%8A%EF%BC%89%E2%80%94%E2%80%94baseline/"/>
      <url>/2022/11/04/FATE%E6%A8%AA%E5%90%91%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0%EF%BC%9A%E8%82%A0%E7%99%8C%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1%EF%BC%88%E4%B8%8A%EF%BC%89%E2%80%94%E2%80%94baseline/</url>
      
        <content type="html"><![CDATA[<p>本案例分上下两篇，上篇介绍肠癌图像分类任务的本地baseline，下篇介绍将肠癌图像分类任务移植到FATE上，实现联邦学习。</p><h1 id="任务目标"><a href="#任务目标" class="headerlink" title="任务目标"></a>任务目标</h1><ol><li>使用FATE开发新的组件，实现图像横向联邦学习</li><li>证明联邦学习有效</li></ol><h1 id="任务介绍"><a href="#任务介绍" class="headerlink" title="任务介绍"></a>任务介绍</h1><p>该任务将开发基于结肠的组织病理学图像正确判断是良性组织或者结肠癌的二分类算法。</p><h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><p>数据集来自于<a href="https://www.kaggle.com/datasets/andrewmvd/lung-and-colon-cancer-histopathological-images的colon_image_sets">https://www.kaggle.com/datasets/andrewmvd/lung-and-colon-cancer-histopathological-images的colon_image_sets</a></p><p>本任务数据集由2个类别组成的10000张符合HIPAA标准的结肠组织病理学图像。所有图像的尺寸为$768 <em> 768 </em> 3$，为jpeg文件格式。</p><p>为了进行实验，需要对数据进行划分：步骤如下：</p><ol><li><p>数据shuffle。</p></li><li><p>分为五个子集，包含三份训练集子集，命名为Train_1, Train_2, Train_3，训练集子集各三千张图像，一份验证集和一份测试集各500张，分别命名为val和test。（这里我没有对图像本身进行改动，而是生成了一个excel，每个sheet包含image_path和type两列，分别对应图像的位置和label，一共有input1，input2，input3，val和test五个sheet页）</p></li></ol><p>三份训练数据和一份测试数据对应的三种类型的图像数量如下：</p><div class="table-container"><table><thead><tr><th>Data</th><th>结肠癌组织</th><th>良性组织</th><th>总计</th></tr></thead><tbody><tr><td>Train_1</td><td>1505</td><td>1495</td><td>3000</td></tr><tr><td>Train_2</td><td>1467</td><td>1533</td><td>3000</td></tr><tr><td>Train_3</td><td>1515</td><td>1485</td><td>3000</td></tr><tr><td>Test</td><td>253</td><td>247</td><td>500</td></tr><tr><td>总计（不算Test）</td><td>4487</td><td>4513</td><td>/</td></tr></tbody></table></div><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>为了保证单一变量影响，在本地训练和联邦训练的模型参数相同，具体参数如下表</p><div class="table-container"><table><thead><tr><th>key</th><th>val</th></tr></thead><tbody><tr><td>平台</td><td>kaggle</td></tr><tr><td>算法</td><td>基于ImageNet1K预训练的vgg16模型</td></tr><tr><td>Epoch</td><td>2</td></tr><tr><td>Batch Size</td><td>16 or 32</td></tr><tr><td>Optimizer</td><td>Adam</td></tr><tr><td>Learning Rate</td><td>1e-5</td></tr><tr><td>Loss</td><td>CrossEntropyLoss</td></tr><tr><td>Metrics</td><td>Accuracy</td></tr></tbody></table></div><h1 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h1><ol><li><p>使用全部训练集在本地进行训练，在测试集进行模型评估。</p></li><li><p>分别使用三份训练集子集在本地进行训练，在测试集进行模型评估。</p></li><li><p>使用FATE对三份训练集子集进行联邦训练，在测试集上进行模型评估。</p></li></ol><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><blockquote><p>这里只列出重要的code，详细code可以参见：<a href="https://www.kaggle.com/code/guoyujian/colon-cancer101">https://www.kaggle.com/code/guoyujian/colon-cancer101</a></p></blockquote><h2 id="define-params"><a href="#define-params" class="headerlink" title="define params"></a>define params</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">EPOCHS = <span class="number">2</span></span><br><span class="line">BATCH_SIZE = <span class="number">32</span></span><br><span class="line">lr = <span class="number">1e-5</span></span><br><span class="line"></span><br><span class="line">device = torch.device(<span class="string">&#x27;cuda&#x27;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&#x27;cpu&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(device)</span><br></pre></td></tr></table></figure><h2 id="加载数据"><a href="#加载数据" class="headerlink" title="加载数据"></a>加载数据</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从元数据中读取图像的path和label</span></span><br><span class="line">metadata_path = <span class="string">&#x27;../input/input-colon/colon_inputs.xls&#x27;</span></span><br><span class="line"><span class="comment"># metadata_path = &#x27;../input/input-colon-cuts/colon_inputs_cuts.xls&#x27;</span></span><br><span class="line">df1 = pd.read_excel(metadata_path, sheet_name = <span class="string">&#x27;input1&#x27;</span>)</span><br><span class="line">df2 = pd.read_excel(metadata_path, sheet_name = <span class="string">&#x27;input2&#x27;</span>)</span><br><span class="line">df3 = pd.read_excel(metadata_path, sheet_name = <span class="string">&#x27;input3&#x27;</span>)</span><br><span class="line">df4 = pd.read_excel(metadata_path, sheet_name = <span class="string">&#x27;val&#x27;</span>)</span><br><span class="line">df5 = pd.read_excel(metadata_path, sheet_name = <span class="string">&#x27;test&#x27;</span>)</span><br><span class="line">df = pd.concat([df1, df2, df3])</span><br><span class="line"></span><br><span class="line">df.head()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 全部的图片路径和标签</span></span><br><span class="line"><span class="comment"># images_all_over = df[&#x27;image_path&#x27;].to_list()</span></span><br><span class="line">images_all_over = []</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> df[<span class="string">&#x27;image_path&#x27;</span>]:</span><br><span class="line">    item = images_all_over.append(<span class="string">&#x27;../input/lung-and-colon-cancer-histopathological-images/lung_colon_image_set/colon_image_sets/&#x27;</span> + item)</span><br><span class="line">labels_all_over = df[<span class="string">&#x27;type&#x27;</span>].to_list()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;len images_all_over: <span class="subst">&#123;<span class="built_in">len</span>(images_all_over)&#125;</span>; len labels_all_over: <span class="subst">&#123;<span class="built_in">len</span>(labels_all_over)&#125;</span>; &#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># part1,2,3 &amp; val</span></span><br><span class="line">images_1_over = []</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> df1[<span class="string">&#x27;image_path&#x27;</span>]:</span><br><span class="line">    item = images_1_over.append(<span class="string">&#x27;../input/lung-and-colon-cancer-histopathological-images/lung_colon_image_set/colon_image_sets/&#x27;</span> + item)</span><br><span class="line">labels_1_over = df1[<span class="string">&#x27;type&#x27;</span>].to_list()</span><br><span class="line"></span><br><span class="line">images_2_over = []</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> df2[<span class="string">&#x27;image_path&#x27;</span>]:</span><br><span class="line">    item = images_2_over.append(<span class="string">&#x27;../input/lung-and-colon-cancer-histopathological-images/lung_colon_image_set/colon_image_sets/&#x27;</span> + item)</span><br><span class="line">labels_2_over = df2[<span class="string">&#x27;type&#x27;</span>].to_list()</span><br><span class="line"></span><br><span class="line">images_3_over = []</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> df3[<span class="string">&#x27;image_path&#x27;</span>]:</span><br><span class="line">    item = images_3_over.append(<span class="string">&#x27;../input/lung-and-colon-cancer-histopathological-images/lung_colon_image_set/colon_image_sets/&#x27;</span> + item)</span><br><span class="line">labels_3_over = df3[<span class="string">&#x27;type&#x27;</span>].to_list()</span><br><span class="line"></span><br><span class="line">images_val_over = []</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> df4[<span class="string">&#x27;image_path&#x27;</span>]:</span><br><span class="line">    item = images_val_over.append(<span class="string">&#x27;../input/lung-and-colon-cancer-histopathological-images/lung_colon_image_set/colon_image_sets/&#x27;</span> + item)</span><br><span class="line">labels_val_over = df4[<span class="string">&#x27;type&#x27;</span>].to_list()</span><br><span class="line"></span><br><span class="line">images_test_over = []</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> df5[<span class="string">&#x27;image_path&#x27;</span>]:</span><br><span class="line">    item = images_test_over.append(<span class="string">&#x27;../input/lung-and-colon-cancer-histopathological-images/lung_colon_image_set/colon_image_sets/&#x27;</span> + item)</span><br><span class="line">labels_test_over = df5[<span class="string">&#x27;type&#x27;</span>].to_list()</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对全部数据shuffle</span></span><br><span class="line"></span><br><span class="line">shuffle_dataset = np.hstack((np.array(images_all_over).reshape(-<span class="number">1</span>, <span class="number">1</span>), np.array(labels_all_over).reshape(-<span class="number">1</span>, <span class="number">1</span>)))</span><br><span class="line">np.random.shuffle(shuffle_dataset)</span><br><span class="line">images_all_over = shuffle_dataset[:, <span class="number">0</span>].tolist()</span><br><span class="line">labels_all_over = shuffle_dataset[:, <span class="number">1</span>].astype(<span class="built_in">int</span>).tolist()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#定义dataset类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Colon_Dataset</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, image_path, target, train_transform = <span class="literal">None</span>, test_transform = <span class="literal">None</span></span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.image_path = image_path</span><br><span class="line">        self.target = target</span><br><span class="line">        self.train_transform = train_transform</span><br><span class="line">        self.test_transform = test_transform</span><br><span class="line">        self.transform = <span class="literal">None</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.image_path)</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, index</span>):</span><br><span class="line">        path = self.image_path[index]</span><br><span class="line">        image = cv2.imread(path)</span><br><span class="line">        label = self.target[index]</span><br><span class="line">        <span class="keyword">if</span> self.transform:</span><br><span class="line">            image = self.transform(image)</span><br><span class="line">        <span class="keyword">return</span> image, label</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">train_mode</span>(<span class="params">self</span>):</span><br><span class="line">        self.transform = self.train_transform</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_mode</span>(<span class="params">self</span>):</span><br><span class="line">        self.transform = self.test_transform</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># define data transform</span></span><br><span class="line">train_transform = transforms.Compose([</span><br><span class="line">    transforms.ToPILImage(),</span><br><span class="line">    transforms.Resize(<span class="number">256</span>),</span><br><span class="line">    transforms.CenterCrop(<span class="number">224</span>),</span><br><span class="line">    transforms.RandomHorizontalFlip(),</span><br><span class="line">    transforms.RandomRotation(<span class="number">10</span>),</span><br><span class="line">    transforms.ColorJitter(),</span><br><span class="line">    transforms.ToTensor(),</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">test_transform = transforms.Compose([</span><br><span class="line">    transforms.ToPILImage(),</span><br><span class="line">    transforms.Resize(<span class="number">256</span>),</span><br><span class="line">    transforms.CenterCrop(<span class="number">224</span>),</span><br><span class="line">    transforms.ToTensor()</span><br><span class="line">])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 全部训练数据</span></span><br><span class="line">colon_all_dataset = Colon_Dataset(images_all_over, labels_all_over, train_transform, test_transform)</span><br><span class="line">train_loader = DataLoader(colon_all_dataset, batch_size=BATCH_SIZE)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 三份训练数据、验证数据和测试数据</span></span><br><span class="line">colon_1_dataset = Colon_Dataset(images_1_over, labels_1_over, train_transform, test_transform)</span><br><span class="line">colon_2_dataset = Colon_Dataset(images_2_over, labels_2_over, train_transform, test_transform)</span><br><span class="line">colon_3_dataset = Colon_Dataset(images_3_over, labels_3_over, train_transform, test_transform)</span><br><span class="line">colon_val_dataset = Colon_Dataset(images_val_over, labels_val_over, train_transform, test_transform)</span><br><span class="line">colon_test_dataset = Colon_Dataset(images_test_over, labels_test_over, train_transform, test_transform)</span><br><span class="line"></span><br><span class="line">train_1_loader = DataLoader(colon_1_dataset, batch_size=BATCH_SIZE)</span><br><span class="line">train_2_loader = DataLoader(colon_2_dataset, batch_size=BATCH_SIZE)</span><br><span class="line">train_3_loader = DataLoader(colon_3_dataset, batch_size=BATCH_SIZE)</span><br><span class="line">val_loader = DataLoader(colon_val_dataset, batch_size=BATCH_SIZE)</span><br><span class="line">test_loader = DataLoader(colon_test_dataset, batch_size=BATCH_SIZE)</span><br></pre></td></tr></table></figure><h2 id="define-a-model"><a href="#define-a-model" class="headerlink" title="define a model"></a>define a model</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Model = models.vgg16(pretrained=<span class="literal">True</span>)</span><br><span class="line">Model.classifier[<span class="number">6</span>] = nn.Linear(in_features=<span class="number">4096</span>, out_features=<span class="number">2</span>, bias=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">Model = Model.to(device)</span><br><span class="line"></span><br><span class="line">optimizer = torch.optim.Adam(Model.parameters() , lr = lr)</span><br><span class="line"></span><br><span class="line">scheduler = torch.optim.lr_scheduler.MultiStepLR(optimizer, milestones=[<span class="number">10</span>, <span class="number">25</span>, <span class="number">50</span>, <span class="number">75</span>, <span class="number">120</span>], gamma=<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">loss_fn = nn.CrossEntropyLoss()</span><br></pre></td></tr></table></figure><h2 id="train-amp-val"><a href="#train-amp-val" class="headerlink" title="train&amp;val"></a>train&amp;val</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 训练一轮</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train_one_epoch</span>(<span class="params">train_loader, model, criterion, optimizer, device</span>):</span><br><span class="line">    model.train()</span><br><span class="line">  </span><br><span class="line">    colon_all_dataset.train_mode()</span><br><span class="line">    colon_1_dataset.train_mode()</span><br><span class="line">    colon_2_dataset.train_mode()</span><br><span class="line">    colon_3_dataset.train_mode()</span><br><span class="line">    colon_val_dataset.train_mode()</span><br><span class="line">  </span><br><span class="line">    size = <span class="built_in">len</span>(train_loader.dataset)</span><br><span class="line">    num_batches = <span class="built_in">len</span>(train_loader)</span><br><span class="line">    losses, correct = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="comment">################################# train #################################</span></span><br><span class="line">    <span class="keyword">for</span> batch, (x, y) <span class="keyword">in</span> <span class="built_in">enumerate</span>(tqdm(train_loader)):</span><br><span class="line">        device = torch.device(device)</span><br><span class="line">        x, y = x.to(device), y.to(device)  </span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        pred = model(x)</span><br><span class="line"></span><br><span class="line">        loss = criterion(pred, y.long().squeeze())</span><br><span class="line"></span><br><span class="line">        current = batch * <span class="built_in">len</span>(x)</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">        y_pred, y_true = torch.argmax(pred, axis=<span class="number">1</span>), y.long().squeeze()</span><br><span class="line">        correct += (y_pred == y_true).<span class="built_in">type</span>(torch.<span class="built_in">float</span>).<span class="built_in">sum</span>().item()</span><br><span class="line">        losses += loss.item()</span><br><span class="line">    correct /= size</span><br><span class="line">    losses /= num_batches</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Train: Accuracy: <span class="subst">&#123;(<span class="number">100</span>*correct):&gt;<span class="number">0.2</span>f&#125;</span>%, Avg loss: <span class="subst">&#123;losses:&gt;5f&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> losses, correct</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 验证一轮， 验证集数据加载，模型，损失函数，device</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">valid_one_epoch</span>(<span class="params">valid_loader, model, criterion, device</span>):</span><br><span class="line">    model.<span class="built_in">eval</span>()</span><br><span class="line"></span><br><span class="line">    colon_all_dataset.train_mode()</span><br><span class="line">    colon_1_dataset.train_mode()</span><br><span class="line">    colon_2_dataset.train_mode()</span><br><span class="line">    colon_3_dataset.train_mode()</span><br><span class="line">    colon_val_dataset.train_mode()</span><br><span class="line">  </span><br><span class="line">    size = <span class="built_in">len</span>(valid_loader.dataset)</span><br><span class="line">    num_batches = <span class="built_in">len</span>(valid_loader)</span><br><span class="line">    losses, correct = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="comment">################################# validation #################################</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> batch, (x, y) <span class="keyword">in</span> <span class="built_in">enumerate</span>(tqdm(valid_loader)):</span><br><span class="line">            device = torch.device(device)</span><br><span class="line">            x, y = x.to(device), y.to(device)</span><br><span class="line">            pred = model(x)</span><br><span class="line">            loss = criterion(pred, y.long().squeeze())</span><br><span class="line"></span><br><span class="line">            current = batch * <span class="built_in">len</span>(x)</span><br><span class="line">            y_pred, y_true = torch.argmax(pred, axis=<span class="number">1</span>), y.long().squeeze()</span><br><span class="line">            correct += (y_pred == y_true).<span class="built_in">type</span>(torch.<span class="built_in">float</span>).<span class="built_in">sum</span>().item()</span><br><span class="line">            losses += loss.item()</span><br><span class="line">    correct /= size</span><br><span class="line">    losses /= num_batches</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Valid: Accuracy: <span class="subst">&#123;(<span class="number">100</span>*correct):&gt;<span class="number">0.2</span>f&#125;</span>%, Avg loss: <span class="subst">&#123;losses:&gt;5f&#125;</span> \n&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> losses, correct</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">train_valid</span>(<span class="params">train_loader,valid_loader, model, criterion, optimizer, scheduler, device, part = <span class="literal">None</span></span>):</span><br><span class="line">    liveloss = PlotLosses()</span><br><span class="line">  </span><br><span class="line">    tolerance = <span class="number">0</span></span><br><span class="line">    best_loss = np.inf</span><br><span class="line">    best_epoch = <span class="number">0</span></span><br><span class="line">    best_acc = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Starting Training...\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, EPOCHS):</span><br><span class="line">        logs = &#123;&#125;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;-------------------------------   Epoch <span class="subst">&#123;epoch + <span class="number">1</span>&#125;</span>   -------------------------------&quot;</span>)</span><br><span class="line"></span><br><span class="line">        train_loss, train_acc = train_one_epoch(train_loader, model, criterion, optimizer, device)</span><br><span class="line">        valid_loss, valid_acc = valid_one_epoch(valid_loader, model, criterion, device)</span><br><span class="line">        scheduler.step()</span><br><span class="line">      </span><br><span class="line">        <span class="comment"># save validation loss if it was improved (reduced) &amp; validation accuracy if it was improved (increased)</span></span><br><span class="line">        <span class="keyword">if</span> valid_loss &lt; best_loss <span class="keyword">and</span> valid_acc &gt; best_acc:</span><br><span class="line">            best_epoch = epoch + <span class="number">1</span></span><br><span class="line">            best_loss = valid_loss</span><br><span class="line">            best_acc = valid_acc</span><br><span class="line">            <span class="comment"># save the model&#x27;s weights and biases</span></span><br><span class="line">            <span class="keyword">if</span> part:</span><br><span class="line">                torch.save(model, <span class="string">f&quot;vgg_ep<span class="subst">&#123;best_epoch&#125;</span>_part<span class="subst">&#123;part&#125;</span>.pth&quot;</span>)</span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                torch.save(model, <span class="string">f&quot;vgg_ep<span class="subst">&#123;best_epoch&#125;</span>.pth&quot;</span>)</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span> valid_acc &lt; best_acc:</span><br><span class="line">            tolerance += <span class="number">1</span></span><br><span class="line">      </span><br><span class="line">        logs[<span class="string">&#x27;log loss&#x27;</span>] = train_loss</span><br><span class="line">        logs[<span class="string">&#x27;accuracy&#x27;</span>] = train_acc*<span class="number">100</span></span><br><span class="line">        logs[<span class="string">&#x27;val_log loss&#x27;</span>] = valid_loss</span><br><span class="line">        logs[<span class="string">&#x27;val_accuracy&#x27;</span>] = valid_acc*<span class="number">100</span></span><br><span class="line">      </span><br><span class="line">        liveloss.update(logs)</span><br><span class="line">        liveloss.send()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Done!&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># train all</span></span><br><span class="line">train_valid(train_loader,val_loader, Model, loss_fn, optimizer, scheduler, device)</span><br></pre></td></tr></table></figure><p>可以看到模型拟合的很快</p><p><img src="image-20221101180725-qad0jfu.png" alt="image.png"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 3 parts train </span></span><br><span class="line">train_valid(train_1_loader,val_loader, Model, loss_fn, optimizer, scheduler, device, part = <span class="number">1</span>)</span><br><span class="line">train_valid(train_2_loader,val_loader, Model, loss_fn, optimizer, scheduler, device, part = <span class="number">2</span>)</span><br><span class="line">train_valid(train_3_loader,val_loader, Model, loss_fn, optimizer, scheduler, device, part = <span class="number">3</span>)</span><br></pre></td></tr></table></figure><h2 id="模型评估"><a href="#模型评估" class="headerlink" title="模型评估"></a>模型评估</h2><p>这里注意的是不需要先对pred进行softmax，在计算loss，而是直接计算loss：</p><p>Ref:<a href="https://blog.csdn.net/DragonGirI/article/details/105743487">pytorch 计算 CrossEntropyLoss 和 softmax 激活层</a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># test</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_model</span>(<span class="params">test_loader, model, criterion, device</span>):</span><br><span class="line">    model.<span class="built_in">eval</span>()</span><br><span class="line">    cervical_test_dataset.test_mode()</span><br><span class="line">  </span><br><span class="line">    true_labels = []</span><br><span class="line">    pred_labels = []</span><br><span class="line">    scores = []</span><br><span class="line"></span><br><span class="line">    size = <span class="built_in">len</span>(test_loader.dataset)</span><br><span class="line"></span><br><span class="line">    num_batches = <span class="built_in">len</span>(test_loader)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;size:<span class="subst">&#123;size&#125;</span>; num_batches:<span class="subst">&#123;num_batches&#125;</span>&#x27;</span>)</span><br><span class="line">    losses, correct = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="comment">################################# validation #################################</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> batch, (x, y) <span class="keyword">in</span> <span class="built_in">enumerate</span>(tqdm(test_loader)):</span><br><span class="line">            device = torch.device(device)</span><br><span class="line">            x, y = x.to(device), y.to(device)</span><br><span class="line">            pred = model(x)</span><br><span class="line"><span class="comment">#             pred = nn.Softmax()(pred)</span></span><br><span class="line"></span><br><span class="line">            loss = criterion(pred, y.long().squeeze()) </span><br><span class="line">            current = batch * <span class="built_in">len</span>(x)</span><br><span class="line">            scores += pred.tolist()</span><br><span class="line">            y_pred, y_true = torch.argmax(pred, axis=<span class="number">1</span>), y.long().squeeze()</span><br><span class="line">            correct += (y_pred == y_true).<span class="built_in">type</span>(torch.<span class="built_in">float</span>).<span class="built_in">sum</span>().item()</span><br><span class="line">            loss, current = np.<span class="built_in">round</span>(loss.item(), <span class="number">5</span>), batch * <span class="built_in">len</span>(x)</span><br><span class="line">            true_labels += y_true.detach().cpu().tolist()</span><br><span class="line">            pred_labels += y_pred.detach().cpu().tolist()</span><br><span class="line">            losses += loss.item()</span><br><span class="line">    correct /= size</span><br><span class="line">    losses /= num_batches</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Test: Accuracy: <span class="subst">&#123;(<span class="number">100</span>*correct):&gt;<span class="number">0.2</span>f&#125;</span>%, Avg loss: <span class="subst">&#123;losses:&gt;5f&#125;</span> \n&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> np.array(true_labels), np.array(pred_labels), np.array(scores)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">test_model_obj = torch.load(<span class="string">&#x27;模型文件path&#x27;</span>)</span><br><span class="line">test_model_obj = test_model_obj.to(device)</span><br><span class="line">test_model(test_loader, test_model_obj, loss_fn, device)</span><br></pre></td></tr></table></figure><h1 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h1><div class="table-container"><table><thead><tr><th>使用的数据</th><th>评估结果</th></tr></thead><tbody><tr><td>全部训练数据（Train_1+Train_2+Train_3）</td><td>Accuracy: 99.60%, Avg loss: 0.011775</td></tr><tr><td>Train_1</td><td>Accuracy: 73.20%, Avg loss: 0.641481</td></tr><tr><td>Train_2</td><td>Accuracy: 71.40%, Avg loss: 0.649055</td></tr><tr><td>Train_3</td><td>Accuracy: 56.80%, Avg loss: 0.654335</td></tr></tbody></table></div><h1 id="实验分析"><a href="#实验分析" class="headerlink" title="实验分析"></a>实验分析</h1><p>见下篇</p>]]></content>
      
      
      <categories>
          
          <category> 联邦学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 联邦学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FATE横向联邦学习：手写数字识别</title>
      <link href="/2022/11/04/FATE%E6%A8%AA%E5%90%91%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0%EF%BC%9A%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/"/>
      <url>/2022/11/04/FATE%E6%A8%AA%E5%90%91%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0%EF%BC%9A%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<blockquote><p>上上一篇介绍了如何使用FATE发起一个横向联邦学习任务，使用的数据格式是结构化的数据，使用的算法是经典的LR算法。</p><p>能不能使用FATE做计算机视觉的神经网络的联邦学习呢？</p><p>答案是可以的。本篇就通过手写数字识别这一经典任务来学习如何使用FATE来完成一个计算机视觉方面的神经网络算法的联邦学习job</p></blockquote><p>‍</p><h1 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h1><p>fate standalone 1.9.0</p><ul><li>数据集mnist：<code>/data/projects/fate/examples/data/mnist_train</code></li><li>code:<code>/data/projects/fate/examples/dsl/v2/homo_nn/mnist_demo</code></li></ul><blockquote><p>最好把这几个文件夹复制出来，再改</p></blockquote><p>code文件夹中有以下几个文件，后面需要用到。</p><p>‍</p><p>在README.md中已经写出了用法，本篇将详细讲解。</p><p><img src="image-20221028155604-ny1t6o7.png" alt="image.png"></p><p>‍</p><h1 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h1><h2 id="下载数据集"><a href="#下载数据集" class="headerlink" title="下载数据集"></a>下载数据集</h2><p>执行<code>fate_test data download -t mnist</code>命令下载mnist数据集，下载的位置位于<code>FATE/examples/data/mnist_train</code></p><h2 id="绑定数据"><a href="#绑定数据" class="headerlink" title="绑定数据"></a>绑定数据</h2><p>修改bind_local_path.json的address.path为数据集文件夹所在的位置，修改后如下。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;engine&quot;</span>: <span class="string">&quot;PATH&quot;</span>,</span><br><span class="line">    <span class="string">&quot;namespace&quot;</span>: <span class="string">&quot;experiment&quot;</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;mnist_images&quot;</span>,</span><br><span class="line">    <span class="string">&quot;address&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;path&quot;</span>: <span class="string">&quot;/data/projects/fate/examples/data/mnist_train&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改完成后执行<code>flow table bind -c bind_local_path.json</code>命令进行数据绑定。这样一来，文件夹中的数据就和命名空间为experiment，表名为mnist_images的表关联了起来。</p><p>返回类似即绑定成功。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;retcode&quot;</span>: 0,</span><br><span class="line"><span class="string">&quot;retmsg&quot;</span>: <span class="string">&quot;success&quot;</span></span><br></pre></td></tr></table></figure><h2 id="配置文件并提交job"><a href="#配置文件并提交job" class="headerlink" title="配置文件并提交job"></a>配置文件并提交job</h2><p>mnist_dsl.json文件：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;components&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;reader_0&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;module&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Reader&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;output&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                    <span class="string">&quot;data&quot;</span></span><br><span class="line">                <span class="punctuation">]</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;homo_nn_0&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;module&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HomoNN&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;input&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;train_data&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                        <span class="string">&quot;reader_0.data&quot;</span></span><br><span class="line">                    <span class="punctuation">]</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;output&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                    <span class="string">&quot;data&quot;</span></span><br><span class="line">                <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;model&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                    <span class="string">&quot;model&quot;</span></span><br><span class="line">                <span class="punctuation">]</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>mnist_conf.json文件：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;dsl_version&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;initiator&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;role&quot;</span><span class="punctuation">:</span> <span class="string">&quot;guest&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;party_id&quot;</span><span class="punctuation">:</span> <span class="number">9999</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;role&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;arbiter&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="number">9999</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;host&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="number">9999</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;guest&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="number">9999</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;component_parameters&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;common&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;homo_nn_0&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;api_version&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;encode_label&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;max_iter&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;batch_size&quot;</span><span class="punctuation">:</span> <span class="number">32</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;early_stop&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;early_stop&quot;</span><span class="punctuation">:</span> <span class="string">&quot;diff&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;eps&quot;</span><span class="punctuation">:</span> <span class="number">0.0001</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;optimizer&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;lr&quot;</span><span class="punctuation">:</span> <span class="number">0.001</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;optimizer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Adam&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;loss&quot;</span><span class="punctuation">:</span> <span class="string">&quot;NLLLoss&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;metrics&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                    <span class="string">&quot;accuracy&quot;</span></span><br><span class="line">                <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;nn_define&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                    <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;layer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Conv2d&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;in_channels&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;out_channels&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;kernel_size&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                            <span class="number">5</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="number">5</span></span><br><span class="line">                        <span class="punctuation">]</span></span><br><span class="line">                    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;layer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;MaxPool2d&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;kernel_size&quot;</span><span class="punctuation">:</span> <span class="number">2</span></span><br><span class="line">                    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;layer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ReLU&quot;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;layer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Conv2d&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;in_channels&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;out_channels&quot;</span><span class="punctuation">:</span> <span class="number">20</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;kernel_size&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                            <span class="number">5</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="number">5</span></span><br><span class="line">                        <span class="punctuation">]</span></span><br><span class="line">                    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;layer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Dropout2d&quot;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;layer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;MaxPool2d&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;kernel_size&quot;</span><span class="punctuation">:</span> <span class="number">2</span></span><br><span class="line">                    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;layer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ReLU&quot;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;layer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Flatten&quot;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;layer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Linear&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;in_features&quot;</span><span class="punctuation">:</span> <span class="number">320</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;out_features&quot;</span><span class="punctuation">:</span> <span class="number">50</span></span><br><span class="line">                    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;layer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ReLU&quot;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;layer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Linear&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;in_features&quot;</span><span class="punctuation">:</span> <span class="number">50</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;out_features&quot;</span><span class="punctuation">:</span> <span class="number">10</span></span><br><span class="line">                    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;layer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;LogSoftmax&quot;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span></span><br><span class="line">                <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;config_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pytorch&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;role&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;host&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;0&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;reader_0&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;table&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mnist_images&quot;</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;namespace&quot;</span><span class="punctuation">:</span> <span class="string">&quot;experiment&quot;</span></span><br><span class="line">                        <span class="punctuation">&#125;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;guest&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;0&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;reader_0&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;table&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mnist_images&quot;</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;namespace&quot;</span><span class="punctuation">:</span> <span class="string">&quot;experiment&quot;</span></span><br><span class="line">                        <span class="punctuation">&#125;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行<code>flow job submit -c mnist_conf.json -d mnist_dsl.json</code>命令提交job：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@693afd940463 mnist_demo]<span class="comment"># flow job submit -c mnist_conf.json -d mnist_dsl.json </span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;data&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;board_url&quot;</span>: <span class="string">&quot;http://127.0.0.1:8080/index.html#/dashboard?job_id=202209210827526887030&amp;role=guest&amp;party_id=10000&quot;</span>,</span><br><span class="line">        <span class="string">&quot;code&quot;</span>: 0,</span><br><span class="line">        <span class="string">&quot;dsl_path&quot;</span>: <span class="string">&quot;/data/projects/fate/fateflow/jobs/202209210827526887030/job_dsl.json&quot;</span>,</span><br><span class="line">        <span class="string">&quot;job_id&quot;</span>: <span class="string">&quot;202209210827526887030&quot;</span>,</span><br><span class="line">        <span class="string">&quot;logs_directory&quot;</span>: <span class="string">&quot;/data/projects/fate/fateflow/logs/202209210827526887030&quot;</span>,</span><br><span class="line">        <span class="string">&quot;message&quot;</span>: <span class="string">&quot;success&quot;</span>,</span><br><span class="line">        <span class="string">&quot;model_info&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;model_id&quot;</span>: <span class="string">&quot;arbiter-10000#guest-10000#host-10000#model&quot;</span>,</span><br><span class="line">            <span class="string">&quot;model_version&quot;</span>: <span class="string">&quot;202209210827526887030&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;pipeline_dsl_path&quot;</span>: <span class="string">&quot;/data/projects/fate/fateflow/jobs/202209210827526887030/pipeline_dsl.json&quot;</span>,</span><br><span class="line">        <span class="string">&quot;runtime_conf_on_party_path&quot;</span>: <span class="string">&quot;/data/projects/fate/fateflow/jobs/202209210827526887030/guest/10000/job_runtime_on_party_conf.json&quot;</span>,</span><br><span class="line">        <span class="string">&quot;runtime_conf_path&quot;</span>: <span class="string">&quot;/data/projects/fate/fateflow/jobs/202209210827526887030/job_runtime_conf.json&quot;</span>,</span><br><span class="line">        <span class="string">&quot;train_runtime_conf_path&quot;</span>: <span class="string">&quot;/data/projects/fate/fateflow/jobs/202209210827526887030/train_runtime_conf.json&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;jobId&quot;</span>: <span class="string">&quot;202209210827526887030&quot;</span>,</span><br><span class="line">    <span class="string">&quot;retcode&quot;</span>: 0,</span><br><span class="line">    <span class="string">&quot;retmsg&quot;</span>: <span class="string">&quot;success&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用flow-test提交Job"><a href="#使用flow-test提交Job" class="headerlink" title="使用flow-test提交Job"></a>使用flow-test提交Job</h2><p>除了上述之外，还可以快速提交一个job。</p><p>flow-test 快速的flow测试，比较方便，只需要修改mnist_nn_testsuite.json并执行一次命令即可。他有以下特点：</p><ul><li>不需要提前绑定数据，执行完成后，也不存在被绑定的数据</li><li>日志会保存在到本地目录logs</li><li>不会产生model_id和model_version</li></ul><p>下面介绍执行步骤：</p><h3 id="修改mnist-nn-testsuite-json"><a href="#修改mnist-nn-testsuite-json" class="headerlink" title="修改mnist_nn_testsuite.json"></a>修改<code>mnist_nn_testsuite.json</code></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;data&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;engine&quot;</span>: <span class="string">&quot;PATH&quot;</span>,</span><br><span class="line">            <span class="string">&quot;namespace&quot;</span>: <span class="string">&quot;experiment&quot;</span>,</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;mnist_images&quot;</span>,</span><br><span class="line">            <span class="string">&quot;address&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;path&quot;</span>: <span class="string">&quot;/data/projects/fate/work/mnist_fed/mnist_images&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;role&quot;</span>: <span class="string">&quot;guest_0&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;engine&quot;</span>: <span class="string">&quot;PATH&quot;</span>,</span><br><span class="line">            <span class="string">&quot;namespace&quot;</span>: <span class="string">&quot;experiment&quot;</span>,</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;mnist_images&quot;</span>,</span><br><span class="line">            <span class="string">&quot;address&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;path&quot;</span>: <span class="string">&quot;/data/projects/fate/work/mnist_fed/mnist_images&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;role&quot;</span>: <span class="string">&quot;host_0&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;tasks&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;mnist&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;conf&quot;</span>: <span class="string">&quot;./mnist_conf.json&quot;</span>,</span><br><span class="line">            <span class="string">&quot;dsl&quot;</span>: <span class="string">&quot;./mnist_dsl.json&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="执行flow-test"><a href="#执行flow-test" class="headerlink" title="执行flow-test"></a>执行flow-test</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fate_test suite -i mnist_nn_testsuite.json</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><p><img src="image-20220922142054-e4f41jc.png" alt="image.png"></p><p>‍</p><h1 id="模型评估"><a href="#模型评估" class="headerlink" title="模型评估"></a>模型评估</h1><p>上述训练完成之后，如何进行评估本次训练得到的模型效果呢？</p><p>答案是：截止到1.9.0版本，FATE还暂不支持对计算机视觉类任务进行模型评估。。。</p><p>我的做法是，<strong>直接在FATE-FLOW中找到Job生成的模型文件，自行实现对模型的评估。</strong></p><p>要做到这一点需要熟悉源码。</p><h1 id="从How到Why"><a href="#从How到Why" class="headerlink" title="从How到Why"></a>从How到Why</h1><p>前面我们了解了FATE提交一个视觉分类任务的基本流程，但是我们还有很多未知的东西：比如为什么要这样组织数据，FATE是如何读取配置创建模型的，联邦学习结束后保存的模型在哪里，如何调用？</p><p>想要知道这些需要读懂FATE源码。</p><h1 id="源码（部分）"><a href="#源码（部分）" class="headerlink" title="源码（部分）"></a>源码（部分）</h1><p>该部分介绍FATE是如何根据DSL和CONF配置读入数据、创建和训练模型以及导出模型的。</p><p>这里先介绍一些比较重要的目录：</p><blockquote><ul><li><a href="https://github.com/FederatedAI/FATE：">https://github.com/FederatedAI/FATE：</a> FATE官方开源的根目录</li><li><a href="https://github.com/FederatedAI/FATE/tree/master/python/federatedml：FATE联邦学习算法组件的源码目录，也是后面重点研究的目录，读懂该目录下的源码就可以开始开发新的算法组件。">https://github.com/FederatedAI/FATE/tree/master/python/federatedml：FATE联邦学习算法组件的源码目录，也是后面重点研究的目录，读懂该目录下的源码就可以开始开发新的算法组件。</a></li><li><a href="https://github.com/FederatedAI/FATE-Flow/tree/3afbc3e5d335ac96634eadfc493c4c697ecbfc19/python/fate_flow/apps：FATE">https://github.com/FederatedAI/FATE-Flow/tree/3afbc3e5d335ac96634eadfc493c4c697ecbfc19/python/fate_flow/apps：FATE</a> API源码目录，可以在这里开发新的API</li></ul></blockquote><p>‍</p><p>从上面的案例中可以看到，我们主要使用的是HomoNN算法组件，所以这里我们要找到NN对应的位置：<a href="https://github.com/FederatedAI/FATE/tree/master/python/federatedml/nn，这里nn是神经网络的意思。">https://github.com/FederatedAI/FATE/tree/master/python/federatedml/nn，这里nn是神经网络的意思。</a></p><p>在该目录下，可以看到三个文件夹：</p><ul><li>backend：公共后端代码</li><li>hetero_nn：纵向nn组件</li><li>homo_nn：横向nn组件</li></ul><p>这三个文件夹中是需要重点读懂的代码。</p><p>首先，这里明确，我们要弄懂的问题：</p><ol><li>图像数据是如何input的</li><li>为什么做图像任务时，数据的组织形式要分为images/、config.yaml、filenames以及targets</li><li>FATE是如何根据CONF生成模型，optimizer等算法参数的。</li><li>FATE是如何进行训练的。</li><li>FATE是否支持使用预训练的模型进行训练，是否支持使用GPU进行训练，是否可以自定义添加log等等，如果不能，可否开发自己的组件来实现。</li><li>如果使用配置定义模型，那么FATE支持的layer以及参数有哪些？</li></ol><p>带着这些问题，我们来学习源码。</p><h2 id="enter-point-py"><a href="#enter-point-py" class="headerlink" title="enter_point.py"></a>enter_point.py</h2><p>enter_point是homo_nn组件被调用的起点（存疑），文件位置：<a href="https://github.com/FederatedAI/FATE/blob/master/python/federatedml/nn/homo_nn/enter_point.py">https://github.com/FederatedAI/FATE/blob/master/python/federatedml/nn/homo_nn/enter_point.py</a></p><p>重点关注<code>HomoNNClient</code>类。它包含几个重要的方法：</p><ul><li>fit：模型训练</li><li>predict：模型预测</li><li>export_model和load_model：模型的导出和加载。</li></ul><h3 id="fit"><a href="#fit" class="headerlink" title="fit"></a>fit</h3><p>以下是该方法的主要代码。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fit</span>(<span class="params">self, data, *args</span>):</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">from</span> federatedml.nn.homo_nn._torch <span class="keyword">import</span> build_trainer</span><br><span class="line">...</span><br><span class="line">        self._trainer, dataloader = build_trainer(</span><br><span class="line">            param=self.param,</span><br><span class="line">            data=data,</span><br><span class="line">            should_label_align=<span class="keyword">not</span> self.component_properties.is_warm_start,</span><br><span class="line">            trainer=self._trainer,</span><br><span class="line">        ) <span class="comment"># 调用build_trainer获取trainer和dataloader</span></span><br><span class="line">        self._trainer.fit(dataloader) <span class="comment"># 执行训练</span></span><br><span class="line">        self.set_summary(self._trainer.summary())</span><br><span class="line">        <span class="comment"># save model to local filesystem</span></span><br><span class="line">        self._trainer.save_checkpoint()</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以看到trainer和dataloader是通过调用build_trainer返回的。</p><p>‍</p><h2 id="torch-py"><a href="#torch-py" class="headerlink" title="_torch.py"></a>_torch.py</h2><p>这是FATE进行联邦学习，homo_nn组件的主要实现代码。</p><h3 id="build-trainer"><a href="#build-trainer" class="headerlink" title="build_trainer"></a>build_trainer</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">build_trainer</span>(<span class="params">param: HomoNNParam, data, should_label_align=<span class="literal">True</span>, trainer=<span class="literal">None</span></span>):</span><br><span class="line">    ...</span><br><span class="line">    pl_trainer = pl.Trainer(</span><br><span class="line">        max_epochs=total_epoch,</span><br><span class="line">        callbacks=[EarlyStopCallback(context)],</span><br><span class="line">        num_sanity_val_steps=<span class="number">0</span>,</span><br><span class="line">    )</span><br><span class="line">    ...</span><br><span class="line">    pl_model = FedLightModule(</span><br><span class="line">        context,</span><br><span class="line">        layers_config=param.nn_define,</span><br><span class="line">        optimizer_config=param.optimizer,</span><br><span class="line">        loss_config=&#123;<span class="string">&quot;loss&quot;</span>: param.loss&#125;,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    dataset = make_dataset(</span><br><span class="line">        data=data,</span><br><span class="line">        is_train=should_label_align,</span><br><span class="line">        expected_label_type=expected_label_type,</span><br><span class="line">    )</span><br><span class="line">    ...</span><br><span class="line">    dataloader = torch.utils.data.DataLoader(</span><br><span class="line">        dataset=dataset, batch_size=batch_size, num_workers=<span class="number">1</span></span><br><span class="line">    )</span><br><span class="line"><span class="keyword">return</span> trainer, dataloader</span><br></pre></td></tr></table></figure><p>这里就可以看到dataset是调用make_dataset方法得到，model是FedLightModule的实例化对象。</p><p>‍</p><h3 id="make-dataset"><a href="#make-dataset" class="headerlink" title="make_dataset"></a>make_dataset</h3><p>这里可以看到，图像数据，是通过VisionDataSet实例化得到的。具体VisionDataSet后面再谈。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make_dataset</span>(<span class="params">data, **kwargs</span>):</span><br><span class="line">    <span class="keyword">if</span> is_table(data):</span><br><span class="line">        dataset = TableDataSet(data_instances=data, **kwargs)</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">isinstance</span>(data, LocalData):</span><br><span class="line">        dataset = VisionDataSet(data.path, **kwargs)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">f&quot;data type <span class="subst">&#123;data&#125;</span> not supported&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dataset</span><br></pre></td></tr></table></figure><p>‍</p><h3 id="FedLightModule-init"><a href="#FedLightModule-init" class="headerlink" title="FedLightModule.init()"></a>FedLightModule.<strong>init</strong>()</h3><p>关注<code>FedLightModule</code>这个类。该类继承了<code>LightningModule</code>。这东西看上去是一个将pytorch轻量化、规范化的库。</p><p>该类有以下方法：</p><ul><li><strong>init</strong>：初始化</li><li>forward：前向传播</li><li>training_step：每个batch训练的执行代码，传入batch和batch_idx，返回loss</li><li>validation_step：每个batch验证的执行代码，传入batch和batch_idx，返回loss和acc</li><li>validation_epoch_end：每个epoch结束后执行，输入的是所有batch的outputs，打印该epoch的local loss和local acc。（local的意思是，只基于自己这一方的数据计算的结果）</li><li>configure_optimizers：配置optimizer</li></ul><p>在init方法中，非常清晰的可以看到，model、loss和optimizer是如何读取配置定义出来的。</p><p>model是通过读取配置中的layer_config，生成模型的每一层，然后在“组装起来”。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"></span></span><br><span class="line"><span class="params">    self,</span></span><br><span class="line"><span class="params">    context: PyTorchSAClientContext,</span></span><br><span class="line"><span class="params">    layers_config: typing.<span class="type">List</span>[typing.Mapping],</span></span><br><span class="line"><span class="params">    optimizer_config: types.SimpleNamespace,</span></span><br><span class="line"><span class="params">    loss_config: typing.Mapping,</span></span><br><span class="line"><span class="params"></span>):</span><br><span class="line">    <span class="built_in">super</span>().__init__()</span><br><span class="line">    self.save_hyperparameters()</span><br><span class="line">    self.context = context</span><br><span class="line"></span><br><span class="line">    <span class="comment"># model</span></span><br><span class="line">    layers = []</span><br><span class="line">    <span class="keyword">for</span> layer_config <span class="keyword">in</span> layers_config:</span><br><span class="line">        layer_name = layer_config[<span class="string">&quot;layer&quot;</span>]</span><br><span class="line">        layer_kwargs = &#123;k: v <span class="keyword">for</span> k, v <span class="keyword">in</span> layer_config.items() <span class="keyword">if</span> k != <span class="string">&quot;layer&quot;</span>&#125;</span><br><span class="line">        layers.append(get_layer_fn(layer_name, layer_kwargs))</span><br><span class="line">    self.model = nn.Sequential(*layers)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># loss</span></span><br><span class="line">    loss_name = loss_config[<span class="string">&quot;loss&quot;</span>]</span><br><span class="line">    loss_kwargs = &#123;k: v <span class="keyword">for</span> k, v <span class="keyword">in</span> loss_config.items() <span class="keyword">if</span> k != <span class="string">&quot;loss&quot;</span>&#125;</span><br><span class="line">    self.loss_fn, self.expected_label_type = get_loss_fn(loss_name, loss_kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># optimizer</span></span><br><span class="line">    self._optimizer_name = optimizer_config.optimizer</span><br><span class="line">    self._optimizer_kwargs = optimizer_config.kwargs</span><br><span class="line"></span><br><span class="line">    self.num_data_consumed = <span class="number">0</span></span><br><span class="line">    self._all_consumed_data_aggregated = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    self._should_early_stop = <span class="literal">False</span></span><br><span class="line">    self._loss = <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>如果我们需要定义自己的模型，比如，我们想要定义一个预训练的vgg16，则修改代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">self.model = models.vgg16(pretrained=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>这里，我们可以回答第三、四、五个问题： FATE本身不支持加载预训练模型、使用GPU训练、自定义日志，但是您可以自行开发。</p><h3 id="PyTorchFederatedTrainer"><a href="#PyTorchFederatedTrainer" class="headerlink" title="PyTorchFederatedTrainer"></a>PyTorchFederatedTrainer</h3><p>这个类和模型有关。从<code>save_checkpoint</code>方法中可以知道，FATE将模型文件保存为model.ckpt。从<code>load_model</code>方法中可以了解到，加载最后得到的模型文件的方式：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pl_model = FedLightModule.load_from_checkpoint(filepath)</span><br></pre></td></tr></table></figure><p>这样，我们只需要找到最后生成的模型，就可以load进来， 自己开发进行模型评估。</p><h2 id="data-py"><a href="#data-py" class="headerlink" title="data.py"></a>data.py</h2><p><a href="https://github.com/FederatedAI/FATE/blob/master/python/federatedml/nn/backend/pytorch/data.py">https://github.com/FederatedAI/FATE/blob/master/python/federatedml/nn/backend/pytorch/data.py</a></p><p>FATE通过<code>VisionDataSet</code>类加载图像数据，这也回答了第一、二个问题。</p><p>‍</p><h2 id="FATE支持的layer"><a href="#FATE支持的layer" class="headerlink" title="FATE支持的layer"></a>FATE支持的layer</h2><p>在CONF文件的“nn_define”中出现了很多类型的layer：Conv2d、ReLu…</p><p>FATE支持的层的定义位于<a href="https://github.com/FederatedAI/FATE/blob/master/python/federatedml/nn/backend/fate_torch/nn.py">https://github.com/FederatedAI/FATE/blob/master/python/federatedml/nn/backend/fate_torch/nn.py</a></p><blockquote><p>这里我一开始误以为定义的层位于：<a href="https://github.com/FederatedAI/FATE/blob/master/python/federatedml/nn/backend/pytorch/nn_model.py">https://github.com/FederatedAI/FATE/blob/master/python/federatedml/nn/backend/pytorch/nn_model.py</a></p><p>后来发现是不对的，为什么不对。我也没搞清楚。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 联邦学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 联邦学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FATE DSL配置文件详细解释</title>
      <link href="/2022/11/04/FATE-DSL%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E7%BB%86%E8%A7%A3%E9%87%8A/"/>
      <url>/2022/11/04/FATE-DSL%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E7%BB%86%E8%A7%A3%E9%87%8A/</url>
      
        <content type="html"><![CDATA[<p>这里对FATE DSL文件做详细解释。</p><h1 id="DSL"><a href="#DSL" class="headerlink" title="DSL"></a>DSL</h1><p>DSL有两个版本，FATE 1.7以上版本强制使用v2。</p><p>dsl.json提供了流程，conf.json提供了个流程参数。</p><p>其中dsl.json的配置参见：<a href="https://github.com/FederatedAI/FATE/blob/master/doc/tutorial/dsl_conf/dsl_conf_v2_setting_guide.zh.md">https://github.com/FederatedAI/FATE/blob/master/doc/tutorial/dsl_conf/dsl_conf_v2_setting_guide.zh.md</a></p><p>下面选取一个案例。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//dsl.json</span><br><span class="line">&#123;</span><br><span class="line">    &quot;components&quot;: &#123; // 一级配置，表示这个任务会使用的组件</span><br><span class="line">        &quot;reader_0&quot;: &#123; // 组件的名字，自定义</span><br><span class="line">    // 指定模块，参数需要和目录/data/projects/fate/fate/python/federatedml/components一致，里面有一些定义好的组件，但是感觉不全，我的建议还是看官方docs：https://fate.readthedocs.io/en/latest/federatedml_component/</span><br><span class="line">            &quot;module&quot;: &quot;Reader&quot;, //数据需要通过Reader组件从数据存储拿取数据，注意此组件仅有输出output，此模块必须要有</span><br><span class="line">            &quot;output&quot;: &#123;</span><br><span class="line">                &quot;data&quot;: [</span><br><span class="line">                    &quot;data&quot; // 这个地方是自定义还是必须是train？需要尝试</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">// 除reader之外，每个组件下包含input和output，input和output下又包含data和model</span><br><span class="line">// data input: 来自于之前的组件有四种可能的类型，</span><br><span class="line">// 1. data: 用在data_transform, feature_engineering modules 和 evaluation模块</span><br><span class="line">// 2. train_data: 用在训练组件，比如HeteroLR、HeteroSBT，如果使用了这个字段， 则这个task会被解析为一个fit task（训练任务？）</span><br><span class="line">// 3. validate_data: 如果有了train_data，那么该字段就是可选地. 这种情况下，数据被用作validation集.</span><br><span class="line">// 4. test_data: 指定用于预测的数据，如果设置了这个字段，模型也需要。</span><br><span class="line"></span><br><span class="line">// model input: 来自于之前的模块，有2种可能的类型，</span><br><span class="line">// 1. model: 由同类型（指“module”字段相同）组件输入的模型。把其他组件的模型输出作为输入。</span><br><span class="line">// 2. isometric_model: 模型输入来自上游组件。</span><br><span class="line"></span><br><span class="line">// data output: 来自于之前的模块，有4种可能的类型，</span><br><span class="line">// 1. data: </span><br><span class="line">// 2. train_data、validate_data、test_data: 仅用于数据分片？</span><br><span class="line"></span><br><span class="line">// model : 来自于之前的模块，有1种可能的类型，</span><br><span class="line">// 1. model</span><br><span class="line"></span><br><span class="line">        &quot;data_transform_0&quot;: &#123;</span><br><span class="line">            &quot;module&quot;: &quot;DataTransform&quot;,</span><br><span class="line">            &quot;input&quot;: &#123;</span><br><span class="line">                &quot;data&quot;: &#123;</span><br><span class="line">                    &quot;data&quot;: [</span><br><span class="line">                        &quot;reader_0.data&quot;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;output&quot;: &#123;</span><br><span class="line">                &quot;data&quot;: [</span><br><span class="line">                    &quot;data&quot;</span><br><span class="line">                ],</span><br><span class="line">                &quot;model&quot;: [</span><br><span class="line">                    &quot;model&quot;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;scale_0&quot;: &#123;</span><br><span class="line">            &quot;module&quot;: &quot;FeatureScale&quot;,</span><br><span class="line">            &quot;input&quot;: &#123;</span><br><span class="line">                &quot;data&quot;: &#123;</span><br><span class="line">                    &quot;data&quot;: [</span><br><span class="line">                        &quot;data_transform_0.data&quot;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;output&quot;: &#123;</span><br><span class="line">                &quot;data&quot;: [</span><br><span class="line">                    &quot;data&quot;</span><br><span class="line">                ],</span><br><span class="line">                &quot;model&quot;: [</span><br><span class="line">                    &quot;model&quot;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;homo_lr_0&quot;: &#123;</span><br><span class="line">            &quot;module&quot;: &quot;HomoLR&quot;,</span><br><span class="line">            &quot;input&quot;: &#123;</span><br><span class="line">                &quot;data&quot;: &#123;</span><br><span class="line">                    &quot;train_data&quot;: [</span><br><span class="line">                        &quot;scale_0.data&quot;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;output&quot;: &#123;</span><br><span class="line">                &quot;data&quot;: [</span><br><span class="line">                    &quot;data&quot;</span><br><span class="line">                ],</span><br><span class="line">                &quot;model&quot;: [</span><br><span class="line">                    &quot;model&quot;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;evaluation_0&quot;: &#123;</span><br><span class="line">            &quot;module&quot;: &quot;Evaluation&quot;,</span><br><span class="line">            &quot;input&quot;: &#123;</span><br><span class="line">                &quot;data&quot;: &#123;</span><br><span class="line">                    &quot;data&quot;: [</span><br><span class="line">                        &quot;homo_lr_0.data&quot;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;output&quot;: &#123;</span><br><span class="line">                &quot;data&quot;: [</span><br><span class="line">                    &quot;data&quot;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>‍</p><h1 id="CONF"><a href="#CONF" class="headerlink" title="CONF"></a>CONF</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">//conf.json</span><br><span class="line">&#123;</span><br><span class="line">    //fate版本大于等于1.7时，必须设置dsl_version=2</span><br><span class="line">    &quot;dsl_version&quot;: 2,</span><br><span class="line"></span><br><span class="line">    &quot;initiator&quot;: &#123; //定义发起者的角色和partyid</span><br><span class="line">        &quot;role&quot;: &quot;guest&quot;,</span><br><span class="line">        &quot;party_id&quot;: 10000</span><br><span class="line">    &#125;,</span><br><span class="line">    //定义所有的参与方</span><br><span class="line">    &quot;role&quot;: &#123;</span><br><span class="line">        &quot;guest&quot;: [</span><br><span class="line">            10000</span><br><span class="line">        ],</span><br><span class="line">        &quot;host&quot;: [</span><br><span class="line">            10000</span><br><span class="line">        ],</span><br><span class="line">        &quot;arbiter&quot;: [</span><br><span class="line">            10000</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">  </span><br><span class="line">    &quot;component_parameters&quot;: &#123;</span><br><span class="line">        //common：参数应用到所有的参与方, role：参数应用到指定的参与方</span><br><span class="line">        &quot;common&quot;: &#123;</span><br><span class="line">    //组件的详细参数参见：https://fate.readthedocs.io/en/latest/federatedml_component/</span><br><span class="line">            &quot;data_transform_0&quot;: &#123;</span><br><span class="line">                &quot;with_label&quot;: true,</span><br><span class="line">                &quot;output_format&quot;: &quot;dense&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;homo_lr_0&quot;: &#123;</span><br><span class="line">                &quot;penalty&quot;: &quot;L2&quot;,</span><br><span class="line">                &quot;tol&quot;: 1e-05,</span><br><span class="line">                &quot;alpha&quot;: 0.01,</span><br><span class="line">                &quot;optimizer&quot;: &quot;sgd&quot;,</span><br><span class="line">                &quot;batch_size&quot;: -1,</span><br><span class="line">                &quot;learning_rate&quot;: 0.15,</span><br><span class="line">                &quot;init_param&quot;: &#123;</span><br><span class="line">                    &quot;init_method&quot;: &quot;zeros&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;max_iter&quot;: 30,</span><br><span class="line">                &quot;early_stop&quot;: &quot;diff&quot;,</span><br><span class="line">                &quot;encrypt_param&quot;: &#123;</span><br><span class="line">                    &quot;method&quot;: null</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;cv_param&quot;: &#123;</span><br><span class="line">                    &quot;n_splits&quot;: 4,</span><br><span class="line">                    &quot;shuffle&quot;: true,</span><br><span class="line">                    &quot;random_seed&quot;: 33,</span><br><span class="line">                    &quot;need_cv&quot;: false</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;decay&quot;: 1,</span><br><span class="line">                &quot;decay_sqrt&quot;: true</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;evaluation_0&quot;: &#123;</span><br><span class="line">                &quot;eval_type&quot;: &quot;binary&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        &quot;role&quot;: &#123;</span><br><span class="line">            &quot;host&quot;: &#123;</span><br><span class="line">                &quot;0&quot;: &#123; //role.host.0：参数应用到host的index=0的参与方</span><br><span class="line">                    &quot;reader_0&quot;: &#123;</span><br><span class="line">                        &quot;table&quot;: &#123;</span><br><span class="line">                            &quot;name&quot;: &quot;homo_default_credit_host&quot;,</span><br><span class="line">                            &quot;namespace&quot;: &quot;homo_default_credit_host&quot;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &quot;evaluation_0&quot;: &#123;</span><br><span class="line">                        &quot;need_run&quot;: false</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;guest&quot;: &#123;</span><br><span class="line">                &quot;0&quot;: &#123;</span><br><span class="line">                    &quot;reader_0&quot;: &#123;</span><br><span class="line">                        &quot;table&quot;: &#123;</span><br><span class="line">                            &quot;name&quot;: &quot;homo_default_credit_guest&quot;,</span><br><span class="line">                            &quot;namespace&quot;: &quot;homo_default_credit_guest&quot;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注：</p><ol><li>上面的conf没有使用到provider组件，该组件支持加载多种且多版本的组件提供方</li><li>上面conf没涉及系统运行时参数，具体参见：<a href="https://federatedai.github.io/FATE-Flow/latest/zh/fate_flow_job_scheduling/#43">https://federatedai.github.io/FATE-Flow/latest/zh/fate_flow_job_scheduling/#43</a></li><li>dsl v2中，predict dsl不会在训练后自动生成，用户需要通过flow client部署所需的组件：<a href="https://github.com/FederatedAI/FATE-Flow/blob/main/doc/cli/model.md#deploy">https://github.com/FederatedAI/FATE-Flow/blob/main/doc/cli/model.md#deploy</a></li><li>train dsl 和predict dsl examples：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;components&quot;: &#123;</span><br><span class="line">    &quot;reader_0&quot;: &#123;</span><br><span class="line">        &quot;module&quot;: &quot;Reader&quot;,</span><br><span class="line">        &quot;output&quot;: &#123;</span><br><span class="line">            &quot;data&quot;: [</span><br><span class="line">                &quot;data&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;data_transform_0&quot;: &#123;</span><br><span class="line">        &quot;module&quot;: &quot;DataTransform&quot;,</span><br><span class="line">        &quot;input&quot;: &#123;</span><br><span class="line">            &quot;data&quot;: &#123;</span><br><span class="line">                &quot;data&quot;: [</span><br><span class="line">                    &quot;reader_0.data&quot;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;output&quot;: &#123;</span><br><span class="line">            &quot;data&quot;: [</span><br><span class="line">                &quot;data&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;model&quot;: [</span><br><span class="line">                &quot;model&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;intersection_0&quot;: &#123;</span><br><span class="line">        &quot;module&quot;: &quot;Intersection&quot;,</span><br><span class="line">        &quot;input&quot;: &#123;</span><br><span class="line">            &quot;data&quot;: &#123;</span><br><span class="line">                &quot;data&quot;: [</span><br><span class="line">                    &quot;data_transform_0.data&quot;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;output&quot;: &#123;</span><br><span class="line">            &quot;data&quot;:[</span><br><span class="line">                &quot;data&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;hetero_nn_0&quot;: &#123;</span><br><span class="line">        &quot;module&quot;: &quot;HeteroNN&quot;,</span><br><span class="line">        &quot;input&quot;: &#123;</span><br><span class="line">            &quot;data&quot;: &#123;</span><br><span class="line">                &quot;train_data&quot;: [</span><br><span class="line">                    &quot;intersection_0.data&quot;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;output&quot;: &#123;</span><br><span class="line">            &quot;data&quot;: [</span><br><span class="line">                &quot;data&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;model&quot;: [</span><br><span class="line">                &quot;model&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>‍</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;components&quot;: &#123;</span><br><span class="line">    &quot;reader_0&quot;: &#123;</span><br><span class="line">        &quot;module&quot;: &quot;Reader&quot;,</span><br><span class="line">        &quot;output&quot;: &#123;</span><br><span class="line">            &quot;data&quot;: [</span><br><span class="line">                &quot;data&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;data_transform_0&quot;: &#123;</span><br><span class="line">        &quot;module&quot;: &quot;DataTransform&quot;,</span><br><span class="line">        &quot;input&quot;: &#123;</span><br><span class="line">            &quot;data&quot;: &#123;</span><br><span class="line">                &quot;data&quot;: [</span><br><span class="line">                    &quot;reader_0.data&quot;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;output&quot;: &#123;</span><br><span class="line">            &quot;data&quot;: [</span><br><span class="line">                &quot;data&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;model&quot;: [</span><br><span class="line">                &quot;model&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;intersection_0&quot;: &#123;</span><br><span class="line">        &quot;module&quot;: &quot;Intersection&quot;,</span><br><span class="line">        &quot;input&quot;: &#123;</span><br><span class="line">            &quot;data&quot;: &#123;</span><br><span class="line">                &quot;data&quot;: [</span><br><span class="line">                    &quot;data_transform_0.data&quot;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;output&quot;: &#123;</span><br><span class="line">            &quot;data&quot;:[</span><br><span class="line">                &quot;data&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;hetero_nn_0&quot;: &#123;</span><br><span class="line">        &quot;module&quot;: &quot;HeteroNN&quot;,</span><br><span class="line">        &quot;input&quot;: &#123;</span><br><span class="line">            &quot;data&quot;: &#123;</span><br><span class="line">                &quot;train_data&quot;: [</span><br><span class="line">                    &quot;intersection_0.data&quot;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;output&quot;: &#123;</span><br><span class="line">            &quot;data&quot;: [</span><br><span class="line">                &quot;data&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;model&quot;: [</span><br><span class="line">                &quot;model&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;evaluation_0&quot;: &#123;</span><br><span class="line">        &quot;module&quot;: &quot;Evaluation&quot;,</span><br><span class="line">        &quot;input&quot;: &#123;</span><br><span class="line">            &quot;data&quot;: &#123;</span><br><span class="line">                &quot;data&quot;: [</span><br><span class="line">                    &quot;hetero_nn_0.data&quot;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;,</span><br><span class="line">         &quot;output&quot;: &#123;</span><br><span class="line">             &quot;data&quot;: [</span><br><span class="line">                 &quot;data&quot;</span><br><span class="line">             ]</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="基本工作流"><a href="#基本工作流" class="headerlink" title="基本工作流"></a>基本工作流</h1><ol><li>提交作业后，作业的dsl和配置会存储到相应的目录：<code>/data/projects/fate/fateflow/jobs</code></li><li>解析dsl和conf，生成配置，分发共同的配置给每一方，并生成存储特定方的配置在目录：<code>/data/projects/fate/fateflow/jobs/[job_id]/[role]/[party_id]</code></li></ol><p>‍</p>]]></content>
      
      
      <categories>
          
          <category> 联邦学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 联邦学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FATE横向联邦学习：信用数据案例</title>
      <link href="/2022/11/04/FATE%E6%A8%AA%E5%90%91%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0%EF%BC%9A%E4%BF%A1%E7%94%A8%E6%95%B0%E6%8D%AE%E6%A1%88%E4%BE%8B/"/>
      <url>/2022/11/04/FATE%E6%A8%AA%E5%90%91%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0%EF%BC%9A%E4%BF%A1%E7%94%A8%E6%95%B0%E6%8D%AE%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>通过FATE平台提交联邦学习job，有两种方式：DSL和pipline；</p><p>DSL是通过写配置文件的方式，配置联邦学习job的各个参数；pipeline是通过写python代码的方式配置和提交job</p><p>本文使用Fate的信用样例数据，介绍通过DSL的方式进行Fate横向联邦学习的使用案例。</p></blockquote><h1 id="实验设置"><a href="#实验设置" class="headerlink" title="实验设置"></a>实验设置</h1><blockquote><p>fate lastest 1.9 standalone</p><p>数据集：信用数据，位置FATE/examples/data/default_credit_homo_guest/</p><p>算法：logistics regression</p></blockquote><h1 id="实验配置"><a href="#实验配置" class="headerlink" title="实验配置"></a>实验配置</h1><h2 id="上传两方数据"><a href="#上传两方数据" class="headerlink" title="上传两方数据"></a>上传两方数据</h2><p>编辑上传数据配置文件：upload_my_homolr_guest.json</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"> <span class="attr">&quot;file&quot;</span><span class="punctuation">:</span><span class="string">&quot;/data/projects/fate/examples/data/default_credit_homo_guest.csv&quot;</span><span class="punctuation">,</span></span><br><span class="line"> <span class="attr">&quot;head&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span></span><br><span class="line"> <span class="attr">&quot;partition&quot;</span><span class="punctuation">:</span><span class="number">10</span><span class="punctuation">,</span></span><br><span class="line"> <span class="attr">&quot;work_mode&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span></span><br><span class="line"> <span class="attr">&quot;namespace&quot;</span><span class="punctuation">:</span><span class="string">&quot;homo_default_credit_guest&quot;</span><span class="punctuation">,</span></span><br><span class="line"> <span class="attr">&quot;table_name&quot;</span><span class="punctuation">:</span><span class="string">&quot;homo_default_credit_guest&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>upload_my_homolr_host.json</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"> <span class="attr">&quot;file&quot;</span><span class="punctuation">:</span><span class="string">&quot;/data/projects/fate/examples/data/default_credit_homo_host_1.csv&quot;</span><span class="punctuation">,</span></span><br><span class="line"> <span class="attr">&quot;head&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span></span><br><span class="line"> <span class="attr">&quot;partition&quot;</span><span class="punctuation">:</span><span class="number">10</span><span class="punctuation">,</span></span><br><span class="line"> <span class="attr">&quot;work_mode&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span></span><br><span class="line"> <span class="attr">&quot;namespace&quot;</span><span class="punctuation">:</span><span class="string">&quot;homo_default_credit_host&quot;</span><span class="punctuation">,</span></span><br><span class="line"> <span class="attr">&quot;table_name&quot;</span><span class="punctuation">:</span><span class="string">&quot;homo_default_credit_host&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>file指出数据文件的位置</li><li>namespace和table_name确定上传表的命名空间和表名。</li></ul><h2 id="DSL配置文件"><a href="#DSL配置文件" class="headerlink" title="DSL配置文件"></a>DSL配置文件</h2><p>找到dsl配置文件：<code>/data/projects/fate/examples/dsl/v2/homo_logistic_regression/homo_lr_train_dsl.json</code>，内容如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;components&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;reader_0&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;module&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Reader&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;output&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                    <span class="string">&quot;data&quot;</span></span><br><span class="line">                <span class="punctuation">]</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;data_transform_0&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;module&quot;</span><span class="punctuation">:</span> <span class="string">&quot;DataTransform&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;input&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                        <span class="string">&quot;reader_0.data&quot;</span></span><br><span class="line">                    <span class="punctuation">]</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;output&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                    <span class="string">&quot;data&quot;</span></span><br><span class="line">                <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;model&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                    <span class="string">&quot;model&quot;</span></span><br><span class="line">                <span class="punctuation">]</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;scale_0&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;module&quot;</span><span class="punctuation">:</span> <span class="string">&quot;FeatureScale&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;input&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                        <span class="string">&quot;data_transform_0.data&quot;</span></span><br><span class="line">                    <span class="punctuation">]</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;output&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                    <span class="string">&quot;data&quot;</span></span><br><span class="line">                <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;model&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                    <span class="string">&quot;model&quot;</span></span><br><span class="line">                <span class="punctuation">]</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;homo_lr_0&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;module&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HomoLR&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;input&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;train_data&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                        <span class="string">&quot;scale_0.data&quot;</span></span><br><span class="line">                    <span class="punctuation">]</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;output&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                    <span class="string">&quot;data&quot;</span></span><br><span class="line">                <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;model&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                    <span class="string">&quot;model&quot;</span></span><br><span class="line">                <span class="punctuation">]</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;evaluation_0&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;module&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Evaluation&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;input&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                        <span class="string">&quot;homo_lr_0.data&quot;</span></span><br><span class="line">                    <span class="punctuation">]</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;output&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                    <span class="string">&quot;data&quot;</span></span><br><span class="line">                <span class="punctuation">]</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>该文件配置了job的各个组件的类型，以及组件的输入、输出。</p><p>找到conf配置文件：<code>/data/projects/fate/examples/dsl/v2/homo_logistic_regression/homo_lr_train_conf.json</code>，内容（略作修改）如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;dsl_version&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;initiator&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;role&quot;</span><span class="punctuation">:</span> <span class="string">&quot;guest&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;party_id&quot;</span><span class="punctuation">:</span> <span class="number">10000</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;role&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;guest&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="number">10000</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;host&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="number">10000</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;arbiter&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="number">10000</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;component_parameters&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;common&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;data_transform_0&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;with_label&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;output_format&quot;</span><span class="punctuation">:</span> <span class="string">&quot;dense&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;homo_lr_0&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;penalty&quot;</span><span class="punctuation">:</span> <span class="string">&quot;L2&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;tol&quot;</span><span class="punctuation">:</span> <span class="number">1e-05</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;alpha&quot;</span><span class="punctuation">:</span> <span class="number">0.01</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;optimizer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sgd&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;batch_size&quot;</span><span class="punctuation">:</span> <span class="number">-1</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;learning_rate&quot;</span><span class="punctuation">:</span> <span class="number">0.15</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;init_param&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;init_method&quot;</span><span class="punctuation">:</span> <span class="string">&quot;zeros&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;max_iter&quot;</span><span class="punctuation">:</span> <span class="number">30</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;early_stop&quot;</span><span class="punctuation">:</span> <span class="string">&quot;diff&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;encrypt_param&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;method&quot;</span><span class="punctuation">:</span> <span class="keyword">null</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;cv_param&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;n_splits&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;shuffle&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;random_seed&quot;</span><span class="punctuation">:</span> <span class="number">33</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;need_cv&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;decay&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;decay_sqrt&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;evaluation_0&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;eval_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;binary&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;role&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;host&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;0&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;reader_0&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;table&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;homo_default_credit_guest&quot;</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;namespace&quot;</span><span class="punctuation">:</span> <span class="string">&quot;homo_default_credit_guest&quot;</span></span><br><span class="line">                        <span class="punctuation">&#125;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;evaluation_0&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;need_run&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span></span><br><span class="line">                    <span class="punctuation">&#125;</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;guest&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;0&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;reader_0&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;table&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;homo_default_credit_host&quot;</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;namespace&quot;</span><span class="punctuation">:</span> <span class="string">&quot;homo_default_credit_host&quot;</span></span><br><span class="line">                        <span class="punctuation">&#125;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>该文件配置了联邦学习发起方（initiator）、参与方（role）以及每一方组件的参数（component_parameters）。</p><blockquote><ol><li>initiator段设置了联邦发起者的角色和id</li><li>role段设置了联邦的参与方，和参与方的角色</li><li>job_parameters定义了工作模式（单机/集群）</li><li>component_parameters设置了组件的参数，分为各参与方公共的参数（common），以及各参与方的独特的参数（role）</li></ol></blockquote><h1 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h1><p>进入实验环境；这里使用standalone模拟两方联邦学习，所以所有操作是在同一机器上进行。</p><h2 id="上传训练数据"><a href="#上传训练数据" class="headerlink" title="上传训练数据"></a>上传训练数据</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(venv) [root@5af726377674 fate]<span class="comment"># flow data upload -c upload_my_homolr_guest.json</span></span><br><span class="line">...</span><br><span class="line">(venv) [root@5af726377674 fate]<span class="comment"># flow data upload -c upload_my_homolr_host.json</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">#guest host分两次上传。</span></span><br></pre></td></tr></table></figure><p>使用flow table 查看上传的表信息：homo_default_credit_host</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(venv) [root@5af726377674 fate]# flow table info -n homo_default_credit_host -t homo_default_credit_host</span><br><span class="line">&#123;</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">        &quot;address&quot;: &#123;</span><br><span class="line">            &quot;connector_name&quot;: null,</span><br><span class="line">            &quot;home&quot;: null,</span><br><span class="line">            &quot;name&quot;: &quot;homo_default_credit_host&quot;,</span><br><span class="line">            &quot;namespace&quot;: &quot;homo_default_credit_host&quot;,</span><br><span class="line">            &quot;storage_type&quot;: &quot;LMDB&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;count&quot;: 8000,</span><br><span class="line">        &quot;enable&quot;: true,</span><br><span class="line">        &quot;exist&quot;: 1,</span><br><span class="line">        &quot;namespace&quot;: &quot;homo_default_credit_host&quot;,</span><br><span class="line">        &quot;origin&quot;: &quot;upload&quot;,</span><br><span class="line">        &quot;partition&quot;: 10,</span><br><span class="line">        &quot;schema&quot;: &#123;</span><br><span class="line">            &quot;header&quot;: &quot;y,x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22&quot;,</span><br><span class="line">            &quot;sid&quot;: &quot;id&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;table_name&quot;: &quot;homo_default_credit_host&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;retcode&quot;: 0,</span><br><span class="line">    &quot;retmsg&quot;: &quot;success&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="提交训练任务"><a href="#提交训练任务" class="headerlink" title="提交训练任务"></a>提交训练任务</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(venv) [root@5af726377674 fate]<span class="comment"># flow job submit -d test_my_homolr_train_dsl.json -c test_my_homolr_train_conf.json </span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;data&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;board_url&quot;</span>: <span class="string">&quot;http://127.0.0.1:8080/index.html#/dashboard?job_id=202209200821441165650&amp;role=guest&amp;party_id=10000&quot;</span>,</span><br><span class="line">        <span class="string">&quot;code&quot;</span>: 0,</span><br><span class="line">        <span class="string">&quot;dsl_path&quot;</span>: <span class="string">&quot;/data/projects/fate/fateflow/jobs/202209200821441165650/job_dsl.json&quot;</span>,</span><br><span class="line">        <span class="string">&quot;job_id&quot;</span>: <span class="string">&quot;202209200821441165650&quot;</span>,</span><br><span class="line">        <span class="string">&quot;logs_directory&quot;</span>: <span class="string">&quot;/data/projects/fate/fateflow/logs/202209200821441165650&quot;</span>,</span><br><span class="line">        <span class="string">&quot;message&quot;</span>: <span class="string">&quot;success&quot;</span>,</span><br><span class="line">        <span class="string">&quot;model_info&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;model_id&quot;</span>: <span class="string">&quot;arbiter-10000#guest-10000#host-10000#model&quot;</span>,</span><br><span class="line">            <span class="string">&quot;model_version&quot;</span>: <span class="string">&quot;202209200821441165650&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;pipeline_dsl_path&quot;</span>: <span class="string">&quot;/data/projects/fate/fateflow/jobs/202209200821441165650/pipeline_dsl.json&quot;</span>,</span><br><span class="line">        <span class="string">&quot;runtime_conf_on_party_path&quot;</span>: <span class="string">&quot;/data/projects/fate/fateflow/jobs/202209200821441165650/guest/10000/job_runtime_on_party_conf.json&quot;</span>,</span><br><span class="line">        <span class="string">&quot;runtime_conf_path&quot;</span>: <span class="string">&quot;/data/projects/fate/fateflow/jobs/202209200821441165650/job_runtime_conf.json&quot;</span>,</span><br><span class="line">        <span class="string">&quot;train_runtime_conf_path&quot;</span>: <span class="string">&quot;/data/projects/fate/fateflow/jobs/202209200821441165650/train_runtime_conf.json&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;jobId&quot;</span>: <span class="string">&quot;202209200821441165650&quot;</span>,</span><br><span class="line">    <span class="string">&quot;retcode&quot;</span>: 0,</span><br><span class="line">    <span class="string">&quot;retmsg&quot;</span>: <span class="string">&quot;success&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="查看状态"><a href="#查看状态" class="headerlink" title="查看状态"></a>查看状态</h2><p>在fate-board上查看训练状态：<code>http://ip:8086</code></p><p><img src="image-20220920170949-v81vtm8.png" alt="image.png"></p><p>选择<code>guest</code>的那条记录，进入详情页。点击<code>evaluation</code>，选择<code>view the outputs</code>，查看模型效果。</p><p><img src="image-20220920203955-qua2axz.png" alt="image.png"></p><p><img src="image-20220920204118-0eu2i1y.png" alt="image.png"></p><p>loss在<code>homo_lr_0</code>的outputs</p><p>‍</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>使用DSL进行FATE横向联邦学习的流程包括：各方上传数据；编写DSL和CONF文件配置组件、参与方信息等；提交job。</li><li>为了方便测试，这里使用的standalone单机版本，所以所有操作都在同一台机器上。实际在集群上可能会有所不同，例如需要在多方机器上上传不同的数据。</li><li>FATE的组件列表、组件输入的格式、组件的参数配置可以查看官方文档：<a href="https://fate.readthedocs.io/en/latest/federatedml_component/">https://fate.readthedocs.io/en/latest/federatedml_component/</a></li><li>FATE关于DSL和CONF文件的配置说明可以参考：<a href="https://github.com/FederatedAI/FATE/blob/master/doc/tutorial/dsl_conf/dsl_conf_v2_setting_guide.zh.md">https://github.com/FederatedAI/FATE/blob/master/doc/tutorial/dsl_conf/dsl_conf_v2_setting_guide.zh.md</a></li><li>flow命令指南：<a href="https://federatedai.github.io/FATE-Flow/latest/zh/document_navigation/">https://federatedai.github.io/FATE-Flow/latest/zh/document_navigation/</a></li><li>flow api文档：<a href="https://federatedai.github.io/FATE-Flow/latest/zh/swagger/">https://federatedai.github.io/FATE-Flow/latest/zh/swagger/</a></li></ol><h1 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h1><ol><li><a href="https://www.freesion.com/article/2169210597/#1_3">联邦学习框架FATE使用案例记录</a></li><li><a href="https://blog.csdn.net/WenDong1997/article/details/106743620">联邦学习框架FATE实践（训练/测试步骤及参数说明</a></li></ol><p>‍</p>]]></content>
      
      
      <categories>
          
          <category> 联邦学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 联邦学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FATE联邦学习框架简介</title>
      <link href="/2022/11/03/FATE%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B/"/>
      <url>/2022/11/03/FATE%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="联邦学习介绍"><a href="#联邦学习介绍" class="headerlink" title="联邦学习介绍"></a>联邦学习介绍</h1><h2 id="联邦学习的出现解决什么问题"><a href="#联邦学习的出现解决什么问题" class="headerlink" title="联邦学习的出现解决什么问题"></a>联邦学习的出现解决什么问题</h2><p>解决“数据孤岛”问题，保证数据安全与隐私保护。</p><p>由于各种原因，数据孤岛问题普遍存在。在用户和企业角度下，商业公司所拥有的数据往往都有巨大的潜在价值。两个公司甚至公司间的部门都要考虑利益的交换，往往这些机构不会提供各自数据与其他公司做与单的聚合，导致即使在同一个公司内，数据也往往以孤岛形式出现。</p><h2 id="联邦学习的概念"><a href="#联邦学习的概念" class="headerlink" title="联邦学习的概念"></a>联邦学习的概念</h2><p>本质：联邦学习本质上是一种<strong>分布式</strong>机器学习技术，或机器学习<strong>框架</strong>。</p><p>目标：联邦学习的目标是在保证数据隐私安全及合法合规的基础上，实现共同建模，提升AI模型的效果。</p><h2 id="联邦学习的分类"><a href="#联邦学习的分类" class="headerlink" title="联邦学习的分类"></a>联邦学习的分类</h2><p>根据每个参与共同建模的企业称为参与方，根据多参与方之间数据分布的不同，把联邦学习分为三类：横向联邦学习、纵向联邦学习和联邦迁移学习。</p><p><img src="image-20221016171301-jpflppr.png" alt="image.png"></p><ul><li>横向联邦适用于，参与方之间的数据特征相似，但样本不同。</li><li>纵向联邦适用于，参与方之间的数据特征重叠多，但样本重叠少。</li><li>联邦迁移学习则适用于，参与方之间的数据特征重叠少，样本重叠也少。</li></ul><p>这三种类型的联邦学习的学习过程不太相同，这里不做详细描述。</p><h2 id="联邦学习框架"><a href="#联邦学习框架" class="headerlink" title="联邦学习框架"></a>联邦学习框架</h2><p>据了解，联邦学习框架有Fate、PySyft、FedLab、Rosetta、PaddleFL等等。具体可参见<a href="https://zhuanlan.zhihu.com/p/387101962">联邦学习开源框架调研</a></p><p>不同框架的受众定位、加密手段、支持的算法、开发的机构不同。下面是对比图。图片来源于Fate官网。</p><p>这张图时间比较久了，具体还是要看最新版本。</p><p><img src="image-20220907160332-fp0kf9k.png" alt="image.png"></p><p>‍</p><h1 id="Fate介绍"><a href="#Fate介绍" class="headerlink" title="Fate介绍"></a>Fate介绍</h1><p>FATE (Federated AI Technology Enabler) 是微众银行AI部门发起的开源项目，为联邦学习生态系统提供了可靠的安全计算框架。FATE项目使用多方安全计算 (MPC) 以及同态加密 (HE) 技术构建底层安全计算协议，以此支持不同种类的机器学习的安全计算，包括逻辑回归、基于树的算法、深度学习和迁移学习等。</p><h2 id="Fate架构"><a href="#Fate架构" class="headerlink" title="Fate架构"></a>Fate架构</h2><p><img src="image-20220907151347-1sl8y67.png" alt="image.png"></p><p>其中，</p><ul><li>FATE Board：联邦学习可视化界面。</li><li>FATE Flow：联邦学习端到端全流程的多方联合任务安全调度平台，提供生产级的服务能力。</li><li>FATE Serving：在线模型管理服务（只支持纵向联邦学习）</li><li>FederatedML：联邦学习的核心组件</li><li>Secure Protocols：FATE的安全协议</li></ul><h2 id="FATE核心功能"><a href="#FATE核心功能" class="headerlink" title="FATE核心功能"></a>FATE核心功能</h2><ul><li>联邦在线模型服务（FATE Serving）</li><li>联邦建模Pipline和可视化（FATE Flow）</li><li>联邦学习算法的各个功能组件（FederatedML）</li><li>分布式计算和存储抽象（EggRoll）</li><li>跨站点网络通信抽象（Federated Network）</li></ul><h2 id="更多介绍"><a href="#更多介绍" class="headerlink" title="更多介绍"></a>更多介绍</h2><p>FATE github地址：<a href="https://github.com/FederatedAI/FATE">https://github.com/FederatedAI/FATE</a></p><h2 id="单机版FATE安装"><a href="#单机版FATE安装" class="headerlink" title="单机版FATE安装"></a>单机版FATE安装</h2><p>这里采用docker安装</p><p><a href="https://github.com/FederatedAI/FATE/blob/master/deploy/standalone-deploy/README.zh.md">部署文档</a></p><p>如果需要docker使用GPU资源，需要在docker容器启动时加上参数<code>--gpus</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d --gpus all --name standalone_fate -p 8080:8080 federatedai/standalone_fate:1.9.0</span><br></pre></td></tr></table></figure><p>如果启动报类似错误：<code>Error could not select device driver with capabilities: [[gpu]]</code>，则查看下面的链接进行解决。</p><p><a href="https://developer.aliyun.com/article/767168">Centos7安装nvidia-container-toolkit</a></p><p>安装完成后，进入容器，要先执行命令：<code>source bin/init_env.sh</code></p><p>FATE Board 默认用户名密码：admin/admin</p><p>想要修改用户名和密码</p><p><code>/data/projects/fate/fateboard/conf/application.properties</code></p><h2 id="集群版"><a href="#集群版" class="headerlink" title="集群版"></a>集群版</h2><p>集群可以使用docker-compose或者kube安装，这里不做介绍。</p><p>集群版会加入eggroll、mysql之类的组件，其开放的端口如下：</p><p><img src="C:/Users/11599/Desktop/FATE联邦学习框架/FATE联邦学习框架/assets/image-20220923161817-1viqwi3.png" alt="image.png"></p><p>9380端口是FATE flow调用api的接口，有哪些接口可以参看下面的链接。</p><p><a href="https://federatedai.github.io/FATE-Flow/latest/zh/swagger/">https://federatedai.github.io/FATE-Flow/latest/zh/swagger/</a></p><p>集群安装后，每个节点应该有以下docker容器</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fate@vm172-31-0-217:~$ docker ps </span><br><span class="line">CONTAINER ID   IMAGE                                   COMMAND                  CREATED       STATUS                PORTS                                            NAMES</span><br><span class="line">f2ab95400e3f   federatedai/client:1.9.0-release        <span class="string">&quot;/bin/sh -c &#x27;flow in…&quot;</span>   2 weeks ago   Up 7 days             0.0.0.0:20000-&gt;20000/tcp                         confs-10000-client-1</span><br><span class="line">f24fac183cbe   federatedai/fateboard:1.9.0-release     <span class="string">&quot;/bin/sh -c &#x27;java -D…&quot;</span>   2 weeks ago   Up 7 days             0.0.0.0:6080-&gt;6080/tcp, 8080/tcp                 confs-10000-fateboard-1</span><br><span class="line">33ca56f46fe3   federatedai/fateflow-nn:1.9.0-release   <span class="string">&quot;/bin/bash -c &#x27;set -…&quot;</span>   2 weeks ago   Up 7 days (healthy)   0.0.0.0:9360-&gt;9360/tcp, 0.0.0.0:9380-&gt;9380/tcp   confs-10000-fateflow-1</span><br><span class="line">4dbb83db37cc   mysql:8.0.28                            <span class="string">&quot;docker-entrypoint.s…&quot;</span>   2 weeks ago   Up 7 days             3306/tcp, 33060/tcp                              confs-10000-mysql-1</span><br><span class="line">7e4567d52d9d   federatedai/eggroll-nn:1.9.0-release    <span class="string">&quot;/tini -- bash -c &#x27;j…&quot;</span>   2 weeks ago   Up 7 days             0.0.0.0:9370-&gt;9370/tcp                           confs-10000-rollsite-1</span><br><span class="line">10f118347296   federatedai/eggroll-nn:1.9.0-release    <span class="string">&quot;/tini -- bash -c &#x27;j…&quot;</span>   2 weeks ago   Up 7 days             4670/tcp                                         confs-10000-clustermanager-1</span><br><span class="line">7ceafb32bfd9   federatedai/eggroll-nn:1.9.0-release    <span class="string">&quot;/tini -- bash -c &#x27;j…&quot;</span>   2 weeks ago   Up 7 days             4671/tcp   </span><br></pre></td></tr></table></figure><p>集群开放的端口：</p><div class="table-container"><table><thead><tr><th>port</th><th>service</th></tr></thead><tbody><tr><td>6080</td><td>fate-board</td></tr><tr><td>8350</td><td>serving</td></tr><tr><td>20000</td><td>jupyter</td></tr><tr><td>9370</td><td>rollsite</td></tr><tr><td>9380</td><td>flow api</td></tr></tbody></table></div><p>这里我们使用了四个节点，分别是FATE9997-10000，其中FATE10000为arbiter用于将梯度聚合和分发，其余为guest/host，是参与联邦学习的各方。</p><h2 id="Toy-Test"><a href="#Toy-Test" class="headerlink" title="Toy Test"></a>Toy Test</h2><p>安装完成后可以进行简单测试，以检查安装是否成功。10000是各个参与方的partyid</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">flow test toy -gid 10000 -hid 10000</span><br></pre></td></tr></table></figure><h1 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h1><ol><li><a href="https://zhuanlan.zhihu.com/p/79284686">详解联邦学习Federated Learning</a></li></ol><p>‍</p>]]></content>
      
      
      <categories>
          
          <category> 联邦学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 联邦学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FATE联邦学习框架（共八篇）</title>
      <link href="/2022/11/03/FATE%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6%EF%BC%88%E5%85%B1%E5%85%AB%E7%AF%87%EF%BC%89/"/>
      <url>/2022/11/03/FATE%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6%EF%BC%88%E5%85%B1%E5%85%AB%E7%AF%87%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ol><li>FATE联邦学习框架简介：联邦学习+fate介绍+单机版docker安装+toy test</li><li>FATE横向联邦学习：信用数据案例</li><li>FATE DSL配置文件详细解释</li><li>FATE横向联邦学习：手写数字识别（开发组件：自定义的模型、使用gpu、模型评估？）</li><li>FATE横向联邦学习：肠癌图像分类任务（上）——baseline</li><li>FATE横向联邦学习：肠癌图像分类任务（下）——联邦化</li><li>FATE横向联邦学习：肺炎的多模态任务的联邦学习</li><li>FATE使用遇到的问题汇总</li></ol><h1 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h1><p><a href="https://github.com/guoyujian/FATE">https://github.com/guoyujian/FATE</a></p>]]></content>
      
      
      <categories>
          
          <category> 联邦学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 联邦学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP缓存</title>
      <link href="/2022/09/24/HTTP%E7%BC%93%E5%AD%98/"/>
      <url>/2022/09/24/HTTP%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h1 id="前端缓存知识点"><a href="#前端缓存知识点" class="headerlink" title="前端缓存知识点"></a>前端缓存知识点</h1><p><img src="前端缓存一览.png" alt="前端缓存一览">​</p><h1 id="什么是HTTP缓存"><a href="#什么是HTTP缓存" class="headerlink" title="什么是HTTP缓存"></a>什么是HTTP缓存</h1><p>http缓存指的是: 当客户端向服务器请求资源时，会先抵达浏览器缓存，如果浏览器有“要请求资源”的副本，就可以直接从浏览器缓存中提取而不是从原始服务器中提取这个资源。</p><p>常见的http缓存只能缓存get请求响应的资源，对于其他类型的响应则无能为力，所以后续说的请求缓存都是指GET请求。</p><p>http缓存都是从第二次请求开始的。第一次请求资源时，服务器返回资源，并在respone header头中回传资源的缓存参数；第二次请求时，浏览器判断这些请求参数，命中强缓存就直接200，否则就把请求参数加到request header头中传给服务器，看是否命中协商缓存，命中则返回304，否则服务器会返回新的资源。</p><h1 id="为什么要使用HTTP缓存-？"><a href="#为什么要使用HTTP缓存-？" class="headerlink" title="为什么要使用HTTP缓存 ？"></a>为什么要使用HTTP缓存 ？</h1><ol><li>减少了冗余的数据传输，节省了网费。</li><li>缓解了服务器的压力， 大大提高了网站的性能</li><li>加快了客户端加载网页的速度</li></ol><h1 id="如何使用HTTP缓存-？"><a href="#如何使用HTTP缓存-？" class="headerlink" title="如何使用HTTP缓存 ？"></a>如何使用HTTP缓存 ？</h1><p>一般需要缓存的资源有html页面和其他静态资源：</p><blockquote><p>1、 <strong>html页面缓存的设置主要是在<code>&lt;head&gt;</code>标签中嵌入<code>&lt;meta&gt;</code>标签，这种方式只对页面有效，对页面上的资源无效</strong></p></blockquote><p>1.1 html页面禁用缓存的设置如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;cache-control&quot; content=&quot;no-cache&quot; \&gt;</span><br></pre></td></tr></table></figure><p>1.2 html设置缓存如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;max-age=7200&quot; /&gt;</span><br></pre></td></tr></table></figure><blockquote><p>2、 <strong>静态资源的缓存一般是在web服务器上配置的，常用的web服务器有：nginx、apache。具体的配置这里不做详细介绍，大家自行查阅。</strong></p><p><strong>3、不想使用缓存的几种方式</strong></p></blockquote><ul><li>Ctrl + F5强制刷新，都会直接向服务器提取数据。</li><li>按F5刷新或浏览器的刷新按钮，默认加上Cache-Control：max-age=0，即会走协商缓存。</li><li>还有就是上面1、2中禁用缓存的做法</li></ul><h1 id="HTTP缓存的几个注意点"><a href="#HTTP缓存的几个注意点" class="headerlink" title="HTTP缓存的几个注意点"></a>HTTP缓存的几个注意点</h1><p>1、强缓存情况下，只要缓存还没过期，就会直接从缓存中取数据，就算服务器端有数据变化，也不会从服务器端获取了，这样就无法获取到修改后的数据。解决的办法有：在修改后的资源加上随机数，确保不会从缓存中取。</p><p>例如：<code>http://www.kimshare.club/kim/common.css?v=22324432</code></p><p>2、尽量减少304的请求，因为我们知道，协商缓存每次都会与后台服务器进行交互，所以性能上不是很好。从性能上来看尽量多使用强缓存。</p><p>3、与缓存相关的几个header属性有：Vary、Date/Age。</p><h1 id="HTTP缓存的分类"><a href="#HTTP缓存的分类" class="headerlink" title="HTTP缓存的分类"></a><strong>HTTP缓存的分类</strong></h1><ul><li>根据是否需要重新向服务器发起请求来分类，可分为强制缓存，协商缓存</li><li>根据是否可以被单个或者多个用户使用来分类，可分为私有缓存，共享缓存（不care）</li></ul><p>强制缓存如果生效，不需要再和服务器发生交互，而协商缓存不管是否生效，都需要与服务端发生交互。下面是强制缓存和协商缓存的一些对比：</p><p><img src="HTTP缓存分类.png" alt="HTTP缓存分类"></p><h2 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h2><p>强制缓存在缓存数据未失效的情况下（即Cache-Control的max-age没有过期或者Expires的缓存时间没有过期），那么就会直接使用浏览器的缓存数据，不会再向服务器发送任何请求。</p><p>强制缓存生效时，http状态码为200。这种方式页面的加载速度是最快的，性能也是很好的，但是在这期间，如果服务器端的资源修改了，页面上是拿不到的，因为它不会再向服务器发请求了。</p><p>这种情况就是我们在开发种经常遇到的，比如你修改了页面上的某个样式，在页面上刷新了但没有生效，因为走的是强缓存，所以Ctrl + F5一顿操作之后就好了。 </p><p>跟强制缓存相关的header头属性有（Pragma/Cache-Control/Expires）</p><h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p>当第一次请求时服务器返回的响应头中没有Cache-Control和Expires或者Cache-Control和Expires过期还或者它的属性设置为no-cache时(即不走强缓存)，那么浏览器第二次请求时就会与服务器进行协商，与服务器端对比判断资源是否进行了修改更新。</p><p>如果服务器端的资源没有修改，那么就会返回304状态码，告诉浏览器可以使用缓存中的数据，这样就减少了服务器的数据传输压力。</p><p>如果数据有更新就会返回200状态码，服务器就会返回更新后的资源并且将缓存信息一起返回。</p><p>跟协商缓存相关的header头属性有（ETag/If-Not-Match 、Last-Modified/If-Modified-Since）请求头和响应头需要成对出现。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>下图是浏览器首次和再次发送http请求的执行流程图：</strong></p><p><img src="首次HTTP请求.png" alt="首次HTTP请求"></p><p><img src="再次HTTP请求.png" alt="再次HTTP请求"></p><h1 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h1><ol><li><a href="https://www.jianshu.com/p/227cee9c8d15">https://www.jianshu.com/p/227cee9c8d15</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> HTTP协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> HTTP协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTPS协议</title>
      <link href="/2022/09/24/HTTPS%E5%8D%8F%E8%AE%AE/"/>
      <url>/2022/09/24/HTTPS%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><p>加密分为对称加密和非对称加密，HTTPS兼顾两者。</p><p>关于非对称加密，可以查阅相关资料。这里只提一点：</p><blockquote><p><strong>公钥加密，私钥解密！</strong></p></blockquote><h1 id="为什么需要HTTPS"><a href="#为什么需要HTTPS" class="headerlink" title="为什么需要HTTPS"></a>为什么需要HTTPS</h1><p>HTTP 主要有这些不足：</p><ul><li>通信使用明文（不加密），内容可能会被窃听；</li><li>不验证通信方的身份，因此有可能遭遇伪装；</li><li>无法证明报文的完整性，所以有可能已遭篡改；</li></ul><p>为了解决这些问题，HTTPS顺应而生。</p><h1 id="HTTPS介绍"><a href="#HTTPS介绍" class="headerlink" title="HTTPS介绍"></a>HTTPS介绍</h1><p><strong>HTTP+ 加密 + 认证 + 完整性保护=HTTPS</strong>。</p><p>可以这么理解，HTTPS是安全版的HTTP，它不是一个新的协议，而是HTTP 加上加密处理（解决HTTP通信使用明文的问题）和认证（解决HTTP不验证通信方的身份问题）以及完整性保护（解决HTTP无法证明报文完整性的问题）后的东西。</p><p><strong>端口：443</strong></p><p><img src="HTTP和HTTPS对比.png" alt="HTTP和HTTPS对比"></p><p>注：上图并不代表顺序。也就是说<strong>HTTPS是先建立TCP连接，再进行TLS/SSL握手。</strong></p><h1 id="HTTPS通信"><a href="#HTTPS通信" class="headerlink" title="HTTPS通信"></a>HTTPS通信</h1><p>直接上图</p><p><img src="HTTPS通信.png" alt="HTTPS通信">​</p><p>上图基本把HTTPS的通信流程说的非常清晰了，补充两点：</p><ol><li>这里对比HASH是为了防止握手消息被篡改。浏览器与网站互相发送加密的握手消息并验证，目的是为了保证双方都获得了一致的密码，并且可以正常的加密解密数据，为后续真正数据的传输做一次测试。</li><li>因为对称加密要比非对称加密的计算快很多，所以HTTPS没有全程使用非对称加密，而是先使用非对称加密交换对称密钥，再使用对称加密手段通信。</li><li>证书确保了双方身份。</li></ol><p>另外，HTTPS一般使用的加密与HASH算法如下：</p><ul><li>非对称加密算法：RSA，DSA/DSS</li><li>对称加密算法：AES，RC4，3DES</li><li>HASH算法：MD5，SHA1，SHA256</li></ul><h1 id="HTTPS-的优缺点"><a href="#HTTPS-的优缺点" class="headerlink" title="HTTPS 的优缺点?"></a>HTTPS 的优缺点?</h1><p>优点</p><ul><li><p>安全性：</p><ul><li>使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；</li><li>HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。</li><li>HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</li></ul></li><li>SEO方面：谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。</li></ul><p>缺点</p><ul><li>在相同网络环境中，HTTPS 相比 HTTP 无论是响应时间还是耗电量都有大幅度上升。</li><li>HTTPS 的安全是有范围的，在黑客攻击、服务器劫持等情况下几乎起不到作用。</li><li>在现有的证书机制下，中间人攻击依然有可能发生。</li><li>HTTPS 需要更多的服务器资源，也会导致成本的升高。</li></ul><h1 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h1><ol><li><a href="https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html">SSL/TLS协议运行机制的概述</a></li><li><a href="https://www.cnblogs.com/zery/p/5164795.html">HTTPS 原理解析</a></li><li><a href="https://cloud.tencent.com/developer/article/1007810?from=article.detail.1017988">HTTPS 建立连接的详细过程</a></li><li><a href="https://juejin.cn/post/6906126429381984264">HTTPS连接过程</a></li><li><a href="https://zhuanlan.zhihu.com/p/45390160">HTTPS详细介绍</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> HTTP协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> HTTP协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP面试题</title>
      <link href="/2022/09/24/HTTP%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2022/09/24/HTTP%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<blockquote><p>作为复习，也作为一个目录</p></blockquote><h1 id="说一下HTTP协议"><a href="#说一下HTTP协议" class="headerlink" title="说一下HTTP协议"></a>说一下HTTP协议</h1><p>HTTP全称是Hyper Text Transfer Protocol。即<strong>超文本传输协议</strong>，它是以<strong>TCP/IP</strong>为基础来传输HTML，文件，图片等。 它本身处于<strong>应用层</strong>，<strong>端口号80</strong>。</p><ol><li>HTTP是基于<strong>浏览器/服务器</strong>架构；</li><li>HTTP是<strong>无状态</strong>协议：HTTP本身并不保存用户的任何信息，也不会对传输的数据，状态信息进行持久化；</li><li>HTTP是<strong>无连接</strong>协议：每次连接只处理一个请求，服务器处理完用户请求，即断开连接，借此节约传输时间。</li></ol><h1 id="HTTP通信过程"><a href="#HTTP通信过程" class="headerlink" title="HTTP通信过程"></a>HTTP通信过程</h1><ol><li>用户输入网址</li><li>DNS服务器解析域名</li><li>浏览器和服务器建立TCP连接</li><li>浏览器向服务器发送请求行</li><li>浏览器向服务器发送请求头，并以空行代表发送结束，如果请求类型为<code>post</code>，则继续发送请求体</li><li>服务器应答协议版本号和应答状态码</li><li>服务器发送响应头，并以空行代表发送结束</li><li>服务器发送数据：以<code>Content-Type</code>给出的格式发送用户所请求的信息</li><li>服务器关闭TCP连接：如果浏览器或者服务器的头信息中加入了这样一段代码：<code>connection：Keep-alive</code> 则TCP连接会保持打开状态</li><li>客户端浏览器解析HTML内容</li></ol><p>下图整理了HTTP通信的关键步骤：</p><p><img src="http通信过程.png" alt="计算机网络-http通信过程">​</p><h1 id="说一下HTTPS协议"><a href="#说一下HTTPS协议" class="headerlink" title="说一下HTTPS协议"></a>说一下HTTPS协议</h1><p>可以看我的博客：《HTTPS协议》</p><h1 id="HTTP与HTTPS的对比"><a href="#HTTP与HTTPS的对比" class="headerlink" title="HTTP与HTTPS的对比"></a>HTTP与HTTPS的对比</h1><ul><li>两者工作的端口号不同：HTTP工作在80，HTTPS工作在443；</li><li>HTTPS需要用到CA（数字证书认证机构）申请证书，一般需要一定费用；</li><li>HTTP响应比HTTPS快，主要因为HTTPS除了TCP3次握手外还要加上<strong>SSL9次握手</strong>共12次握手；</li><li>HTTPS是构建在SSL/TLS上的HTTP协议，因此需要占用服务器资源。</li></ul><h1 id="HTTP缓存​"><a href="#HTTP缓存​" class="headerlink" title="HTTP缓存​"></a>HTTP缓存​</h1><p>http缓存指的是: 当客户端向服务器请求资源时，会先抵达<strong>浏览器缓存</strong>，如果浏览器有“要请求资源”的副本，就可以<strong>直接从浏览器缓存中提取</strong>而不是从原始服务器中提取这个资源。</p><p>常见的http缓存<strong>只能缓存get请求</strong>响应的资源，对于其他类型的响应则无能为力，所以后续说的请求缓存都是指GET请求。<br>http缓存都是从第二次请求开始的。第一次请求资源时，服务器返回资源，并在respone header头中回传资源的缓存参数；第二次请求时，浏览器判断这些请求参数，命中强缓存就直接200，否则就把请求参数加到request header头中传给服务器，看是否命中协商缓存，命中则返回304，否则服务器会返回新的资源。（可以画个图理解一下）</p><p>HTTP 缓存又分为<strong>强缓存</strong>和 <strong>协商缓存</strong> ：</p><p><strong>强制缓存</strong>：在缓存数据未失效的情况下（即Cache-Control的max-age没有过期或者Expires的缓存时间没有过期），那么就会直接使用浏览器的缓存数据，不会再向服务器发送任何请求。</p><p><strong>协商缓存</strong>：当第一次请求时服务器返回的响应头中没有Cache-Control和Expires或者Cache-Control和Expires过期还或者它的属性设置为no-cache时(即不走强缓存)，那么浏览器第二次请求时就会与服务器进行 <strong>协商</strong>，与服务器端对比判断资源是否进行了修改更新。如果服务器端的资源没有修改，那么就会返回304状态码，告诉浏览器可以使用缓存中的数据，这样就减少了服务器的数据传输压力。如果数据有更新就会返回200状态码，服务器就会返回更新后的资源并且将缓存信息一起返回。</p><h1 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h1><ul><li>1xx：<strong>目前是协议的中间状态，还需要后续请求。</strong><ul><li>101 切换请求协议，从 HTTP 切换到 WebSocket</li></ul></li><li>2xx：<strong>表示请求成功。</strong><ul><li>200 请求成功，有响应体</li></ul></li><li><p>3xx：<strong>表示重定向状态，需要重新请求。</strong></p><ul><li>301 永久重定向：会缓存</li><li>302 临时重定向：不会缓存</li><li>304 协商缓存命中</li></ul></li><li><p>4xx：<strong>请求报文错误。</strong></p><ul><li>403 服务器禁止访问</li><li>404 资源未找到</li><li>400 请求错误</li></ul></li><li><p>5xx：<strong>服务器错误。</strong></p><ul><li>500 服务器端错误</li><li>503 服务器繁忙</li></ul></li></ul><h1 id="一个典型的HTTP请求报文包括哪些部分？响应报文呢？"><a href="#一个典型的HTTP请求报文包括哪些部分？响应报文呢？" class="headerlink" title="一个典型的HTTP请求报文包括哪些部分？响应报文呢？"></a>一个典型的HTTP请求报文包括哪些部分？响应报文呢？</h1><p>一个HTTP请求报文包括：  <strong>请求头，请求行，空行，请求体</strong>。</p><p>一个响应报文包括： <strong>响应行，响应头，空行，响应体</strong> 。</p><p>具体参考我的博客《详解HTTP协议》</p><h1 id="HTTP1-0、HTTP1-1、HTTP2-0区别"><a href="#HTTP1-0、HTTP1-1、HTTP2-0区别" class="headerlink" title="HTTP1.0、HTTP1.1、HTTP2.0区别"></a>HTTP1.0、HTTP1.1、HTTP2.0区别</h1><h2 id="HTTP1-0和HTTP1-1的区别-长短连接的区别"><a href="#HTTP1-0和HTTP1-1的区别-长短连接的区别" class="headerlink" title="HTTP1.0和HTTP1.1的区别/长短连接的区别"></a>HTTP1.0和HTTP1.1的区别/长短连接的区别</h2><p>这里主要回答长短连接的区别就行吧。。</p><p>在HTTP/1.0中采用短连接。客户端和服务器每进行一次HTTP操作，就建立一次连接，任务中断连接；Connection: close</p><p>在HTTP/1.1默认采用长连接和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。Connection: keep-alive，就是保持连接。</p><hr><p>长连接适用的场景：长连接适用于操作频繁/点对点通讯等连接数不太多的情况，如：一些游戏/即时通讯场景应该使用长连接；</p><p>短连接适用的场景： 短连接适用于大量连接的场景，如Web【wapWeb/H5等】的http服务，长连接对于服务端来说会耗费一定资源。</p><blockquote><p>补充其他区别：</p><ul><li>长短连接</li><li><strong>缓存处理</strong>：在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略，可供选择的缓存头来控制缓存策略。</li><li><strong>带宽优化及网络连接的使用</strong>：HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li><li><strong>错误通知的管理</strong>：在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li><li><strong>Host头处理</strong>：在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。</li></ul></blockquote><h2 id="HTTP1和HTTP2的区别"><a href="#HTTP1和HTTP2的区别" class="headerlink" title="HTTP1和HTTP2的区别"></a>HTTP1和HTTP2的区别</h2><p>HTTP2.0是第二代TCP协议。它与HTTP1.1的不同点在于：</p><ul><li>HTTP2采用<strong>二进制</strong>而非文本格式；此属性减轻了框架的复杂性，并简化了由于包含文本和可选空格的命令而导致混淆的命令的实现。</li><li>HTTP2是 <strong>完全多路复用</strong> ，而线端阻塞的——只需一个连接可以实现并行；</li><li>HTTP2使用<strong>标头（headers）压缩</strong> ，减小了开销；</li><li>HTTP2让服务器可以将响应主动推送到客户端缓存中。</li></ul><p>名词解释：</p><blockquote><p>线端阻塞和多路复用</p><p>HTTP/1.x 有个问题叫线端阻塞(head-of-line blocking), 它是指<strong>一个连接(connection)一次只提交一个请求的效率比较高, 多了就会变慢</strong>。 HTTP/1.1 试过用流水线(pipelining)来解决这个问题, 但是效果并不理想(数据量较大或者速度较慢的响应, 会阻碍排在他后面的请求)。</p><p>多路传输(Multiplexing)能很好的解决这些问题, 因为它能同时处理多个消息的请求和响应; 甚至可以在传输过程中将一个消息跟另外一个掺杂在一起。所以<strong>客户端只需要一个连接</strong>就能加载一个页面。减少额外的往返时间。</p><p><img src="http1和2建立连接.png" alt="http1和2建立连接"></p><p>主动推送：通俗理解就是客户端请求了html，服务器觉得和其相关的css也会被关联到，于是主动同送其他资源到客户端。</p></blockquote><h1 id="GET、POST区别"><a href="#GET、POST区别" class="headerlink" title="GET、POST区别"></a>GET、POST区别</h1><p>具体看我的博客《详解HTTP协议》和《HTTP协议幂等性》</p><p><img src="get和post区别.png" alt="get和post区别"></p><p>‍</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> HTTP协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> HTTP协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用腾讯会议的屏幕共享功能时开启PPT演示者视图的方法</title>
      <link href="/2022/09/11/%E4%BD%BF%E7%94%A8%E8%85%BE%E8%AE%AF%E4%BC%9A%E8%AE%AE%E7%9A%84%E5%B1%8F%E5%B9%95%E5%85%B1%E4%BA%AB%E5%8A%9F%E8%83%BD%E6%97%B6%E5%BC%80%E5%90%AFPPT%E6%BC%94%E7%A4%BA%E8%80%85%E8%A7%86%E5%9B%BE%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2022/09/11/%E4%BD%BF%E7%94%A8%E8%85%BE%E8%AE%AF%E4%BC%9A%E8%AE%AE%E7%9A%84%E5%B1%8F%E5%B9%95%E5%85%B1%E4%BA%AB%E5%8A%9F%E8%83%BD%E6%97%B6%E5%BC%80%E5%90%AFPPT%E6%BC%94%E7%A4%BA%E8%80%85%E8%A7%86%E5%9B%BE%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><a href="https://meeting.tencent.com/support-doc-detail/79/index.html">https://meeting.tencent.com/support-doc-detail/79/index.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具箱 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 腾讯会议 </tag>
            
            <tag> ppt </tag>
            
            <tag> 演示者视图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown公式编辑语法</title>
      <link href="/2022/09/11/markdown%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91%E8%AF%AD%E6%B3%95/"/>
      <url>/2022/09/11/markdown%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>下面两个连接给出的公式语法涵盖了大部分的内容，第一个是官方连接。</p><ol><li><a href="https://katex.org/docs/supported.html">Supported Functions</a></li><li><a href="https://blog.csdn.net/weixin_42782150/article/details/104878759">史上最全Markdown公式、符号总结！！！</a></li></ol><p>另外推荐一款公式生成软件</p><blockquote><p><strong>mathpix snipping tool</strong></p></blockquote><p>通过截图生成公式code，可以直接复制公式代码，也可以直接复制到word等。</p>]]></content>
      
      
      <categories>
          
          <category> 工具箱 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
            <tag> typora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【不经意传输】算法介绍</title>
      <link href="/2022/09/11/%E3%80%90%E4%B8%8D%E7%BB%8F%E6%84%8F%E4%BC%A0%E8%BE%93%E3%80%91%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/"/>
      <url>/2022/09/11/%E3%80%90%E4%B8%8D%E7%BB%8F%E6%84%8F%E4%BC%A0%E8%BE%93%E3%80%91%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>“不经意传输”要解决这类问题：你需要给对方多条信息，但是你又必须确保对方只获得其中一条，但是对方又希望能够确保你不知道他看到哪一条信息。</p><p>设计一个具体场景：你给你的哥们介绍相亲女朋友，你有两个可供介绍的单身女性，但是你不想同时将两人的情况和联系方式给对方。但你也无法抉择到底给哪个，所以你想让他随机抽签选择一个。但与此同时，你的哥们也不想让你知道，他最终抽到了谁。</p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p><strong>不经意传输</strong>（Oblivious Transfer，简称OT）是一个密码学协议，在这个协议中，消息发送者从一些待发送的消息中发送一条给接收者，但事后对发送了哪一条消息仍然oblivious（不知道），这个协议也叫茫然传输协议。</p><p>不经意传输是密码学中的一个基本而重要的问题，被认为是该领域的关键问题之一，对于<strong>安全多方计算</strong>来说是完整的实现。</p><p>例如下图，Alice是消息发送者，Bob是消息接受者。Alice想要将消息$M_0$、$M_1$之一传给Bob，Bob只能得到自己想要的那个（$M_0$或$M_1$）不能获取另外一个消息，Alice也不能知道Bob选的是哪一条消息。</p><p><img src="不经意传输1.png" alt="不经意传输1"></p><h1 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h1><p>第一种形式的不经意传输，最初是在1981由Michael O.Rabin提出，在这种不经意传输中，发送者Alice发送一条消息给接收着Bob，而Bob以1/2的概率接收到信息，在结束后Alice并不知道Bob是否接收到了信息，而Bob能确信地知道自己是否收到了信息。</p><p>另一种更实用的不经意传输协议，被称为2选一不经意传输（1 out 2 oblivious transfer）由 Shimon Even，Oded Goldreich和Abraham Lempel在1985年提出，在这种形式的不经意传输模型中，Alice每次发两条信息（m1、m2）给Bob，<strong>Bob提供一个输入</strong>，并根据输入获得输出信息，在协议结束后，Bob得到了自己想要的那条信息（m1或者m2），而Alice并不知道Bob最终得到的是哪条。</p><blockquote><p>这个输入，我的理解是通知发送者发哪些消息，发送消息的范围</p></blockquote><p>1986年，Brassard等人将2选1不经意传输拓展为n选1。</p><p><img src="不经意传输2.png" alt="不经意传输2"></p><p>不经意传输一种实现方式是<strong>基于RSA公钥算法</strong>，下面就2选1不经意传输的实现做简要介绍。</p><h1 id="基于RSA公钥算法的2选1不经意传输"><a href="#基于RSA公钥算法的2选1不经意传输" class="headerlink" title="基于RSA公钥算法的2选1不经意传输"></a>基于RSA公钥算法的2选1不经意传输</h1><p>先把「基于RSA公钥算法的2选1不经意传输」的流程图列出来：</p><p><img src="不经意传输流程.png" alt="不经意传输流程"></p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ol><li>发送者Alice生成两对RSA公私钥$(puk0, pri0)$，$(puk1, pri1)$，并将两个公钥$puk0$和$puk1$发送给Bob。</li><li>Bob生成一个随机数$r$，并用收到的两个公钥之一加密随机数，$c=Encrypt(r)$。（用哪个秘钥取决于想获取哪条数据，例如如果想要得到消息$M_0$就用$puk0$加密随机数，如果想要得到$M_1$就用$puk1$加密随机数），并将密文结果发送给Alice。</li><li>Alice用自己的两个私钥分别解密收到随机数密文，得到两个解密结果：$k_0=Decrypt(c, pri_0)$，$k_1=Decrypt(c, pri_1)$。（$k_0$，$k_1$其中一个就是随机数$r$）。并将两个结果分别与两条信息进行异或，生成掩码消息：$e_0=k_0\bigoplus m_0$，$e_1=k_1\bigoplus m_1$，并将两个结果$e_0$，$e_1$发给Bob。</li><li>Bob用之前生成的随机数$r$与收到的$e_0$，$e_1$分别做异或操作，得到的两个结果中只有一条为真实数据，另外一条为随机数：$m^{‘}_0=e_0\bigoplus r$，$m^{‘}_1=e_1\bigoplus r$。</li><li>Bob在步骤2中，如果使用$puk0$加密，得到的$m^{‘}_0=m_0$，反之是$m_1$。</li></ol><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>在此过程中第3步最为关键，如果Alice无法从用两条私钥解密得到的结果$k_0$、$k_1$中区分出Bob的真实随机数，则能保证Alice无法得知Bob将要获取的是哪条数据。Bob没有私钥也就无法得出真实的私钥解密结果（如果$k_0$为真实随机数，Bob无法得知$k_1$的值），所以也就只能得到自己想要的那条数据而无法得到另外一条，保障协议能执行成功。</p><h1 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h1><ol><li><a href="https://learnblockchain.cn/article/2022">区块链中的数学 - 不经意传输</a></li><li><a href="https://zhuanlan.zhihu.com/p/208295083">什么是不经意传输</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RSA加密算法</title>
      <link href="/2022/08/28/RSA%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
      <url>/2022/08/28/RSA%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="对称加密与非对称加密"><a href="#对称加密与非对称加密" class="headerlink" title="对称加密与非对称加密"></a>对称加密与非对称加密</h1><p>使用相同的规则（秘钥）进行加密解密的算法成为“<strong>对称加密算法</strong>”，这种加密模式有一个最大弱点：甲方必须把加密规则告诉乙方，否则无法解密。保存和传递密钥，就成了最头疼的问题。</p><p>1976年，两位美国计算机学家Whitfield Diffie 和 Martin Hellman，提出了一种崭新构思，可以在不直接传递密钥的情况下，完成解密。这被称为<a href="https://en.wikipedia.org/wiki/Diffie–Hellman_key_exchange">“Diffie-Hellman密钥交换算法”</a>。这个算法启发了其他科学家。人们认识到，加密和解密可以使用不同的规则，只要这两种规则之间存在某种对应关系即可，这样就避免了直接传递密钥。</p><p>这种新的加密模式被称为”非对称加密算法”。</p><blockquote><p>（1）乙方生成两把密钥（公钥和私钥）。公钥是公开的，任何人都可以获得，私钥则是保密的。</p><p>（2）甲方获取乙方的公钥，然后用它对信息加密。</p><p>（3）乙方得到加密后的信息，用私钥解密。</p></blockquote><p>如果公钥加密的信息只有私钥解得开，那么只要私钥不泄漏，通信就是安全的。</p><blockquote><p> 我的理解：RSA加密算法就是一种非对称加密算法。甲向乙发送消息，乙先生成私钥和公钥，乙把公钥给甲，甲用公钥将信息加密，将加密信息发给乙，乙拿私钥解密。</p></blockquote><p>在介绍RSA算法之前需要先介绍一点数学知识。</p><h1 id="RSA算法的数学基础"><a href="#RSA算法的数学基础" class="headerlink" title="RSA算法的数学基础"></a>RSA算法的数学基础</h1><h2 id="互质关系"><a href="#互质关系" class="headerlink" title="互质关系"></a>互质关系</h2><p>如果两个正整数，除了1以外，没有其他公因子，我们就称这两个数是<a href="https://zh.wikipedia.org/zh-cn/互素">互质关系</a>（coprime）。比如，15和32没有公因子，所以它们是互质关系。这说明，不是质数也可以构成互质关系。</p><p>关于互质关系，不难得到以下结论：</p><blockquote><ol><li>任意两个质数构成互质关系，比如13和61。☆</li><li>一个数是质数，另一个数只要不是前者的倍数，两者就构成互质关系，比如3和10。</li><li>如果两个数之中，较大的那个数是质数，则两者构成互质关系，比如97和57。</li><li>1和任意一个自然数是都是互质关系，比如1和99。</li><li>p是大于1的整数，则p和p-1构成互质关系，比如57和56。</li><li>p是大于1的奇数，则p和p-2构成互质关系，比如17和15。</li></ol></blockquote><h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><p>对于任意给定的正整数n，计算在小于等于n的正整数之中，有多少个与n构成互质关系的方法就叫做<strong>欧拉函数</strong>。以φ(n)表示。在1到8之中，与8形成互质关系的是1、3、5、7，所以 φ(n) = 4。</p><p><strong>第一种情况</strong></p><p>如果n=1，则 φ(1) = 1 。因为1与任何数（包括自身）都构成互质关系。</p><p><strong>第二种情况</strong></p><p>如果n是质数，则 φ(n)=n-1。因为质数与小于它的每一个数，都构成互质关系。比如5与1、2、3、4都构成互质关系。</p><p><strong>第三种情况</strong></p><p>如果n是质数的某一个次方，即$ n = p^k $ （p为质数，k为大于等于1的整数），则</p><script type="math/tex; mode=display">φ(p^k) = p^k - p^{k-1}</script><p>比如 $φ(8) = φ(2^3) = 2^3 - 2^2 = 4$。</p><p>这是因为只有当一个数不包含质数p，才可能与n互质。而包含质数p的数一共有$p^{k-1}$个，即$1×p$、$2×p$、$3×p$、…、$p^{k-1}×p$，把它们去除，剩下的就是与n互质的数。</p><p>上面的式子还可以写成下面的形式：</p><script type="math/tex; mode=display">φ(p^k) = p^k - p^{k-1} = p^k(1-\frac{1}{p})</script><p>可以看出，上面的第二种情况是 k=1 时的特例。</p><p><strong>第四种情况</strong></p><p>如果n可以分解成两个互质的整数之积，$n = p_1 <em> p_2$，则$φ(n) = φ(p_1</em>p_2) = φ(p_1) * φ(p_2)$</p><p>即积的欧拉函数等于欧拉函数的积。比如，$φ(56)=φ(8×7)=φ(8)×φ(7)=4×6=24$。</p><p>这一条的证明要用到<a href="https://en.wikipedia.org/wiki/Chinese_remainder_theorem">“中国剩余定理”</a>，这里就不展开了。</p><p><strong>第五种情况</strong></p><p>因为任意一个大于1的正整数，都可以写成一系列质数的积。</p><script type="math/tex; mode=display">n = p_1^{k_1}p_2^{k_2}…p_r^{k_r}</script><p>根据第4条的结论，得到</p><script type="math/tex; mode=display">φ(n)=φ(p_1^{k_1})φ(p_2^{k_2})…φ(p_r^{k_r})</script><p>再根据第3条的结论，得到</p><script type="math/tex; mode=display">φ(n)=p_1^{k_1}p_2^{k_2}…p_r^{k_r}(1-\frac{1}{p_1})(1-\frac{1}{p_2})…(1-\frac{1}{p_r})</script><p>也就等于</p><script type="math/tex; mode=display">φ(n)=n(1-\frac{1}{p_1})(1-\frac{1}{p_2})…(1-\frac{1}{p_r})</script><p>这就是欧拉函数的通用计算公式。比如，1323的欧拉函数，计算过程如下：</p><script type="math/tex; mode=display">φ(1323)=φ(3^3*7^2)=1323(1-\frac{1}{3})(1-\frac{1}{7})=756</script><h2 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h2><p>欧拉函数的用处，在于<a href="https://zh.wikipedia.org/wiki/欧拉定理_(数论">欧拉定理</a>)。”欧拉定理”指的是：</p><blockquote><p>如果两个正整数a和n互质，则n的欧拉函数 φ(n) 可以让下面的等式成立：</p><script type="math/tex; mode=display">a^{φ(n)}\equiv1 \pmod n</script></blockquote><p>也就是说，a的φ(n)次方被n除的余数为1。或者说，a的φ(n)次方减去1，可以被n整除。比如，3和7互质，而7的欧拉函数φ(7)等于6，所以3的6次方（729）减去1，可以被7整除（728/7=104）。</p><p>欧拉定理的证明比较复杂，这里就省略了。我们只要记住它的结论就行了。</p><p>欧拉定理可以大大简化某些运算。比如，7和10互质，根据欧拉定理，</p><script type="math/tex; mode=display">7^{φ(10)}\equiv1 \pmod {10}</script><p>已知 φ(10) 等于4，所以马上得到7的4倍数次方的个位数肯定是1。</p><script type="math/tex; mode=display">7^{4k}\equiv1 \pmod {10}</script><p>因此，7的任意次方的个位数（例如7的222次方），心算就可以算出来。</p><p>欧拉定理有一个特殊情况。</p><blockquote><p>假设正整数a与质数p互质，因为质数p的φ(p)等于p-1，则欧拉定理可以写成</p><script type="math/tex; mode=display">a^{p-1} \equiv 1 \pmod p</script></blockquote><p>这就是著名的<a href="https://zh.wikipedia.org/wiki/费马小定理">费马小定理</a>。它是欧拉定理的特例。</p><p>欧拉定理是RSA算法的核心。理解了这个定理，就可以理解RSA。</p><h2 id="模反元素"><a href="#模反元素" class="headerlink" title="模反元素"></a>模反元素</h2><p>还剩下最后一个概念：</p><blockquote><p>如果两个正整数a和n互质，那么一定可以找到整数b，使得 ab-1 被n整除，或者说ab被n除的余数是1。</p><script type="math/tex; mode=display">ab \equiv 1 \pmod n</script><p>这时，b就叫做a的<a href="https://zh.wikipedia.org/wiki/模反元素">“模反元素”</a>。</p></blockquote><p>比如，3和11互质，那么3的模反元素就是4，因为 (3 × 4)-1 可以被11整除。显然，模反元素不止一个， 4加减11的整数倍都是3的模反元素 {…,-18,-7,4,15,26,…}，即如果b是a的模反元素，则 b+kn 都是a的模反元素。</p><p>欧拉定理可以用来证明模反元素必然存在。</p><script type="math/tex; mode=display">a^{φ(n)}=a*a^{φ(n)-1} \equiv 1 \pmod n</script><p>可以看到，a的 φ(n)-1 次方，就是a的模反元素。</p><h1 id="RSA算法"><a href="#RSA算法" class="headerlink" title="RSA算法"></a>RSA算法</h1><h2 id="密钥生成的步骤"><a href="#密钥生成的步骤" class="headerlink" title="密钥生成的步骤"></a>密钥生成的步骤</h2><p>我们通过一个例子，来理解RSA算法。假设爱丽丝要与鲍勃进行加密通信，她该怎么生成公钥和私钥呢？</p><p><img src="bg2013070302.png" alt="img"></p><p><strong>第一步，随机选择两个不相等的质数p和q。</strong></p><p>爱丽丝选择了61和53。（实际应用中，这两个质数越大，就越难破解。）</p><p><strong>第二步，计算p和q的乘积n。</strong></p><p>爱丽丝就把61和53相乘。</p><script type="math/tex; mode=display">n = 61*53 = 3233</script><p>n的二进制长度就是密钥长度。3233写成二进制是110010100001，一共有12位，所以这个密钥就是12位。</p><p>实际应用中，RSA密钥一般是1024位，重要场合则为2048位。</p><p><strong>第三步，计算n的欧拉函数φ(n)。</strong></p><p>根据公式：</p><script type="math/tex; mode=display">φ(n) = (p-1)(q-1)</script><p>$φ(3233)=φ(61<em>53)=φ(61)</em>φ（53）=60*52=3120$</p><p><strong>第四步，随机选择一个整数e，条件是1&lt; e &lt; φ(n)，且e与φ(n) 互质。</strong></p><p>爱丽丝就在1到3120之间，随机选择了17。（实际应用中，常常选择65537。）</p><p><strong>第五步，计算e对于φ(n)的模反元素d。</strong></p><p>所谓<a href="https://zh.wikipedia.org/wiki/模反元素">“模反元素”</a>就是指有一个整数d，可以使得ed被φ(n)除的余数为1。</p><script type="math/tex; mode=display">ed \equiv 1 \pmod {φ(n)}</script><p>这个式子等价于</p><script type="math/tex; mode=display">ed - 1 = k φ(n)</script><p>于是，找到模反元素d，实质上就是对下面这个二元一次方程求解。</p><script type="math/tex; mode=display">ed - kφ(n) = 1</script><p>已知 e=17, φ(n)=3120，</p><script type="math/tex; mode=display">17d-3120k=1</script><p>这个方程可以用<a href="https://zh.wikipedia.org/wiki/扩展欧几里得算法">“扩展欧几里得算法”</a>求解，此处省略具体过程。总之，爱丽丝算出一组整数解为 (d, k)=(2753,-15)，即 d=2753。</p><p>至此所有计算完成。</p><p><strong>第六步，将n和e封装成公钥，n和d封装成私钥。</strong></p><p>在爱丽丝的例子中，n=3233，e=17，d=2753，所以公钥就是(n, e) =  (3233,17)，私钥就是(n, d)=(3233, 2753)。</p><h2 id="RSA算法的可靠性"><a href="#RSA算法的可靠性" class="headerlink" title="RSA算法的可靠性"></a>RSA算法的可靠性</h2><p>回顾上面的密钥生成步骤，一共出现六个数字：</p><blockquote><p>p<br>q<br>n<br>φ(n)<br>e<br>d</p></blockquote><p>这六个数字之中，公钥用到了两个（n和e），其余四个数字都是不公开的。其中最关键的是d，因为n和d组成了私钥，一旦d泄漏，就等于私钥泄漏。</p><p><strong>那么，有无可能在已知n和e的情况下，推导出d？</strong></p><blockquote><ol><li>ed≡1 (mod φ(n))。只有知道e和φ(n)，才能算出d。</li><li>φ(n)=(p-1)(q-1)。只有知道p和q，才能算出φ(n)。</li><li>n=pq。只有将n因数分解，才能算出p和q。</li></ol></blockquote><p><strong>结论：如果n可以被因数分解，d就可以算出，也就意味着私钥被破解。</strong></p><p>可是，大整数的因数分解，是一件非常困难的事情。目前，除了暴力破解，还没有发现别的有效方法。维基百科这样写道：</p><blockquote><p>“对极大整数做因数分解的难度决定了RSA算法的可靠性。换言之，对一极大整数做因数分解愈困难，RSA算法愈可靠。</p><p>假如有人找到一种快速因数分解的算法，那么RSA的可靠性就会极度下降。但找到这样的算法的可能性是非常小的。今天只有短的RSA密钥才可能被暴力破解。到2008年为止，世界上还没有任何可靠的攻击RSA算法的方式。</p><p>只要密钥长度足够长，用RSA加密的信息实际上是不能被解破的。”</p></blockquote><p>举例来说，你可以对3233进行因数分解（61×53），但是你没法对下面这个整数进行因数分解。</p><blockquote><p>12301866845301177551304949<br>58384962720772853569595334<br>79219732245215172640050726<br>36575187452021997864693899<br>56474942774063845925192557<br>32630345373154826850791702<br>61221429134616704292143116<br>02221240479274737794080665<br>351419597459856902143413</p></blockquote><p>它等于这样两个质数的乘积：</p><blockquote><p>33478071698956898786044169<br>84821269081770479498371376<br>85689124313889828837938780<br>02287614711652531743087737<br>814467999489<br>×<br>36746043666799590428244633<br>79962795263227915816434308<br>76426760322838157396665112<br>79233373417143396810270092<br>798736308917</p></blockquote><p>事实上，这大概是人类已经分解的最大整数（232个十进制位，768个二进制位）。比它更大的因数分解，还没有被报道过，因此目前被破解的最长RSA密钥就是768位。</p><h2 id="加密和解密"><a href="#加密和解密" class="headerlink" title="加密和解密"></a>加密和解密</h2><p>有了公钥和密钥，就能进行加密和解密了。</p><p><strong>加密要用公钥 (n,e)</strong></p><p>假设鲍勃要向爱丽丝发送加密信息m，他就要用爱丽丝的公钥 (n,e) 对m进行加密。这里需要注意，m必须是整数（字符串可以取ascii值或unicode值），且m必须小于n。</p><p>所谓”加密”，就是算出下式的c：</p><script type="math/tex; mode=display">m^e \equiv c \pmod n</script><p>爱丽丝的公钥是 (3233, 17)，鲍勃的m假设是65，那么可以算出下面的等式：</p><script type="math/tex; mode=display">65^{17} \equiv 2790 \pmod {3233}</script><p>于是，c等于2790，鲍勃就把2790发给了爱丽丝。</p><p><strong>解密要用私钥(n,d)</strong></p><p>爱丽丝拿到鲍勃发来的2790以后，就用自己的私钥(3233, 2753) 进行解密。可以证明，下面的等式一定成立：</p><script type="math/tex; mode=display">c^d \equiv m \pmod n</script><p>也就是说，c的d次方除以n的余数为m。现在，c等于2790，私钥是(3233, 2753)，那么，爱丽丝算出</p><script type="math/tex; mode=display">2790^{2753}\equiv65 \pmod {3233}</script><p>因此，爱丽丝知道了鲍勃加密前的原文就是65。</p><p>至此，”加密—解密”的整个过程全部完成。</p><p>我们可以看到，如果不知道d，就没有办法从c求出m。而前面已经说过，要知道d就必须分解n，这是极难做到的，所以RSA算法保证了通信安全。</p><p>你可能会问，公钥(n,e) 只能加密小于n的整数m，那么如果要加密大于n的整数，该怎么办？有两种解决方法：一种是把长信息分割成若干段短消息，每段分别加密；另一种是先选择一种”对称性加密算法”（比如<a href="https://zh.wikipedia.org/wiki/资料加密标准">DES</a>），用这种算法的密钥加密信息，再用RSA公钥加密DES密钥。</p><h2 id="私钥解密的证明"><a href="#私钥解密的证明" class="headerlink" title="私钥解密的证明"></a>私钥解密的证明</h2><p>最后，我们来证明，为什么用私钥解密，一定可以正确地得到m。也就是证明下面这个式子：</p><script type="math/tex; mode=display">c^d\equiv m \pmod n</script><p>因为，根据加密规则</p><script type="math/tex; mode=display">m^e\equiv c \pmod n</script><p>于是，c可以写成下面的形式：</p><script type="math/tex; mode=display">c = m^e -kn</script><p>将c代入要我们要证明的那个解密规则：</p><script type="math/tex; mode=display">(m^e-kn)^d=m \pmod n</script><p>左边二项式拆出来，除了第一项$m^e$，其他项都是n的倍数，所以它等同于求证</p><script type="math/tex; mode=display">m^{ed} \equiv m \pmod n</script><p>由于</p><script type="math/tex; mode=display">ed \equiv 1 \pmod {φ(n)}</script><p>所以</p><script type="math/tex; mode=display">ed = h φ(n) + 1</script><p>将ed代入：</p><script type="math/tex; mode=display">m^{hφ(n)+1}=m \pmod n</script><p>接下来，分成两种情况证明上面这个式子。</p><p><strong>（1）m与n互质。</strong></p><p>根据欧拉定理，此时</p><script type="math/tex; mode=display">m^{φ(n)} \equiv 1 \pmod n</script><p>得到</p><script type="math/tex; mode=display">(m^{φ(n)})^h*m \equiv m \pmod n</script><p>原式得到证明。</p><p><strong>（2）m与n不是互质关系。</strong></p><p>此时，由于n等于质数p和q的乘积，所以m必然等于kp或kq。</p><p>以 m = kp为例，考虑到这时k与q必然互质，则根据欧拉定理，下面的式子成立：</p><script type="math/tex; mode=display">(kp)^{q-1} \equiv 1 \pmod q</script><p>进一步得到</p><script type="math/tex; mode=display">[(kp)^{q-1}]^{h(p-1)}*kp \equiv kp \pmod q</script><p>即</p><script type="math/tex; mode=display">(kp)^{ed} \equiv kp \pmod q</script><p>将它改写成下面的等式</p><script type="math/tex; mode=display">(kp)^{ed} = tq + kp</script><p>这时t必然能被p整除，即 t=t’p</p><script type="math/tex; mode=display">(kp)^{ed}=t'pq+kp</script><p>因为 m=kp，n=pq，所以</p><script type="math/tex; mode=display">m^{ed} \equiv m \pmod n</script><p>原式得到证明。</p><h1 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h1><ol><li><a href="https://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html">RSA算法原理（一）</a></li><li><a href="https://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html">RSA算法原理（二）</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 加密算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 加密算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习中图像分类问题的总结</title>
      <link href="/2022/08/16/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%BB%E7%BB%93/"/>
      <url>/2022/08/16/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><blockquote><p>企业实习中遇到的场景。</p><p>输入是ICU中病人的一段视频，输出是基于判断该病人是否贫血。</p><p>甲方给出了300多个的视频，每个视频对应一个病人。其中重度贫血样本最少，轻度贫血的样本量最多。</p><p>（说实在的，这个任务实在是有点玄学，查了一些资料，也没有理论依据。但是甲方说有经验的医生看几眼就能看出来<strong>病人</strong>是否是贫血，所以只能硬着头皮做。）</p><p>在实践过程中，得到了专家的指点，故把专家给出的技巧和实践中遇到的若干问题和解决思路记录下来。</p></blockquote><h1 id="数据处理和算法流程"><a href="#数据处理和算法流程" class="headerlink" title="数据处理和算法流程"></a>数据处理和算法流程</h1><p>如图。圆角矩形是数据，矩形是处理流程</p><p><img src="image-20220816222412537.png" alt="数据处理和算法流程"></p><h1 id="指导纪要"><a href="#指导纪要" class="headerlink" title="指导纪要"></a>指导纪要</h1><p>本节记录专家给出的一些指导要点。</p><h2 id="明确需求"><a href="#明确需求" class="headerlink" title="明确需求"></a>明确需求</h2><p>在开始之前，需要明确需求，针对本次任务主要是明确一下几点：</p><ol><li>目标是什么？最终的算法模型是科研，还是落地应用。如果是落地应用，那么可能更看重重度贫血的召回。</li><li>明确输入：是一段视频，还是一张照片，如果是一段视频还要考虑时序信息。</li><li>预测样本是已知的还是未知的：未知。</li><li>是否能有更多的数据？能，但比较慢，毕竟实际情况就是ICU的病床数量比较少。总样本量就那些。</li></ol><h2 id="分析bad-case"><a href="#分析bad-case" class="headerlink" title="分析bad case"></a>分析bad case</h2><p>找一个模型快速实现，（我们这里使用的是Efficient Net），基于这个baseline，分析bad case。</p><p>所谓bad case 就是模型经过训练后，预测错的case。分析bad case非常重要。（这一点在我实践的过程中没有重视，原因是ICU的病人的视频和照片容易引起不适）</p><p>分析bad case的目的有如下几个：</p><ol><li>确定算法上限：<strong>数据决定算法上限，模型只是在逼近这个上限。</strong>我们的模型做到什么样才算可以交差了，不是拍脑袋决定的，而是由本步骤得到的算法上限决定的。</li><li>如果人眼分辨起来都比较困难，那该任务可能是不可实现的。</li><li>纠正数据（标注）问题。在分析bad case的时候我发现有一些视频帧非常模糊，后面通过计算清晰度，将视频帧中比较模糊的图像去除掉了。</li></ol><h2 id="调参"><a href="#调参" class="headerlink" title="调参"></a>调参</h2><p>在明确了算法上限之后，再进行调参。</p><ol><li>train阶段：<ol><li>针对数据不均衡的问题，主要有三种方式：对每一个类别进行加权；把占比大的分类样本量调低；数据增强。（前两种在以前的实践中提升不大，最后一种PyTorch有现成的code）</li><li>针对模型，一般来说<strong>模型的分类力度要比需求的粒度更细</strong>，在该场景下，需求要求二分类，而模型取四分类。方便后续的调整。</li><li>测试后，画出<strong>混淆矩阵</strong>，看哪几个子类容易混淆，再对混淆的子类单独训练模型。（多个模型级联）</li><li>更换loss：我们尝试了把交叉熵损失换成center loss、focal loss，但效果也没有好到哪去。</li></ol></li><li>val阶段：<ol><li>loss：在该场景下，模型会给出四个分数，分别对应四个类别的可能性。一般是取四个分数中max对应的分类，作为最后的分类结果。<strong>修改阈值</strong>以改变最后的分类结果（比如，当重度贫血的概率大于人为设定的X时，就认为分类结果为重度贫血）。</li><li>X怎么定？X的值取决于指标。比如我想要重度贫血的Recall达到99%，那我把预测的重度贫血的分数由高到低排序，画一个最低线，在该线之上都被预测为重度贫血，那么该线就是我们想要的X。</li><li>loss：也可以给四个分数分别乘上四个权重。这条与上条的区别是，上一条可以轻易的确保Precision或Recall。</li></ol></li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="手工提取特征V-S-自动提取特征"><a href="#手工提取特征V-S-自动提取特征" class="headerlink" title="手工提取特征V.S.自动提取特征"></a>手工提取特征V.S.自动提取特征</h3><p>上面的<em>数据处理流程图</em>中可见，为了避免背景（病床等）干扰，我们先用网上一个训练好的模型提取人脸。再把提取的人脸拿去训练。</p><p>由于提取的效果有限，后来又使用K-means算法对颜色进行聚类，设置一个阈值，把大部分图像中病人的插管，口罩等去掉，用黑色背景代替。（当然效果依然有限）</p><p>一开始我们认为通过手工提取特征后，再丢到网络里训练，这样的效果会更好。</p><p>但专家认为并非如此，实际效果也确实如专家所料。</p><p>专家说，手工提取特征的缺点是，提取特征的同时会损害图像本身（图像出现一小块一小块的黑色背景）；其次，手工提取特征需要手工设定一个阈值，而这个阈值的最佳情形在训练集和测试集可能是不同的。</p><p>专家又说，<strong>在以往的实践中，深度学习的自动提取特征效果更好、更稳定。</strong></p><h3 id="三百个样本够不够用"><a href="#三百个样本够不够用" class="headerlink" title="三百个样本够不够用"></a>三百个样本够不够用</h3><p><strong>样本够不够取决于问题的难度。</strong>没有绝对意义上的够不够。</p><h3 id="预训练OR没有预训练"><a href="#预训练OR没有预训练" class="headerlink" title="预训练OR没有预训练"></a>预训练OR没有预训练</h3><p><strong>使用预训练的网络模型要比没有预训练的模型更好。</strong>（具体原因忘了。）</p><h3 id="交叉验证"><a href="#交叉验证" class="headerlink" title="交叉验证"></a>交叉验证</h3><p>虽然数据都是随机的分到train或者val，但是为了防止，分到train的数据太简单、val的数据太难和分到train的数据太难、val的数据太简单，会导致模型最后的效果不一样。<strong>为了提高模型的鲁棒性，需要K-Fold交叉验证。</strong></p><h3 id="多次迭代训练"><a href="#多次迭代训练" class="headerlink" title="多次迭代训练"></a>多次迭代训练</h3><p>由易到难多轮迭代。</p><p>先人工筛选出一些<strong>简单</strong>样本，按照一定比例组织数据进行训练，得到一个可以分类简单样本的模型。</p><p>再筛选出比简单样本稍难一点的样本，按照一定比例组织数据进行训练，得到一个可以分类比简单样本稍难样本的模型。</p><p>……</p><p>依次类推，直到所有样本都丢进去训练。</p><blockquote><p>这里所说的简单是人容易分辨的。</p><p>如果所有样本人都不容易看出来怎么办？</p><p>那就先进行一次整体的训练。找到本次训练中模型预测正确的样本，这样的样本即为模型认为的简单样本</p></blockquote><p>这种方法的优点是，效果会更好。（专家的原话是，屡试不爽）</p><p>我想可能是因为它比较符合人由易到难的学习思路。</p><p>缺点就是耗时长，人干预的时间长。（毕竟需要挑样本，挺累的。。）</p><h3 id="Attention"><a href="#Attention" class="headerlink" title="Attention"></a>Attention</h3><p>如果希望模型集中到某些局部特征可以使用attention机制。</p><h3 id="对于不清楚的代码或者参数"><a href="#对于不清楚的代码或者参数" class="headerlink" title="对于不清楚的代码或者参数"></a>对于不清楚的代码或者参数</h3><p>细究论文、源码。</p><h1 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h1>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 计算机视觉 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣-前K个高频元素-用流来做</title>
      <link href="/2022/07/11/%E5%8A%9B%E6%89%A3-%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0-%E7%94%A8%E6%B5%81%E6%9D%A5%E5%81%9A/"/>
      <url>/2022/07/11/%E5%8A%9B%E6%89%A3-%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0-%E7%94%A8%E6%B5%81%E6%9D%A5%E5%81%9A/</url>
      
        <content type="html"><![CDATA[<blockquote><p>使用Java8 Stream来完成力扣 <a href="https://leetcode.cn/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a></p></blockquote><h1 id="题目及思路"><a href="#题目及思路" class="headerlink" title="题目及思路"></a>题目及思路</h1><blockquote><p>给一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 <strong>任意顺序</strong> 返回答案。</p><p>例如：</p><p>输入: nums = [1,1,1,2,2,3], k = 2</p><p>输出: [1,2]</p></blockquote><p>思路很简单：</p><p>将<key: 元素，value: 元素出现的次数>存到Map中，将map按value倒序排序，输出前k个返回。</p><h1 id="经典做法"><a href="#经典做法" class="headerlink" title="经典做法"></a>经典做法</h1><p>下面是根据上面的思路实现的代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> tmp[] = &#123;&#125;;</span><br><span class="line">            <span class="keyword">return</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建返回的res数组</span></span><br><span class="line">        <span class="type">int</span> res[] = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="comment">//创建map</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//将nums数组中元素和元素出现的次数保存到map中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(num)) &#123;</span><br><span class="line">                map.put(num, map.get(num)+<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(num, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建map.entrySet()的list用于排序</span></span><br><span class="line">        List&lt;Map.Entry&lt;Integer, Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(map.entrySet());</span><br><span class="line">        <span class="comment">//按map的值倒序排序</span></span><br><span class="line">        Collections.sort(list, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Map.Entry&lt;Integer, Integer&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Map.Entry&lt;Integer, Integer&gt; o1, Map.Entry&lt;Integer, Integer&gt; o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> o2.getValue() - o1.getValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//取出前k个放到res中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            res[i] = list.get(i).getKey();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用Stream"><a href="#使用Stream" class="headerlink" title="使用Stream"></a>使用Stream</h1><p>使用Stream实现的代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(nums) <span class="comment">// IntStream</span></span><br><span class="line">                .boxed() <span class="comment">// Stream&lt;Integer&gt;</span></span><br><span class="line">                .collect(Collectors.toMap(key -&gt; key, value -&gt; <span class="number">1</span>, Integer::sum)) <span class="comment">// Map&lt;Integer, Integer&gt;</span></span><br><span class="line">                .entrySet() <span class="comment">// Set&lt;Map&lt;K, V&gt;.Entry&lt;Integer, Integer&gt;&gt;</span></span><br><span class="line">                .stream() <span class="comment">// Stream&lt;Map&lt;K, V&gt;.Entry&lt;Integer, Integer&gt;&gt;</span></span><br><span class="line">                .sorted(Map.Entry.comparingByValue(Comparator.reverseOrder()))</span><br><span class="line">                .map(Map.Entry::getKey) <span class="comment">// Stream&lt;Integer&gt;</span></span><br><span class="line">                .limit(k)</span><br><span class="line">                .mapToInt(i -&gt; i) <span class="comment">//IntStream</span></span><br><span class="line">                .toArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是非常的简洁明了？下面对代码做一下必要解释</p><ul><li><p>为了将<code>int[]</code>转为流，使用了<code>Arrays.stream(nums)</code></p></li><li><p>需要注意的是，普通的流总是包装类，但这里直接得到了IntStream，为了后面封装为<code>Map&lt;Integer, Integer&gt;</code>，所以需要使用<code>boxed()</code>将IntStream转为<code>Stream&lt;Integer&gt;</code></p></li><li><p><code>collect</code>将Stream收集到一个Map</p></li><li><p><code>Collectors.toMap</code>的三个参数分别是，收集到Map的key，value当遇到重复key时的处理方法；</p></li><li><p>3-5行的代码等价于下面</p><ul><li><pre><code class="lang-java">Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();Arrays.stream(nums).forEach(num -&gt; &#123;    map.put(num, map.getOrDefault(num, 0) + 1);&#125;);</code></pre></li></ul></li><li><p>为了从map中再次获得流，我们使用代码先得到map的set在获得流。代码对应<code>entryset()</code>和<code>stream()</code></p></li><li><p>获得流之后需要根据value进行倒序排序，使用<code>sorted()</code>，其传入的参数是一个比较器</p></li><li><p>排序之后映射使用map()将<code>Stream&lt;Map&lt;K, V&gt;.Entry&lt;Integer, Integer&gt;&gt;</code>映射为<code>Stream&lt;Integer&gt;</code></p></li><li><p>我们只需要前k个，所以用limit(k)</p></li><li><p>使用<code>mapToInt(i -&gt; i)</code>进行拆包，得到IntStream</p></li><li><p><code>toArray()</code>转换为数组并返回。</p></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Java8 Stream在处理集合方面有着很大的优势：</p><ul><li>逻辑清晰</li><li>代码简洁</li><li>……</li></ul><p>但我刚接触，使用起来不是很熟悉，还需要再多练习。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>null</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分库分表总结</title>
      <link href="/2022/07/10/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E6%80%BB%E7%BB%93/"/>
      <url>/2022/07/10/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么要分库分表"><a href="#为什么要分库分表" class="headerlink" title="为什么要分库分表"></a>为什么要分库分表</h1><p>移动互联网时代，海量的用户每天产生海量的数量，比如：用户表、订单表、交易流水表。</p><p>以支付宝用户为例，8亿；微信用户更是10亿。订单表更夸张，比如美团外卖，每天都是几千万的订单。淘宝的历史订单总量应该百亿，甚至千亿级别，这些海量数据远不是一张表能Hold住的。</p><p>事实上MySQL单表可以存储10亿级数据，只是这时候性能比较差，<strong>业界公认MySQL单表容量在1KW以下是最佳状态，因为这时它的BTREE索引树高在3~5之间。</strong></p><p>既然<strong>一张表无法搞定，那么就想办法将数据放到多个地方</strong>，目前比较普遍的方案有3个：</p><blockquote><ol><li>分区；</li><li>分库分表；</li><li>NoSQL/NewSQL；NoSQL比较具有代表性的是MongoDB，es。NewSQL比较具有代表性的是TiDB。</li></ol></blockquote><h2 id="数据库架构演变：从读写分离到分库分表"><a href="#数据库架构演变：从读写分离到分库分表" class="headerlink" title="数据库架构演变：从读写分离到分库分表"></a>数据库架构演变：从读写分离到分库分表</h2><p>刚开始我们只用单机数据库就够了，随后面对越来越多的请求，我们将数据库的<strong>写操作和读操作进行分离</strong>， 使用多个从库副本<strong>（Slaver Replication）</strong>负责读，使用主库<strong>（Master）</strong>负责写， 从库从主库同步更新数据，保持数据一致。架构上就是数据库主从同步。 从库可以水平扩展，所以更多的读请求不成问题。</p><p>但是当用户量级上来后，写请求越来越多，该怎么办？加一个Master是不能解决问题的， 因为数据要保存一致性，写操作需要2个master之间同步，相当于是重复了，而且更加复杂。</p><p>这时就需要用到<strong>分库分表（sharding），对写操作进行切分。</strong></p><h2 id="为什么不NoSQL-NewSQL"><a href="#为什么不NoSQL-NewSQL" class="headerlink" title="为什么不NoSQL/NewSQL?"></a>为什么不NoSQL/NewSQL?</h2><p>首先，为什么不选择第三种方案NoSQL/NewSQL，我认为主要是RDBMS有以下几个优点：</p><blockquote><p>RDBMS：关系型数据库管理系统（Relational Database Management System）</p><ul><li>RDBMS生态完善；</li><li>RDBMS绝对稳定；</li><li>RDBMS的事务特性；</li></ul></blockquote><p>NoSQL/NewSQL作为新生儿，在我们把可靠性当做首要考察对象时，它是无法与RDBMS相提并论的。RDBMS发展几十年，只要有软件的地方，它都是核心存储的首选。</p><p>目前绝大部分公司的核心数据都是：<strong>以RDBMS存储为主，NoSQL/NewSQL存储为辅</strong>！互联网公司又以MySQL为主，国企&amp;银行等不差钱的企业以Oracle/DB2为主！NoSQL/NewSQL宣传的无论多牛逼，就现在各大公司对它的定位，都是RDBMS的补充，而不是取而代之！</p><h2 id="为什么不分区"><a href="#为什么不分区" class="headerlink" title="为什么不分区?"></a>为什么不分区?</h2><p>我们再看分区表方案。了解这个方案之前，先了解它的原理：</p><p>分区：就是把一张表的数据分成N个区块，在逻辑上看最终只是一张表，但底层是由N个物理区块组成的，分区实现比较简单，数据库mysql、oracle等很容易就可支持。</p><blockquote><p><strong>分区表是由多个相关的底层表实现，这些底层表也是由句柄对象表示</strong>，所以我们也可以直接访问各个分区，存储引擎管理分区的各个底层表和管理普通表一样（所有的底层表都必须使用相同的存储引擎），<strong>分区表的索引只是在各个底层表上各自加上一个相同的索引</strong>，从存储引擎的角度来看，底层表和一个普通表没有任何不同，存储引擎也无须知道这是一个普通表还是一个分区表的一部分。</p></blockquote><p>一旦分表，一个库中的表会越来越多</p><blockquote><p>将整个数据库比作图书馆，一张表就是一本书。当要在一本书中查找某项内容时，如果不分章节，查找的效率将会下降。而同理，在数据库中就是分区。</p></blockquote><ul><li><strong>什么时候考虑使用分区</strong>：一张表的查询速度已经慢到影响使用的时候。</li></ul><blockquote><ol><li>sql经过优化</li><li>数据量大</li><li>表中的数据是分段的</li><li>对数据的操作往往只涉及一部分数据，而不是所有的数据</li></ol></blockquote><ul><li><p><strong>分区解决的问题</strong>：主要可以提升查询效率</p></li><li><p><strong>分区的实现方式</strong>（简单）：</p></li></ul><blockquote><p>mysql5 开始支持分区功能</p><p>CREATE TABLE sales (</p><p>id INT AUTO_INCREMENT,</p><p>amount DOUBLE NOT NULL,</p><p>order_day DATETIME NOT NULL,</p><p>PRIMARY KEY(id, order_day)</p><p>) ENGINE=Innodb</p><p>PARTITION BY RANGE(YEAR(order_day)) (</p><p>PARTITION p_2010 VALUES LESS THAN (2010),</p><p>PARTITION p_2011 VALUES LESS THAN (2011),</p><p>PARTITION p_2012 VALUES LESS THAN (2012),</p><p>PARTITION p_catchall VALUES LESS THAN MAXVALUE);</p></blockquote><ul><li>事实上，这个方案也不错，<strong>它对用户屏蔽了sharding的细节，即使查询条件没有sharding column，它也能正常工作（只是这时候性能一般）。</strong></li><li>不过它的缺点很明显：<strong>很多的资源都受到单机的限制，例如连接数，网络吞吐等</strong>！虽然每个分区可以独立存储，但是分区表的总入口还是一个MySQL示例。从而导致它的并发能力非常一般，远远达不到互联网高并发的要求！</li><li>至于网上提到的一些其他缺点比如：无法使用外键，不支持全文索引。我认为这都不算缺点，21世纪的项目如果还是使用外键和数据库的全文索引，我都懒得吐槽了！</li></ul><p>所以，<strong>如果使用分区表，你的业应该具备如下两个特点：</strong></p><blockquote><p>数据不是海量（分区数有限，存储能力就有限）；</p><p>并发能力要求不高；</p></blockquote><h1 id="分库分表概述"><a href="#分库分表概述" class="headerlink" title="分库分表概述"></a>分库分表概述</h1><p><img src="分库分表概述.jpg" alt="分库分表概述"></p><blockquote><p>读写分离：分散数据库读写操作压力</p><p>分库分表：分散存储压力</p></blockquote><h1 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h1><p><img src="适用场景.png" alt="适用场景"></p><ul><li>类似读写分离，分库分表也是确定没有其他优化空间之后才采取的优化方案。</li><li>那如果业务真的发展很快岂不是很快要进行分库分表了？那为何不一开始就设计好呢？</li></ul><p><strong>按照架构设计的“三原则”（简单原则，合适原则，演化原则）</strong>，简单分析一下：</p><blockquote><p>首先，<strong>这里的“如果”事实上发生的概率比较低</strong>，做10个业务有一个业务能活下去就很不错了，更何况快速发展，和中彩票的概率差不多。如果我们每个业务上来就按照淘宝、微信的规模去做架构设计，不但会累死自己，还会害死业务。</p><p>其次，<strong>如果业务真的发展很快，后面进行分库分表也不迟</strong>。因为业务发展好，相应的资源投入就会加大，可以投入更多的人和更多的钱，那业务分库带来的代码和业务复杂问题就可以通过加人来解决，成本问题也可以通过增加资金来解决。</p></blockquote><h1 id="分库分表的方式方法"><a href="#分库分表的方式方法" class="headerlink" title="分库分表的方式方法"></a>分库分表的方式方法</h1><blockquote><p>一般就是<strong>垂直切分和水平切分</strong>，这是一种结果集描述的切分方式，是物理空间上的切分。</p><p>我们从面临的问题，开始解决，阐述： 首先是用户请求量太大，我们就堆机器搞定（这不是本文重点）。</p><p>然后是单个库太大，这时我们要看是因为<strong>表多而导致数据多</strong>，还是因为<strong>单张表里面的数据多</strong>。</p><p>如果是因为表多而数据多，使用垂直切分，根据业务切分成不同的库。</p><p>如果是因为单张表的数据量太大，这时要用水平切分，即把表的数据按<strong>某种规则</strong>切分成多张表，甚至多个库上的多张表。 </p><p><strong>分库分表的顺序应该是先垂直分，后水平分</strong>。 因为垂直分更简单，更符合我们处理现实世界问题的方式。</p></blockquote><h2 id="垂直拆分"><a href="#垂直拆分" class="headerlink" title="垂直拆分"></a>垂直拆分</h2><h3 id="垂直分表"><a href="#垂直分表" class="headerlink" title="垂直分表"></a>垂直分表</h3><blockquote><p>也就是“大表拆小表”，基于列字段进行的。</p><p>一般是表中的字段较多，将不常用的， 数据较大，长度较长（比如text类型字段）的拆分到“扩展表“。</p><p>一般是针对那种几百列的大表，也避免查询时，数据量太大造成的“跨页”问题。</p></blockquote><h4 id="垂直分库"><a href="#垂直分库" class="headerlink" title="垂直分库"></a>垂直分库</h4><blockquote><p>垂直分库针对的是一个系统中的不同业务进行拆分，比如用户User一个库，商品Producet一个库，订单Order一个库。</p><p>切分后，要放在多个服务器上，而不是一个服务器上。</p><p>为什么？ 我们想象一下，一个购物网站对外提供服务，会有用户，商品，订单等的CRUD。没拆分之前， 全部都是落到单一的库上的，这会让数据库的<strong>单库处理能力成为瓶颈</strong>。</p><p>按垂直分库后，如果还是放在一个数据库服务器上， 随着用户量增大，这会让<strong>单个数据库的处理能力成为瓶颈</strong>，还有<strong>单个服务器的磁盘空间，内存，tps等非常吃紧</strong>。 所以我们要拆分到多个服务器上，这样上面的问题都解决了，以后也不会面对单机资源问题。</p><p>数据库业务层面的拆分，和服务的“治理”，“降级”机制类似，也能对不同业务的数据分别的进行管理，维护，监控，扩展等。</p><p>数据库往往最容易成为应用系统的瓶颈，<strong>而数据库本身属于“有状态”的，相对于Web和应用服务器来讲，是比较难实现“横向扩展”的。</strong></p><p>数据库的连接资源比较宝贵且单机处理能力也有限，在高并发场景下，垂直分库一定程度上能够突破IO、连接数及单机硬件资源的瓶颈。</p></blockquote><p><img src="业务分库1.jpg" alt="业务分库1"></p><p><img src="业务分库2.jpg" alt="业务分库2"></p><h2 id="水平拆分"><a href="#水平拆分" class="headerlink" title="水平拆分"></a>水平拆分</h2><h3 id="水平分表"><a href="#水平分表" class="headerlink" title="水平分表"></a>水平分表</h3><blockquote><p>针对数据量巨大的单张表（比如订单表），按照某种规则（<strong>RANGE，HASH取模</strong>等），切分到多张表里面去。 但是这些表还是在同一个库中，所以<strong>库级别的数据库操作还是有IO瓶颈</strong>。不建议采用。</p></blockquote><h3 id="水平分库分表"><a href="#水平分库分表" class="headerlink" title="水平分库分表"></a>水平分库分表</h3><blockquote><p>将单张表的数据切分到多个服务器上去，每个服务器具有相应的库与表，只是表中数据集合不同。 水平分库分表能够有效的缓解单机和单库的性能瓶颈和压力，突破IO、连接数、硬件资源等的瓶颈。</p></blockquote><h3 id="水平分库分表切分规则"><a href="#水平分库分表切分规则" class="headerlink" title="水平分库分表切分规则"></a>水平分库分表切分规则</h3><p><strong>RANGE</strong></p><blockquote><p>从0到10000一个表，10001到20000一个表；</p></blockquote><p><strong>HASH取模</strong></p><blockquote><p>一个商场系统，一般都是将用户，订单作为主表，然后将和它们相关的作为附表，这样不会造成跨库事务之类的问题。 <strong>取用户id，然后hash取模</strong>，分配到不同的数据库上。</p></blockquote><p><strong>地理区域</strong></p><blockquote><p>比如按照华东，华南，华北这样来区分业务，七牛云应该就是如此。</p></blockquote><p><strong>时间</strong></p><blockquote><p>按照时间切分，就是将6个月前，甚至一年前的数据切出去放到另外的一张表，因为随着时间流逝，这些表的数据 被查询的概率变小，所以没必要和“热数据”放在一起，这个也是“冷热数据分离”。</p></blockquote><h2 id="业务分表"><a href="#业务分表" class="headerlink" title="业务分表"></a>业务分表</h2><p><img src="业务分表.png" alt="业务分表"></p><p><img src="业务分表2.jpg" alt="业务分表2"></p><h1 id="分库分表后面临的问题"><a href="#分库分表后面临的问题" class="headerlink" title="分库分表后面临的问题"></a>分库分表后面临的问题</h1><h2 id="事务支持"><a href="#事务支持" class="headerlink" title="事务支持"></a>事务支持</h2><blockquote><p>分库分表后，就成了<strong>分布式事务</strong>了。</p><p>如果依赖数据库本身的分布式事务管理功能去执行事务，将付出高昂的性能代价； 如果由应用程序去协助控制，形成程序逻辑上的事务，又会造成编程方面的负担。</p></blockquote><h2 id="路由问题："><a href="#路由问题：" class="headerlink" title="路由问题："></a>路由问题：</h2><blockquote><p>垂直分表：增加表操作的次数</p><p>水平分表：<strong>路由问题</strong></p></blockquote><p> <img src="路由问题.jpg" alt="路由问题"></p><h2 id="数据库操作问题"><a href="#数据库操作问题" class="headerlink" title="数据库操作问题"></a>数据库操作问题</h2><h3 id="多库结果集合并（group-by，order-by）"><a href="#多库结果集合并（group-by，order-by）" class="headerlink" title="多库结果集合并（group by，order by）"></a>多库结果集合并（group by，order by）</h3><h3 id="跨库join"><a href="#跨库join" class="headerlink" title="跨库join"></a>跨库join</h3><blockquote><p>分库分表后表之间的关联操作将受到限制，我们无法join位于不同分库的表，也无法join分表粒度不同的表， 结果原本一次查询能够完成的业务，可能需要多次查询才能完成。</p><p>粗略的解决方法： 全局表：基础数据，所有库都拷贝一份。 字段冗余：这样有些字段就不用join去查询了。 系统层组装：分别查询出所有，然后组装起来，较复杂。</p></blockquote><p><img src="数据库操作问题.png" alt="数据库操作问题"></p><ul><li>解决方法</li></ul><p><img src="解决方法.png" alt="解决方法"></p><p>类似读写分离，具体实现也是“程序代码封装”和“中间件封装”，但具体实现复杂一些，因为还有要判断SQL中具体操作的表，具体操作（例如count、order by、group by等），根据具体操作做不同的处理。</p><h2 id="多分片（水平切分）返回结果合并（排序）"><a href="#多分片（水平切分）返回结果合并（排序）" class="headerlink" title="多分片（水平切分）返回结果合并（排序）"></a>多分片（水平切分）返回结果合并（排序）</h2><h3 id="①-Select-None-Aggregate-Function的有序记录合并排序"><a href="#①-Select-None-Aggregate-Function的有序记录合并排序" class="headerlink" title="① Select + None Aggregate Function的有序记录合并排序"></a>① Select + None Aggregate Function的有序记录合并排序</h3><blockquote><p>解决思路：对各分片返回的有序记录，进行排序去重合并。此处主要是编写排序去重合并算法。</p></blockquote><h3 id="②-Select-None-Aggregate-Function的无序记录合并"><a href="#②-Select-None-Aggregate-Function的无序记录合并" class="headerlink" title="② Select + None Aggregate Function的无序记录合并"></a>② Select + None Aggregate Function的无序记录合并</h3><blockquote><p>解决思路：对各分片返回的无序记录，进行去重合并。</p><ul><li>优点：实现比较简单。</li><li>缺点：数据量越大，字段越多，去重处理就会越耗时。</li></ul></blockquote><h3 id="③-Select-Aggregate-Function的记录合并（排序）Oracle常用聚合函数：Count、Max、Min、Avg、Sum。"><a href="#③-Select-Aggregate-Function的记录合并（排序）Oracle常用聚合函数：Count、Max、Min、Avg、Sum。" class="headerlink" title="③ Select + Aggregate Function的记录合并（排序）Oracle常用聚合函数：Count、Max、Min、Avg、Sum。"></a>③ Select + Aggregate Function的记录合并（排序）Oracle常用聚合函数：Count、Max、Min、Avg、Sum。</h3><blockquote><ul><li>AF：Max、Min<ul><li>思路：通过算法对各分片返回结果再求max、min值。</li></ul></li><li>AF：Avg、Sum、Count<ul><li>思路：分片间无重复记录或字段时，通过算法对各分片返回结果再求avg、sum、count值。分片间有重复记录或字段时，先对各分片记录去重合并，再通过算法求avg、sum、count值。</li></ul></li></ul></blockquote><p>比如：</p><blockquote><p>select count(*) from user</p><p>select count(deptno) from user;</p><p>select count(distinct deptno) from user;</p></blockquote><h2 id="多分片（水平切分）返回结果分页"><a href="#多分片（水平切分）返回结果分页" class="headerlink" title="多分片（水平切分）返回结果分页"></a>多分片（水平切分）返回结果分页</h2><blockquote><p>解决思路：合并各分片返回结果，逻辑分页。</p><ul><li>优点：  实现简单。</li><li>缺点：  数据量越大，缓存压力就越大。分片数据量越大，查询也会越慢。</li></ul></blockquote><h2 id="多分片（水平切分）查询有分组语法的合并"><a href="#多分片（水平切分）查询有分组语法的合并" class="headerlink" title="多分片（水平切分）查询有分组语法的合并"></a>多分片（水平切分）查询有分组语法的合并</h2><h3 id="①-Group-By-Having-None-Aggregate-Function时"><a href="#①-Group-By-Having-None-Aggregate-Function时" class="headerlink" title="① Group By Having + None Aggregate Function时"></a>① Group By Having + None Aggregate Function时</h3><blockquote><ul><li>Select + None Aggregate Function<ul><li>比如：select job user group by job;</li><li>思路：直接去重（排序）合并。</li></ul></li><li>Select + Aggregate Function<ul><li>比如：select max(sal),job user group by job;</li><li>思路：同Select + Aggregate Function的记录合并（排序）。</li></ul></li></ul></blockquote><h3 id="②-Group-By-Having-Aggregate-Function时"><a href="#②-Group-By-Having-Aggregate-Function时" class="headerlink" title="② Group By Having + Aggregate Function时"></a>② Group By Having + Aggregate Function时</h3><blockquote><p>解决思路：去掉having AF条件查询各分片，然后把数据放到一张表里。再用group by having 聚合函数查询。</p></blockquote><h2 id="分布式数据库架构—排序分组分页参考解决方案"><a href="#分布式数据库架构—排序分组分页参考解决方案" class="headerlink" title="分布式数据库架构—排序分组分页参考解决方案"></a>分布式数据库架构—排序分组分页参考解决方案</h2><blockquote><ul><li>解决方案1：Hadoop + Hive。<ul><li>思路：使用Hadoop HDFS来存储数据，通过Hdoop MapReduce完成数据计算，通过Hive HQL语言使用部分与RDBBS一样的表格查询特性和分布式存储计算特性。</li><li>优点：<ul><li>可以解决问题</li><li>具有并发处理能力</li><li>可以离线处理</li></ul></li><li>缺点： <ul><li>实时性不能保证</li><li>网络延迟会增加</li><li>异常捕获难度增加</li><li>Web应用起来比较复杂</li></ul></li></ul></li><li>解决方案2：总库集中查询。<ul><li>优点：<ul><li>可以解决问题</li><li>实现简单</li></ul></li><li>缺点：<ul><li>总库数据不能太大</li><li>并发压力大</li></ul></li></ul></li></ul></blockquote><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>对于分布式数据库架构来说，排序、分页、分组一直就是一个比较复杂的问题。避免此问题需要好好地设计分库、分表策略。同时根据特定的场景来解决问题。也可以 充分利用海量数据存储（Hadoop-HDFS|Hive|HBse）、搜索引擎（Lucene|Solr）及分布式计算（MapReduce）等技术来 解决问题。</p><p>另外，也可以用NoSQL技术替代关系性数据库来解决问题，比如MogonDB/Redis。</p><h1 id="参考（COPY）资料"><a href="#参考（COPY）资料" class="headerlink" title="参考（COPY）资料"></a>参考（COPY）资料</h1><ol><li><a href="https://blog.csdn.net/fly910905/article/details/87090092">分库分表：应用场景、方式方法、面临问题</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【读书笔记】生而贫穷</title>
      <link href="/2022/06/02/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91%E7%94%9F%E8%80%8C%E8%B4%AB%E7%A9%B7/"/>
      <url>/2022/06/02/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91%E7%94%9F%E8%80%8C%E8%B4%AB%E7%A9%B7/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第一个Spring应用</title>
      <link href="/2022/05/26/%E7%AC%AC%E4%B8%80%E4%B8%AASpring%E5%BA%94%E7%94%A8/"/>
      <url>/2022/05/26/%E7%AC%AC%E4%B8%80%E4%B8%AASpring%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本人以前学过Spring，也写过相关业务代码。但是对Spring理解不深刻，故重新认识Spring</p></blockquote><h1 id="初始化Spring项目"><a href="#初始化Spring项目" class="headerlink" title="初始化Spring项目"></a>初始化Spring项目</h1><p>我这里使用的是IDEA初始化Spring项目。</p><p>创建一个项目，并做如下设置，选择下一步。</p><p><img src="image-20220526234222155.png" alt="init"></p><p>配置新项目：</p><p><img src="image-20220526234348424.png" alt="config1"></p><p>选择Spring Boot的版本和插件，选择下一步。</p><p><img src="image-20220526234432034.png" alt="config2"></p><p>配置项目名称等。选择完成。</p><p><img src="image-20220526234505163.png" alt="config3"></p><blockquote><p>这里配置有问题也没关系，在pom.xml文件中做修改即可。</p></blockquote><h1 id="认识Spring项目"><a href="#认识Spring项目" class="headerlink" title="认识Spring项目"></a>认识Spring项目</h1><blockquote><p>本项目上传到了GitHub：<a href="https://github.com/guoyujian/spring-in-action5-code">https://github.com/guoyujian/spring-in-action5-code</a></p></blockquote><h2 id="mvnw和mvnw-cmd"><a href="#mvnw和mvnw-cmd" class="headerlink" title="mvnw和mvnw.cmd"></a>mvnw和mvnw.cmd</h2><p>mvnw和mvnw.cmd是Maven包装器（wrapper）脚本。借助这些脚本，即便你的机器上没有安装Maven，也可以构建项目。</p><h2 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h2><p>下面是我的pom.xml配置</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;version&gt;2.7.0&lt;/version&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>sia<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>taco-cloud<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>taco-cloud<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Taco Cloud Example<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>11<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--以下都是我加的--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>注意几点：</p><ol><li>parent/version标签指定了所有Spring相关包的版本，这样我们就不用在下面的dependency中配置版本。</li><li>packaging指出了打包方式，相比于war，jar更加流行。</li><li>properties/java.version指定了运行的java版本</li><li>dependencies标签下面全是依赖。其实一个最基本的项目是不需要这么多dependency的。可以自行注释掉这些dependency测试一下。</li></ol></blockquote><h2 id="TacoCloudApplication"><a href="#TacoCloudApplication" class="headerlink" title="TacoCloudApplication"></a>TacoCloudApplication</h2><p>这是主类。代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TacoCloudApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(TacoCloudApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中最重要的是@SpringBootApplication注解，这是一个组合注解，它组合了3个其他的注解：</p><ul><li>@SpringBootConfiguration：将该类声明为配置类。尽管这个类目前还没有太多的配置，但是后续我们可以按需添加基于Java的Spring框架配置。这个注解实际上是@Configuration注解的特殊形式。</li><li>@EnableAutoConfiguration：启用Spring Boot的自动配置。我们随后会介绍自动配置的更多功能。就现在来说，我们只需要知道这个注解会告诉Spring Boot自动配置它认为我们会用到的组件。</li><li>@ComponentScan：启用组件扫描。这样我们能够通过像@Component、@Controller、@Service这样的注解声明其他类，Spring会自动发现它们并将它们注册为Spring应用上下文中的组件。</li></ul><h2 id="TacoCloudApplicationTests"><a href="#TacoCloudApplicationTests" class="headerlink" title="TacoCloudApplicationTests"></a>TacoCloudApplicationTests</h2><p>测试类。后面细讲。</p><h2 id="resources"><a href="#resources" class="headerlink" title="resources/"></a>resources/</h2><p>该目录下，有</p><p><code>templates/</code>：存放thymeleaf模板，由于现在前后端分离开发，thymeleaf是用来代替jsp的一个东西，所以这个文件夹和thymeleaf没那么重要。</p><p><code>static/</code>：存放静态资源，图片，JS啥的，同上，不重要</p><p><code>application.properties</code>：Spring的配置文件，可以是yml，重要</p><h1 id="编写简单的Spring应用"><a href="#编写简单的Spring应用" class="headerlink" title="编写简单的Spring应用"></a>编写简单的Spring应用</h1><h2 id="MyController"><a href="#MyController" class="headerlink" title="MyController"></a>MyController</h2><p>在<code>tacos</code>包下面加入MyController，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/home&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">home</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;home&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>该类有一个@Controller注解所以Spring的组件扫描功能会自动发现它，并创建一个HomeController实例作为Spring应用上下文中的bean。实际上，有一些其他的注解与@Controller有着类似的目的（包括@Component、@Service和@Repository）。你可以为HomeController添加上述的任意其他注解，其作用是完全相同的。但是，在这里选择使用@Controller更能描述这个组件在应用中的角色。</p><p>home()是一个简单的控制器方法。它带有@GetMapping注解，表明如果针对<code>/home</code>发送HTTP GET请求，那么这个方法将会处理请求。</p><p>该方法所做的只是返回String类型的home值。这个值将会被解析为视图的逻辑名。视图如何实现取决于多个因素，但是因为Thymeleaf位于类路径中，所以我们可以使用Thymeleaf来定义模板。</p><p>模板名称是由逻辑视图名派生而来的，再加上“/templates/”前缀和“.html”后缀。最终形成的模板路径将是“/templates/home.html”。所以，我们需要将模板放到项目的“/src/main/resources/templates/home.html”目录中。</p><h2 id="home-html"><a href="#home-html" class="headerlink" title="home.html"></a>home.html</h2><p>这块代码很简单：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">hello!</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="编写测试类"><a href="#编写测试类" class="headerlink" title="编写测试类"></a>编写测试类</h2><p>在上面的TacoCloudApplicationTests测试类中编写代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.hamcrest.Matchers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.web.servlet.MockMvc;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.web.servlet.RequestBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@WebMvcTest(MyController.class)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TacoCloudApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MockMvc mvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHomePage</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        mvc.perform(MockMvcRequestBuilders.get(<span class="string">&quot;/home&quot;</span>))</span><br><span class="line">                .andExpect(MockMvcResultMatchers.status().isOk())</span><br><span class="line">                .andExpect(MockMvcResultMatchers.view().name(<span class="string">&quot;home&quot;</span>))</span><br><span class="line">                .andExpect(MockMvcResultMatchers.content().string(Matchers.containsString(<span class="string">&quot;hello&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这个类带有@RunWith(SpringRunner.class)注解。@RunWith是JUnit的注解，它会提供一个测试运行器（runner）来指导JUnit如何运行测试。可以将其想象为给JUnit应用一个插件，以提供自定义的测试行为。在本例中，为JUnit提供的是SpringRunner，这是一个Spring提供的测试运行器，它会创建测试运行所需的Spring应用上下文。</p><p>@WebMvcTest注解。这是Spring Boot所提供的一个特殊测试注解，它会让这个测试在Spring MVC应用的上下文中执行。更具体来讲，在本例中，它会将MyController注册到Spring MVC中，这样的话，我们就可以向它发送请求了。</p><p>测试类被注入了一个MockMvc，能够让测试实现mockup。通过testHomePage()方法，我们定义了针对主页想要执行的测试。它首先使用MockMvc对象对“/home”（根路径）发起HTTP GET请求。对于这个请求，我们设置了如下的预期（assert）：</p><ul><li>响应应该具备HTTP 200 (OK)状态</li><li>视图的逻辑名称应该是home</li><li>渲染后的视图应该包含文本hello</li></ul><blockquote><p>注意，如果Spring版本为2.7.0，这里@Autowired会报错，目前还不知道为什么。</p></blockquote><p>执行这个测试类，发现程序执行成功了。</p><p><img src="image-20220527003138947.png" alt="res"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对本人来说，最大的收获就是如何编写测试类，对Spring应用进行快速测试。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>《Spring 实战（第五版）》</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Springy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8 流（1）</title>
      <link href="/2022/05/22/Java8-%E6%B5%81%EF%BC%881%EF%BC%89/"/>
      <url>/2022/05/22/Java8-%E6%B5%81%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="流是什么"><a href="#流是什么" class="headerlink" title="流是什么"></a>流是什么</h1><p>流是Java API的新成员，它允许你以<strong>声明性</strong>方式处理数据集合（通过查询语句来表达，而不是临时编写一个实现）。就现在来说，你可以把它们看成遍历数据集的高级迭代器。</p><p>此外，流还可以透明的并行处理，你无需写任何多线程代码了！</p><hr><p>在继续介绍之前，先定义一会要使用到的集合对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Dish&gt; menu = Arrays.asList(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Dish</span>(<span class="string">&quot;pork&quot;</span>, <span class="literal">false</span>, <span class="number">800</span>, Dish.Type.MEAT),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Dish</span>(<span class="string">&quot;beef&quot;</span>, <span class="literal">false</span>, <span class="number">700</span>, Dish.Type.MEAT),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Dish</span>(<span class="string">&quot;chicken&quot;</span>, <span class="literal">false</span>, <span class="number">400</span>, Dish.Type.MEAT),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Dish</span>(<span class="string">&quot;french fries&quot;</span>, <span class="literal">true</span>, <span class="number">530</span>, Dish.Type.OTHER),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Dish</span>(<span class="string">&quot;rice&quot;</span>, <span class="literal">true</span>, <span class="number">350</span>, Dish.Type.OTHER),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Dish</span>(<span class="string">&quot;season fruit&quot;</span>, <span class="literal">true</span>, <span class="number">120</span>, Dish.Type.OTHER),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Dish</span>(<span class="string">&quot;pizza&quot;</span>, <span class="literal">true</span>, <span class="number">550</span>, Dish.Type.OTHER),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Dish</span>(<span class="string">&quot;prawns&quot;</span>, <span class="literal">false</span>, <span class="number">300</span>, Dish.Type.FISH),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Dish</span>(<span class="string">&quot;salmon&quot;</span>, <span class="literal">false</span>, <span class="number">450</span>, Dish.Type.FISH) );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Dish对象的声明如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dish</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> vegetarian;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> calories;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Type type;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dish</span><span class="params">(String name, <span class="type">boolean</span> vegetarian, <span class="type">int</span> calories, Type type)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.vegetarian = vegetarian;</span><br><span class="line">        <span class="built_in">this</span>.calories = calories;</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//getter、setter</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Type</span> &#123;MEAT, FISH, OTHER&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="流简介"><a href="#流简介" class="headerlink" title="流简介"></a>流简介</h1><blockquote><p>简短的定义就是“从支持数据处理操作的源生成的元素序列”</p></blockquote><ul><li><strong>元素序列</strong>——就像集合一样，流也提供了一个接口，可以访问特定元素类型的一组有序值。因为集合是数据结构，所以它的主要目的是以特定的时间/空间复杂度存储和访问元素（如ArrayList 与 LinkedList）。但流的目的在于表达计算。<strong>集合讲的是数据，流讲的是计算</strong>。我们会在后面详细解 释这个思想。</li><li><strong>源</strong>——流会使用一个提供数据的源，如集合、数组或输入/输出资源。 请注意，从有序集合生成流时会保留原有的顺序。由列表生成的流，其元素顺序与列表一致。</li><li><strong>数据处理操作</strong>——流的数据处理功能支持类似于数据库的操作，以及函数式编程语言中 的常用操作，如filter、map、reduce、find、match、sort等。流操作可以顺序执行，也可并行执行。</li></ul><p>此外，流操作有两个重要的特点。</p><ul><li><strong>流水线</strong>——很多流操作本身会返回一个流，这样多个操作就可以链接起来，形成一个大的流水线。这让一些优化成为可能，如延迟和短路。流水线的操作可以看作对数据源进行数据库式查询。</li><li><strong>内部迭代</strong>——与使用迭代器显式迭代的集合不同，流的迭代操作是在背后进行的。</li></ul><p>举例：筛选菜单中卡路里高于300的三个菜名</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; res = menu.stream()</span><br><span class="line">    .filter(d -&gt; d.getCalories() &gt; <span class="number">300</span>)</span><br><span class="line">    .map(d -&gt; d.getName())</span><br><span class="line">    .limit(<span class="number">3</span>)</span><br><span class="line">    .collect(Collectors.toList());</span><br><span class="line">System.out.println(res);</span><br></pre></td></tr></table></figure><blockquote><p>在本例中，我们先是对menu调用stream方法，由菜单得到一个流。<strong>数据源</strong>是菜单列表， 它给流提供一个<strong>元素序列</strong>。接下来，对流应用一系列数据处理操作：filter、map、limit 和collect。除了collect之外，所有这些操作都会返回另一个流，这样它们就可以接成一条流水线，于是就可以看作对源的一个查询。最后，collect操作开始处理流水线，并返回结果（它和别的操作不一样，因为它返回的不是流，在这里是一个List）。在调用collect之前，没有任何结果产生，实际上根本就没有从menu里选择元素。你可以这么理解：链中的方法调用都在排队等待，直到调用collect。</p></blockquote><p>过程如下：</p><p><img src="img1.png" alt="流可视化"></p><h1 id="流与集合"><a href="#流与集合" class="headerlink" title="流与集合"></a>流与集合</h1><blockquote><p>简单地说，集合与流之间的差异就在于什么时候进行计算。集合是一个内存中的数据结构， 它包含数据结构中目前所有的值——集合中的每个元素都得先算出来才能添加到集合中。（你可 以往集合里加东西或者删减东西，但是不管什么时候，集合中的每个元素都是放在内存里的，元素 都得先算出来才能成为集合的一部分。）</p><p>相比之下，流则是在概念上固定的数据结构（你不能添加或删除元素），其元素则是按需计 算的。</p></blockquote><ul><li>与集合不同，流只能遍历一次</li><li>集合是外部迭代，而流使用内部迭代——它帮你把迭代做了</li></ul><h1 id="流操作"><a href="#流操作" class="headerlink" title="流操作"></a>流操作</h1><p>stream定义了很多操作，分为两类：</p><ol><li>filter、map和limit可以连成一条流水线；</li><li>collect触发流水线执行并关闭它；</li></ol><p>可以连接起来的流操作称为中间操作，关闭流的操作称为终端操作。</p><p>总而言之，流的使用一般包括三件事：</p><ol><li>一个数据源（如集合）来执行一个查询；</li><li>一个中间操作链，形成一条流的流水线；</li><li>一个中间操作，执行流水线，并能生成结果。</li></ol><h1 id="使用流"><a href="#使用流" class="headerlink" title="使用流"></a>使用流</h1><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p>Streams接口支持filter方法（你现在应该很熟悉了）。该操作会接受一个<a href="https://geek-docs.com/java/java-tutorial/predicate.html">谓词</a>（一个返回 boolean的函数）作为参数，并返回一个包括所有符合谓词的元素的流。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 筛选所有素菜</span></span><br><span class="line">List&lt;Dish&gt; vegetarianMenu = menu.stream() </span><br><span class="line">                .filter(Dish::isVegetarian) </span><br><span class="line">                .collect(toList());</span><br></pre></td></tr></table></figure><h2 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h2><p>和数据库的distinct关键词很像，它会返回一个元素各异（即无重复的，根据流所生成元素的 hashCode和equals方法实现）的流。</p><h2 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h2><p>和数据库的limit关键词很像，该方法会返回一个不超过给定长度的流。</p><h2 id="skip"><a href="#skip" class="headerlink" title="skip"></a>skip</h2><p>流还支持skip(n)方法，返回一个扔掉了前n个元素的流。</p><h2 id="☆map"><a href="#☆map" class="headerlink" title="☆map"></a>☆map</h2><p><strong>对流中每一个元素应用函数</strong>。流支持map方法，这个方法接收一个函数作为参数，这个函数会被应用到流中的每个元素，并将其映 成一个新的元素，（创建新版本而不是修改原始流）例如，下面的代码把方法引用Dish::getName传给了map方法， 来提取流中菜肴的名称：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; dishNames = menu.stream() </span><br><span class="line">                             .map(Dish::getName) </span><br><span class="line">                             .collect(toList());</span><br></pre></td></tr></table></figure><h2 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h2><p>当给定单词列表<code>[&quot;Hello&quot;,&quot;World&quot;]</code>，想要返回各不相同的字符列表<code>[&quot;H&quot;,&quot;e&quot;,&quot;l&quot;, &quot;o&quot;,&quot;W&quot;,&quot;r&quot;,&quot;d&quot;]</code>。如果你使用<code>map(word -&gt; word.split(&quot;&quot;))</code>，你会发现这根本不起作用，这个方法的问题在于，传递给map方法的Lambda（word -&gt; word.split(“”)）为每个单词返回了一个String[]（String 列表）。因此，map返回的流实际上是Stream<String[]>类型的。你真正想要的是用 Stream来表示一个字符流。</p><p>此时你可以使用flatMap。使用flatMap方法的效果是，各个数组并不是分别映射成一个流，而映射成流的内容。所 有使用map(Arrays::stream)时生成的单个流都被合并起来，即扁平化为一个流。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; uniqueCharacters = words.stream() </span><br><span class="line">                                    .map(w -&gt; w.split(<span class="string">&quot;&quot;</span>)) </span><br><span class="line">                                    .flatMap(Arrays::stream) </span><br><span class="line">                                    .distinct() </span><br><span class="line">                                    .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><h2 id="查找与匹配"><a href="#查找与匹配" class="headerlink" title="查找与匹配"></a>查找与匹配</h2><blockquote><p> 另一个常见的数据处理操作是看看数据集中的某些元素是否匹配一个给定的属性， Stream API通过allMatch、anyMatch、noneMatch、findFirst和findAny方法提供了这样的工具。</p></blockquote><h3 id="anyMatch"><a href="#anyMatch" class="headerlink" title="anyMatch"></a>anyMatch</h3><p>anyMatch方法可以解决 “流中是否有一个元素能匹配给定的谓词”。比如，你可以用它来看看菜单里面是否有素食可选择：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">menu.stream().anyMatch(Dish::isVegetarian)</span><br></pre></td></tr></table></figure><p>anyMatch方法返回一个boolean，因此是一个终端操作</p><h3 id="allMatch"><a href="#allMatch" class="headerlink" title="allMatch"></a>allMatch</h3><p>allMatch方法会检查流中的元素是否都能匹配给定的谓词。</p><h3 id="noneMatch"><a href="#noneMatch" class="headerlink" title="noneMatch"></a>noneMatch</h3><p>noneMatch它可以确保流中没有任何元素与给定的谓词匹配。</p><h3 id="findany"><a href="#findany" class="headerlink" title="findany"></a>findany</h3><p>findAny方法将返回当前流中的任意元素，它返回的是<code>Optional&lt;T&gt;</code></p><h3 id="findFirst"><a href="#findFirst" class="headerlink" title="findFirst"></a>findFirst</h3><p>findFirst查找第一个元素</p><h2 id="归约"><a href="#归约" class="headerlink" title="归约"></a>归约</h2><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><p>使用reduce，你可以像下面这样对流中所有的元素求和：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int sum = numbers.stream().reduce(0, (a, b) -&gt; a + b);</span><br></pre></td></tr></table></figure><p>reduce接受两个参数：</p><ul><li>一个初始值，这里是0；</li><li>一个BinaryOperator来将两个元素结合起来产生一个新值，这里我们用的是 lambda (a, b) -&gt; a + b。</li></ul><p>你也很容易把所有的元素相乘，只需要将另一个Lambda：(a, b) -&gt; a * b传递给reduce 操作就可以了：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int product = numbers.stream().reduce(1, (a, b) -&gt; a * b);</span><br></pre></td></tr></table></figure><p>reduce还有一个重载的变体，它不接受初始值，但是会返回一个Optional对象：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Optional&lt;Integer&gt; sum = numbers.stream().reduce((a, b) -&gt; (a + b));</span><br></pre></td></tr></table></figure><blockquote><p>为什么它返回一个Optional呢？考虑流中没有任何元素的情况。reduce操作无 法返回其和，因为它没有初始值。这就是为什么结果被包裹在一个Optional对象里，以表明和可能不存在。</p><p>map和reduce的连接通常称为map-reduce模式，因Google用它来进行网络搜索而出名， 因为它很容易并行化。</p></blockquote><h3 id="中间操作和终端操作表"><a href="#中间操作和终端操作表" class="headerlink" title="中间操作和终端操作表"></a>中间操作和终端操作表</h3><p><img src="img2.png" alt="操作表"></p><h2 id="数值流"><a href="#数值流" class="headerlink" title="数值流"></a>数值流</h2><p>我们在前面看到了可以使用reduce方法计算流中元素的总和。例如，你可以像下面这样计 算菜单的热量：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int calories = menu.stream() </span><br><span class="line">                .map(Dish::getCalories) </span><br><span class="line">                .reduce(0, Integer::sum);</span><br></pre></td></tr></table></figure><p>这段代码的问题是，它有一个暗含的装箱成本。每个Integer都必须拆箱成一个原始类型， 再进行求和。但是Stream为我们提供了更好的解决办法</p><h3 id="原始类型流特化"><a href="#原始类型流特化" class="headerlink" title="原始类型流特化"></a>原始类型流特化</h3><p>Java 8引入了三个原始类型特化流接口来解决这个问题：IntStream、DoubleStream和 LongStream，分别将流中的元素特化为int、long和double，从而避免了暗含的装箱成本。</p><h3 id="映射到数值流"><a href="#映射到数值流" class="headerlink" title="映射到数值流"></a>映射到数值流</h3><p>将流转换为特化版本的常用方法是mapToInt、mapToDouble和mapToLong。这些方法和前 面说的map方法的工作方式一样，只是它们返回的是一个特化流，而不是Stream。</p><p>你可以像下面这样用mapToInt对menu中的卡路里求和：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int calories = menu.stream() </span><br><span class="line">                .mapToInt(Dish::getCalories) </span><br><span class="line">                .sum();</span><br></pre></td></tr></table></figure><blockquote><p>这里，mapToInt会从每道菜中提取热量（用一个Integer表示），并返回一个IntStream （而不是一个Stream）。然后你就可以调用IntStream接口中定义的sum方法，对卡 路里求和了！请注意，如果流是空的，sum默认返回0。IntStream还支持其他的方便方法，如 max、min、average等。</p></blockquote><h3 id="转换回对象流"><a href="#转换回对象流" class="headerlink" title="转换回对象流"></a>转换回对象流</h3><p>同样，一旦有了数值流，你可能会想把它转换回非特化流。例如，IntStream上的操作只能 产生原始整数： IntStream 的 map 操作接受的 Lambda 必须接受 int 并返回 int （一个IntUnaryOperator）。但是你可能想要生成另一类值，比如Dish。为此，你需要访问Stream 接口中定义的那些更广义的操作。要把原始流转换成一般流（每个int都会装箱成一个 Integer），可以使用boxed方法</p><h3 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a>数值范围</h3><p>假设你想要生成1和100之间的所有数值， Java 8引入了两个可以用于IntStream和LongStream的静态方法，帮助生成这种范围： range和rangeClosed。这两个方法都是第一个参数接受起始值，第二个参数接受结束值。但 range是不包含结束值的，而rangeClosed则包含结束值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里的范围是[1,100] 结果为50个</span></span><br><span class="line"><span class="type">int</span> <span class="variable">evenNumbers</span> <span class="operator">=</span> IntStream.rangeClosed(<span class="number">1</span>, <span class="number">100</span>)</span><br><span class="line">                            .filter(n -&gt; n % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                            .count();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的范围是[1,100) 不包含100 结果为49</span></span><br><span class="line"><span class="type">int</span> <span class="variable">evenNumbers2</span> <span class="operator">=</span> IntStream.range(<span class="number">1</span>, <span class="number">100</span>)</span><br><span class="line">                            .filter(n -&gt; n % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                            .count();</span><br></pre></td></tr></table></figure><h3 id="应用：勾股数"><a href="#应用：勾股数" class="headerlink" title="应用：勾股数"></a>应用：勾股数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">生成N个勾股数三元组，例(3,4,5), (5,12,13)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Stream&lt;<span class="type">double</span>[]&gt; stream = IntStream.rangeClosed(<span class="number">1</span>, <span class="number">100</span>) <span class="comment">// 生成1-100的int(a)</span></span><br><span class="line">    .boxed() <span class="comment">//封装为Stream&lt;Integer&gt;才能继续流的操作</span></span><br><span class="line">    .flatMap(a -&gt; IntStream.rangeClosed(a, <span class="number">100</span>) <span class="comment">//// 生成a-100的int(b)</span></span><br><span class="line">             .mapToObj(b -&gt; <span class="keyword">new</span> <span class="title class_">double</span>[]&#123;a, b, Math.sqrt(a * a + b * b)&#125;)) <span class="comment">//生成三元组 a,b,a^2+b^2的开方</span></span><br><span class="line">    .filter(t -&gt; t[<span class="number">2</span>] % <span class="number">1</span> == <span class="number">0</span>); <span class="comment">// 筛选掉非整数</span></span><br><span class="line">stream.limit(<span class="number">4</span>).forEach(t -&gt; System.out.println(t[<span class="number">0</span>] + <span class="string">&quot;, &quot;</span> + t[<span class="number">1</span>] + <span class="string">&quot;, &quot;</span> + t[<span class="number">2</span>])); <span class="comment">//打印前四个</span></span><br></pre></td></tr></table></figure><h2 id="构建流"><a href="#构建流" class="headerlink" title="构建流"></a>构建流</h2><h3 id="由值创建流"><a href="#由值创建流" class="headerlink" title="由值创建流"></a>由值创建流</h3><p>你可以使用静态方法<code>Stream.of</code>，通过显式值创建一个流。它可以接受任意数量的参数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;Java 8 &quot;</span>, <span class="string">&quot;Lambdas &quot;</span>, <span class="string">&quot;In &quot;</span>, <span class="string">&quot;Action&quot;</span>); </span><br></pre></td></tr></table></figure><p>你可以使用empty得到一个空流，如下所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; emptyStream = Stream.empty();</span><br></pre></td></tr></table></figure><h3 id="数组创建流"><a href="#数组创建流" class="headerlink" title="数组创建流"></a>数组创建流</h3><p>你可以使用静态方法<code>Arrays.stream</code>从数组创建一个流。它接受一个数组作为参数。例如， 你可以将一个原始类型int的数组转换成一个IntStream，如下所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] numbers = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;; </span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> Arrays.stream(numbers).sum();</span><br></pre></td></tr></table></figure><h3 id="由文件生成流"><a href="#由文件生成流" class="headerlink" title="由文件生成流"></a>由文件生成流</h3><p>Java中用于处理文件等I/O操作的NIO API（非阻塞I/O）已更新，以便利用Stream API。 java.nio.file.Files中的很多静态方法都会返回一个流。</p><blockquote><p>例如，一个很有用的方法是Files.lines，它会返回一个由指定文件中的各行构成的字符串流。使用你迄今所学的内容， 你可以用这个方法看看一个文件中有多少各不相同的词：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">uniqueWords</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">Stream&lt;String&gt; lines = Files.lines(Paths.get(<span class="string">&quot;data.txt&quot;</span>), </span><br><span class="line">uniqueWords = lines.flatMap(line -&gt; Arrays.stream(line.split(<span class="string">&quot; &quot;</span>)))</span><br><span class="line">                .distinct() </span><br><span class="line">                .count(); </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="由函数生成无限流"><a href="#由函数生成无限流" class="headerlink" title="由函数生成无限流"></a>由函数生成无限流</h3><p>Stream API提供了两个静态方法来从函数生成流：Stream.iterate和Stream.generate。 这两个操作可以创建所谓的无限流：不像从固定集合创建的流那样有固定大小的流。由iterate 和generate产生的流会用<strong>给定的函数按需创建值</strong>，因此可以无穷无尽地计算下去！一般来说， 应该使用limit(n)来对这种流加以限制</p><h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><p>我们先来看一个iterate的简单例子，然后再解释：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.iterate(<span class="number">0</span>, n -&gt; n + <span class="number">2</span>) </span><br><span class="line">    .limit(<span class="number">10</span>) </span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>iterate方法接受一个初始值（在这里是0），还有一个依次应用在每个产生的新值上的 Lambda（UnaryOperator类型）。这里，我们使用Lambda n -&gt; n + 2，返回的是前一个元 素加上2</p><h4 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h4><p>与iterate方法类似，generate方法也可让你按需生成一个无限流。但generate不是依次 对每个新生成的值应用函数的。它接受一个Supplier类型的Lambda提供新的值。我们先来 看一个简单的用法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.generate(Math::random) </span><br><span class="line">    .limit(<span class="number">5</span>) </span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>这段代码将生成一个流，其中有五个0到1之间的随机双精度数。例如，运行一次得到了下面 的结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0.9410810294106129 </span><br><span class="line">0.6586270755634592 </span><br><span class="line">0.9592859117266873 </span><br><span class="line">0.13743396659487006 </span><br><span class="line">0.3942776037651241</span><br></pre></td></tr></table></figure><p>Math.Random静态方法被用作新值生成器。</p><p>详略。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>《Java8 实战》</li><li><a href="https://github.com/caotinging/Java8Action#%E6%B5%81%E6%98%AF%E4%BB%80%E4%B9%88">《java8实战》学习笔记</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java8 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经典内排序算法汇总</title>
      <link href="/2022/05/18/%E7%BB%8F%E5%85%B8%E5%86%85%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/"/>
      <url>/2022/05/18/%E7%BB%8F%E5%85%B8%E5%86%85%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文介绍几种经典、常考的内排序算法。</p><p>本文试图建立一个比较标准的快速排序、归并排序、堆排序算法代码。</p><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>了解。</p><h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>每一轮选取未排定的部分中<strong>最小</strong>的部分交换到未排定部分的最开头，经过若干个步骤，就能排定整个数组。即：先选出最小的，再选出第 2 小的，以此类推。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>略</p><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>了解</p><h2 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h2><p>每次将一个数字插入一个有序的数组里，成为一个长度更长的有序数组，有限次操作以后，数组整体有序。</p><p><img src="插入排序.gif" alt="插入排序排序"></p><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><p>略</p><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>了解</p><h2 id="算法思想-2"><a href="#算法思想-2" class="headerlink" title="算法思想"></a>算法思想</h2><p>外层循环每一次经过两两比较，把每一轮未排定部分最大的元素放到了数组的末尾；<br>「冒泡排序」有个特点：在遍历的过程中，提前检测到数组是有序的，从而结束排序，而不像「选择排序」那样，即使输入数据是有序的，「选择排序」依然需要「傻乎乎」地走完所有的流程。</p><h2 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h2><p>略</p><h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p>了解</p><h2 id="算法思想-3"><a href="#算法思想-3" class="headerlink" title="算法思想"></a>算法思想</h2><p>插入排序的优化。在插入排序里，如果靠后的数字较小，它来到前面就得交换多次。「希尔排序」改进了这种做法。带间隔地使用插入排序，直到最后「间隔」为 11 的时候，就是标准的「插入排序」，此时数组里的元素已经「几乎有序」了。</p><h2 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h2><p>略</p><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>重要</p><h2 id="算法思想-4"><a href="#算法思想-4" class="headerlink" title="算法思想"></a>算法思想</h2><p>快速排序每一次都排定一个元素（这个元素呆在了它最终应该呆的位置），然后递归地去排它左边的部分和右边的部分，依次进行下去，直到数组有序。</p><h2 id="实现（递归）"><a href="#实现（递归）" class="headerlink" title="实现（递归）"></a>实现（递归）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//https://mp.weixin.qq.com/s/8ZTMhvHJK_He48PpSt_AmQ</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Quick</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 为了避免出现耗时的极端情况，先随机打乱</span></span><br><span class="line">        shuffle(nums);</span><br><span class="line">        <span class="comment">// 排序整个数组（原地修改）</span></span><br><span class="line">        sort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lo &gt;= hi) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对 nums[lo..hi] 进行切分</span></span><br><span class="line">        <span class="comment">// 使得 nums[lo..p-1] &lt;= nums[p] &lt; nums[p+1..hi]</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> partition(nums, lo, hi);</span><br><span class="line"></span><br><span class="line">        sort(nums, lo, p - <span class="number">1</span>);</span><br><span class="line">        sort(nums, p + <span class="number">1</span>, hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对 nums[lo..hi] 进行切分</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> nums[lo];</span><br><span class="line">        <span class="comment">// 关于区间的边界控制需格外小心，稍有不慎就会出错</span></span><br><span class="line">        <span class="comment">// 我这里把 i, j 定义为开区间，同时定义：</span></span><br><span class="line">        <span class="comment">// [lo, i) &lt;= pivot；(j, hi] &gt; pivot</span></span><br><span class="line">        <span class="comment">// 之后都要正确维护这个边界区间的定义</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo + <span class="number">1</span>, j = hi;</span><br><span class="line">        <span class="comment">// 当 i &gt; j 时结束循环，以保证区间 [lo, hi] 都被覆盖</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; hi &amp;&amp; nums[i] &lt;= pivot) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="comment">// 此 while 结束时恰好 nums[i] &gt; pivot</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; lo &amp;&amp; nums[j] &gt; pivot) &#123;</span><br><span class="line">                j--;</span><br><span class="line">                <span class="comment">// 此 while 结束时恰好 nums[j] &lt;= pivot</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 此时 [lo, i) &lt;= pivot &amp;&amp; (j, hi] &gt; pivot</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= j) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将 pivot 放到合适的位置，即 pivot 左边元素较小，右边元素较大</span></span><br><span class="line">        swap(nums, lo, j);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 洗牌算法，将输入的数组随机打乱</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shuffle</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 生成 [i, n - 1] 的随机数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> i + rand.nextInt(n - i);</span><br><span class="line">            swap(nums, i, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原地交换数组中的两个元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现（非递归）"><a href="#实现（非递归）" class="headerlink" title="实现（非递归）"></a>实现（非递归）</h2><p>暂略</p><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>重要</p><h2 id="算法思想-5"><a href="#算法思想-5" class="headerlink" title="算法思想"></a>算法思想</h2><p>借助额外空间，合并两个有序数组，得到更长的有序数组。</p><h2 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Merge</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于辅助合并有序数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] temp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 先给辅助数组开辟内存空间</span></span><br><span class="line">        temp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="comment">// 排序整个数组（原地修改）</span></span><br><span class="line">        sort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义：将子数组 nums[lo..hi] 进行排序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lo == hi) &#123;</span><br><span class="line">            <span class="comment">// 单个元素不用排序</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这样写是为了防止溢出，效果等同于 (hi + lo) / 2</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 先对左半部分数组 nums[lo..mid] 排序</span></span><br><span class="line">        sort(nums, lo, mid);</span><br><span class="line">        <span class="comment">// 再对右半部分数组 nums[mid+1..hi] 排序</span></span><br><span class="line">        sort(nums, mid + <span class="number">1</span>, hi);</span><br><span class="line">        <span class="comment">// 将两部分有序数组合并成一个有序数组</span></span><br><span class="line">        merge(nums, lo, mid, hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 nums[lo..mid] 和 nums[mid+1..hi] 这两个有序数组合并成一个有序数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> mid, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="comment">// 先把 nums[lo..hi] 复制到辅助数组中</span></span><br><span class="line">        <span class="comment">// 以便合并后的结果能够直接存入 nums</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo; i &lt;= hi; i++) &#123;</span><br><span class="line">            temp[i] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数组双指针技巧，合并两个有序数组</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo, j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> lo; p &lt;= hi; p++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == mid + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 左半边数组已全部被合并</span></span><br><span class="line">                nums[p] = temp[j++];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == hi + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 右半边数组已全部被合并</span></span><br><span class="line">                nums[p] = temp[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp[i] &gt; temp[j]) &#123;</span><br><span class="line">                nums[p] = temp[j++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[p] = temp[i++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>重要</p><h2 id="算法思想-6"><a href="#算法思想-6" class="headerlink" title="算法思想"></a>算法思想</h2><p>将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列。</p><h2 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">// 将数组整理成堆</span></span><br><span class="line">        heapify(nums);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环不变量：区间 [0, i] 堆有序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len - <span class="number">1</span>; i &gt;= <span class="number">1</span>; ) &#123;</span><br><span class="line">            <span class="comment">// 把堆顶元素（当前最大）交换到数组末尾</span></span><br><span class="line">            swap(nums, <span class="number">0</span>, i);</span><br><span class="line">            <span class="comment">// 逐步减少堆有序的部分</span></span><br><span class="line">            i--;</span><br><span class="line">            <span class="comment">// 下标 0 位置下沉操作，使得区间 [0, i] 堆有序</span></span><br><span class="line">            siftDown(nums, <span class="number">0</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将数组整理成堆（堆有序）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">// 只需要从 i = (len - 1) / 2 这个位置开始逐层下移</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (len - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            siftDown(nums, i, len - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k    当前下沉元素的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end  [0, end] 是 nums 的有效部分</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftDown</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span> * k + <span class="number">1</span> &lt;= end) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span> * k + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> &lt;= end &amp;&amp; nums[j + <span class="number">1</span>] &gt; nums[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; nums[k]) &#123;</span><br><span class="line">                swap(nums, j, k);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> index1, <span class="type">int</span> index2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[index1];</span><br><span class="line">        nums[index1] = nums[index2];</span><br><span class="line">        nums[index2] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="排序复杂度比较"><a href="#排序复杂度比较" class="headerlink" title="排序复杂度比较"></a>排序复杂度比较</h1><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/sort.png" alt="图片来源：菜鸟教程/十大经典排序"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://leetcode-cn.com/problems/sort-an-array/solution/fu-xi-ji-chu-pai-xu-suan-fa-java-by-liweiwei1419/">复习基础排序算法</a></li><li><a href="https://www.runoob.com/w3cnote/ten-sorting-algorithm.html">菜鸟教程：十大排序算法</a></li><li>《算法 第四版》</li><li><a href="https://mp.weixin.qq.com/s/8ZTMhvHJK_He48PpSt_AmQ">快速排序的正确理解方式及运用</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&amp;mid=2247495989&amp;idx=1&amp;sn=30e34ac75dd1c724205e9c8b0f488e35&amp;scene=21#wechat_redirect">归并排序的正确理解方式及运用</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8新特性1：行为参数化</title>
      <link href="/2022/05/05/Java8%E6%96%B0%E7%89%B9%E6%80%A71%EF%BC%9A%E8%A1%8C%E4%B8%BA%E5%8F%82%E6%95%B0%E5%8C%96/"/>
      <url>/2022/05/05/Java8%E6%96%B0%E7%89%B9%E6%80%A71%EF%BC%9A%E8%A1%8C%E4%B8%BA%E5%8F%82%E6%95%B0%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在软件工程中，一个众所周知的问题就是，<strong>不管你做什么，用户的需求肯定会变</strong>。<br><strong>行为参数化</strong>就是可以帮助你处理频繁变更的需求的一种软件开发模式。一言以蔽之，它意味着拿出一个代码块，把它准备好却不去执行它。这个代码块以后可以被你程序的其他部分调用，这意味着你可以推迟这块代码的执行。例如，你可以将代码块作为参数传递给另一个方法，稍后再去执行它。这样，这个方法的行为就基于那块代码被参数化了。</p><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><p>通过逐步改进案例，来熟悉什么是“行为参数化”。</p><blockquote><p>需求：农民希望筛选出1. 绿色的苹果，2. 重量大于150的苹果 3….</p></blockquote><h2 id="方案1"><a href="#方案1" class="headerlink" title="方案1"></a>方案1</h2><p>可能的代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据颜色筛选苹果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> apples</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> color</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Apple&gt; <span class="title function_">filterByColor</span><span class="params">(List&lt;Apple&gt; apples, String color)</span> &#123;</span><br><span class="line">    List&lt;Apple&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Apple apple : apples) &#123;</span><br><span class="line">        <span class="keyword">if</span>(apple.getColor().equals(color)) &#123;</span><br><span class="line">            res.add(apple);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据重量筛选苹果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> apples</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weight</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Apple&gt; <span class="title function_">filterByWeight</span><span class="params">(List&lt;Apple&gt; apples, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">    List&lt;Apple&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Apple apple : apples) &#123;</span><br><span class="line">        <span class="keyword">if</span>(apple.getWeight() &gt; weight) &#123;</span><br><span class="line">            res.add(apple);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>农民通过调用来获得答案</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">filterByColor(apples, <span class="string">&quot;green&quot;</span>);</span><br><span class="line">filterByWeight(apples, <span class="number">150</span>);</span><br></pre></td></tr></table></figure><p>这样做打破了<strong>DRY（Don’t RepeatYourself，不要重复自己）的软件工程原则</strong>。这样做出现了大量的重复代码，当你想要修改某些逻辑，比如优化遍历语句时，你需要修改所有方法中的代码。</p><p>另一种方案是，把所有参数都整合到一个方法中去，签名如下：<code>public static List&lt;Apple&gt; filterByColor(List&lt;Apple&gt; apples, String color, int weight)</code></p><p>这样做不仅笨拙，而且面对变化不能做出调整，如果有新的筛选条件，比如产地，大小，形状等怎么办？</p><h2 id="方案2：行为参数化"><a href="#方案2：行为参数化" class="headerlink" title="方案2：行为参数化"></a>方案2：行为参数化</h2><p>让我们后退一步来看看更高层次的抽象。一种可能的解决方案是对你的选择标准建模：你考虑的是苹果，需要根据Apple的某些属性（比如它是绿色的吗？重量超过150克吗？）来返回一个boolean值。我们把它称为<strong>谓词</strong>（即一个返回boolean值的函数）。让我们定义一个接口来对选择标准建模：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ApplePredicate</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Apple apple)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们就可以用ApplePredicate的多个实现代表不同的选择标准：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppleGreenColorPredicate</span> <span class="keyword">implements</span> <span class="title class_">ApplePredicate</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Apple apple)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;green&quot;</span>.equals(apple.getColor());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppleHeavyWeightPredicate</span> <span class="keyword">implements</span> <span class="title class_">ApplePredicate</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Apple apple)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> apple.getWeight() &gt; <span class="number">150</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以把这些标准看作filter方法的不同行为。你刚做的这些和“<strong>策略设计模式</strong>”相关，它让你定义一族算法，把它们封装起来（称为“策略”），然后在运行时选择一个算法。在这里，算法族就是ApplePredicate，不同的策略就是AppleHeavyWeightPredicate和AppleGreenColorPredicate。</p><p>但是，该怎么利用ApplePredicate的不同实现呢？你需要filterApples方法接受ApplePredicate对象，对Apple做条件测试。这就是行为参数化：<strong>让方法接受多种行为（或战略）作为参数</strong>，并在内部使用，来完成不同的行为。这在软件工程上有很大好处：现在你把filterApples方法迭代集合的逻辑与你要应用到集合中每个元素的行为（这里是一个谓词）区分开了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Apple&gt; <span class="title function_">filterApples</span><span class="params">(List&lt;Apple&gt; apples, ApplePredicate p)</span> &#123;</span><br><span class="line">    List&lt;Apple&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Apple apple : apples) &#123;</span><br><span class="line">        <span class="keyword">if</span>(p.test(apple)) &#123;</span><br><span class="line">            res.add(apple);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：这样做有一点缺憾就是，我明明重要的只有一个test方法，但是filterApples只能接受对象，所以我们不得不把test方法封装在ApplePredicate对象中进行传递。后面会使用Lambda表达式进行简化。</p><h2 id="方案2-1：使用匿名类改进"><a href="#方案2-1：使用匿名类改进" class="headerlink" title="方案2-1：使用匿名类改进"></a>方案2-1：使用匿名类改进</h2><p>对于以上代码的调用我们要费很大劲，创建ApplePredicate的两个实现类，然后把这两个类实例化传入到filterApples方法中去。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">filterApples(apples, <span class="keyword">new</span> <span class="title class_">AppleGreenColorPredicate</span>());</span><br></pre></td></tr></table></figure><p>我们可以使用匿名类简化这一流程。以筛选出绿色苹果为例，改进后的代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">filterApples(apples, <span class="keyword">new</span> <span class="title class_">ApplePredicate</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Apple apple)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;green&quot;</span>.equals(apple.getColor());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>但匿名类还不够好：</p><ul><li>笨重：每次实现新的<code>new ApplePredicate()</code>都要写很多模板代码<code>...test...</code></li><li>费解：这里不过多解释</li></ul><p>因此我们可以使用Lambda表达式让代码更干净</p><h2 id="方案2-2：使用Lambda表达式"><a href="#方案2-2：使用Lambda表达式" class="headerlink" title="方案2-2：使用Lambda表达式"></a>方案2-2：使用Lambda表达式</h2><p>使用Lambda表达式让上述代码重写为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">filterApples(apples, (Apple apple) -&gt; <span class="string">&quot;green&quot;</span>.equals(apple.getColor()) );</span><br></pre></td></tr></table></figure><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>将苹果按照重量由大到小排序</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对苹果按重量排序，使用java8 Collections.sort</span></span><br><span class="line"><span class="comment">//使用匿名类</span></span><br><span class="line">Collections.sort(apples, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Apple&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Apple a1, Apple a2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a1.getWeight() - a2.getWeight();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用lambda表达式</span></span><br><span class="line">Collections.sort(apples, (Apple a1, Apple a2) -&gt; a1.getWeight() - a2.getWeight() );</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>《Java 8实战》</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 基础知识整理</title>
      <link href="/2022/05/02/Docker-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"/>
      <url>/2022/05/02/Docker-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker-能做什么"><a href="#Docker-能做什么" class="headerlink" title="Docker 能做什么"></a>Docker 能做什么</h1><p>以前学习的时候，想要搭建一个Hadoop集群，那就要安装一个VMWare，然后装至少三个虚拟机。每个虚拟机至少20GB以上，有了Docker，你只需要安装一台虚拟机（Linux操作系统），在这台虚拟机上启动多个Docker容器，每个容器只有几百兆。</p><p>Docker将硬件要求和应用环境之间进一步解耦，大大提升了程序🐒的生产力和幸福指数。</p><p>Docker的应用场景包括但不限于：</p><ul><li>本地依赖：快速尝试开源项目而不用操心环境配置。</li><li>搭建环境：同一个Docker配置可以在不同的环境中运行。</li><li>微服务</li><li>扩容：Docker支持水平扩容。</li><li>……</li></ul><h1 id="Docker和虚拟机技术的比较"><a href="#Docker和虚拟机技术的比较" class="headerlink" title="Docker和虚拟机技术的比较"></a>Docker和虚拟机技术的比较</h1><p>自己查。</p><h1 id="Docker核心组件"><a href="#Docker核心组件" class="headerlink" title="Docker核心组件"></a>Docker核心组件</h1><ul><li>Docker客户端：Client</li><li>Docker服务器：Docker daemon</li><li>Docker镜像：Image</li><li>Registry</li><li>Docker容器：Container</li></ul><p><img src="image-20220428230419609.png" alt="Docker架构"></p><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>Docker客户端是执行Docker命令的地方。<code>docker run</code>等等</p><p>Docker客户端也支持REST API</p><h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><p>Docker daemon运行在Docker host上，负责创建、运行、监控容器，构建、存储镜像。</p><p>Docker服务器默认情况下只响应来自本地Host的客户端请求，如果要允许远程客户端请求，则需要修改配置（Google）</p><h2 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h2><p>Docker镜像看成只读模板，通过它可以创建Docker容器。</p><p>例如某个镜像可能包含一个操作系统、一个Apache HTTP Server以及用户开发的Web应用。</p><p>镜像有多种生成方法：（1）从无到有开始创建镜像；（2）下载并使用别人创建好的现成的镜像；（3）在现有镜像上创建新的镜像。可以将镜像的内容和创建步骤描述在一个文本文件（Dockerfile）中，通过执行dockerbuild 命令可以构建出Docker镜像，后面讨论。</p><h2 id="Docker-容器"><a href="#Docker-容器" class="headerlink" title="Docker 容器"></a>Docker 容器</h2><p>Docker容器就是Docker镜像的运行实例。</p><p>如果镜像是软件生命周期的构建和打包阶段，那么容器则是启动和运行阶段。（类似于程序与线程的关系。）</p><h2 id="Registry"><a href="#Registry" class="headerlink" title="Registry"></a>Registry</h2><p>Registry是存放Docker镜像的仓库。</p><h1 id="hello-word"><a href="#hello-word" class="headerlink" title="hello-word"></a>hello-word</h1><p>本节介绍Docker安装到运行一个Container的基本流程。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">官方安装脚本自动安装</span></span><br><span class="line">curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun</span><br></pre></td></tr></table></figure><h2 id="启动Docker服务器"><a href="#启动Docker服务器" class="headerlink" title="启动Docker服务器"></a>启动Docker服务器</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><h2 id="拉取hello-world镜像"><a href="#拉取hello-world镜像" class="headerlink" title="拉取hello-world镜像"></a>拉取hello-world镜像</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull hello-world </span><br></pre></td></tr></table></figure><h2 id="查看image信息"><a href="#查看image信息" class="headerlink" title="查看image信息"></a>查看image信息</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop01 ~]# docker images hello-world</span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED        SIZE</span><br><span class="line">hello-world   latest    feb5d9fea6a5   7 months ago   13.3kB</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="运行hello-world"><a href="#运行hello-world" class="headerlink" title="运行hello-world"></a>运行hello-world</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop01 ~]# docker run hello-world</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="查看Dockerfile"><a href="#查看Dockerfile" class="headerlink" title="查看Dockerfile"></a>查看Dockerfile</h2><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> scratch</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> hello/</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;hello/&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>只有短短三条指令。</p><ol><li>FROM scratch：镜像是从白手起家，从0开始构建。</li><li>COPY hello/：将宿主机上的文件“hello”复制到镜像的根目录。</li><li>CMD[“/hello”]：容器启动时，执行/hello。</li></ol><h1 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h1><h2 id="base-镜像"><a href="#base-镜像" class="headerlink" title="base 镜像"></a>base 镜像</h2><p>hello-world虽然是一个完整的镜像，但它并没有什么实际用途。通常来说，我们希望镜像能提供一个基本的操作系统环境，用户可以根据需要安装和配置软件。这样的镜像我们称作base镜像。</p><p>base镜像有两层含义：（1）不依赖其他镜像，从scratch构建；（2）其他镜像可以以之为基础进行扩展。</p><p>能称作base镜像的通常都是各种Linux发行版的Docker镜像，比如Ubuntu、Debian、CentOS等。</p><p>我们尝试下载并查看centos的镜像：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop01 ~]# docker pull centos</span><br><span class="line">...</span><br><span class="line">[root@hadoop01 ~]# docker images centos</span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED        SIZE</span><br><span class="line">centos       latest    5d0da3dc9764   7 months ago   231MB</span><br></pre></td></tr></table></figure><blockquote><p>为什么一个centos镜像只有200MB？</p><p>答：Linux操作系统由内核空间（bootfs/kernel）和用户空间（rootfs）组成。</p><p>Linux刚启动时会加载bootfs文件系统，之后bootfs会被卸载掉。</p><p>用户空间的文件系统是rootfs，包含我们熟悉的/dev、/proc、/bin等目录。对于base镜像来说，底层直接用Host的kernel，自己只需要提供rootfs就行了。<strong>而对于一个精简的OS, rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了。</strong></p><p>因此，base镜像只是在用户空间与发行版一致，kernel版本与发行版是不同的。镜像的Kernel版本取决于Docker Host（Docker装在哪台机器上，这台机器就是Docker Host）。所以容器只能使用Host的kernel，并且不能修改</p><p>base镜像提供的是最小安装的Linux发行版。</p></blockquote><h2 id="镜像分层"><a href="#镜像分层" class="headerlink" title="镜像分层"></a>镜像分层</h2><p>我们拿一个Dockerfile来举例：</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> debian</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install emacs</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install apach2</span></span><br></pre></td></tr></table></figure><p>上述构建过程如图所示：</p><p><img src="image-20220428234124163.png" alt="构建"></p><p>可以看到，新镜像是从base镜像一层一层叠加生成的。每安装一个软件，就在现有镜像的基础上增加一层。</p><blockquote><p>为什么Docker镜像要采用这种分层结构呢？</p><ul><li>最大的一个好处就是：共享资源。比如：有多个镜像都从相同的base镜像构建而来，那么Docker Host只需在磁盘上保存一份base镜像；同时内存中也只需加载一份base镜像，就可以为所有容器服务了，而且镜像的每一层都可以被共享，我们将在后面更深入地讨论这个特性。</li></ul><p>如果多个容器共享一份基础镜像，当某个容器修改了基础镜像的内容，比如/etc下的文件，这时其他容器的 /etc是否也会被修改？</p><ul><li>答案是不会！修改会被限制在单个容器内。这就是我们接下来要学习的容器Copy-on-Write特性。</li></ul></blockquote><h2 id="Copy-on-Write特性"><a href="#Copy-on-Write特性" class="headerlink" title="Copy-on-Write特性"></a>Copy-on-Write特性</h2><p>对于Dockerfile的每一行构建语句都会增加一层镜像，而当容器启动时，一个新的<strong>可写层</strong>被加载到镜像的顶部。这是特殊的一层，这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。所有对容器的改动，无论添加、删除，还是修改文件都只会发生在容器层中。<strong>只有容器层是可写的，容器层下面的所有镜像层都是只读的。</strong></p><ol><li>添加文件。在容器中创建文件时，新文件被添加到容器层中。</li><li>读取文件。在容器中读取某个文件时，Docker会从上往下依次在各镜像层中查找此文件。一旦找到，打开并读入内存。</li><li>修改文件。在容器中修改已存在的文件时，Docker会从上往下依次在各镜像层中查找此文件。一旦找到，<strong>立即将其复制到容器层</strong>，然后修改之。</li><li>删除文件。在容器中删除文件时，Docker也是从上往下依次在镜像层中查找此文件。找到后，会在容器层中记录下此删除操作。</li></ol><p>只有当需要修改时才复制一份数据，这种特性被称作Copy-on-Write。可见，容器层保存的是镜像变化的部分，不会对镜像本身进行任何修改。</p><p>这样就解释了我们前面提出的问题：容器层记录对镜像的修改，所有镜像层都是只读的，不会被容器修改，所以镜像可以被多个容器共享。</p><h2 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h2><p>Docker提供了两种构建镜像的方法： <code>docker commit</code>命令与Dockerfile构建文件。</p><h3 id="docker-commit（不推荐）"><a href="#docker-commit（不推荐）" class="headerlink" title="docker commit（不推荐）"></a>docker commit（不推荐）</h3><p>docker commit命令是创建新镜像最直观的方法，其过程包含三个步骤：运行容器。修改容器。将容器保存为新的镜像。</p><p>下面的例子将在CentOS base镜像中安装vim并保存为新镜像：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it ubuntu # 启动Container并进入容器</span><br><span class="line">vim # command not found</span><br><span class="line">apt-get install -y vim # 安装vim</span><br><span class="line">vim # 发现命令可以执行成功了</span><br></pre></td></tr></table></figure><p>在新窗口使用命令查看容器：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop01 ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE             COMMAND       CREATED          STATUS          PORTS     NAMES</span><br><span class="line">013be1649d31   centos:7.2.1511   &quot;/bin/bash&quot;   54 seconds ago   Up 53 seconds             frosty_kowalevski</span><br></pre></td></tr></table></figure><p>frosty_kowalevski是Docker为我们的容器随机分配的名字。</p><p>执行docker commit命令将容器保存为镜像，然后查看镜像</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop01 ~]# docker commit frosty_kowalevski centos_test</span><br><span class="line">sha256:5889b0d6ca05e96a7d1ba31dcc732d36b0651ebf7725bf0fb91def9aa2211420</span><br><span class="line">[root@hadoop01 ~]# docker images</span><br><span class="line">REPOSITORY    TAG        IMAGE ID       CREATED         SIZE</span><br><span class="line">centos_test   latest     5889b0d6ca05   6 seconds ago   409MB</span><br><span class="line">httpd         latest     c30a46771695   10 days ago     144MB</span><br><span class="line">hello-world   latest     feb5d9fea6a5   7 months ago    13.3kB</span><br><span class="line">centos        7.2.1511   9aec5c5fe4ba   3 years ago     195MB</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上演示了如何用docker commit创建新镜像。然而，Docker并不建议用户通过这种方式构建镜像。原因如下：</p><ol><li>这是一种手工创建镜像的方式，容易出错，效率低且可重复性弱。比如要在debian base镜像中也加入vi，还得重复前面的所有步骤。</li><li>更重要的：使用者并不知道镜像是如何创建出来的，里面是否有恶意程序。也就是说无法对镜像进行审计，存在安全隐患。</li></ol><p>既然docker commit不是推荐的方法，我们为什么还要花时间学习呢？原因是：即便是用Dockerfile（推荐方法）构建镜像，底层也是docker commit一层一层构建新镜像的。学习docker commit能够帮助我们更加深入地理解构建过程和镜像的分层结构。</p><h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><p>使用Dockerfile创建上一节的centos_test镜像</p><h4 id="编辑Dockerfile文件"><a href="#编辑Dockerfile文件" class="headerlink" title="编辑Dockerfile文件"></a>编辑Dockerfile文件</h4><p>创建一个Dockerfile，内容为</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos:<span class="number">7.2</span>.<span class="number">1511</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum -y install vim</span></span><br></pre></td></tr></table></figure><blockquote><p>注意这里<code>-y</code>必须加，否则在执行yum install时，很可能因为需要用户输入<code>yes</code>而失败</p></blockquote><p>执行build命令，并进行分析：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop01 docker]# pwd</span><br><span class="line">/root/docker</span><br><span class="line">[root@hadoop01 docker]# ls</span><br><span class="line">Dockerfile</span><br><span class="line">[root@hadoop01 docker]# docker build -t centos-vim-dockerfile-image .</span><br><span class="line">Sending build context to Docker daemon  2.048kB</span><br><span class="line">Step 1/2 : FROM centos:7.2.1511</span><br><span class="line"><span class="meta prompt_"> ---&gt; </span><span class="language-bash">9aec5c5fe4ba</span></span><br><span class="line">Step 2/2 : RUN yum install vim</span><br><span class="line"><span class="meta prompt_"> ---&gt; </span><span class="language-bash">Running <span class="keyword">in</span> 1caec46cd6a4</span></span><br><span class="line">Loaded plugins: fastestmirror</span><br><span class="line">……</span><br><span class="line">Successfully built b93576fddd48</span><br><span class="line">Successfully tagged centos-vim-dockerfile-image:latest</span><br></pre></td></tr></table></figure><ol><li>第三行显示文件夹下的所有文件，这里只有我们编写好的Dockerfile，值得注意的是，文件名必须叫“Dockerfile”否则执行docker build时会显示文件不存在。</li><li>第五行执行docker build命令，-t参数指定了镜像的名字，最后的点表示指定docker context为当前目录。</li><li>关于docker context：Docker默认会从build context中查找Dockerfile文件；Docker将build context中的所有文件发送给Docker daemon；Dockerfile中的ADD、COPY等命令可以将build context中的文件添加到镜像。因此不要在docker context加入不需要的文件。</li><li>第7到14行显示了执行docker build的具体过程。</li></ol><p>构建好的镜像可以通过docker history命令查看构建过程：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop01 docker]# docker history centos-vim-dockerfile-image:latest </span><br><span class="line">IMAGE          CREATED         CREATED BY                                      SIZE      COMMENT</span><br><span class="line">b93576fddd48   6 minutes ago   /bin/sh -c yum -y install vim                   214MB     </span><br><span class="line">9aec5c5fe4ba   3 years ago     /bin/sh -c #(nop)  CMD [&quot;/bin/bash&quot;]            0B        </span><br><span class="line">&lt;missing&gt;      3 years ago     /bin/sh -c #(nop)  LABEL license=GPLv2          0B        </span><br><span class="line">&lt;missing&gt;      3 years ago     /bin/sh -c #(nop)  LABEL vendor=CentOS          0B        </span><br><span class="line">&lt;missing&gt;      3 years ago     /bin/sh -c #(nop)  LABEL name=CentOS Base Im…   0B        </span><br><span class="line">&lt;missing&gt;      3 years ago     /bin/sh -c #(nop) ADD file:e76000d9816e4e380…   195MB     </span><br><span class="line">&lt;missing&gt;      3 years ago     /bin/sh -c #(nop)  MAINTAINER The CentOS Pro…   0B        </span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="镜像的缓存特性"><a href="#镜像的缓存特性" class="headerlink" title="镜像的缓存特性"></a>镜像的缓存特性</h4><p>Docker会缓存已有镜像的镜像层，构建新镜像时，如果某镜像层已经存在，就直接使用，无须重新创建。</p><p>例如在之前的Dockerfile中加入一行：</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos:<span class="number">7.2</span>.<span class="number">1511</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum -y install vim</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> <span class="built_in">test</span>/</span></span><br></pre></td></tr></table></figure><p>则在执行的过程中，之前已经运行过相同的RUN指令，这次直接使用缓存中的镜像层</p><h4 id="Dockerfile构建过程"><a href="#Dockerfile构建过程" class="headerlink" title="Dockerfile构建过程"></a>Dockerfile构建过程</h4><p>总结一下通过Dockerfile构建镜像的过程：</p><ol><li>从base镜像运行一个容器。</li><li>执行一条指令，对容器做修改。</li><li>执行类似docker commit的操作，生成一个新的镜像层。</li><li>Docker再基于刚刚提交的镜像运行一个新容器。</li><li>重复2～4步，直到Dockerfile中的所有指令执行完毕。</li></ol><p>从这个过程可以看出，如果Dockerfile由于某种原因执行到某个指令失败了，我们也将能够得到前一个指令成功执行构建出的镜像，这对调试Dockerfile非常有帮助。</p><h4 id="调试Dockerfile"><a href="#调试Dockerfile" class="headerlink" title="调试Dockerfile"></a>调试Dockerfile</h4><p>一句话概括就是：启动失败的前一层构建成功镜像的容器，进入容器，执行失败的语句，从而查看问题所在。</p><h2 id="分发镜像"><a href="#分发镜像" class="headerlink" title="分发镜像"></a>分发镜像</h2><h3 id="docker-tag"><a href="#docker-tag" class="headerlink" title="docker tag"></a>docker tag</h3><p>这里注意tag为lastest，注意docker tag的合并方式。</p><h3 id="使用公共的Registry"><a href="#使用公共的Registry" class="headerlink" title="使用公共的Registry"></a>使用公共的Registry</h3><p>看官方文档去。</p><h1 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h1><h2 id="运行容器的三种方法"><a href="#运行容器的三种方法" class="headerlink" title="运行容器的三种方法"></a>运行容器的三种方法</h2><ul><li>CMD指令</li><li>ENTRYPOINT指令</li><li>在docker run命令行中指定，例如，<code>docker run ubuntu pwd</code></li></ul><h2 id="长期运行容器"><a href="#长期运行容器" class="headerlink" title="长期运行容器"></a>长期运行容器</h2><p>容器在执行完启动时的指令后就会退出。想要让容器保持运行状态，那运行的命令不退出就好了。。</p><h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><p>在容器running时，我们可以进入容器work，有两种方法，</p><ul><li>docker attach</li><li>docker exec</li></ul><p>详细见常用命令总结章节</p><p>docker attach和docker exec区别：</p><ol><li>attach直接进入容器启动命令的终端，不会启动新的进程。</li><li>exec则是在容器中打开新的终端，并且可以启动新的进程。</li><li>如果想直接在终端中查看启动命令的输出，用attach；其他情况使用exec。</li></ol><h2 id="docker-start-stop-restart"><a href="#docker-start-stop-restart" class="headerlink" title="docker start/stop/restart"></a>docker start/stop/restart</h2><p>容器在docker host中实际上是一个进程，通过<code>docker start/stop/restart &lt;container id&gt;</code>命令启动，停止和重启容器。</p><h2 id="docker-pause-unpause"><a href="#docker-pause-unpause" class="headerlink" title="docker pause/unpause"></a>docker pause/unpause</h2><p>通过<code>docker pause/unpause &lt;container id&gt;</code>命令暂停和恢复容器。</p><h2 id="docker-rm"><a href="#docker-rm" class="headerlink" title="docker rm"></a>docker rm</h2><p>通过<code>docker rm &lt;container id&gt;</code>命令删除容器。</p><h2 id="docker生命周期"><a href="#docker生命周期" class="headerlink" title="docker生命周期"></a>docker生命周期</h2><p><img src="image-20220502225040947.png" alt="docker生命周期"></p><h2 id="资源限制"><a href="#资源限制" class="headerlink" title="资源限制"></a>资源限制</h2><p>一个docker host 会运行若干容器，对于容器，Docker也提供了类似的机制避免某个容器因占用太多资源而影响其他容器乃至整个host的性能。</p><p>docker 提供命令以限制容器的内存，CPU，BlockIO（磁盘读写）等。</p><p>具体请查阅相关资料。</p><h2 id="实现容器的底层技术"><a href="#实现容器的底层技术" class="headerlink" title="实现容器的底层技术"></a>实现容器的底层技术</h2><p>cgroup和namespace是最重要的两种技术。cgroup实现资源限额，namespace实现资源隔离。</p><p>Linux使用了6种namespace，分别对应6种资源：Mount、UTS、IPC、PID、Network和User。</p><p>具体用到再说。</p><h1 id="Docker-网络"><a href="#Docker-网络" class="headerlink" title="Docker 网络"></a>Docker 网络</h1><p>4种网络：</p><ul><li>none：封闭网络，对安全性要求高并且不需要联网的应用可以使用none网络。</li><li>host： 连接到host网络的容器共享Docker host的网络栈，容器的网络配置与host完全一样。可以通过 —network=host指定使用host网络。</li><li>bridge：Docker安装时会创建一个命名为docker0的Linuxbridge。如果不指定—network，创建的容器默认都会挂到docker0上。</li><li>user-defined：除了none、host、bridge这三个自动创建的网络，用户也可以根据业务需要创建user-defined网络。</li></ul><h2 id="容器间通信"><a href="#容器间通信" class="headerlink" title="容器间通信"></a>容器间通信</h2><p>待补充</p><h2 id="将容器与外部世界连接"><a href="#将容器与外部世界连接" class="headerlink" title="将容器与外部世界连接"></a>将容器与外部世界连接</h2><p>待补充</p><h1 id="Docker-存储"><a href="#Docker-存储" class="headerlink" title="Docker 存储"></a>Docker 存储</h1><p>待补充</p><h1 id="常用命令总结"><a href="#常用命令总结" class="headerlink" title="常用命令总结"></a>常用命令总结</h1><h2 id="Docker镜像-1"><a href="#Docker镜像-1" class="headerlink" title="Docker镜像"></a>Docker镜像</h2><h3 id="docker-images"><a href="#docker-images" class="headerlink" title="docker  images"></a>docker  images</h3><p>列出镜像</p><p><code>docker images [OPTIONS] [REPOSITORY[:TAG]]</code></p><p>OPTIONS说明：</p><ul><li><strong>-a :</strong>列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）；</li></ul><h3 id="docker-rmi"><a href="#docker-rmi" class="headerlink" title="docker rmi"></a>docker rmi</h3><p><code>docker rmi [OPTIONS] IMAGE [IMAGE...]</code></p><p>删除本地镜像</p><h3 id="docker-build"><a href="#docker-build" class="headerlink" title="docker build"></a>docker build</h3><p>使用 Dockerfile 创建镜像。</p><p><code>docker build [OPTIONS] PATH | URL | -</code></p><p>OPTIONS说明：</p><ul><li><strong>—build-arg=[] :</strong>设置镜像创建时的变量；</li><li><strong>—cpu-shares :</strong>设置 cpu 使用权重；</li><li><strong>-f :</strong>指定要使用的Dockerfile路径；</li><li><strong>—force-rm :</strong>设置镜像过程中删除中间容器；</li><li><strong>—isolation :</strong>使用容器隔离技术；</li><li><strong>-m :</strong>设置内存最大值；</li><li><strong>—memory-swap :</strong>设置Swap的最大值为内存+swap，”-1”表示不限swap；</li><li><strong>—no-cache :</strong>创建镜像的过程不使用缓存；</li><li><strong>—pull :</strong>尝试去更新镜像的新版本；</li><li><strong>—quiet, -q :</strong>安静模式，成功后只输出镜像 ID；</li><li><strong>—rm :</strong>设置镜像成功后删除中间容器；</li><li><strong>—tag, -t:</strong> 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。</li><li><strong>—network:</strong> 默认 default。在构建期间设置RUN指令的网络模式</li></ul><h3 id="docker-history"><a href="#docker-history" class="headerlink" title="docker history"></a>docker history</h3><p>查看指定镜像的创建历史。</p><p><code>docker history [OPTIONS] IMAGE</code></p><hr><h3 id="docker-login"><a href="#docker-login" class="headerlink" title="docker login"></a>docker login</h3><p> 登陆到一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub</p><h3 id="docker-pull"><a href="#docker-pull" class="headerlink" title="docker pull"></a>docker pull</h3><p>拉取镜像</p><h3 id="docker-push"><a href="#docker-push" class="headerlink" title="docker push"></a>docker push</h3><p>推送镜像</p><h3 id="docker-search"><a href="#docker-search" class="headerlink" title="docker search"></a>docker search</h3><p>查找镜像</p><h2 id="Docker-容器-1"><a href="#Docker-容器-1" class="headerlink" title="Docker 容器"></a>Docker 容器</h2><h3 id="docker-run"><a href="#docker-run" class="headerlink" title="docker run"></a>docker run</h3><p><strong>docker run ：</strong>创建一个新的容器并运行一个命令</p><p><code>docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</code></p><p>OPTIONS说明：</p><ul><li><strong>-d:</strong> 后台运行容器，并返回容器ID；</li><li><strong>-i:</strong> 以交互模式运行容器，通常与 -t 同时使用；</li><li><strong>-p:</strong> 指定端口映射，格式为：<strong>主机(宿主)端口:容器端口</strong></li><li><strong>-t:</strong> 为容器重新分配一个伪输入终端，通常与 -i 同时使用；</li><li><strong>—name=”nginx-lb”:</strong> 为容器指定一个名称；</li><li><strong>—dns 8.8.8.8:</strong> 指定容器使用的DNS服务器，默认和宿主一致；</li><li><strong>—dns-search example.com:</strong> 指定容器DNS搜索域名，默认和宿主一致；</li><li><strong>-h “mars”:</strong> 指定容器的hostname；</li><li><strong>-e username=”ritchie”:</strong> 设置环境变量；</li><li><strong>-m :</strong>设置容器使用内存最大值；</li><li><strong>—net=”bridge”:</strong> 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型；</li><li><strong>—expose=[]:</strong> 开放一个端口或一组端口；</li></ul><h3 id="docker-start-stop-restart-1"><a href="#docker-start-stop-restart-1" class="headerlink" title="docker start/stop/restart"></a>docker start/stop/restart</h3><p><strong>docker start</strong> :启动一个或多个已经被停止的容器</p><p><strong>docker stop</strong> :停止一个运行中的容器</p><p><strong>docker restart</strong> :重启容器</p><h3 id="docker-rm-1"><a href="#docker-rm-1" class="headerlink" title="docker rm"></a>docker rm</h3><p><strong>docker rm ：</strong>删除一个或多个容器。</p><h3 id="docker-pause-unpause-1"><a href="#docker-pause-unpause-1" class="headerlink" title="docker pause/unpause"></a>docker pause/unpause</h3><p><strong>docker pause</strong> :暂停容器中所有的进程。</p><p><strong>docker unpause</strong> :恢复容器中所有的进程。</p><h3 id="docker-create"><a href="#docker-create" class="headerlink" title="docker create"></a>docker create</h3><p><strong>docker create ：</strong>创建一个新的容器但不启动它；用法同docker run</p><h3 id="docker-attach"><a href="#docker-attach" class="headerlink" title="docker attach"></a>docker attach</h3><p><strong>docker attach :</strong>连接到正在运行中的容器。</p><p>要attach上去的容器必须正在运行，可以同时连接上同一个container来共享屏幕（与screen命令的attach类似）。</p><h3 id="docker-exec"><a href="#docker-exec" class="headerlink" title="docker exec"></a>docker exec</h3><p><strong>docker exec ：</strong>在运行的容器中执行命令</p><p><code>docker exec [OPTIONS] CONTAINER COMMAND [ARG...]</code></p><p>OPTIONS说明：</p><ul><li><strong>-d :</strong>分离模式: 在后台运行</li><li><strong>-t :</strong>分配一个伪终端</li></ul><h3 id="docker-ps"><a href="#docker-ps" class="headerlink" title="docker ps"></a>docker ps</h3><p>列出容器</p><p><code>docker ps [OPTIONS]</code></p><p>OPTIONS说明：</p><ul><li><strong>-a :</strong>显示所有的容器，包括未运行的。</li><li><strong>-n :</strong>列出最近创建的n个容器。</li><li><strong>-q :</strong>静默模式，只显示容器编号。</li></ul><h3 id="docker-inspect"><a href="#docker-inspect" class="headerlink" title="docker inspect"></a>docker inspect</h3><p><strong>docker inspect :</strong> 获取容器/镜像的元数据。</p><h3 id="docker-top"><a href="#docker-top" class="headerlink" title="docker top"></a>docker top</h3><p>查看容器中运行的进程信息，支持 ps 命令参数。</p><p>容器运行时不一定有/bin/bash终端来交互执行top命令，而且容器还不一定有top命令，可以使用docker top来实现查看container中正在运行的进程。</p><h3 id="docker-logs"><a href="#docker-logs" class="headerlink" title="docker logs"></a>docker logs</h3><p>获取容器的日志</p><h3 id="docker-commit"><a href="#docker-commit" class="headerlink" title="docker commit"></a>docker commit</h3><p>从容器创建一个新的镜像。</p><p><code>docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</code></p><p>OPTIONS说明：</p><ul><li><strong>-a :</strong>提交的镜像作者；</li><li><strong>-c :</strong>使用Dockerfile指令来创建镜像；</li><li><strong>-m :</strong>提交时的说明文字；</li><li><strong>-p :</strong>在commit时，将容器暂停。</li></ul><h3 id="docker-cp"><a href="#docker-cp" class="headerlink" title="docker cp"></a>docker cp</h3><p>用于容器与主机之间的数据拷贝。</p><p>例如：将主机/www/runoob目录拷贝到容器96f7f14e99ab的/www目录下。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker cp /www/runoob 96f7f14e99ab:/www/</span><br></pre></td></tr></table></figure><h2 id="Dockerfile-1"><a href="#Dockerfile-1" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><ul><li>FROM指定base镜像。</li><li>MAINTAINER设置镜像的作者，可以是任意字符串。</li><li>COPY将文件从build context复制到镜像。COPY支持两种形式： COPY src dest与COPY [“src”, “dest”]。注意：src只能指定build context中的文件或目录。</li><li>ADD与COPY类似，从build context复制文件到镜像。不同的是，如果src是归档文件（tar、zip、tgz、xz等），文件会被自动解压到dest。</li><li>ENV设置环境变量，环境变量可被后面的指令使用。</li><li>EXPOSE指定容器中的进程会监听某个端口，Docker可以将该端口暴露出来。我们会在容器网络部分详细讨论。</li><li>VOLUME将文件或目录声明为volume。我们会在容器存储部分详细讨论。</li><li>WORKDIR为后面的RUN、CMD、ENTRYPOINT、ADD或COPY指令设置镜像中的当前工作目录。</li><li>RUN在容器中运行指定的命令。</li><li>CMD容器启动时运行指定的命令。Dockerfile中可以有多个CMD指令，但只有最后一个生效。CMD可以被dockerrun之后的参数替换。</li><li>ENTRYPOINT设置容器启动时运行的命令。Dockerfile中可以有多个ENTRYPOINT指令，但只有最后一个生效。CMD或docker run之后的参数会被当作参数传递给ENTRYPOINT。</li></ul><h3 id="RUN-vs-CMD-vs-ENTRYPOINT"><a href="#RUN-vs-CMD-vs-ENTRYPOINT" class="headerlink" title="RUN vs CMD vs ENTRYPOINT"></a>RUN vs CMD vs ENTRYPOINT</h3><p>略</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>《每天五分钟玩转Docker容器技术》</li></ol>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap知识整理</title>
      <link href="/2022/04/21/HashMap%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"/>
      <url>/2022/04/21/HashMap%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Java为数据结构中的映射定义了一个接口java.util.Map，此接口主要有四个常用的实现类，分别是HashMap、Hashtable、LinkedHashMap和TreeMap，类继承关系如下图所示：</p><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/f7fe16a2.png" alt="Map类图"></p><ol><li><strong>HashMap</strong>：它根据键的hashCode值存储数据，<strong>遍历顺序不确定</strong>。 HashMap<strong>最多只允许一条记录的key为null</strong>，允许多条记录的value为null。HashMap<strong>非线程安全</strong>，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。</li><li><strong>Hashtable</strong>：Hashtable是遗留类，不再推荐使用。</li><li><strong>LinkedHashMap</strong>：LinkedHashMap是HashMap的一个子类，<strong>保存了记录的插入顺序</strong>，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。</li><li><strong>TreeMap</strong>：TreeMap实现SortedMap接口，能够<strong>把它保存的记录根据键排序</strong>，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator**，否则会在运行时抛出java.lang.ClassCastException类型的异常。</li></ol><p>对于上述四种Map类型的类，要求映射中的key是<strong>不可变对象</strong>。不可变对象是该对象在创建后它的哈希值不会被改变。如果对象的哈希值发生变化，Map对象很可能就定位不到映射的位置了。</p><h1 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h1><p>从结构实现来讲，HashMap是数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下如所示。</p><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/e4a19398.png" alt="HashMap存储结构"></p><h2 id="什么是Node"><a href="#什么是Node" class="headerlink" title="什么是Node"></a>什么是Node</h2><p>源码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> hash;    <span class="comment">//用来定位数组索引位置</span></span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;   <span class="comment">//链表的下一个node</span></span><br><span class="line"></span><br><span class="line">        Node(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123; ... &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> K <span class="title function_">getKey</span><span class="params">()</span>&#123; ... &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">getValue</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">setValue</span><span class="params">(V newValue)</span> &#123; ... &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)。上图中的每个黑色圆点就是一个Node对象。</p><blockquote><p>Map.Entry是Map声明的一个内部接口，此接口为泛型，定义为Entry<K,V>。它表示Map中的一个实体（一个key-value对）。接口中有getKey(), getValue方法。</p></blockquote><h2 id="HashMap存储"><a href="#HashMap存储" class="headerlink" title="HashMap存储"></a>HashMap存储</h2><p>HashMap就是使用哈希表来存储的。哈希表为解决冲突，可以采用开放地址法和链地址法等来解决问题，Java中HashMap采用了<strong>链地址法</strong>。链地址法，简单来说，就是数组加链表的结合。在每个数组元素上都一个链表结构，当数据被Hash后，得到数组下标，把数据放在对应下标元素的链表上。</p><p>对于HashMap来说，调用<code>map.put(key, value)</code>方法时，先通过<code>key.hashCode()</code>得到hashCode值（该方法适用于每个Java对象），在对hashCode值进行Hash运算来确定该键值对在哈希桶数组中的存储位置。如果两个key会定位到相同的位置，表示发生了Hash冲突。</p><p>HashMap的存储效率取决于Hash算法和哈希桶数组的大小。如果哈希桶数组很大，即使较差的Hash算法也会比较分散，如果哈希桶数组数组很小，即使好的Hash算法也会出现较多碰撞，所以就需要在空间成本和时间成本之间权衡，其实就是在根据实际情况确定哈希桶数组的大小，并在此基础上设计好的hash算法减少Hash碰撞。那么通过什么方式来控制map使得Hash碰撞的概率又小，哈希桶数组（Node[] table）占用空间又少呢？答案就是好的<strong>Hash算法</strong>和<strong>扩容机制</strong>。</p><h2 id="HashMap关键变量"><a href="#HashMap关键变量" class="headerlink" title="HashMap关键变量"></a>HashMap关键变量</h2><p>在理解Hash和扩容流程之前，我们得先了解下HashMap的几个字段。从HashMap的默认构造函数源码可知，构造函数就是对下面几个字段进行初始化，源码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="type">int</span> threshold;             <span class="comment">// 所能容纳的key-value对极限 </span></span><br><span class="line"><span class="keyword">final</span> <span class="type">float</span> loadFactor;    <span class="comment">// 负载因子</span></span><br><span class="line"><span class="type">int</span> modCount;  </span><br><span class="line"><span class="type">int</span> size;</span><br></pre></td></tr></table></figure><ul><li>table是哈希桶数组，它默认初始化长度length为16</li><li>loadFactor为负载因子(默认值是0.75)</li><li>threshold是HashMap所能容纳的最大数据量的Node(键值对)个数</li><li>threshold = length * Load factor，也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。</li><li>负载因子的定义公式可知，threshold就是在此Load factor和length(数组长度)对应下允许的<strong>最大元素数目</strong>，超过这个数目就重新resize(扩容)，<strong>扩容后的HashMap容量是之前容量的两倍</strong>。默认的负载因子0.75是对空间和时间效率的一个平衡选择，建议大家不要修改，除非在时间和空间比较特殊的情况下，如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值；相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。</li><li>size就是HashMap中<strong>实际存在的键值对数量</strong>。</li><li>modCount字段主要用来记录HashMap内部结构发生变化的次数（比如扩容， 或者链表变为红黑树），主要用于迭代的快速失败。强调一点，内部结构发生变化指的是结构发生变化，例如put新键值对，但是某个key对应的value值被覆盖不属于结构变化。</li></ul><h2 id="哈希桶数组的设计"><a href="#哈希桶数组的设计" class="headerlink" title="哈希桶数组的设计"></a>哈希桶数组的设计</h2><p>在HashMap中，哈希桶数组table的长度length大小必须为2的n次方(一定是合数)，这是一种<strong>非常规</strong>的设计，常规的设计是把桶的大小设计为素数。相对来说素数导致冲突的概率要小于合数，具体证明可以参考<a href="http://blog.csdn.net/liuqiyao_01/article/details/14475159">这篇文章</a>，Hashtable初始化桶大小为11，就是桶大小设计为素数的应用（Hashtable扩容后不能保证还是素数）。HashMap采用这种非常规设计，主要是<strong>为了在取模和扩容时做优化</strong>。同时为了减少冲突，HashMap定位哈希桶索引位置时，也加入了高位参与运算的过程。</p><p>这里存在一个问题，即使负载因子和Hash算法设计的再合理，也免不了会出现拉链过长的情况（即链表很长），一旦出现拉链过长，则会严重影响HashMap的性能。于是，在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树。而当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入、删除、查找等算法。本文不再对红黑树展开讨论，想了解更多红黑树数据结构的工作原理可以参考<a href="http://blog.csdn.net/v_july_v/article/details/6105630">这篇文章</a>。</p><h1 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h1><h2 id="hash算法"><a href="#hash算法" class="headerlink" title="hash算法"></a>hash算法</h2><p>源码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法一：</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;   <span class="comment">//jdk1.8 &amp; jdk1.7</span></span><br><span class="line">     <span class="type">int</span> h;</span><br><span class="line">     <span class="comment">// h = key.hashCode() 为第一步 取hashCode值</span></span><br><span class="line">     <span class="comment">// h ^ (h &gt;&gt;&gt; 16)  为第二步 高位参与运算</span></span><br><span class="line">     <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line">方法二：</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">indexFor</span><span class="params">(<span class="type">int</span> h, <span class="type">int</span> length)</span> &#123;  <span class="comment">//jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的</span></span><br><span class="line">     <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);  <span class="comment">//第三步 取模运算</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的Hash算法本质上就是三步：<strong>取key的hashCode值、高位运算、取模运算</strong>。</p><p>对于任意给定的对象，只要它的hashCode()返回值相同，那么程序调用方法一所计算得到的Hash码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，<strong>模运算的消耗还是比较大</strong>的，在HashMap中是这样做的：调用方法二来计算该对象应该保存在table数组的哪个索引处。</p><p>这个方法（方法二）非常巧妙，它通过h &amp; (table.length -1)来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n次方时，<strong>h&amp; (length-1)运算等价于对length取模</strong>，也就是h%length，但是&amp;比%具有更高的效率。</p><p>在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。</p><p>下面举例说明下，n为table的长度</p><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/45205ec2.png" alt="hash算法"></p><h2 id="HashMap的put方法"><a href="#HashMap的put方法" class="headerlink" title="HashMap的put方法"></a>HashMap的put方法</h2><p>HashMap的put方法执行过程可以通过下图来理解</p><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/d669d29c.png" alt="HashMap的put方法（1.7，1.8有变化）"></p><ol><li>判断键值对数组table是否为空或长度为0，否则执行resize()进行扩容；（这里可以看出，<code>new HashMap()</code>的时候并不会初始化哈希桶数组，而是当第一次执行put操作的时候才会初始化。）</li><li>根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向6，如果table[i]不为空，转向3</li><li>判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向4，这里的相同指的是hashCode以及equals；</li><li>判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向5；</li><li>遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可； </li><li>插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。</li></ol><p>put方法源码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="comment">// 对key的hashCode()做hash</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">               <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">// 步骤①：tab为空则创建</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 步骤②：计算index，并对null做处理 </span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>) </span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 步骤③：节点key存在，直接覆盖value</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 步骤④：判断该链为红黑树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 步骤⑤：该链为链表</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key,value,<span class="literal">null</span>);</span><br><span class="line">                     <span class="comment">//链表长度大于8转换为红黑树进行处理</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st  </span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                 <span class="comment">// key已经存在直接覆盖value</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) </span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 步骤⑥：超过最大容量 就扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><p>扩容(resize)就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。当然Java里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组，就像我们用一个小桶装水，如果想装更多的水，就得换大水桶。</p><blockquote><p>这里有一个不大不小的质疑，如果所有的size到达了threshold，但是所有的键值对都装在了一个哈希桶中，那么其实其他桶是空的，也是可以继续放更多的键值对，那么此时不能说<HashMap对象内部的数组无法装载更多的元素>，但依然会扩容</p></blockquote><p>我们分析下resize的源码，鉴于JDK1.8融入了红黑树，较复杂，为了便于理解我们仍然使用JDK1.7的代码，好理解一些，本质上区别不大，具体区别后文再说。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(<span class="type">int</span> newCapacity)</span> &#123;   <span class="comment">//传入新的容量</span></span><br><span class="line">    Entry[] oldTable = table;    <span class="comment">//引用扩容前的Entry数组</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> oldTable.length;         </span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;  <span class="comment">//扩容前的数组大小如果已经达到最大(2^30)了</span></span><br><span class="line">        threshold = Integer.MAX_VALUE; <span class="comment">//修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> <span class="title class_">Entry</span>[newCapacity];  <span class="comment">//初始化一个新的Entry数组</span></span><br><span class="line">    transfer(newTable);                         <span class="comment">//！！将数据转移到新的Entry数组里</span></span><br><span class="line">    table = newTable;                           <span class="comment">//HashMap的table属性引用新的Entry数组</span></span><br><span class="line">    threshold = (<span class="type">int</span>)(newCapacity * loadFactor);<span class="comment">//修改阈值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Entry[] newTable)</span> &#123;</span><br><span class="line">    Entry[] src = table;                   <span class="comment">//src引用了旧的Entry数组</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; src.length; j++) &#123; <span class="comment">//遍历旧的Entry数组</span></span><br><span class="line">        Entry&lt;K,V&gt; e = src[j];             <span class="comment">//取得旧Entry数组的每个元素</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            src[j] = <span class="literal">null</span>;<span class="comment">//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash, newCapacity); <span class="comment">//！！重新计算每个元素在数组中的位置</span></span><br><span class="line">                e.next = newTable[i]; <span class="comment">//标记[1]，这句不太理解</span></span><br><span class="line">                newTable[i] = e;      <span class="comment">//将元素放在数组上</span></span><br><span class="line">                e = next;             <span class="comment">//访问下一个Entry链上的元素</span></span><br><span class="line">            &#125; <span class="keyword">while</span> (e != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>newTable[i]的引用赋给了e.next，也就是使用了单链表的<strong>头插</strong>入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素终会被放到Entry链的尾部(如果发生了hash冲突的话），这一点和Jdk1.8有区别，下文详解。在旧数组中同一条Entry链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。</p><p>下面举个例子说明下扩容过程。假设了我们的hash算法就是简单的用key mod 一下表的大小（也就是数组的长度）。其中的哈希桶数组table的size=2， 所以key = 3、7、5，put顺序依次为 5、7、3。在mod 2以后都冲突在table[1]这里了。这里假设负载因子 loadFactor=1，即当键值对的实际大小size 大于 table的实际大小时进行扩容。接下来的三个步骤是哈希桶数组 resize成4，然后所有的Node重新rehash的过程。</p><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/b2330062.png" alt="JDK7 HashMap扩容"></p><p>下面我们讲解下JDK1.8做了哪些优化。经过观测可以发现，我们使用的是<strong>2次幂</strong>的扩展(指长度扩为原来2倍)，所以，<strong>元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置</strong>。看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。</p><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/4d8022db.png" alt="img"></p><p>元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：</p><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/d773f86e.png" alt="img"></p><p>因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，<strong>只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”</strong>，可以看看下图为16扩充为32的resize示意图：</p><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/3cc9813a.png" alt="img"></p><p>这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。有一点注意区别，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，<strong>JDK1.8不会倒置</strong>。有兴趣的同学可以研究下JDK1.8的resize源码，写的很赞，如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没超过最大值，就扩充为原来的2倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算新的resize上限</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;，&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 把每个bucket都移动到新的buckets中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// 链表优化重hash的代码块</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 原索引</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 原索引+oldCap</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 原索引放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 原索引+oldCap放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><h2 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h2><p>在多线程使用场景中，应该尽量避免使用线程不安全的HashMap，而使用线程安全的ConcurrentHashMap。那么为什么说HashMap是线程不安全的，下面举例子说明在并发的多线程使用场景中使用HashMap可能造成死循环。代码例子如下(便于理解，仍然使用JDK1.7的环境)：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapInfiniteLoop</span> &#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;Integer,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer,String&gt;(<span class="number">2</span>，<span class="number">0.75f</span>);  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        map.put(<span class="number">5</span>， <span class="string">&quot;C&quot;</span>);  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;Thread1&quot;</span>) &#123;  </span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;  </span><br><span class="line">                map.put(<span class="number">7</span>, <span class="string">&quot;B&quot;</span>);  </span><br><span class="line">                System.out.println(map);  </span><br><span class="line">            &#125;;  </span><br><span class="line">        &#125;.start();  </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;Thread2&quot;</span>) &#123;  </span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;  </span><br><span class="line">                map.put(<span class="number">3</span>, <span class="string">&quot;A);  </span></span><br><span class="line"><span class="string">                System.out.println(map);  </span></span><br><span class="line"><span class="string">            &#125;;  </span></span><br><span class="line"><span class="string">        &#125;.start();        </span></span><br><span class="line"><span class="string">    &#125;  </span></span><br><span class="line"><span class="string">&#125; </span></span><br></pre></td></tr></table></figure><p>其中，map初始化为一个长度为2的数组，loadFactor=0.75，threshold=2*0.75=1，也就是说当put第二个key的时候，map就需要进行resize。</p><p>通过设置断点让线程1和线程2同时debug到transfer方法(3.3小节代码块)的首行。注意此时两个线程已经成功添加数据。放开thread1的断点至transfer方法的“Entry next = e.next;” 这一行；然后放开线程2的的断点，让线程2进行resize。结果如下图。</p><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/7df99266.png" alt="img"></p><p>注意，Thread1的 e 指向了key(3)，而next指向了key(7)，其在线程二rehash后，指向了线程二重组后的链表。</p><p>线程一被调度回来执行，先是执行 newTalbe[i] = e， 然后是e = next，导致了e指向了key(7)，而下一次循环的next = e.next导致了next指向了key(3)。</p><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/4c3c28fb.png" alt="img"></p><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/6c8d086a.png" alt="img"></p><p>e.next = newTable[i] 导致 key(3).next 指向了 key(7)。注意：此时的key(7).next 已经指向了key(3)， 环形链表就这样出现了。</p><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/6eed9aaf.png" alt="img"></p><p>于是，当我们用线程一调用map.get(11)时，悲剧就出现了——Infinite Loop。</p><h1 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h1><p>JDK1.8做了多方面的优化，总体性能优于JDK1.7。具体详见参考资料1</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://tech.meituan.com/2016/06/24/java-hashmap.html">Java 8系列之重新认识HashMap</a></li><li></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 集合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>医学影像处理：将NII格式的CT图转换为PNG</title>
      <link href="/2022/04/12/%E5%8C%BB%E5%AD%A6%E5%BD%B1%E5%83%8F%E5%A4%84%E7%90%86%EF%BC%9A%E5%B0%86NII%E6%A0%BC%E5%BC%8F%E7%9A%84CT%E5%9B%BE%E8%BD%AC%E6%8D%A2%E4%B8%BAPNG/"/>
      <url>/2022/04/12/%E5%8C%BB%E5%AD%A6%E5%BD%B1%E5%83%8F%E5%A4%84%E7%90%86%EF%BC%9A%E5%B0%86NII%E6%A0%BC%E5%BC%8F%E7%9A%84CT%E5%9B%BE%E8%BD%AC%E6%8D%A2%E4%B8%BAPNG/</url>
      
        <content type="html"><![CDATA[<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>本文使用Python进行医学影像处理：通过旋转、切片、调整窗宽窗位，将3D NII格式的<strong>肺部</strong>CT影像转为2D PNG格式图像。</p><p>下面介绍流程。</p><p>===</p><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><p>==</p><h2 id="读取NII图像"><a href="#读取NII图像" class="headerlink" title="读取NII图像"></a>读取NII图像</h2><p>一般使用<code>nibabel</code>来读NII格式图像。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> nibabel <span class="keyword">as</span> nib</span><br><span class="line">img = nib.load(img_path)</span><br><span class="line"><span class="comment"># 获得图像的ndarray</span></span><br><span class="line">img_fdata = img.get_fdata()</span><br></pre></td></tr></table></figure><p>==</p><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>将3D图以z轴分片为若干2D图。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(x, y, z) = img.shape</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(z):</span><br><span class="line">silce = img_fdata[:, :, i]</span><br></pre></td></tr></table></figure><p>==</p><h2 id="调整窗宽窗位1"><a href="#调整窗宽窗位1" class="headerlink" title="调整窗宽窗位1"></a>调整窗宽窗位1</h2><p>窗宽窗位的基本概念详见：<a href="https://www.zhihu.com/question/33587197">https://www.zhihu.com/question/33587197</a></p><p>简单来说，不同的窗宽窗位使得不同的组织器官展示的更清楚。</p><p>这里，我处理的是肺部CT，不同部位的对应不同的窗宽窗位。</p><p>==</p><h2 id="调整窗宽窗位2"><a href="#调整窗宽窗位2" class="headerlink" title="调整窗宽窗位2"></a>调整窗宽窗位2</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">center = -<span class="number">500</span> <span class="comment">#肺部的窗宽窗位</span></span><br><span class="line">width = <span class="number">1500</span></span><br><span class="line"><span class="built_in">min</span> = (<span class="number">2</span> * center - width) / <span class="number">2.0</span> + <span class="number">0.5</span></span><br><span class="line"><span class="built_in">max</span> = (<span class="number">2</span> * center + width) / <span class="number">2.0</span> + <span class="number">0.5</span></span><br><span class="line">dFactor = <span class="number">255.0</span> / (<span class="built_in">max</span> - <span class="built_in">min</span>)</span><br><span class="line"></span><br><span class="line">silce = silce - <span class="built_in">min</span></span><br><span class="line">silce =np.trunc( silce * dFactor)</span><br><span class="line"><span class="comment"># 由于RGB格式的要求，这里对不在[0~255]的像素值进行截断</span></span><br><span class="line">silce[silce &lt; <span class="number">0.0</span>] = <span class="number">0</span></span><br><span class="line">silce[silce &gt; <span class="number">255.0</span>] = <span class="number">255</span>  <span class="comment"># 转换为窗位窗位之后的数据</span></span><br></pre></td></tr></table></figure><p>==</p><h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><p>旋转90°让图像“正”过来</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">silce = np.fliplr(np.rot90(silce,-<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>==</p><h2 id="保存PNG"><a href="#保存PNG" class="headerlink" title="保存PNG"></a>保存PNG</h2><p>略</p><p>=== </p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><p>==</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> nibabel <span class="keyword">as</span> nib</span><br><span class="line"><span class="keyword">import</span> imageio  </span><br><span class="line"></span><br><span class="line"><span class="comment">#肺部的窗宽窗位</span></span><br><span class="line">center = -<span class="number">500</span> </span><br><span class="line">width = <span class="number">1500</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nii_to_image</span>(<span class="params">src_path, dst_path</span>):</span><br><span class="line"><span class="keyword">for</span> p, d, f <span class="keyword">in</span> os.walk(src_path):</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(f) &gt; <span class="number">0</span>:</span><br><span class="line"><span class="keyword">for</span> file_name <span class="keyword">in</span> f:</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> file_name.endswith(<span class="string">&quot;.nii&quot;</span>):</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="comment"># 开始读取nii文件</span></span><br><span class="line">img_path = os.path.join(p, file_name)</span><br><span class="line">img = nib.load(img_path)</span><br><span class="line">img_fdata = img.get_fdata()</span><br><span class="line"><span class="comment"># 新建文件夹</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(dst_path):</span><br><span class="line">os.mkdir(dst_path)</span><br><span class="line"><span class="comment"># 转换成窗宽窗位</span></span><br><span class="line"><span class="built_in">min</span> = (<span class="number">2</span> * center - width) / <span class="number">2.0</span> + <span class="number">0.5</span></span><br><span class="line"><span class="built_in">max</span> = (<span class="number">2</span> * center + width) / <span class="number">2.0</span> + <span class="number">0.5</span></span><br><span class="line">dFactor = <span class="number">255.0</span> / (<span class="built_in">max</span> - <span class="built_in">min</span>)</span><br><span class="line"><span class="comment"># 开始转换为图像</span></span><br><span class="line">(x, y, z) = img.shape</span><br><span class="line"><span class="comment"># z是图像的序列</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(z):</span><br><span class="line">silce = img_fdata[:, :, i]</span><br><span class="line"><span class="comment"># 反转，旋转90°</span></span><br><span class="line">silce = np.fliplr(np.rot90(silce,-<span class="number">1</span>)) </span><br><span class="line">silce = silce - <span class="built_in">min</span></span><br><span class="line">silce =np.trunc( silce * dFactor)</span><br><span class="line">silce[silce &lt; <span class="number">0.0</span>] = <span class="number">0</span></span><br><span class="line">silce[silce &gt; <span class="number">255.0</span>] = <span class="number">255</span> </span><br><span class="line"><span class="comment"># maskimg_slice = maskimg_fdata[:,:,i]</span></span><br><span class="line">temp = file_name.replace(<span class="string">&quot;.nii&quot;</span>, <span class="string">&quot;&quot;</span>)+<span class="string">&quot;_&quot;</span> + <span class="string">&#x27;&#123;&#125;.png&#x27;</span>.<span class="built_in">format</span>(i)</span><br><span class="line">imageio.imwrite(os.path.join(dst_path, temp), silce.astype(<span class="string">&#x27;uint8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">src_path = <span class="string">&#x27;NII保存文件夹&#x27;</span></span><br><span class="line">dst_path = <span class="string">&#x27;PNG保存文件夹&#x27;</span></span><br><span class="line">nii_to_image(src_path, dst_path)</span><br></pre></td></tr></table></figure><p>===</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>==</p><ol><li><a href="https://www.zhihu.com/question/33587197">CT的窗宽，窗位到底是什么意思？</a></li><li><a href="https://blog.csdn.net/Zzhouzhou237/article/details/105345048">python nii 图像读取，转换成CT 值，设置窗宽窗位，保存成png 图像</a></li></ol><p>===</p><h1 id="Thanks"><a href="#Thanks" class="headerlink" title="Thanks~"></a>Thanks~</h1>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>完美解决ChromeDriver与Chrome版本匹配问题</title>
      <link href="/2022/04/11/%E5%AE%8C%E7%BE%8E%E8%A7%A3%E5%86%B3ChromeDriver%E4%B8%8EChrome%E7%89%88%E6%9C%AC%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98/"/>
      <url>/2022/04/11/%E5%AE%8C%E7%BE%8E%E8%A7%A3%E5%86%B3ChromeDriver%E4%B8%8EChrome%E7%89%88%E6%9C%AC%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>在使用Selenium调用Chrome浏览器爬取互联网数据时，会遇到Chrome和ChromeDriver版本不兼容的问题，导致爬取失败。</p><p>一种解决方案是，进行版本匹配。但是随着本机Chrome的更新，每次都需要随之更新ChromeDriver版本。</p><p>更好的方案是，通过使用<code>webdriver-manager</code>来自动匹配ChromeDriver，安装：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install webdriver-manager</span><br></pre></td></tr></table></figure><p>Usage：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> webdriver_manager.chrome <span class="keyword">import</span> ChromeDriverManager</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome(ChromeDriverManager().install())</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://stackoverflow.com/questions/60296873/sessionnotcreatedexception-message-session-not-created-this-version-of-chrome">SessionNotCreatedException: Message: session not created: This version of ChromeDriver only supports Chrome version 81</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 网络爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络爬虫 </tag>
            
            <tag> Selenium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test_slides</title>
      <link href="/2022/04/11/test-slides/"/>
      <url>/2022/04/11/test-slides/</url>
      
        <content type="html"><![CDATA[<h1 id="这是一个slides测试博客"><a href="#这是一个slides测试博客" class="headerlink" title="这是一个slides测试博客"></a>这是一个slides测试博客</h1><p>===</p><p>它可以把markdown渲染的像幻灯片一样</p><p>==</p><p>还有垂直切换</p><p>==</p><p>还可以切换背景等。</p><p>===</p><p>Have Fun~</p>]]></content>
      
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于ResNet的树叶分类任务</title>
      <link href="/2022/04/04/%E5%9F%BA%E4%BA%8EResNet%E7%9A%84%E6%A0%91%E5%8F%B6%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/"/>
      <url>/2022/04/04/%E5%9F%BA%E4%BA%8EResNet%E7%9A%84%E6%A0%91%E5%8F%B6%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本文任务、数据集来源于《动手学深度学习》课程中的树叶分类竞赛。详见参考资料1</p><p>本文代码主要参考kaggle用户nekokiku给出的resnet baseline。详见参考资料2</p><p>通过本次竞赛和代码可以学习到：</p><ul><li>简单的PyTorch深度学习项目代码、结构是怎样的</li><li>如何继承PyTorch中的Dataset, DataLoader实现自己的Dataset, DataLoader类</li><li>如何使用PyTorch快速实现ResNet模型。</li></ul></blockquote><h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><p>分析baseline code，总结一下深度学习的代码流程。</p><ol><li>处理数据：包括元数据和图像数据。比如看看数据的样子，标签的分布，unique 标签的数量等。</li><li>实现自己的Dataset、DataLoader类</li><li>CPU OR GPU</li><li>定义模型</li><li>定义超参数：学习率等</li><li>train&amp;valid</li><li>使用训练好的模型进行预测。</li></ol><h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p>针对本次任务项目结构如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">leaves_classification_competition/</span><br><span class="line">└─data/</span><br><span class="line">    └─classify-leaves/</span><br><span class="line">        └─images/</span><br><span class="line">└─train.csv</span><br><span class="line">└─test.csv</span><br><span class="line">└─script.ipynb</span><br></pre></td></tr></table></figure><p><code>data/</code>目录下是本次任务用到的数据。将从kaggle上下载的数据压缩包解压到本文件夹。</p><p><code>script.ipynb</code>是代码脚本。</p><p>在更大的训练中，代码应该拆分为各种<code>.py</code>文件。</p><h1 id="baseline"><a href="#baseline" class="headerlink" title="baseline"></a>baseline</h1><h2 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 首先导入包</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset, DataLoader</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> torchvision.models <span class="keyword">as</span> models</span><br><span class="line"><span class="comment"># This is for the progress bar.</span></span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br></pre></td></tr></table></figure><h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><p>看一看train.csv长什么样</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DATA_BASE_PATH = <span class="string">&#x27;./data/classify-leaves/&#x27;</span></span><br><span class="line"><span class="comment"># label文件</span></span><br><span class="line">labels_df = pd.read_csv(os.path.join(DATA_BASE_PATH, <span class="string">&#x27;train.csv&#x27;</span>))</span><br><span class="line">labels_df.head()</span><br><span class="line"><span class="comment"># len(labels_df)</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">labels_df.describe()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 把树叶的标签去重映射为数值</span></span><br><span class="line">leaves_labels = <span class="built_in">sorted</span>(<span class="built_in">list</span>(<span class="built_in">set</span>(labels_df[<span class="string">&#x27;label&#x27;</span>])))</span><br><span class="line">n_classes = <span class="built_in">len</span>(leaves_labels)</span><br><span class="line">class2num = <span class="built_in">dict</span>(<span class="built_in">zip</span>(leaves_labels, <span class="built_in">range</span>(n_classes)))</span><br><span class="line">class2num</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#x27;abies_concolor&#x27;: 0,</span><br><span class="line"> &#x27;abies_nordmanniana&#x27;: 1,</span><br><span class="line"> &#x27;acer_campestre&#x27;: 2,</span><br><span class="line">……</span><br><span class="line"> &#x27;zelkova_serrata&#x27;: 175&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 转换成key为数字，val为树叶类型，方便预测。</span></span><br><span class="line">num2class = &#123;v:k <span class="keyword">for</span> k, v <span class="keyword">in</span> class2num.items()&#125;</span><br><span class="line">num2class</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;0: &#x27;abies_concolor&#x27;,</span><br><span class="line"> 1: &#x27;abies_nordmanniana&#x27;,</span><br><span class="line"> 2: &#x27;acer_campestre&#x27;,</span><br><span class="line"> 3: &#x27;acer_ginnala&#x27;,</span><br><span class="line"> 4: &#x27;acer_griseum&#x27;,</span><br><span class="line">……</span><br><span class="line"> 175: &#x27;zelkova_serrata&#x27;&#125;</span><br></pre></td></tr></table></figure><h2 id="实现Dataset"><a href="#实现Dataset" class="headerlink" title="实现Dataset"></a>实现Dataset</h2><p>继承Dataset类，实现自己的Dataset。继承之后，需要实现三个函数</p><ul><li><code>__init__</code>：传入必要的参数，初始化；</li><li><code>__getitem__</code>：返回item，如果是train或者valid则返回img和label，如果是test则返回img</li><li><code>__len__</code>：数据集长度</li><li>更多参见参考资料3</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 继承Dataset类。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LeaveDataSet</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, csv_path, img_path, mode=<span class="string">&#x27;train&#x27;</span>, valid_ratio = <span class="number">0.2</span>, resize_height = <span class="number">256</span>, resize_width = <span class="number">256</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">          csv_path: label文件路径</span></span><br><span class="line"><span class="string">          img_path: 图片存放路径</span></span><br><span class="line"><span class="string">          mode: 训练模式还是测试模式</span></span><br><span class="line"><span class="string">          valid_ratio: 验证集比例</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.img_path = img_path</span><br><span class="line">        self.mode = mode</span><br><span class="line">        self.data_info = pd.read_csv(csv_path)</span><br><span class="line">        self.data_len = <span class="built_in">len</span>(self.data_info)</span><br><span class="line">        self.train_len = <span class="built_in">int</span>(self.data_len * (<span class="number">1</span> - valid_ratio))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> mode == <span class="string">&#x27;train&#x27;</span>:</span><br><span class="line">            <span class="comment"># 为啥要转成nparray</span></span><br><span class="line">            self.train_image = np.asarray(self.data_info.iloc[:self.train_len, <span class="number">0</span>])</span><br><span class="line">            self.train_label = np.asarray(self.data_info.iloc[:self.train_len, <span class="number">1</span>])</span><br><span class="line">            <span class="comment"># 为了在不同模式下统一变量</span></span><br><span class="line">            self.image_arr = self.train_image</span><br><span class="line">            self.label_arr = self.train_label</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> mode == <span class="string">&#x27;valid&#x27;</span>:</span><br><span class="line">            self.valid_image = np.asarray(self.data_info.iloc[self.train_len:,<span class="number">0</span>])</span><br><span class="line">            self.valid_label = np.asarray(self.data_info.iloc[self.train_len:,<span class="number">1</span>])</span><br><span class="line">            self.image_arr = self.valid_image</span><br><span class="line">            self.label_arr = self.valid_label</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.test_image = np.asarray(self.data_info.iloc[:,<span class="number">0</span>])</span><br><span class="line">            self.image_arr = self.test_image</span><br><span class="line">            <span class="comment">#test 没有label</span></span><br><span class="line">        self.real_len = <span class="built_in">len</span>(self.image_arr)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Finished reading the &#123;&#125; set of Leaves Dataset. (&#123;&#125; samples found)&quot;</span>.<span class="built_in">format</span>(mode, self.real_len))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, index</span>):</span><br><span class="line"></span><br><span class="line">        single_image_name = self.image_arr[index]</span><br><span class="line">        img_as_img = Image.<span class="built_in">open</span>(os.path.join(self.img_path, single_image_name))</span><br><span class="line">        <span class="keyword">if</span> self.mode == <span class="string">&#x27;train&#x27;</span>:</span><br><span class="line">            transform = transforms.Compose([</span><br><span class="line">                transforms.Resize((<span class="number">224</span>, <span class="number">224</span>)),</span><br><span class="line">                transforms.RandomHorizontalFlip(p=<span class="number">0.5</span>),   <span class="comment">#随机水平翻转 选择一个概率</span></span><br><span class="line">                transforms.ToTensor()</span><br><span class="line">            ])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># valid和test不做数据增强</span></span><br><span class="line">            transform = transforms.Compose([</span><br><span class="line">                transforms.Resize((<span class="number">224</span>, <span class="number">224</span>)),</span><br><span class="line">                transforms.ToTensor()</span><br><span class="line">            ])</span><br><span class="line">        img_as_img = transform(img_as_img)</span><br><span class="line">        <span class="comment"># 先不做图像裁剪，增强和灰度处理</span></span><br><span class="line">        <span class="keyword">if</span> self.mode == <span class="string">&#x27;test&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> img_as_img</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            label = self.label_arr[index]</span><br><span class="line">            <span class="comment"># label转数字</span></span><br><span class="line">            number_label = class2num[label]</span><br><span class="line">            <span class="keyword">return</span> img_as_img, number_label</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.real_len</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">生成dataset对象</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">train_csv_path = <span class="string">&#x27;./data/classify-leaves/train.csv&#x27;</span></span><br><span class="line">test_csv_path = <span class="string">&#x27;./data/classify-leaves/test.csv&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># csv文件中已经images的路径了，因此这里只到上一级目录</span></span><br><span class="line"></span><br><span class="line">img_path = <span class="string">&#x27;./data/classify-leaves/&#x27;</span></span><br><span class="line"></span><br><span class="line">train_dataset = LeaveDataSet(train_csv_path, img_path, mode=<span class="string">&#x27;train&#x27;</span>)</span><br><span class="line">test_dataset = LeaveDataSet(train_csv_path, img_path, mode=<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line">valid_dataset = LeaveDataSet(train_csv_path, img_path, mode=<span class="string">&#x27;valid&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Finished reading the train set of Leaves Dataset (14681 samples found)</span><br><span class="line">Finished reading the test set of Leaves Dataset (18353 samples found)</span><br><span class="line">Finished reading the valid set of Leaves Dataset (3672 samples found)</span><br></pre></td></tr></table></figure><h2 id="实现Dataloader"><a href="#实现Dataloader" class="headerlink" title="实现Dataloader"></a>实现Dataloader</h2><p>定义train，valid，test的dataloader，参数详见参考资料4</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义 data loader</span></span><br><span class="line"><span class="comment"># dataloader 参数详解：https://blog.csdn.net/qq_36653505/article/details/84728855</span></span><br><span class="line"></span><br><span class="line">train_loader = DataLoader(</span><br><span class="line">    dataset=train_dataset,</span><br><span class="line">    batch_size=<span class="number">8</span>,</span><br><span class="line">    shuffle=<span class="literal">False</span>,</span><br><span class="line">    num_workers=<span class="number">5</span> <span class="comment"># 使用nums_workers个线程读数据</span></span><br><span class="line">)</span><br><span class="line">valid_loader = DataLoader(</span><br><span class="line">    dataset=valid_dataset,</span><br><span class="line">    batch_size=<span class="number">8</span>,</span><br><span class="line">    shuffle=<span class="literal">False</span>,</span><br><span class="line">    num_workers=<span class="number">5</span></span><br><span class="line">)</span><br><span class="line">test_loader = DataLoader(</span><br><span class="line">    dataset=test_dataset,</span><br><span class="line">    batch_size=<span class="number">8</span>,</span><br><span class="line">    shuffle=<span class="literal">False</span>,</span><br><span class="line">    num_workers=<span class="number">5</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="获取GPU"><a href="#获取GPU" class="headerlink" title="获取GPU"></a>获取GPU</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># CPU OR GPU</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_device</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;cuda&#x27;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&#x27;cpu&#x27;</span></span><br><span class="line"></span><br><span class="line">device = get_device()</span><br><span class="line"><span class="built_in">print</span>(device)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cuda</span><br></pre></td></tr></table></figure><h2 id="定义模型"><a href="#定义模型" class="headerlink" title="定义模型"></a>定义模型</h2><p>这里模型使用resnet34</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义resnet34</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">num_classes: 传入分类任务的类别数，由上面的数据可知，一共有176种树叶，所以一会调用该函数返回模型时，传入的num_classes参数为176</span></span><br><span class="line"><span class="string">use_pretrained: 是否使用预训练模型。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">res_model</span>(<span class="params">num_classes, feature_extract = <span class="literal">False</span>, use_pretrained = <span class="literal">False</span></span>):</span><br><span class="line">    model_ft = models.resnet34(pretrained=use_pretrained)</span><br><span class="line">    <span class="comment"># set_parameter_requires_grad(model_ft, feature_extract)</span></span><br><span class="line">    <span class="comment"># 这里是想要把原始模型的最后一层全连接层替换掉，替换成输出类别为num_classes的全连接层。</span></span><br><span class="line">    <span class="comment"># 为了做到这一点我们需要先知道原始模型的全连接层的输入feature维度。</span></span><br><span class="line">    num_ftrs = model_ft.fc.in_features</span><br><span class="line">    model_ft.fc = nn.Sequential(nn.Linear(num_ftrs, num_classes))</span><br><span class="line">    <span class="keyword">return</span> model_ft</span><br></pre></td></tr></table></figure><h2 id="定义超参数"><a href="#定义超参数" class="headerlink" title="定义超参数"></a>定义超参数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 超参数</span></span><br><span class="line">lr = <span class="number">3e-4</span> <span class="comment">#学习率</span></span><br><span class="line">weight_decay = <span class="number">1e-3</span></span><br><span class="line">num_epoch = <span class="number">50</span> <span class="comment">#迭代轮数</span></span><br><span class="line">model_path = <span class="string">&#x27;./pre_res_model.ckpt&#x27;</span> <span class="comment"># 模型保存位置</span></span><br></pre></td></tr></table></figure><h2 id="train-amp-valid"><a href="#train-amp-valid" class="headerlink" title="train&amp;valid"></a>train&amp;valid</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 模型初始化，并放到具体的设备中</span></span><br><span class="line">model = res_model(<span class="number">176</span>)</span><br><span class="line"><span class="comment"># 将模型放到device上。</span></span><br><span class="line">model = model.to(device)</span><br><span class="line">model.device = device <span class="comment"># 这行代码貌似没什么用</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分类任务使用交叉熵损失作为评估标准</span></span><br><span class="line">criterion = nn.CrossEntropyLoss()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Adam优化器</span></span><br><span class="line">optimizer = torch.optim.Adam(model.parameters(), lr = lr, weight_decay= weight_decay)</span><br><span class="line"></span><br><span class="line">n_epochs = num_epoch</span><br><span class="line"></span><br><span class="line">best_acc = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(n_epochs):</span><br><span class="line">    <span class="comment"># ------- train --------</span></span><br><span class="line">    <span class="comment"># 训练的时候，要调用该函数，使模型处于训练模式</span></span><br><span class="line">    model.train()</span><br><span class="line">    <span class="comment"># 记录每次使用一个batch训练后，模型的损失和精确率。</span></span><br><span class="line">    train_loss = []</span><br><span class="line">    train_accs = []</span><br><span class="line">    <span class="comment"># tqdm是一个显示进度条的工具包，不用管。</span></span><br><span class="line">    <span class="keyword">for</span> batch <span class="keyword">in</span> tqdm(train_loader):</span><br><span class="line">        <span class="comment"># A batch consists of image data and corresponding labels.</span></span><br><span class="line">        imgs, labels = batch</span><br><span class="line">        <span class="comment"># 把数据都放到同一个device上</span></span><br><span class="line">        imgs = imgs.to(device)</span><br><span class="line">        labels = labels.to(device)</span><br><span class="line"></span><br><span class="line">        logits = model(imgs)</span><br><span class="line">        <span class="comment"># 计算模型输出和真实label之间的损失，反向传播。。</span></span><br><span class="line">        loss = criterion(logits, labels)</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">        <span class="comment">#这行code不是很懂，大概就是统计预测正确标签的占比</span></span><br><span class="line">        <span class="comment"># 弄明白：https://csbwang.github.io/dl_ch2#2161</span></span><br><span class="line">        acc = (logits.argmax(dim = -<span class="number">1</span>) == labels).<span class="built_in">float</span>().mean()</span><br><span class="line">        </span><br><span class="line">        train_loss.append(loss.item())</span><br><span class="line">        train_accs.append(acc)</span><br><span class="line">    <span class="comment"># 计算本次epoch后的loss和acc</span></span><br><span class="line">    train_loss = <span class="built_in">sum</span>(train_loss) / <span class="built_in">len</span>(train_loss)</span><br><span class="line">    train_acc = <span class="built_in">sum</span>(train_accs) / <span class="built_in">len</span>(train_accs)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;[ Train | <span class="subst">&#123;epoch + <span class="number">1</span>:03d&#125;</span>/<span class="subst">&#123;n_epochs:03d&#125;</span> ] loss = <span class="subst">&#123;train_loss:<span class="number">.5</span>f&#125;</span>, acc = <span class="subst">&#123;train_acc:<span class="number">.5</span>f&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="comment"># ------- valid --------</span></span><br><span class="line">    <span class="comment"># 验证时，把模型调成评估模式</span></span><br><span class="line">    model.<span class="built_in">eval</span>()  <span class="comment"># eval具体是做什么?</span></span><br><span class="line"></span><br><span class="line">    valid_loss = []</span><br><span class="line">    valid_accs = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> batch <span class="keyword">in</span> tqdm(valid_loader):</span><br><span class="line">        imgs, labels = batch</span><br><span class="line">        <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">            logits = model(imgs.to(device))</span><br><span class="line">        loss = criterion(logits, labels.to(device))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># acc = (logits.argmax(dim = -1) == labels).float().mean()</span></span><br><span class="line">        acc = (logits.argmax(dim = -<span class="number">1</span>) == labels.to(device)).<span class="built_in">float</span>().mean()</span><br><span class="line"></span><br><span class="line">        valid_loss.append(loss.item())</span><br><span class="line">        valid_accs.append(acc)</span><br><span class="line">    </span><br><span class="line">    valid_loss = <span class="built_in">sum</span>(valid_loss) / <span class="built_in">len</span>(valid_loss)</span><br><span class="line">    valid_acc = <span class="built_in">sum</span>(valid_accs) / <span class="built_in">len</span>(valid_accs)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;[ Valid | <span class="subst">&#123;epoch + <span class="number">1</span>:03d&#125;</span>/<span class="subst">&#123;n_epochs:03d&#125;</span> ] loss = <span class="subst">&#123;valid_loss:<span class="number">.5</span>f&#125;</span>, acc = <span class="subst">&#123;valid_acc:<span class="number">.5</span>f&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果在验证集得到的acc大于已知最好的acc，则保存模型。</span></span><br><span class="line">    <span class="keyword">if</span> valid_acc &gt; best_acc:</span><br><span class="line">        best_acc = valid_acc</span><br><span class="line">        torch.save(model.state_dict(), model_path)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;saving model with acc &#123;:.3f&#125;&#x27;</span>.<span class="built_in">format</span>(best_acc))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>//控制台输出</p><h2 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h2><p>上面就是训练过程，下面用训练好的模型进行预测</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">################ </span></span><br><span class="line">saveFileName = <span class="string">&#x27;./data/classify-leaves/submission.csv&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## predict</span></span><br><span class="line">model = res_model(<span class="number">176</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># create model and load weights from checkpoint</span></span><br><span class="line">model = model.to(device)</span><br><span class="line">model.load_state_dict(torch.load(model_path))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Make sure the model is in eval mode.</span></span><br><span class="line"><span class="comment"># Some modules like Dropout or BatchNorm affect if the model is in training mode.</span></span><br><span class="line">model.<span class="built_in">eval</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Initialize a list to store the predictions.</span></span><br><span class="line">predictions = []</span><br><span class="line"><span class="comment"># Iterate the testing set by batches.</span></span><br><span class="line"><span class="keyword">for</span> batch <span class="keyword">in</span> tqdm(test_loader):</span><br><span class="line">    </span><br><span class="line">    imgs = batch</span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        logits = model(imgs.to(device))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Take the class with greatest logit as prediction and record it.</span></span><br><span class="line">    predictions.extend(logits.argmax(dim=-<span class="number">1</span>).cpu().numpy().tolist())</span><br><span class="line"></span><br><span class="line">preds = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> predictions:</span><br><span class="line">    preds.append(num2class[i])</span><br><span class="line"></span><br><span class="line">test_data = pd.read_csv(test_path)</span><br><span class="line">test_data[<span class="string">&#x27;label&#x27;</span>] = pd.Series(preds)</span><br><span class="line">submission = pd.concat([test_data[<span class="string">&#x27;image&#x27;</span>], test_data[<span class="string">&#x27;label&#x27;</span>]], axis=<span class="number">1</span>)</span><br><span class="line">submission.to_csv(saveFileName, index=<span class="literal">False</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Done!!!!!!!!!!!!!!!!!!!!!!!!!!!&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="改进模型"><a href="#改进模型" class="headerlink" title="改进模型"></a>改进模型</h1><p>//TODO</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>初学深度学习，代码上犯了很多细节上的错误。其次，很多细节问题不明白，例如，优化器？各种计算公式等。以后要弄懂。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://www.bilibili.com/video/BV1z64y1o7iz">第二部分完结竞赛：图片分类【动手学深度学习v2】</a></li><li><a href="https://www.kaggle.com/code/nekokiku/simple-resnet-baseline">nekokiku/simple-resnet-baseline</a></li><li><a href="https://blog.csdn.net/leviopku/article/details/99958182">Pytorch中的dataset类——创建适应任意模型的数据集接口</a></li><li><a href="https://blog.csdn.net/qq_36653505/article/details/84728855">Pytorch 中的数据类型 torch.utils.data.DataLoader 参数详解</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
          <category> 动手学深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复现ResNet50（PyTorch）</title>
      <link href="/2022/03/29/%E5%A4%8D%E7%8E%B0ResNet50%EF%BC%88PyTorch%EF%BC%89/"/>
      <url>/2022/03/29/%E5%A4%8D%E7%8E%B0ResNet50%EF%BC%88PyTorch%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本篇博客介绍了 ResNet50 网络 PyTorch 复现（复现代码为 PyTorch 源码）</p></blockquote><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>Residual Net：残差网络。</p><p>将靠前若干层的某一层数据输出直接跳过多层引入到后面数据层的输入部分。意味着后面的特征层的内容会有一部分由其前面的某一层线性贡献。</p><p><img src="image-20220329215711900.png" alt="残差块"></p><p>深度残差网络的设计是为了克服由于网络深度加深而产生的学习效率变低与准确率无法有效提升的问题。</p><p>下面这张图来自参考文献[1]，给出了ResNet18、ResNet34、ResNet50、ResNet101、ResNet152的块结构。</p><p><img src="image-20220329220108463.png" alt="ResNet-XX 网络结构"></p><p>根据该图，我们可以画出ResNet50的网络结构，</p><p><img src="image-20220329220245960.png" alt="ResNet-50 网络结构"></p><p>由上述网络结构可以看到，ResNet包含两种Block：分别为<strong>Conv Block</strong>和<strong>Identity Block</strong>。</p><ul><li><strong>Conv Block</strong>输入和输出的维度（通道数和size）是不一样的，所以相同的Conv Block不能连续串联，它的作用是改变网络的维度；</li><li><strong>Identity Block</strong>输入维度和输出维度（通道数和size）相同，可以串联，用于加深网络的。</li></ul><p>下面是两种块的结构：</p><p><img src="image-20220329221454060.png" alt="Conv Block"></p><p><img src="image-20220329221531582.png" alt="Identity Block"></p><p>这两种块的区别在于残差边是否卷积。如果经过$1*1$卷积。经过卷积的是Conv Block，直连的是Identity Block。</p><p>稍后用一个类<code>Bottleneck</code>实现这两种块。</p><p>下面参考PyTorch框架源码，对 ResNet50  一步步复现。</p><h1 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h1><h2 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br></pre></td></tr></table></figure><h2 id="ResNet50-生成函数"><a href="#ResNet50-生成函数" class="headerlink" title="ResNet50 生成函数"></a>ResNet50 生成函数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">resnet50</span>(<span class="params">pretrained = <span class="literal">False</span>, **kwargs</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    Constructs a ResNet-50 model.</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        pretrained:(bool): If True, return a model pretrained on ImageNet</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    model = ResNet(Bottleneck, [<span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>], **kwargs)</span><br><span class="line">    <span class="keyword">if</span> pretrained:</span><br><span class="line">        <span class="comment"># model.load_state_dict(model_zoo.load_url(model_urls[&#x27;resnet50&#x27;]))</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">return</span> model</span><br><span class="line"></span><br><span class="line">net = resnet50()</span><br></pre></td></tr></table></figure><p>通过 <code>model = ResNet(Bottleneck, [3, 4, 6, 3], **kwargs)</code> 构造网络结构，主要分成两个部分即 <code>Bottleneck</code>和 <code>[3,4,6,3]</code> 由这两个参数共同决定了ResNet50的网络结构 ，当<code>pretrained</code>为<code>True</code>时，model加载ImageNet中预训练的参数。（这块本篇文章先不考虑）</p><p><code>[3,4,6,3]</code>对应于上图中ResNet50中 conv2_x中有三个（$1<em>1, 64$，$3</em>3, 64$，$1<em>1, 256$）卷积层的堆叠 ，同理conv3_x中有4个（$1</em>1, 128$，$3<em>3, 128$，$1</em>1, 512$）卷积层的堆叠，ResNet50将卷积层分为4个大层，<code>[3,4,6,3]</code>代表每一个大层中$1<em>1$，$3</em>3$，$1<em>1$卷积层组合的重复次数总共1（第一个卷积层）+1（第一个池化层）+（3+4+6+3）</em>3 = 50层。</p><p>这里<code>Bottleneck</code>类，就是一个基础块。对应上图（$1<em>1$，$3</em>3$，$1*1$）的三个卷积层组合。</p><h2 id="ResNet类"><a href="#ResNet类" class="headerlink" title="ResNet类"></a>ResNet类</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ResNet</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_make_layer</span>(<span class="params">self, block, planes, blocks, stride=<span class="number">1</span></span>):</span><br><span class="line">        downsample = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> stride != <span class="number">1</span> <span class="keyword">or</span> self.inplanes != planes * block.expansion:</span><br><span class="line">            downsample = nn.Sequential(</span><br><span class="line">                nn.Conv2d(self.inplanes, planes * block.expansion,</span><br><span class="line">                kernel_size=<span class="number">1</span>, stride=stride, bias=<span class="literal">False</span>),</span><br><span class="line">                nn.BatchNorm2d(planes * block.expansion)</span><br><span class="line">            )</span><br><span class="line">        layers = []</span><br><span class="line">        layers.append(block(self.inplanes, planes, stride, downsample))</span><br><span class="line">        self.inplanes = planes * block.expansion</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, blocks): <span class="comment"># for (blocks - 1)</span></span><br><span class="line">            layers.append(block(self.inplanes, planes))</span><br><span class="line">        <span class="keyword">return</span> nn.Sequential(*layers)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, block, layers, num_classes = <span class="number">1000</span></span>):</span><br><span class="line">        self.inplanes = <span class="number">64</span></span><br><span class="line">        <span class="built_in">super</span>(ResNet, self).__init__() <span class="comment"># ?</span></span><br><span class="line">        self.conv1 = nn.Conv2d(<span class="number">3</span>, <span class="number">64</span>, kernel_size=<span class="number">7</span>, stride=<span class="number">2</span>, padding=<span class="number">3</span>, bias=<span class="literal">False</span>)</span><br><span class="line">        self.bn1 = nn.BatchNorm2d(<span class="number">64</span>)</span><br><span class="line">        self.relu = nn.ReLU(inplace=<span class="literal">True</span>)</span><br><span class="line">        self.maxpool = nn.MaxPool2d(kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>, padding=<span class="number">1</span>)</span><br><span class="line">        self.layer1 = self._make_layer(block, <span class="number">64</span>, layers[<span class="number">0</span>])</span><br><span class="line">        self.layer2 = self._make_layer(block, <span class="number">128</span>, layers[<span class="number">1</span>], stride=<span class="number">2</span>)</span><br><span class="line">        self.layer3 = self._make_layer(block, <span class="number">256</span>, layers[<span class="number">2</span>], stride=<span class="number">2</span>)</span><br><span class="line">        self.layer4 = self._make_layer(block, <span class="number">512</span>, layers[<span class="number">3</span>], stride=<span class="number">2</span>)</span><br><span class="line">        self.avgpool = nn.AvgPool2d(<span class="number">7</span>, stride=<span class="number">1</span>)</span><br><span class="line">        <span class="comment">#因为最后feature map在输入为224时，经过layer4之后大小为7*7，此时经过nn.AvgPool2d(7, stride=1)大小变为1*1，再经过全连接层时，self.fc = nn.Linear(512 * block.expansion, num_classes) 前者是输出的所有channel数目，实际应该为channel*1*1，后者为分类数</span></span><br><span class="line">        self.fc = nn.Linear(<span class="number">512</span> * block.expansion, num_classes)</span><br><span class="line"><span class="comment"># ?</span></span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> self.modules():</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(m, nn.Conv2d):</span><br><span class="line">                nn.init.kaiming_normal_(m.weight, mode=<span class="string">&#x27;fan_out&#x27;</span>, nonlinearity=<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">isinstance</span>(m, nn.BatchNorm2d):</span><br><span class="line">                nn.init.constant_(m.weight, <span class="number">1</span>)</span><br><span class="line">                nn.init.constant_(m.bias, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">       self.avgpool = nn.AvgPool2d(<span class="number">7</span>, stride=<span class="number">1</span>)</span><br><span class="line">  x = self.avgpool(x)  </span><br><span class="line"></span><br><span class="line">  x = x.view(x.size(<span class="number">0</span>), -<span class="number">1</span>)     </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="comment"># 首先对输入进行7*7的卷积</span></span><br><span class="line">        x = self.conv1(x)</span><br><span class="line">        x = self.bn1(x)</span><br><span class="line">        x = self.relu(x)</span><br><span class="line">        <span class="comment"># 然后对x进行3*3的最大池化</span></span><br><span class="line">        x = self.maxpool(x)</span><br><span class="line"><span class="comment"># 接着进入四个layer/stage</span></span><br><span class="line">        x = self.layer1(x)</span><br><span class="line">        x = self.layer2(x)</span><br><span class="line">        x = self.layer3(x)</span><br><span class="line">        x = self.layer4(x)</span><br><span class="line"><span class="comment">#最后平均池化</span></span><br><span class="line"></span><br><span class="line">        x = self.avgpool(x)</span><br><span class="line">        <span class="comment"># 将数据拉伸成batchsize * channel * 1 * 1 ?</span></span><br><span class="line">        x = x.view(x.size(<span class="number">0</span>), -<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 如果输入大小不为224  那么相应的可以修改AvgPool2d 或者在全连接层第一个参数中乘上最终的width 和height</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><p>ResNet 是由<code>__init__</code>和<code>forward</code>构成，为了方便分析这里首先分析<code>__init__</code>函数。</p><h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><p>在<code>__init__</code>中，最重要的是<code>_make_layer</code>函数，以<code>layer1</code>为例，block为Bottleneck，planes=64（即channel数目）blocks=3 （<code>[3,4,6,3]</code>分别代表每一层的blocks数目）这里要注意<code>layer1</code>的stride为1，其他layer的stride为2。</p><p>对于<code>layer1</code>而言，<code>inplanes=64</code>， <code>planes=64</code>， <code>block.expansion=4</code>，因此需要经过downsample才能够使得残差和经过该层的feature map能够相加，downsample即为右路部分。（可以看<code>Bottleneck</code>的实现）</p><h3 id="forward"><a href="#forward" class="headerlink" title="forward"></a>forward</h3><p>见上面的代码注释。</p><h2 id="Bottleneck"><a href="#Bottleneck" class="headerlink" title="Bottleneck"></a>Bottleneck</h2><p>接着我们看一下Bottleneck的实现。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    Block的各个plane值：</span></span><br><span class="line"><span class="string">        inplanes：输出block的之前的通道数</span></span><br><span class="line"><span class="string">        planes：在block中间处理的时候的通道数（这个值是输出维度的1/4）</span></span><br><span class="line"><span class="string">        midplane*self.expansion：输出的维度</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bottleneck</span>(nn.Module):</span><br><span class="line">    <span class="comment">#每个stage中维度拓展的倍数</span></span><br><span class="line">    expansion = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1 * 1卷积核不改变feature map的大小，3 * 3卷积核padding=1&amp;&amp;stride=1也不改变输入feature map的大小，因此经过一个Bottleneck组成的卷积层组操作后feature map大小不会改变</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, inplanes, planes, stride = <span class="number">1</span>, downsample=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(Bottleneck, self).__init__()</span><br><span class="line">        self.conv1 = nn.Conv2d(inplanes, planes, kernel_size=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">        self.bn1 = nn.BatchNorm2d(planes)</span><br><span class="line">        self.conv2 = nn.Conv2d(planes, planes, kernel_size=<span class="number">3</span>, stride=stride, padding=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">        self.bn2 = nn.BatchNorm2d(planes)</span><br><span class="line">        self.conv3 = nn.Conv2d(planes, planes * self.expansion, kernel_size=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">        self.bn3 = nn.BatchNorm2d(planes * self.expansion)</span><br><span class="line">        self.relu = nn.ReLU(inplace= <span class="literal">True</span>)</span><br><span class="line">        self.downsample = downsample</span><br><span class="line">        self.stride = stride</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        residual = x</span><br><span class="line">        out = self.conv1(x)</span><br><span class="line">        out = self.bn1(out)</span><br><span class="line">        out = self.conv2(out)</span><br><span class="line">        out = self.bn2(out)</span><br><span class="line">        out = self.conv3(out)</span><br><span class="line">        out = self.bn3(out)</span><br><span class="line">        <span class="keyword">if</span> self.downsample <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            residual = self.downsample(x)</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        out += residual</span><br><span class="line">        out = self.relu(out)</span><br><span class="line">        <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure><p>其中当<code>downsample</code>为None时，残差边直连，此时为Identify Block，当<code>downsample</code>不为None时，残差边进行卷积再相加，此时为Conv Block。</p><blockquote><p>为什么要先卷积再相加呢？</p><p>因为feature map的大小不变 但是在经过Bottleneck 之后channel变成了原来的四倍，因此想要和原始的feature map相加需要将原始的feature map也变为原来的四倍 ，downsample作用是residual+当前feature map时将维度统一。</p></blockquote><h1 id="从输入到layers"><a href="#从输入到layers" class="headerlink" title="从输入到layers"></a>从输入到layers</h1><p>首先输入(3, 224, 224)，即三个通道，224<em>224像素的输入，经过一个输出通道数为64的7\</em>7卷积层，一个3*3池化，得到(64, 56, 56)。然后将其输入到layer1、2、3、4。</p><blockquote><p>解释一下为什么是(64, 56, 56)</p><p>因为ResNet接受的图像大小为224 * 224 经过第一层卷积层<code>self.conv1 = nn.Conv2d(3, 64, kernel_size=7, stride=2, padding=3, bias=False)</code></p><script type="math/tex; mode=display">floor((224-7+3*2)/2)+1=112</script><p>经过第一层池化之后，<code>self.maxpool = nn.MaxPool2d(kernel_size=3, stride=2, padding=1)</code></p><script type="math/tex; mode=display">floor((112+2*1-3)/2)+1=56</script><p>因此在输入到Bottleneck之前得到一个64(channel), 56(height)，56(weight)大小的feature map。</p></blockquote><h2 id="layer1-Bottleneck1"><a href="#layer1-Bottleneck1" class="headerlink" title="layer1/Bottleneck1"></a>layer1/Bottleneck1</h2><p>输入 ：[batch_size,64,56,56]</p><p>调用<code>_make_layer(block, 64, layers[0])</code>构造了layer1，此时<code>self.inplanes</code>为64，<code>planes * block.expansion</code>=64 <em> 4，不相等（之所以要二者相等，是因为在<code>Bottleneck</code>主体分支最后一个卷积层会将<code>channel</code>变为`planes</em>block.expansion<code>，如果</code>inplanes<code>（实际就是输入的channel）与之不相等则不可相加因此构造右路</code>downsample` （1*1卷积核的卷积层扩展channel+BN层）</p><p><img src="20181108104951863.png" alt="主体分支"></p><p><img src="20181108105037539.png" alt="downsample分支"></p><p>更新 inplanes=64*4=256</p><h2 id="layer1-Bottleneck2"><a href="#layer1-Bottleneck2" class="headerlink" title="layer1/Bottleneck2"></a>layer1/Bottleneck2</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">self.conv1 = nn.Conv2d(<span class="number">256</span>, <span class="number">64</span>, kernel_size=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">self.bn1 = nn.BatchNorm2d(<span class="number">64</span>)</span><br><span class="line">self.conv2 = nn.Conv2d(<span class="number">64</span>, <span class="number">64</span>, kernel_size=<span class="number">3</span>, stride=stride, padding=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">self.bn2 = nn.BatchNorm2d(<span class="number">64</span>)</span><br><span class="line">self.conv3 = nn.Conv2d(<span class="number">64</span>,<span class="number">256</span>, kernel_size=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">self.bn3 = nn.BatchNorm2d(planes * self.expansion)</span><br><span class="line">self.relu = nn.ReLU(inplace=<span class="literal">True</span>)</span><br><span class="line">self.downsample = <span class="literal">None</span></span><br><span class="line">self.stride = <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="layer1-Bottleneck3"><a href="#layer1-Bottleneck3" class="headerlink" title="layer1/Bottleneck3"></a>layer1/Bottleneck3</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">self.conv1 = nn.Conv2d(<span class="number">256</span>, <span class="number">64</span>, kernel_size=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">self.bn1 = nn.BatchNorm2d(<span class="number">64</span>)</span><br><span class="line">self.conv2 = nn.Conv2d(<span class="number">64</span>, <span class="number">64</span>, kernel_size=<span class="number">3</span>, stride=stride,padding=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">self.bn2 = nn.BatchNorm2d(<span class="number">64</span>)</span><br><span class="line">self.conv3 = nn.Conv2d(<span class="number">64</span>,<span class="number">256</span>, kernel_size=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">self.bn3 = nn.BatchNorm2d(planes * self.expansion)</span><br><span class="line">self.relu = nn.ReLU(inplace=<span class="literal">True</span>)</span><br><span class="line">self.downsample = <span class="literal">None</span></span><br><span class="line">self.stride = <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="layer2-Bottleneck1"><a href="#layer2-Bottleneck1" class="headerlink" title="layer2/Bottleneck1"></a>layer2/Bottleneck1</h2><p>此时<code>stride</code>=2，<code>self.inplanes</code>=256， <code>planes * block.expansion</code>=128*4，需要生成downsample层</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">downsample = nn.Sequential(</span><br><span class="line">nn.Conv2d(<span class="number">256</span>, <span class="number">512</span>,kernel_size=<span class="number">1</span>, stride=<span class="number">2</span>, bias=<span class="literal">False</span>),</span><br><span class="line">nn.BatchNorm2d(<span class="number">512</span>),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>生成第一个Bottleneck的主干</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">self.conv1 = nn.Conv2d(<span class="number">256</span>, <span class="number">128</span>, kernel_size=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">self.bn1 = nn.BatchNorm2d(planes)</span><br><span class="line"><span class="comment"># 此时feature map 大小由56变成28</span></span><br><span class="line">self.conv2 = nn.Conv2d(<span class="number">128</span>, <span class="number">128</span>, kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>, padding=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">self.bn2 = nn.BatchNorm2d(planes)</span><br><span class="line">self.conv3 = nn.Conv2d(<span class="number">128</span>, <span class="number">512</span>, kernel_size=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">self.bn3 = nn.BatchNorm2d(planes * self.expansion)</span><br><span class="line">self.relu = nn.ReLU(inplace=<span class="literal">True</span>)</span><br><span class="line">self.downsample = downsample</span><br><span class="line">self.stride = stride</span><br></pre></td></tr></table></figure><p>更新inplanes=512</p><h2 id="layer2-Bottleneck234"><a href="#layer2-Bottleneck234" class="headerlink" title="layer2/Bottleneck234"></a>layer2/Bottleneck234</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">self.conv1 = nn.Conv2d(<span class="number">512</span>, <span class="number">128</span>, kernel_size=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">self.bn1 = nn.BatchNorm2d(<span class="number">64</span>)</span><br><span class="line">self.conv2 = nn.Conv2d(<span class="number">128</span>, <span class="number">128</span>, kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>,padding=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">self.bn2 = nn.BatchNorm2d(<span class="number">64</span>)</span><br><span class="line">self.conv3 = nn.Conv2d(<span class="number">128</span>,<span class="number">256</span>, kernel_size=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">self.bn3 = nn.BatchNorm2d(planes * self.expansion)</span><br><span class="line">self.relu = nn.ReLU(inplace=<span class="literal">True</span>)</span><br><span class="line">self.downsample = <span class="literal">None</span></span><br><span class="line">self.stride = <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="layer3-4"><a href="#layer3-4" class="headerlink" title="layer3/4"></a>layer3/4</h2><p>对于layer3和layer4同理。</p><h2 id="打印完整的网络结构"><a href="#打印完整的网络结构" class="headerlink" title="打印完整的网络结构"></a>打印完整的网络结构</h2><p>最后，我们打印完整的网络结构：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">net</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ResNet(</span><br><span class="line">  (conv1): Conv2d(3, 64, kernel_size=(7, 7), stride=(2, 2), padding=(3, 3), bias=False)</span><br><span class="line">  (bn1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">  (relu): ReLU(inplace=True)</span><br><span class="line">  (maxpool): MaxPool2d(kernel_size=3, stride=2, padding=1, dilation=1, ceil_mode=False)</span><br><span class="line">  (layer1): Sequential(</span><br><span class="line">    (0): Bottleneck(</span><br><span class="line">      (conv1): Conv2d(64, 64, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)</span><br><span class="line">      (bn2): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv3): Conv2d(64, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn3): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (relu): ReLU(inplace=True)</span><br><span class="line">      (downsample): Sequential(</span><br><span class="line">        (0): Conv2d(64, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">        (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">    (1): Bottleneck(</span><br><span class="line">      (conv1): Conv2d(256, 64, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)</span><br><span class="line">      (bn2): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv3): Conv2d(64, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn3): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (relu): ReLU(inplace=True)</span><br><span class="line">    )</span><br><span class="line">    (2): Bottleneck(</span><br><span class="line">      (conv1): Conv2d(256, 64, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)</span><br><span class="line">      (bn2): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv3): Conv2d(64, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn3): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (relu): ReLU(inplace=True)</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">  (layer2): Sequential(</span><br><span class="line">    (0): Bottleneck(</span><br><span class="line">      (conv1): Conv2d(256, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv2): Conv2d(128, 128, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False)</span><br><span class="line">      (bn2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv3): Conv2d(128, 512, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn3): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (relu): ReLU(inplace=True)</span><br><span class="line">      (downsample): Sequential(</span><br><span class="line">        (0): Conv2d(256, 512, kernel_size=(1, 1), stride=(2, 2), bias=False)</span><br><span class="line">        (1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">    (1): Bottleneck(</span><br><span class="line">      (conv1): Conv2d(512, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv2): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)</span><br><span class="line">      (bn2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv3): Conv2d(128, 512, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn3): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (relu): ReLU(inplace=True)</span><br><span class="line">    )</span><br><span class="line">    (2): Bottleneck(</span><br><span class="line">      (conv1): Conv2d(512, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv2): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)</span><br><span class="line">      (bn2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv3): Conv2d(128, 512, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn3): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (relu): ReLU(inplace=True)</span><br><span class="line">    )</span><br><span class="line">    (3): Bottleneck(</span><br><span class="line">      (conv1): Conv2d(512, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv2): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)</span><br><span class="line">      (bn2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv3): Conv2d(128, 512, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn3): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (relu): ReLU(inplace=True)</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">  (layer3): Sequential(</span><br><span class="line">    (0): Bottleneck(</span><br><span class="line">      (conv1): Conv2d(512, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False)</span><br><span class="line">      (bn2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv3): Conv2d(256, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn3): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (relu): ReLU(inplace=True)</span><br><span class="line">      (downsample): Sequential(</span><br><span class="line">        (0): Conv2d(512, 1024, kernel_size=(1, 1), stride=(2, 2), bias=False)</span><br><span class="line">        (1): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">    (1): Bottleneck(</span><br><span class="line">      (conv1): Conv2d(1024, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)</span><br><span class="line">      (bn2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv3): Conv2d(256, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn3): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (relu): ReLU(inplace=True)</span><br><span class="line">    )</span><br><span class="line">    (2): Bottleneck(</span><br><span class="line">      (conv1): Conv2d(1024, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)</span><br><span class="line">      (bn2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv3): Conv2d(256, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn3): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (relu): ReLU(inplace=True)</span><br><span class="line">    )</span><br><span class="line">    (3): Bottleneck(</span><br><span class="line">      (conv1): Conv2d(1024, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)</span><br><span class="line">      (bn2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv3): Conv2d(256, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn3): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (relu): ReLU(inplace=True)</span><br><span class="line">    )</span><br><span class="line">    (4): Bottleneck(</span><br><span class="line">      (conv1): Conv2d(1024, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)</span><br><span class="line">      (bn2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv3): Conv2d(256, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn3): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (relu): ReLU(inplace=True)</span><br><span class="line">    )</span><br><span class="line">    (5): Bottleneck(</span><br><span class="line">      (conv1): Conv2d(1024, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)</span><br><span class="line">      (bn2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv3): Conv2d(256, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn3): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (relu): ReLU(inplace=True)</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">  (layer4): Sequential(</span><br><span class="line">    (0): Bottleneck(</span><br><span class="line">      (conv1): Conv2d(1024, 512, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv2): Conv2d(512, 512, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False)</span><br><span class="line">      (bn2): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv3): Conv2d(512, 2048, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn3): BatchNorm2d(2048, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (relu): ReLU(inplace=True)</span><br><span class="line">      (downsample): Sequential(</span><br><span class="line">        (0): Conv2d(1024, 2048, kernel_size=(1, 1), stride=(2, 2), bias=False)</span><br><span class="line">        (1): BatchNorm2d(2048, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">    (1): Bottleneck(</span><br><span class="line">      (conv1): Conv2d(2048, 512, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv2): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)</span><br><span class="line">      (bn2): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv3): Conv2d(512, 2048, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn3): BatchNorm2d(2048, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (relu): ReLU(inplace=True)</span><br><span class="line">    )</span><br><span class="line">    (2): Bottleneck(</span><br><span class="line">      (conv1): Conv2d(2048, 512, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv2): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)</span><br><span class="line">      (bn2): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv3): Conv2d(512, 2048, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn3): BatchNorm2d(2048, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (relu): ReLU(inplace=True)</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">  (avgpool): AvgPool2d(kernel_size=7, stride=1, padding=0)</span><br><span class="line">  (fc): Linear(in_features=2048, out_features=1000, bias=True)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>He K, Zhang X, Ren S, et al. Deep residual learning for image recognition[C]//Proceedings of the IEEE conference on computer vision and pattern recognition. 2016: 770-778.</li><li><a href="https://blog.csdn.net/a940902940902/article/details/83858694">ResNet结构分析</a></li><li><a href="https://www.bilibili.com/video/BV1154y1S7WC">史上最详细ResNet50复现解析（面向小白）</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
          <category> ResNet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> ResNet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【笔记】BFS 算法解题套路框架</title>
      <link href="/2022/03/09/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91BFS-%E7%AE%97%E6%B3%95%E8%A7%A3%E9%A2%98%E5%A5%97%E8%B7%AF%E6%A1%86%E6%9E%B6/"/>
      <url>/2022/03/09/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91BFS-%E7%AE%97%E6%B3%95%E8%A7%A3%E9%A2%98%E5%A5%97%E8%B7%AF%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文FROM《labuladong 算法秘籍》</p></blockquote><h1 id="什么是-BFS"><a href="#什么是-BFS" class="headerlink" title="什么是 BFS"></a>什么是 BFS</h1><p>BFS(Breadth First Search)，广度优先搜索，起源于<strong>树的层次遍历</strong>。其核心是利用<strong>队列</strong>这种数据结构。</p><p>BFS 的核心思想应该不难理解的，就是把⼀些问题抽象成图，从⼀个点开始，向四周开始扩散。 </p><h1 id="BFS-的应用场景"><a href="#BFS-的应用场景" class="headerlink" title="BFS 的应用场景"></a>BFS 的应用场景</h1><p>BFS 算法常见于求最值的场景，因为 BFS 的算法逻辑保证了算法第⼀次到达目标时的代价是最小的（？）。</p><p>举例⼀下 BFS 出现的常见场景好吧，问题的本质就是让你在⼀幅「图」中找到从起点 start 到终点 target 的最近距离。</p><p>这个广义的描述可以有各种变体，比如走迷宫，有的格子是围墙不能走，从起点到终点的最短距离是多少？如果这个迷宫带「传送门」可以瞬间传送呢？再比如说两个单词，要求你通过某些替换，把其中一个变成另一个，每次只能替换一个字符，最少要替换几次？再比如说连连看游戏，两个方块消除的条件不仅仅是图案相同，还得保证两个方块之间的最短连线不能多于两个拐点。你玩连连看，点击两个坐标，游戏是如何判断它俩的最短连线有几个拐点的？</p><h1 id="BFS-框架代码"><a href="#BFS-框架代码" class="headerlink" title="BFS 框架代码"></a>BFS 框架代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算从起点 start 到终点 target 的最近距离</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">BFS</span><span class="params">(Node start, Node target)</span> &#123;</span><br><span class="line">    Queue&lt;Node&gt; q; <span class="comment">// 核心数据结构</span></span><br><span class="line">    Set&lt;Node&gt; visited; <span class="comment">// 避免走回头路</span></span><br><span class="line">    </span><br><span class="line">    q.offer(start); <span class="comment">// 将起点加入队列</span></span><br><span class="line">    visited.add(start);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 记录扩散的步数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (q not empty) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> q.size();</span><br><span class="line">        <span class="comment">/* 将当前队列中的所有节点向四周扩散 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> q.poll();</span><br><span class="line">            <span class="comment">/* 划重点：这里判断是否到达终点 */</span></span><br><span class="line">            <span class="keyword">if</span> (cur is target)</span><br><span class="line">                <span class="keyword">return</span> step;</span><br><span class="line">            <span class="comment">/* 将 cur 的相邻节点加入队列 */</span></span><br><span class="line">            <span class="keyword">for</span> (Node x : cur.adj()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x not in visited) &#123;</span><br><span class="line">                    q.offer(x);</span><br><span class="line">                    visited.add(x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 划重点：更新步数在这里 */</span></span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>队列 <code>q</code> 就不说了，BFS 的核心数据结构；<code>cur.adj()</code> 泛指 <code>cur</code> 相邻的节点，比如说二维数组中，<code>cur</code> 上下左右四面的位置就是相邻节点；<code>visited</code> 的主要作用是防止走回头路，大部分时候都是必须的，但是像一般的二叉树结构，没有子节点到父节点的指针，不会走回头路就不需要 <code>visited</code>。</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p>LeetCode 111、752</p><h1 id="双向BFS（了解）"><a href="#双向BFS（了解）" class="headerlink" title="双向BFS（了解）"></a>双向BFS（了解）</h1><p>传统的 BFS 框架就是从起点开始向四周扩散，遇到终点时停止；而双向 BFS 则是从起点和终点同时开始扩散，当两边有交集的时候停止。</p><h1 id="BFS-与-DFS"><a href="#BFS-与-DFS" class="headerlink" title="BFS 与 DFS"></a>BFS 与 DFS</h1><blockquote><p>这部分不是很懂，后面再看</p></blockquote><p>BFS 相对 DFS 的最主要的区别是：BFS 找到的路径⼀定是最短的，但代价就是空间复杂度可能比 DFS 大很多。</p><p><strong>1、为什么 BFS 可以找到最短距离，DFS 不行吗</strong>？</p><p>首先，你看 BFS 的逻辑，<code>depth</code> 每增加一次，队列中的所有节点都向前迈一步，这保证了第一次到达终点的时候，走的步数是最少的。</p><p>DFS 不能找最短路径吗？其实也是可以的，但是时间复杂度相对高很多。你想啊，DFS 实际上是靠递归的堆栈记录走过的路径，你要找到最短路径，肯定得把二叉树中所有树杈都探索完才能对比出最短的路径有多长对不对？而 BFS 借助队列做到一次一步「齐头并进」，是可以在不遍历完整棵树的条件下找到最短距离的。</p><p>形象点说，DFS 是线，BFS 是面；DFS 是单打独斗，BFS 是集体行动。这个应该比较容易理解吧。</p><p><strong>2、既然 BFS 那么好，为啥 DFS 还要存在</strong>？</p><p>BFS 可以找到最短距离，但是空间复杂度高，而 DFS 的空间复杂度较低。</p><p>还是拿刚才我们处理二叉树问题的例子，假设给你的这个二叉树是满二叉树，节点数为 <code>N</code>，对于 DFS 算法来说，空间复杂度无非就是递归堆栈，最坏情况下顶多就是树的高度，也就是 <code>O(logN)</code>。</p><p>但是你想想 BFS 算法，队列中每次都会储存着二叉树一层的节点，这样的话最坏情况下空间复杂度应该是树的最底层节点的数量，也就是 <code>N/2</code>，用 Big O 表示的话也就是 <code>O(N)</code>。</p><p>由此观之，BFS 还是有代价的，一般来说在找最短路径的时候使用 BFS，其他时候还是 DFS 使用得多一些（主要是递归代码好写）。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://labuladong.gitee.io/algo/4/30/113/">BFS 算法解题套路框架</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> BFS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是端到端（end-to-end）的学习模型</title>
      <link href="/2022/03/07/%E4%BB%80%E4%B9%88%E6%98%AF%E7%AB%AF%E5%88%B0%E7%AB%AF%EF%BC%88end-to-end%EF%BC%89%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B/"/>
      <url>/2022/03/07/%E4%BB%80%E4%B9%88%E6%98%AF%E7%AB%AF%E5%88%B0%E7%AB%AF%EF%BC%88end-to-end%EF%BC%89%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p><strong>端到端的学习模型</strong>是指将原始数据不做任何的预处理直接将原始数据输入到模型当中，最后得到的输出结果与期望结果有误差，这误差在反向传播模型的各层中，将参数进行优化，一直到期望结果结束。<strong>非端到端</strong>是将原始数据进行标注，得到具有特征的处理后的数据，然后在作为输入，这样的弊端是如果提取数据特征时出现错误，将无法调整。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://www.its203.com/article/qq_42514225/108835224?2022-03-07">什么是端到端的学习模型</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大M对齐子集</title>
      <link href="/2022/03/01/%E6%9C%80%E5%A4%A7M%E5%AF%B9%E9%BD%90%E5%AD%90%E9%9B%86/"/>
      <url>/2022/03/01/%E6%9C%80%E5%A4%A7M%E5%AF%B9%E9%BD%90%E5%AD%90%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>有 N 个点位于一条线上，编号从 0 到 N-1 ，其坐标在数组 A 中给出。对于每个I (0 ≤ l &lt;N)，直线上点数 I 的坐标为 A[l] 。点的坐标可能相同。</p><p>对于给定的整数 M ，如果子集内任意两个点之间的距离可被M整除，则称这些点的子集为M<strong>对齐</strong>。您的任务是查找给定 N 个点集的最大 M 对齐子集的大小。</p><p>例如，考虑整数 M=3 和数组 A，如下所示：</p><blockquote><p>A[0] = -3  A[1] = -2  A[2] = 1  A[3] = 0  A[4] = 8  A[5] = 7  A[6] = 1</p></blockquote><p>包含编号为1、2、5和6的点的子集，坐标分别为-2、1、7和1，是3对齐子集的示例，因为：</p><ul><li>编号为1和2的点之间的距离为abs(A[1] - A[2]) = 3，</li><li>从5号点到编号1和2的点的距离分别为9和6，</li><li>从6号点到编号为1、2和5的点的距离分别为3、0和6，</li></ul><p>这些距离都可以被 M=3 整除。此子集的大小为4，并且没有更大的3对齐子集。</p><p>编写一个函数:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">solution</span><span class="params">(<span class="type">int</span>[] A, <span class="type">int</span> M)</span>;</span><br></pre></td></tr></table></figure><p>给定一个由 N 个整数和一个整数 M 组成的数组 A，返回最大 M 对齐子集的大小。</p><p>例如，给定 M=3 且 A=[-3，-2，1，0，8，7，1]，函数应返回4，如上所述；</p><p>给定 M=8 且 A=[7，1，11，8,4，10]，函数应返回1。</p><h1 id="解"><a href="#解" class="headerlink" title="解"></a>解</h1><p>把所有按 M 的余数存成一组就可以，<strong>同组的刚好把余数消掉就是距离整除</strong>。返回最大即为所求。</p><p><strong>注意</strong>：余数为负的，需要转为最小正余数（+M）</p><h2 id="Java实现"><a href="#Java实现" class="headerlink" title="Java实现"></a>Java实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">solution</span><span class="params">(<span class="type">int</span>[] A, <span class="type">int</span> M)</span>&#123;</span><br><span class="line">    <span class="comment">//remainders[i] = j, 表示余数为i的频次是j</span></span><br><span class="line">    <span class="type">int</span>[] remainders = <span class="keyword">new</span> <span class="title class_">int</span>[M];</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 记录最大的频次</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> A.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">remainder</span> <span class="operator">=</span> A[i] % M;</span><br><span class="line">        <span class="keyword">if</span>(remainder &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            remainder += M;</span><br><span class="line">        &#125;</span><br><span class="line">        remainders[remainder] ++;</span><br><span class="line">        ans = Math.max(ans, remainders[remainder]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 数论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>求数字1在所有不超过N的十进制正整数中出现的次数</title>
      <link href="/2022/03/01/%E6%B1%82%E6%95%B0%E5%AD%971%E5%9C%A8%E6%89%80%E6%9C%89%E4%B8%8D%E8%B6%85%E8%BF%87N%E7%9A%84%E5%8D%81%E8%BF%9B%E5%88%B6%E6%AD%A3%E6%95%B4%E6%95%B0%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/"/>
      <url>/2022/03/01/%E6%B1%82%E6%95%B0%E5%AD%971%E5%9C%A8%E6%89%80%E6%9C%89%E4%B8%8D%E8%B6%85%E8%BF%87N%E7%9A%84%E5%8D%81%E8%BF%9B%E5%88%B6%E6%AD%A3%E6%95%B4%E6%95%B0%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>写一个函数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">solution</span><span class="params">(<span class="type">int</span> N)</span>;</span><br></pre></td></tr></table></figure><p>即给定一个整数N，返回数字1在所有不超过 N 的正整数的十进制表示中出现的次数。</p><p>例如，给定N = 13，该函数应返回6，因为：</p><ul><li>所有不超过13的正整数是1、2、3、4、5、6、7、8、9、10、11、12 和13；</li><li>数字1共出现六次：一次在数字1中，一次在数字10中，两次在数字11中，一次在数字12中，一次在数字13中。</li></ul><p>N 是[0.. 100,000,000]范围内的整数。</p><h1 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h1><p>暴力求解：遍历每一个数，对每一个数求1的个数，然后加起来得和。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">solution</span><span class="params">(<span class="type">int</span> N)</span><span class="comment">//统计1-n中1的个数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=i; j&gt;<span class="number">0</span>; j/=<span class="number">10</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(j%<span class="number">10</span>==<span class="number">1</span>)</span><br><span class="line">ans ++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法时间复杂度：$O(nlgn)$</p><h1 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h1><p>考虑两位数。将一个正整数中1的个数分成两部分，一部分是个位上出现1的数目f1(n)，一部分是十位上出现1的数目f2(n) 。</p><p>n=10， f1(10)=1（1-10个位出现的1的个数为1），f2(10)=1（1-10个位出现的1的十数为1）。</p><p>举一些代表性的数：</p><div class="table-container"><table><thead><tr><th>n</th><th>f1(n)</th><th>f2(n)</th><th>f(n)</th></tr></thead><tbody><tr><td>10</td><td>1</td><td>1</td><td>2</td></tr><tr><td>11</td><td>2</td><td>2</td><td>4</td></tr><tr><td>12</td><td>2</td><td>3</td><td>5</td></tr><tr><td>13</td><td>2</td><td>4</td><td>6</td></tr><tr><td>20</td><td>2</td><td>10</td><td>12</td></tr><tr><td>21</td><td>3</td><td>10</td><td>13</td></tr><tr><td>22</td><td>3</td><td>10</td><td>13</td></tr><tr><td>23</td><td>3</td><td>10</td><td>13</td></tr><tr><td>30</td><td>3</td><td>10</td><td>13</td></tr><tr><td>31</td><td>4</td><td>10</td><td>14</td></tr><tr><td>32</td><td>4</td><td>10</td><td>14</td></tr><tr><td>33</td><td>4</td><td>10</td><td>14</td></tr></tbody></table></div><p>先来看十位，当十位上的数为1时，</p><div class="table-container"><table><thead><tr><th>n</th><th>f2(n)</th></tr></thead><tbody><tr><td>10</td><td>1</td></tr><tr><td>11</td><td>2</td></tr><tr><td>12</td><td>3</td></tr><tr><td>13</td><td>4</td></tr></tbody></table></div><p>f2(n)=当前数个位数字+1；</p><p>当十位上的数大于1时，</p><div class="table-container"><table><thead><tr><th>n</th><th>f2(n)</th></tr></thead><tbody><tr><td>20</td><td>10</td></tr><tr><td>21</td><td>10</td></tr><tr><td>22</td><td>10</td></tr><tr><td>23</td><td>10</td></tr><tr><td>30</td><td>10</td></tr><tr><td>31</td><td>10</td></tr><tr><td>32</td><td>10</td></tr><tr><td>33</td><td>10</td></tr></tbody></table></div><p>f2(n) = 10，也就是说此时十位上1的数目仅仅和十位有关系，也就是<strong>十位的位因子</strong>10。</p><p>再来看个位，当个位上的数为1的时候</p><div class="table-container"><table><thead><tr><th>n</th><th>f1(n)</th></tr></thead><tbody><tr><td>11</td><td>2</td></tr><tr><td>21</td><td>3</td></tr><tr><td>31</td><td>4</td></tr></tbody></table></div><p>f1(n) = 当前数十位数字+1；</p><p>当个位上的数大于1时，</p><div class="table-container"><table><thead><tr><th>n</th><th>f1(n)</th></tr></thead><tbody><tr><td>22</td><td>3</td></tr><tr><td>23</td><td>3</td></tr><tr><td>32</td><td>4</td></tr><tr><td>33</td><td>4</td></tr></tbody></table></div><p>f1(n) = 当前数十位数字+1；</p><p>还有当个位上的数等于0时，</p><div class="table-container"><table><thead><tr><th>n</th><th>f1(n)</th></tr></thead><tbody><tr><td>10</td><td>1</td></tr><tr><td>20</td><td>2</td></tr><tr><td>30</td><td>3</td></tr></tbody></table></div><p>f1(n) = 当前数十位数字。</p><p>这还不够，我们还没有分析两位数以上的数字，根据上面的分析，我们将当前位分为三种情况：=0，=1，&gt;1。</p><p>当百位上的数字是0的时候，假设n=12013。此时1-12013的所有整数中，百位上出现1的数是100~199，1100~1199，2100~2199……11100~11199。也就是12个100，1200个。也就是说此时百位上1的数目是由高位（12）决定的，而且等于高位（12）* 当前位因子（100）。</p><p>当百位上的数字是1的时候，假设n=12113。此时1-12113的所有整数中，百位上出现1的数是100~199，1100~1199，2100~2199……11100~11199，12100~12113。也就是13个100，1300个。也就是说此时百位上1的数目是由高位（12）决定的，而且等于（高位（12）+1）* 当前位因子（100）。</p><p>还有一个小问题就是如何求一个数的高位和低位，还有当前位。这和当前位的位因子有关系。</p><p>对于12345，假设当前位是百位（100），则</p><ul><li>低位数字：12345 - (12345 / 100) *100 = 45</li><li>高位数字：12345 / (100 * 10) = 12</li><li>当前位数字：12345 / 100 = 123，123 % 10 = 3。</li></ul><p>以上分析可以写出完整代码。</p><h2 id="Java实现"><a href="#Java实现" class="headerlink" title="Java实现"></a>Java实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">solution</span><span class="params">(<span class="type">int</span> N)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">lowNum</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 当前位的低位的数字</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">currNum</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 当前位数字</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">highNum</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 当前位的高位的数字</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">factor</span> <span class="operator">=</span> <span class="number">1</span>; factor &lt;= N; factor *= <span class="number">10</span>) &#123; <span class="comment">// 位因子</span></span><br><span class="line">        lowNum = N - (N / factor) * factor;</span><br><span class="line">        currNum = (N / factor) % <span class="number">10</span>;</span><br><span class="line">        highNum = N / (factor * <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span>(currNum == <span class="number">0</span>) &#123;</span><br><span class="line">            ans += highNum * factor;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(currNum == <span class="number">1</span>) &#123;</span><br><span class="line">            ans += highNum * factor + lowNum +<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans += (highNum + <span class="number">1</span>) * factor;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度只与N的位数有关，为$O(lgn)$。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://blog.csdn.net/liangbopirates/article/details/9323727">求1-N中十进制正整数1的个数</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【不会做】矩阵路径形成的最大整数</title>
      <link href="/2022/03/01/%E3%80%90%E4%B8%8D%E4%BC%9A%E5%81%9A%E3%80%91%E7%9F%A9%E9%98%B5%E8%B7%AF%E5%BE%84%E5%BD%A2%E6%88%90%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B4%E6%95%B0/"/>
      <url>/2022/03/01/%E3%80%90%E4%B8%8D%E4%BC%9A%E5%81%9A%E3%80%91%E7%9F%A9%E9%98%B5%E8%B7%AF%E5%BE%84%E5%BD%A2%E6%88%90%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B4%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>您将获得一个由 N 行和 M 列组成的板。电路板的每个字段（其实就是数组中的一个坐标点，作者注）都包含一个数字 (0-9)。</p><p>您希望查找由四个相邻字段组成的路径。如果两个字段共享一个共同点，则它们是相邻的。此外，路径中的字段应该是不同的（不能两次访问同一字段）。</p><p>路径的四位数字（按您访问它们的顺序）创建一个 整数。通过这种方式可以实现的最大整数是多少?</p><p>编写函数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">solution</span> <span class="params">(<span class="type">int</span>[][] board)</span> ;</span><br></pre></td></tr></table></figure><p>给定表示为由 N 行和 M 列组成的整数矩阵的板，则返回在长度为 4 的路径中连接值时可以实现的最大整数。<br>例子：给定以下板（N=3, M=5） :</p><p><img src="image-20220228105252210.png" alt="图1"></p><p>该函数应返回9121。您可以选择以下路径（第一 个字段用红色表示)：</p><p><img src="image-20220228105416502.png" alt="图2"></p><h1 id="解"><a href="#解" class="headerlink" title="解"></a>解</h1><p>知道用回溯或者BFS，但是代码写不出来。😓</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 回溯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人比较喜欢的健身动作</title>
      <link href="/2022/02/28/%E4%B8%AA%E4%BA%BA%E6%AF%94%E8%BE%83%E5%96%9C%E6%AC%A2%E7%9A%84%E5%81%A5%E8%BA%AB%E5%8A%A8%E4%BD%9C/"/>
      <url>/2022/02/28/%E4%B8%AA%E4%BA%BA%E6%AF%94%E8%BE%83%E5%96%9C%E6%AC%A2%E7%9A%84%E5%81%A5%E8%BA%AB%E5%8A%A8%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文整理一下个人比较喜欢健身动作。并备注动作要点</p></blockquote><h1 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h1><h2 id="平板支撑"><a href="#平板支撑" class="headerlink" title="平板支撑"></a>平板支撑</h2><p>改善的平板支撑：</p><ol><li>身体后移</li><li>骨盆后倾：收紧臀部，感觉上向后顶</li><li>纠正身体位置。肩膀用力向前推，上肢离地更远。</li></ol><p>新手先做到第二点延长到60秒，再两点一起做。</p><p>禁忌：</p><ol><li>手臂后缩</li><li>提臀或者臀太低。相反要用力收紧骨盆</li></ol><h1 id="臀腿"><a href="#臀腿" class="headerlink" title="臀腿"></a>臀腿</h1><h2 id="深蹲"><a href="#深蹲" class="headerlink" title="深蹲"></a>深蹲</h2><p>使用弹力带加大深蹲的阻力。</p><h2 id="单腿罗马尼亚硬拉"><a href="#单腿罗马尼亚硬拉" class="headerlink" title="单腿罗马尼亚硬拉"></a>单腿罗马尼亚硬拉</h2><p>锻炼臀肌、腘绳肌，锻炼单腿站立的稳定性，膝关节得稳定性。</p><p>视频：<a href="https://www.bilibili.com/video/BV1Ci4y1R72o?spm_id_from=333.999.0.0">https://www.bilibili.com/video/BV1Ci4y1R72o?spm_id_from=333.999.0.0</a></p><h1 id="背部"><a href="#背部" class="headerlink" title="背部"></a>背部</h1><h2 id="引体向上"><a href="#引体向上" class="headerlink" title="引体向上"></a>引体向上</h2><p>如果做不来可以使用弹力绳辅助。</p><h1 id="前锯肌"><a href="#前锯肌" class="headerlink" title="前锯肌"></a>前锯肌</h1><p>待整理：<a href="https://www.bilibili.com/video/BV1qq4y1k7oP?spm_id_from=333.999.0.0">https://www.bilibili.com/video/BV1qq4y1k7oP?spm_id_from=333.999.0.0</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://www.bilibili.com/video/BV1SP4y1j71R?spm_id_from=333.999.0.0">核心太弱，肚子肯定大（3个技巧快速改善）</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 方法论 </category>
          
          <category> 健身 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 健身 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Keep上不错的课程合集</title>
      <link href="/2022/02/28/Keep%E4%B8%8A%E4%B8%8D%E9%94%99%E7%9A%84%E8%AF%BE%E7%A8%8B%E5%90%88%E9%9B%86/"/>
      <url>/2022/02/28/Keep%E4%B8%8A%E4%B8%8D%E9%94%99%E7%9A%84%E8%AF%BE%E7%A8%8B%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文整理了一些适合自己的Keep课程，这些课程都亲自做过一遍。</p><p>本文会不断更新。</p></blockquote><div class="table-container"><table><thead><tr><th>课程名称</th><th>课程链接</th><th>难度</th><th>部位</th><th>器械</th><th>感受</th></tr></thead><tbody><tr><td>HIIT - 腹肌塑造</td><td><a href="https://show.gotokeep.com/course/607fefaa1310a35004149bc4">https://show.gotokeep.com/course/607fefaa1310a35004149bc4</a></td><td>3</td><td>腹部</td><td>不需要</td><td>挺累的，但是不难。做完腹部有明显酸痛</td></tr><tr><td>哑铃全方位胸部刺激-罗洪Ric</td><td><a href="https://show.gotokeep.com/course/6051a1b41310a33405483f53">https://show.gotokeep.com/course/6051a1b41310a33405483f53</a></td><td>4</td><td>胸部</td><td>哑铃</td><td>很有感觉。</td></tr><tr><td>哑铃手臂轰炸</td><td><a href="https://show.gotokeep.com/course/59ddde95a29e342161e42290">https://show.gotokeep.com/course/59ddde95a29e342161e42290</a></td><td>3</td><td>手臂</td><td>哑铃</td><td>练了好几次，快没感觉了，可能需要加大重量</td></tr><tr><td>跃动燃脂强化</td><td><a href="https://show.gotokeep.com/course/5b1e349aa29e343df182c7c0">https://show.gotokeep.com/course/5b1e349aa29e343df182c7c0</a></td><td>4</td><td>全身</td><td>不需要</td><td>挺累的。。</td></tr><tr><td>家庭哑铃增肌特训 · 强力臀腿</td><td><a href="https://show.gotokeep.com/course/601696ae627efb1bdd12ae13">https://show.gotokeep.com/course/601696ae627efb1bdd12ae13</a></td><td>3</td><td>臀腿</td><td>哑铃</td><td>忘记了。</td></tr><tr><td>核心功能强化</td><td><a href="https://show.gotokeep.com/course/5b90af2da29e342ee240c94f">https://show.gotokeep.com/course/5b90af2da29e342ee240c94f</a></td><td>4</td><td>腰腹</td><td>不需要</td><td>和“HIIT - 腹肌塑造”有点重复</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 方法论 </category>
          
          <category> 健身 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 健身 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>银行转账</title>
      <link href="/2022/02/27/%E9%93%B6%E8%A1%8C%E8%BD%AC%E8%B4%A6/"/>
      <url>/2022/02/27/%E9%93%B6%E8%A1%8C%E8%BD%AC%E8%B4%A6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文FROM 微软 软开 笔试题</p></blockquote><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>您将获得两个银行之间的N次转账列表（编号0到N-1）：银行A和银行B，第K次传输由两个值描述：</p><ul><li>R[K]（A或B）代表收款人（转账发送到的银行）；</li><li>V[K]表示通过传输发送的值。</li></ul><p>所有转移均按他们在列表中出现的顺序完成。银行不想负债（即他们的账户余额可能不会低于0）。每家银行的初始账户余额最低是多少才能完成转账？</p><p>编写一个函数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] solution(String R, <span class="type">int</span>[] V);</span><br></pre></td></tr></table></figure><p>给定一个字符串R和一个长度均为N的整数数组V，返回一个由两个整数组成的数组。证书应按以下顺序表示银行A和B的最小初始账户余额：[银行A, 银行B]。</p><p>结果数组应作为整数向量返回。</p><p>例子：</p><ol><li>给定R = “BAABA”且V=[2,4,1,1,2]，函数应该返回[2, 4]。每次转账后的银行账户余额如下表所示：</li></ol><div class="table-container"><table><thead><tr><th></th><th>A</th><th>B</th></tr></thead><tbody><tr><td>初始余额</td><td>2</td><td>4</td></tr><tr><td>A -&gt; B：转移 2</td><td>0</td><td>6</td></tr><tr><td>B -&gt; A：转移 4</td><td>4</td><td>2</td></tr><tr><td>B -&gt; A：转移 1</td><td>5</td><td>1</td></tr><tr><td>A -&gt; B：转移 1</td><td>4</td><td>2</td></tr><tr><td>B -&gt; A：转移 2</td><td>6</td><td>0</td></tr></tbody></table></div><ol><li>给定R = “ABAB”且V=[10,5,10,15]，函数应返回[0, 15]。</li><li>给定R = “B”且V=[100]，函数应返回[100, 0]。</li></ol><p>为以下假设编写有效算法。</p><h1 id="解"><a href="#解" class="headerlink" title="解"></a>解</h1><p>以例1为例，设计银行A的初始余额为X，银行B的初始余额为Y。则每一次转账后A的余额分别为：</p><p>X-2, X+2, X+3, X+2, X+4；B的余额分别为：</p><p>Y+2, Y-2, Y-3, Y-2, Y-4；</p><p>根据题目要求得any(X, X-2, X+2, X+3, X+2, X+4) &gt;=0 &amp;&amp; any(Y, Y+2, Y-2, Y-3, Y-2, Y-4)&gt;=0</p><p>即要求X-2&gt;=0; Y-4&gt;=0;</p><p>题目求最小初始余额，可得，X=2； Y=4</p><p>下面是代码实现。</p><h2 id="Java实现"><a href="#Java实现" class="headerlink" title="Java实现"></a>Java实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] solution(String R, <span class="type">int</span>[] V) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> V.length;</span><br><span class="line">    <span class="type">int</span>[] A = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="type">int</span>[] B = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span>(R.charAt(<span class="number">0</span>) == <span class="string">&#x27;B&#x27;</span>) &#123;</span><br><span class="line">        B[<span class="number">0</span>] = V[<span class="number">0</span>];</span><br><span class="line">        A[<span class="number">0</span>] = -V[<span class="number">0</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        B[<span class="number">0</span>] = -V[<span class="number">0</span>];</span><br><span class="line">        A[<span class="number">0</span>] = V[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">min_A</span> <span class="operator">=</span> A[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">min_B</span> <span class="operator">=</span> B[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(R.charAt(i) == <span class="string">&#x27;B&#x27;</span>) &#123;</span><br><span class="line">            A[i] = A[i-<span class="number">1</span>] - V[i];</span><br><span class="line">            B[i] = B[i-<span class="number">1</span>] + V[i];</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            A[i] = A[i-<span class="number">1</span>] + V[i];</span><br><span class="line">            B[i] = B[i-<span class="number">1</span>] - V[i];</span><br><span class="line">        &#125;</span><br><span class="line">        min_A = Math.min(min_A, A[i]);</span><br><span class="line">        min_B = Math.min(min_B, B[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//min_A和min_B不能是负数</span></span><br><span class="line">    min_A = Math.max(<span class="number">0</span>, -min_A);</span><br><span class="line">    min_B = Math.max(<span class="number">0</span>, -min_B);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;min_A, min_B&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>找到数组中比左边元素都大同时比右边元素都小的元素</title>
      <link href="/2022/02/23/%E6%89%BE%E5%88%B0%E6%95%B0%E7%BB%84%E4%B8%AD%E6%AF%94%E5%B7%A6%E8%BE%B9%E5%85%83%E7%B4%A0%E9%83%BD%E5%A4%A7%E5%90%8C%E6%97%B6%E6%AF%94%E5%8F%B3%E8%BE%B9%E5%85%83%E7%B4%A0%E9%83%BD%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/"/>
      <url>/2022/02/23/%E6%89%BE%E5%88%B0%E6%95%B0%E7%BB%84%E4%B8%AD%E6%AF%94%E5%B7%A6%E8%BE%B9%E5%85%83%E7%B4%A0%E9%83%BD%E5%A4%A7%E5%90%8C%E6%97%B6%E6%AF%94%E5%8F%B3%E8%BE%B9%E5%85%83%E7%B4%A0%E9%83%BD%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>求数组中比左边元素都大同时比右边元素都小的元素，返回这些元素的索引。要求时间复杂度$O(N)$</p><blockquote><p>输入：[2, 3, 1, 8, 9, 20, 12]<br>输出：3, 4<br>解释：数组中 8, 9 满足题目要求，他们的索引分别是 3、4</p></blockquote><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>最简单最暴力的就是没从头到尾遍历元素，对于每个元素分别往前、往后遍历一下，看看是否它是否满足条件。</p><p>这种解法的时间复杂度为$O(N^2)$，不符合题目要求。</p><p>通过分析可以得到，对于每个元素，如果它比<strong>左侧最大的值</strong>要大，同时比<strong>右侧最小的值</strong>要小，就满足条件。</p><p>那如果有这样两个数组，</p><p><code>left_max[i]</code> 表示原数组 [0, i) 的最大值</p><p><code>right_min[i]</code> 表示原数组 (i, n) 的最小值</p><p>内循环就可以通过 <code>left_max[i] &lt; nums[i] &amp;&amp; nums[i] &lt; right_min[i]</code> 来判断了。</p><p>对于 left_max 和 right_min 这两数组，提前先算好，每个数组都能$O(N)$得到。</p><p>left_max 和 right_min 递推式如下：</p><blockquote><p>left_max[i] = max(left_max[i-1], nums[i])</p><p>right_min[i] = min(right_min[i-1], nums[i])</p></blockquote><p>总时间复杂度为 $O(N)$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">find</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] left_max = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span>[] right_min = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(left_max, Integer.MIN_VALUE);</span><br><span class="line">        Arrays.fill(right_min, Integer.MAX_VALUE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            left_max[i] = Math.max(left_max[i-<span class="number">1</span>], nums[i-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n-<span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            right_min[i] = Math.min(right_min[i+<span class="number">1</span>], nums[i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; left_max[i] &amp;&amp; nums[i] &lt; right_min[i]) &#123;</span><br><span class="line">                res.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://mp.weixin.qq.com/s/ilOdw4qdu_EJZNXvybqdag">一道热乎的字节三面原创题</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 数组/链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何读论文</title>
      <link href="/2022/02/22/%E5%A6%82%E4%BD%95%E8%AF%BB%E8%AE%BA%E6%96%87/"/>
      <url>/2022/02/22/%E5%A6%82%E4%BD%95%E8%AF%BB%E8%AE%BA%E6%96%87/</url>
      
        <content type="html"><![CDATA[<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>一篇论文往往分为<strong>标题，摘要，导言，算法，实验，结论</strong>。</p><p><strong>算法</strong>就是论文作者提出的新的方法；<strong>实验</strong>是为了证明提出的算法。</p><h2 id="读第一遍"><a href="#读第一遍" class="headerlink" title="读第一遍"></a>读第一遍</h2><p>关注<strong>标题</strong>，<strong>摘要</strong>和<strong>结论</strong>；结论和摘要往往是一个东西，但是结论会把摘要的问题给证明一下；顺便看一下算法和实验部分的图标。</p><p><strong>目的</strong>：</p><ul><li>这篇论文介绍了什么</li><li>是否与自己相关</li><li>质量怎么样</li><li>是否继续读下去</li></ul><h2 id="读第二遍"><a href="#读第二遍" class="headerlink" title="读第二遍"></a>读第二遍</h2><p>如果第一遍认为该论文需要读下去，则进行第二遍通读，可以忽略很细节的部分，例如公式证明。</p><p>圈出引用的重要的相关的文献，例如，作者解决的问题是哪篇论文提出的，作者的方法是哪篇论文改进来的。</p><p><strong>目的：</strong></p><ul><li>掌握论文中的每一个图、表是什么意思；</li><li>作者的方法和别人的方法是怎么对比的，差距有多大</li></ul><h2 id="读第三遍"><a href="#读第三遍" class="headerlink" title="读第三遍"></a>读第三遍</h2><p>详细阅读第三遍，读懂每一句话，每一个细节。感同身受的去读。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://www.bilibili.com/video/BV1H44y1t75x">如何读论文 - 李沐</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 方法论 </category>
          
          <category> 阅读AI论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 方法论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>_Python 抛出异常后程序继续执行</title>
      <link href="/2022/02/22/Python-%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E5%90%8E%E7%A8%8B%E5%BA%8F%E7%BB%A7%E7%BB%AD%E6%89%A7%E8%A1%8C/"/>
      <url>/2022/02/22/Python-%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E5%90%8E%E7%A8%8B%E5%BA%8F%E7%BB%A7%E7%BB%AD%E6%89%A7%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文是一个知识碎片</p></blockquote><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>当遇到异常时，为了让程序继续执行而不中断，代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 可能抛出异常的代码块</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>注：<strong>这样做需要谨慎</strong>，原因如下：</p><ol><li>这样做抛出异常的类型不明确。可能抛出了你并不想忽略的异常；</li><li>这样做过于敷衍（除非你是有目的的这么做）</li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://blog.csdn.net/weixin_43307577/article/details/87710251">Python异常处理 -跳过异常继续执行</a></li><li><a href="https://developer.aliyun.com/article/803360">问题：为什么“except:pass”是一个不好的编程习惯？</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 异常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《动手学深度学习》读书笔记（三）CNN的填充、步幅、通道、池化</title>
      <link href="/2022/02/15/%E3%80%8A%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89CNN%E7%9A%84%E5%A1%AB%E5%85%85%E3%80%81%E6%AD%A5%E5%B9%85%E3%80%81%E9%80%9A%E9%81%93%E3%80%81%E6%B1%A0%E5%8C%96/"/>
      <url>/2022/02/15/%E3%80%8A%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89CNN%E7%9A%84%E5%A1%AB%E5%85%85%E3%80%81%E6%AD%A5%E5%B9%85%E3%80%81%E9%80%9A%E9%81%93%E3%80%81%E6%B1%A0%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文FROM《动手学深度学习》第六章 卷积神经网络 6.3、6.4和6.5小节</p><p>虽然标题中，填充、步幅、通道、池化放在一起，但是实际这四者并非并列关系。</p></blockquote><h1 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h1><p>在卷积神经网络中，卷积的输出形状取决于输入形状和卷积核的形状。</p><p>例如，一个 240×240 像素的图像，经过 10 层 5×5 的卷积后，将减少到 200×200 像素。如此一来，原始图像的边界丢失了许多有用信息。而<strong>填充</strong>是解决此问题最有效的方法。</p><p>下面的图展示了带填充的二维互相关。</p><p><img src="conv-pad.svg" alt="带填充的二维互相关"></p><p>设网络输入宽高分别为 $n_w$ 和 $n_h$，卷积核宽高分别为 $k_w$ 和 $k_h$，如果我们添加 $p_h$ 行填充（大约一半在顶部，一半在底部）和 $p_w$ 列填充（左侧大约一半，右侧一半），则输出形状将为</p><script type="math/tex; mode=display">(n_h-k_h+p_h+1)\times(n_w-k_w+p_w+1)。</script><p>这意味着输出的高度和宽度将分别增加 $p_h$ 和 $p_w$。</p><p>在许多情况下，我们需要设置 $p_h=k_h-1$ 和 $p_w=k_w-1$，使输入和输出具有相同的高度和宽度。这样可以在构建网络时更容易地预测每个图层的输出形状。假设 $k_h$ 是奇数，我们将在高度的两侧填充 $p_h/2$ 行。<br>如果 $k_h$ 是偶数，则一种可能性是在输入顶部填充 $\lceil p_h/2\rceil$ 行，在底部填充 $\lfloor p_h/2\rfloor$ 行。填充宽度的两侧同理。</p><p>卷积神经网络中卷积核的高度和宽度通常为奇数，例如 1、3、5 或 7。选择奇数的好处是，保持空间维度的同时，我们可以在顶部和底部填充相同数量的行，在左侧和右侧填充相同数量的列。</p><p>此外，使用奇数核和填充也提供了书写上的便利。对于任何二维张量 $X$，当满足：</p><ol><li>内核的大小是奇数；</li><li>所有边的填充行数和列数相同；</li><li>输出与输入具有相同高度和宽度</li></ol><p>则可以得出：输出 $Y[i, j]$ 是通过以输入 $X[i, j]$ 为中心，与卷积核进行互相关计算得到的。比如，在下面的例子中，我们创建一个高度和宽度为3的二维卷积层，并<strong>在所有侧边填充1个像素</strong>。给定高度和宽度为8的输入，则输出的高度和宽度也是8。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 为了方便起见，我们定义了一个计算卷积层的函数。</span></span><br><span class="line"><span class="comment"># 此函数初始化卷积层权重，并对输入和输出提高和缩减相应的维数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">comp_conv2d</span>(<span class="params">conv2d, X</span>):</span><br><span class="line">    <span class="comment"># 这里的（1，1）表示批量大小和通道数都是1</span></span><br><span class="line">    X = X.reshape((<span class="number">1</span>, <span class="number">1</span>) + X.shape)</span><br><span class="line">    Y = conv2d(X)  <span class="comment"># 将X输入到卷积层中，输出Y</span></span><br><span class="line">    <span class="comment"># 省略前两个维度：批量大小和通道</span></span><br><span class="line">    <span class="keyword">return</span> Y.reshape(Y.shape[<span class="number">2</span>:])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 请注意，这里每边都填充了1行或1列，因此总共添加了2行或2列</span></span><br><span class="line">conv2d = nn.Conv2d(<span class="number">1</span>, <span class="number">1</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>)  <span class="comment"># 这里定义了一个卷积层</span></span><br><span class="line">X = torch.rand(size=(<span class="number">8</span>, <span class="number">8</span>))</span><br><span class="line">comp_conv2d(conv2d, X).shape</span><br></pre></td></tr></table></figure><pre><code>torch.Size([8, 8])</code></pre><p>当卷积核的高度和宽度不同时，我们可以填充不同的高度和宽度，使输出和输入具有相同的高度和宽度。在如下示例中，我们使用高度为5，宽度为3的卷积核，高度和宽度两边的填充分别为2和1。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">conv2d = nn.Conv2d(<span class="number">1</span>, <span class="number">1</span>, kernel_size=(<span class="number">5</span>, <span class="number">3</span>), padding=(<span class="number">2</span>, <span class="number">1</span>))</span><br><span class="line">comp_conv2d(conv2d, X).shape</span><br></pre></td></tr></table></figure><pre><code>torch.Size([8, 8])</code></pre><h1 id="步幅"><a href="#步幅" class="headerlink" title="步幅"></a>步幅</h1><p>在计算互相关时，卷积窗口从输入张量的左上角开始，向下、向右滑动。 在前面的例子中，我们默认每次滑动一个元素。 但是，有时候为了高效计算或是缩减采样次数，卷积窗口可以跳过中间位置，每次滑动多个元素。</p><p>我们将每次滑动元素的数量称为步幅（stride）。下图展示了垂直步幅为 3 ，水平步幅为 2 的二维互相关运算。</p><p><img src="conv-stride.svg" alt="垂直步幅为 $3$，水平步幅为 $2$ 的二维互相关运算"></p><p>可以看到，为了计算输出中第一列的第二个元素和第一行的第二个元素，卷积窗口分别向下滑动三行和向右滑动两列。但是，当卷积窗口继续向右滑动两列时，没有输出，因为输入元素无法填充窗口（除非我们添加另一列填充）。</p><p>通常，当垂直步幅为 $s_h$ 、水平步幅为 $s_w$ 时，输出形状为</p><script type="math/tex; mode=display">\lfloor(n_h-k_h+p_h+s_h)/s_h\rfloor \times \lfloor(n_w-k_w+p_w+s_w)/s_w\rfloor.</script><p>如果我们设置了 $p_h=k_h-1$ 和 $p_w=k_w-1$，则输出形状将简化为 $\lfloor(n_h+s_h-1)/s_h\rfloor \times \lfloor(n_w+s_w-1)/s_w\rfloor$。<br>更进一步，如果输入的高度和宽度可以被垂直和水平步幅整除，则输出形状将为 $(n_h/s_h) \times (n_w/s_w)$。</p><p>下面，我们<strong>将高度和宽度的步幅设置为2</strong>，从而将输入的高度和宽度减半。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">conv2d = nn.Conv2d(<span class="number">1</span>, <span class="number">1</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>, stride=<span class="number">2</span>)</span><br><span class="line">comp_conv2d(conv2d, X).shape</span><br></pre></td></tr></table></figure><pre><code>torch.Size([4, 4])</code></pre><p>为了简洁起见，当输入高度和宽度两侧的填充数量分别为 $p_h$ 和 $p_w$ 时，我们称之为填充 $(p_h, p_w)$。当 $p_h = p_w = p$ 时，填充是 $p$。同理，当高度和宽度上的步幅分别为 $s_h$ 和 $s_w$ 时，我们称之为步幅 $(s_h, s_w)$。当时的步幅为 $s_h = s_w = s$ 时，步幅为 $s$。默认情况下，填充为 0，步幅为 1。<strong>在实践中，我们很少使用不一致的步幅或填充，也就是说，我们通常有 $p_h = p_w$ 和 $s_h = s_w$。</strong></p><h1 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h1><p>当我们添加通道时，我们的输入和隐藏的表示从二维张量变成了三维张量。例如，每个RGB输入图像具有 3×h×w 的形状。我们将这个大小为 3 的轴称为通道（channel）维度。</p><p>通道分为输入通道和输出通道。灰度图的输入通道为1，RGB图的输入通道为3。而输出通道是自定义的。灰度图的输出通道也可以大于1，RGB图的输出通道也可以为1，这取决于如何定义卷积核和输出。</p><h2 id="多输入通道"><a href="#多输入通道" class="headerlink" title="多输入通道"></a>多输入通道</h2><p>当输入包含多个通道时，需要构造一个与输入数据具有相同输入通道数目的卷积核，以便与输入数据进行互相关运算。假设输入的通道数为 $c_i$，那么卷积核的输入通道数也需要为 $c_i$ 。如果卷积核的窗口形状是 $k_h\times k_w$，那么当 $c_i=1$ 时，我们可以把卷积核看作形状为 $k_h\times k_w$ 的二维张量。</p><p>然而，当 $c_i&gt;1$ 时，我们卷积核的每个输入通道将包含形状为 $k_h\times k_w$ 的张量。将这些张量 $c_i$ 连结在一起可以得到形状为 $c_i\times k_h\times k_w$ 的卷积核。由于输入和卷积核都有 $c_i$ 个通道，我们可以对每个通道输入的二维张量和卷积核的二维张量进行互相关运算，再对通道求和（将 $c_i$ 的结果相加）得到二维张量。这是多通道输入和多输入通道卷积核之间进行二维互相关运算的结果。</p><p>下图我们演示了一个具有两个输入通道的二维互相关运算的示例。</p><p><img src="conv-multi-in.svg" alt="两个输入通道的互相关计算。"></p><p>多输入通道互相关运算的实现如下。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">corr2d_multi_in</span>(<span class="params">X, K</span>):</span><br><span class="line">    <span class="comment"># 先遍历“X”和“K”的第0个维度（通道维度），再把它们加在一起</span></span><br><span class="line">    <span class="comment"># for x, k in zip(X, K) 拿出X, K对应维度里的矩阵</span></span><br><span class="line">    <span class="comment"># d2l.corr2d()函数：完成互相关运算</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(d2l.corr2d(x, k) <span class="keyword">for</span> x, k <span class="keyword">in</span> <span class="built_in">zip</span>(X, K))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = torch.tensor([[[<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>], [<span class="number">3.0</span>, <span class="number">4.0</span>, <span class="number">5.0</span>], [<span class="number">6.0</span>, <span class="number">7.0</span>, <span class="number">8.0</span>]],</span><br><span class="line">               [[<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>], [<span class="number">4.0</span>, <span class="number">5.0</span>, <span class="number">6.0</span>], [<span class="number">7.0</span>, <span class="number">8.0</span>, <span class="number">9.0</span>]]])</span><br><span class="line">K = torch.tensor([[[<span class="number">0.0</span>, <span class="number">1.0</span>], [<span class="number">2.0</span>, <span class="number">3.0</span>]], [[<span class="number">1.0</span>, <span class="number">2.0</span>], [<span class="number">3.0</span>, <span class="number">4.0</span>]]])</span><br><span class="line"></span><br><span class="line">corr2d_multi_in(X, K)</span><br></pre></td></tr></table></figure><pre><code>tensor([[ 56.,  72.],        [104., 120.]])</code></pre><h2 id="多输出通道"><a href="#多输出通道" class="headerlink" title="多输出通道"></a>多输出通道</h2><p>到目前为止，不论有多少输入通道，我们还只有一个输出通道。然而，这是不够的。在最流行的神经网络架构中，随着神经网络层数的加深，我们常会<strong>增加输出通道的维数，通过减少空间分辨率以获得更大的通道深度</strong>。直观地说，我们可以将每个通道看作是对不同特征的响应。而现实可能更为复杂一些，因为每个通道不是独立学习的，而是为了共同使用而优化的。因此，多输出通道并不仅是学习多个单通道的检测器。</p><p>用 $c_i$ 和 $c_o$ 分别表示输入和输出通道的数目，并让 $k_h$ 和 $k_w$ 为卷积核的高度和宽度。为了获得多个通道的输出，我们可以为每个输出通道创建一个形状为 $c_i\times k_h\times k_w$ 的卷积核张量，这样卷积核的形状是 $c_o\times c_i\times k_h\times k_w$。在互相关运算中，每个输出通道先获取所有输入通道，再以对应该输出通道的卷积核计算出结果。</p><p>如下所示，我们实现一个<strong>计算多个通道的输出的互相关函数</strong>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">corr2d_multi_in_out</span>(<span class="params">X, K</span>):</span><br><span class="line">    <span class="comment"># 迭代“K”的第0个维度，每次都对输入“X”执行互相关运算。</span></span><br><span class="line">    <span class="comment"># 最后将所有结果都叠加在一起</span></span><br><span class="line">    <span class="comment"># `corr2d_multi_in(X, k) for k in K`意思是在拿出每一个二维卷积核k，都对完整的输入X做互相关运算</span></span><br><span class="line">    <span class="comment"># torch.stack(…, 0)意思是将结果在0的维度上“堆”起来</span></span><br><span class="line">    <span class="keyword">return</span> torch.stack([corr2d_multi_in(X, k) <span class="keyword">for</span> k <span class="keyword">in</span> K], <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>上面代码中，<code>torch.stack(…, 0)</code>是将结果在0的维度上“堆”起来。下面通过将核张量K与K+1（K中每个元素加 1 ）和K+2连接起来，构造了一个具有 3 个输出通道的卷积核。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">K = torch.stack((K, K + <span class="number">1</span>, K + <span class="number">2</span>), <span class="number">0</span>)</span><br><span class="line">K.shape  <span class="comment"># 原始K的维度是(2,2,2)</span></span><br></pre></td></tr></table></figure><pre><code>torch.Size([3, 2, 2, 2])</code></pre><p>下面，我们对输入张量X与卷积核张量K执行互相关运算。现在的输出包含 3 个通道，</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">corr2d_multi_in_out(X, K)</span><br></pre></td></tr></table></figure><pre><code>tensor([[[ 56.,  72.],         [104., 120.]],        [[ 76., 100.],         [148., 172.]],        [[ 96., 128.],         [192., 224.]]])</code></pre><h2 id="1-times-1-卷积层"><a href="#1-times-1-卷积层" class="headerlink" title="$1\times 1$ 卷积层"></a>$1\times 1$ 卷积层</h2><p>$1\times 1$ 卷积，即 $k_h = k_w = 1$，看起来似乎没有多大意义。<br>毕竟，卷积的本质是有效提取相邻像素间的相关特征，而 $1 \times 1$ 卷积显然没有此作用。<br>尽管如此，$1 \times 1$ 仍然十分流行，时常包含在复杂深层网络的设计中。下面，让我们详细地解读一下它的实际作用。</p><p>因为使用了最小窗口，$1\times 1$ 卷积失去了卷积层的特有能力——在高度和宽度维度上，识别相邻元素间相互作用的能力。<br>其实 $1\times 1$ 卷积的唯一计算发生在通道上。</p><p>下图展示了使用 $1\times 1$ 卷积核与 $3$ 个输入通道和 $2$ 个输出通道的互相关计算。这里输入和输出具有相同的高度和宽度，输出中的每个元素都是从输入图像中同一位置的元素的线性组合。我们可以将 $1\times 1$ 卷积层看作是在每个像素位置应用的全连接层，以 $c_i$ 个输入值转换为 $c_o$ 个输出值。因为这仍然是一个卷积层，所以跨像素的权重是一致的。同时，$1\times 1$ 卷积层需要的权重维度为 $c_o\times c_i$ ，再额外加上一个偏置。</p><p><img src="conv-1x1.svg" alt="互相关计算使用了具有3个输入通道和2个输出通道的 $1\times 1$ 卷积核。其中，输入和输出具有相同的高度和宽度。"></p><p>下面，我们使用全连接层实现 $1 \times 1$ 卷积。请注意，我们需要对输入和输出的数据形状进行微调。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">corr2d_multi_in_out_1x1</span>(<span class="params">X, K</span>):</span><br><span class="line">    c_i, h, w = X.shape</span><br><span class="line">    c_o = K.shape[<span class="number">0</span>]</span><br><span class="line">    X = X.reshape((c_i, h * w))</span><br><span class="line">    K = K.reshape((c_o, c_i))</span><br><span class="line">    <span class="comment"># 全连接层中的矩阵乘法</span></span><br><span class="line">    Y = torch.matmul(K, X)</span><br><span class="line">    <span class="keyword">return</span> Y.reshape((c_o, h, w))</span><br></pre></td></tr></table></figure><p>当执行 $1\times 1$ 卷积运算时，上述函数相当于先前实现的互相关函数<code>corr2d_multi_in_out</code>。让我们用一些样本数据来验证这一点。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = torch.normal(<span class="number">0</span>, <span class="number">1</span>, (<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line">K = torch.normal(<span class="number">0</span>, <span class="number">1</span>, (<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Y1 = corr2d_multi_in_out_1x1(X, K)</span><br><span class="line">Y2 = corr2d_multi_in_out(X, K)</span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">float</span>(torch.<span class="built_in">abs</span>(Y1 - Y2).<span class="built_in">sum</span>()) &lt; <span class="number">1e-6</span></span><br></pre></td></tr></table></figure><h1 id="pooling"><a href="#pooling" class="headerlink" title="pooling"></a>pooling</h1><p>通常当我们处理图像时，我们希望逐渐降低隐藏表示的空间分辨率，聚集信息，这样随着我们在神经网络中层叠的上升，每个神经元对其敏感的感受野（输入）就越大。</p><p>而我们的机器学习任务通常会跟全局图像的问题有关（例如，“图像是否包含一只猫呢？”）， 所以我们最后一层的神经元应该对整个输入的全局敏感。通过逐渐聚合信息，生成越来越粗糙的映射，最终实现学习全局表示的目标，同时将卷积图层的所有优势保留在中间层。</p><p>此外，当检测较底层的特征时，我们通常希望这些特征保持某种程度上的平移不变性。例如，如果我们拍摄黑白之间轮廓清晰的图像 $X$，并将整个图像向右移动一个像素，即 $Z[i, j] = X[i, j + 1]$，则新图像 $Z$ 的输出可能大不相同。而在现实中，随着拍摄角度的移动，任何物体几乎不可能发生在同一像素上。即使用三脚架拍摄一个静止的物体，由于快门的移动而引起的相机振动，可能会使所有物体左右移动一个像素。</p><p>本节将介绍 <em>池化</em>（pooling）层，它具有双重目的：降低卷积层对位置的敏感性，同时降低对空间降采样表示的敏感性。</p><h2 id="最大汇聚层和平均汇聚层"><a href="#最大汇聚层和平均汇聚层" class="headerlink" title="最大汇聚层和平均汇聚层"></a>最大汇聚层和平均汇聚层</h2><p>与卷积层类似，汇聚层运算符由一个固定形状的窗口组成，该窗口根据其步幅大小在输入的所有区域上滑动，为固定形状窗口（有时称为 <em>池化窗口</em>）遍历的每个位置计算一个输出。</p><p>然而，不同于卷积层中的输入与卷积核之间的互相关计算，汇聚层不包含参数。<br>相反，池运算符是确定性的，我们通常计算池化窗口中所有元素的最大值或平均值。这些操作分别称为 <em>最大汇聚层</em> （maximum pooling）和 <em>平均汇聚层</em> （average pooling）。</p><p>在这两种情况下，与互相关运算符一样，池化窗口从输入张量的左上角开始，从左到右、从上到下的在输入张量内滑动。在池化窗口到达的每个位置，它计算该窗口中输入子张量的最大值或平均值，具体取决于是使用了最大汇聚层还是平均汇聚层。</p><p><img src="pooling.svg" alt="池化窗口形状为 $2\times 2$ 的最大汇聚层。着色部分是第一个输出元素，以及用于计算这个输出的输入元素: $\max(../img/pooling.svg)=4$."></p><p>上图中输出张量的高度为 $2$，宽度为 $2$。这四个元素为每个池化窗口中的最大值：</p><script type="math/tex; mode=display">\max(0, 1, 3, 4)=4,\\\max(1, 2, 4, 5)=5,\\\max(3, 4, 6, 7)=7,\\\max(4, 5, 7, 8)=8.\\</script><p>池化窗口形状为 $p \times q$ 的汇聚层称为 $p \times q$ 汇聚层，池化操作称为 $p \times q$ 池化。</p><p>回到本节开头提到的对象边缘检测示例，现在我们将使用卷积层的输出作为 $2\times 2$ 最大池化的输入。设置卷积层输入为 $X$，汇聚层输出为 $Y$。无论 $X[i, j]$ 和 $X[i, j + 1]$ 的值是否不同，或 $X[i, j + 1]$ 和 $X[i, j + 2]$ 的值是否不同，汇聚层始终输出 $Y[i, j] = 1$。也就是说，使用 $2\times 2$ 最大汇聚层，即使在高度或宽度上移动一个元素，卷积层仍然可以识别到模式。</p><p>在下面的代码中的 <code>pool2d</code> 函数，我们<strong>实现汇聚层的正向传播</strong>。然而，这里我们没有卷积核，输出为输入中每个区域的最大值或平均值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">pool2d</span>(<span class="params">X, pool_size, mode=<span class="string">&#x27;max&#x27;</span></span>):</span><br><span class="line">    p_h, p_w = pool_size</span><br><span class="line">    Y = torch.zeros((X.shape[<span class="number">0</span>] - p_h + <span class="number">1</span>, X.shape[<span class="number">1</span>] - p_w + <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(Y.shape[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(Y.shape[<span class="number">1</span>]):</span><br><span class="line">            <span class="keyword">if</span> mode == <span class="string">&#x27;max&#x27;</span>:</span><br><span class="line">                Y[i, j] = X[i: i + p_h, j: j + p_w].<span class="built_in">max</span>()</span><br><span class="line">            <span class="keyword">elif</span> mode == <span class="string">&#x27;avg&#x27;</span>:</span><br><span class="line">                Y[i, j] = X[i: i + p_h, j: j + p_w].mean()</span><br><span class="line">    <span class="keyword">return</span> Y</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 构建输入X，验证最大池化的输出</span></span><br><span class="line">X = torch.tensor([[<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>], [<span class="number">3.0</span>, <span class="number">4.0</span>, <span class="number">5.0</span>], [<span class="number">6.0</span>, <span class="number">7.0</span>, <span class="number">8.0</span>]])</span><br><span class="line">pool2d(X, (<span class="number">2</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure><pre><code>tensor([[4., 5.],        [7., 8.]])</code></pre><h2 id="填充与步幅"><a href="#填充与步幅" class="headerlink" title="填充与步幅"></a>填充与步幅</h2><p>与卷积层一样，汇聚层也可以改变输出形状。和以前一样，我们可以通过填充和步幅以获得所需的输出形状。 下面，我们用深度学习框架中内置的二维最大汇聚层，来演示汇聚层中填充和步幅的使用。 我们首先构造了一个输入张量X，它有四个维度，其中样本数和通道数都是1。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = torch.arange(<span class="number">16</span>, dtype=torch.float32).reshape((<span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">4</span>))</span><br><span class="line">X</span><br></pre></td></tr></table></figure><pre><code>tensor([[[[ 0.,  1.,  2.,  3.],          [ 4.,  5.,  6.,  7.],          [ 8.,  9., 10., 11.],          [12., 13., 14., 15.]]]])</code></pre><p>默认情况下，深度学习框架中的步幅与汇聚窗口的大小相同。 因此，如果我们使用形状为(3, 3)的汇聚窗口，那么默认情况下，我们得到的步幅形状为(3, 3)</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pool2d = nn.MaxPool2d(<span class="number">3</span>)</span><br><span class="line">pool2d(X)</span><br></pre></td></tr></table></figure><pre><code>tensor([[[[10.]]]])</code></pre><p>填充和步幅可以手动设定：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pool2d = nn.MaxPool2d(<span class="number">3</span>, padding=<span class="number">1</span>, stride=<span class="number">2</span>)</span><br><span class="line">pool2d(X)</span><br></pre></td></tr></table></figure><p>当然，我们可以设定一个任意大小的矩形汇聚窗口，并分别设定填充和步幅的高度和宽度。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pool2d = nn.MaxPool2d((<span class="number">2</span>, <span class="number">3</span>), stride=(<span class="number">2</span>, <span class="number">3</span>), padding=(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">pool2d(X)</span><br></pre></td></tr></table></figure><pre><code>tensor([[[[ 5.,  7.],          [13., 15.]]]])</code></pre><h2 id="多个通道"><a href="#多个通道" class="headerlink" title="多个通道"></a>多个通道</h2><p>在处理多通道输入数据时，汇聚层在每个输入通道上单独运算，而不是像卷积层一样在通道上对输入进行汇总。 这意味着汇聚层的输出通道数与输入通道数相同。 下面，我们将在通道维度上连结张量X和X + 1，以构建具有2个通道的输入。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = torch.cat((X, X + <span class="number">1</span>), <span class="number">1</span>)</span><br><span class="line">X</span><br></pre></td></tr></table></figure><pre><code>tensor([[[[ 0.,  1.,  2.,  3.],          [ 4.,  5.,  6.,  7.],          [ 8.,  9., 10., 11.],          [12., 13., 14., 15.]],         [[ 1.,  2.,  3.,  4.],          [ 5.,  6.,  7.,  8.],          [ 9., 10., 11., 12.],          [13., 14., 15., 16.]]]])</code></pre><p>pooling后输出通道的数量仍然是2。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pool2d = nn.MaxPool2d(<span class="number">3</span>, padding=<span class="number">1</span>, stride=<span class="number">2</span>)</span><br><span class="line">pool2d(X)</span><br></pre></td></tr></table></figure><pre><code>tensor([[[[ 5.,  7.],          [13., 15.]],         [[ 6.,  8.],          [14., 16.]]]])</code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>《动手学深度学习》6.3、6.4、6.5节</li></ol>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
          <category> 动手学深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 动手学深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 多线程基础</title>
      <link href="/2022/01/24/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/01/24/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇博客叙述Java多线程的基本知识和基本操作。</p><blockquote><p>待补充的部分：</p><ul><li>[ ] 线程调度</li><li>[ ] AtomicInteger</li><li>[ ] Semaphore</li><li>[ ] 阻塞队列的实现类详解</li><li>[ ] 多线程共享数据的方法</li><li>[ ] ConcurrentHashMap</li><li>[ ] Java并发关键字</li><li>[ ] 进程调度算法</li><li>[ ] CAS/ABA/AQS</li></ul></blockquote><h1 id="线程概述"><a href="#线程概述" class="headerlink" title="线程概述"></a>线程概述</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>当一个程序进入内存运行时，即变成一个进程。进程是处于运行过程中的程序，并且具有一定独立的功能，进程是系统进行资源分配和调度的一个独立单位。</p><p>一般而言，进程包含三个特征：独立性；动态性；并发性。、</p><p>并发和并行是两个概念，并行是指同一时刻，有多条指令在多个处理器上同时执行；并发指在同一时刻只能有一条指令执行，但多个进程指令被快速轮换执行，使得宏观上具有多个进程同时执行的效果。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>多线程扩展了多进程的概念，使得同一个进程可以同时并发处理多个任务。</p><p>线程是进程的执行单元，是进程的组成部分，一个进程可以拥有多个线程，一个线程必须有一个父进程。线程可以拥有自己的堆栈、自己的程序计数器和自己的局部变量。</p><p>多个线程共享父进程里的全部资源，可以与其他线程共享父进程中的共享变量和部分环境。</p><p>线程是独立于运行的，他并不知道进程中是否还有其他线程存在。现成的执行是抢占式的，也就是说，当前运行的线程在任何时候都可能被挂起，以便另一个线程可以运行。</p><p>一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行。</p><p>从逻辑的角度，多线程存在于一个应用程序中，让一个应用程序中可以有多个执行部分同时执行，但操作系统无须将多个线程看作多个独立的应用，对多线程实现调度和管理以及资源分配。线程的调度和管理由进程本身负责完成。</p><h2 id="线程优势"><a href="#线程优势" class="headerlink" title="线程优势"></a>线程优势</h2><p>进程中线程的之间的隔离程度更小。</p><p>多个线程共享同一个进程虚拟空间。线程共享的环境包括：进程代码段、进程的共有数据等。<br>总结起来，使用多线程编程具有如下优点：</p><ul><li>进程之间不能共享内存，但线程之间共享内存很容易</li><li>系统创建进程时，需要位该进程重新分配系统资源，但创建线程则代价小很多，因此使用多线程实现多任务并发比多进程的效率高。</li><li>Java语言内置了多线程功能支持，而不是单纯的作为底层操作系统的调度方式，从而简化了Java的多线程编程。</li></ul><h1 id="线程创建和启动"><a href="#线程创建和启动" class="headerlink" title="线程创建和启动"></a>线程创建和启动</h1><p>有三种方式创建线程类</p><h2 id="继承Thread类创建线程类"><a href="#继承Thread类创建线程类" class="headerlink" title="继承Thread类创建线程类"></a>继承Thread类创建线程类</h2><ol><li>定义Thread的子类，并重写run方法，该run方法的方法题就代表了线程需要完成的任务。（线程执行体）</li><li>创建Thread子类的实例，即创建了线程对象。</li><li>调用线程对象的start方法来启动该线程。</li></ol><h2 id="实现Runnable接口创建线程类"><a href="#实现Runnable接口创建线程类" class="headerlink" title="实现Runnable接口创建线程类"></a>实现Runnable接口创建线程类</h2><ol><li>定义Runnable接口的实现类，并重写该接口的run方法。该run方法的方法体同样是该线程的线程执行体。</li><li>创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。</li></ol><blockquote><p>代码</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTester</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">firstThread</span>().start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">firstThread</span>().start();</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">tt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">secondThread</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(tt, <span class="string">&quot;新线程1&quot;</span>).start(); <span class="comment">//可以给线程命名</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(tt, <span class="string">&quot;新线程2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">firstThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(getName() + <span class="string">&quot;：&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">secondThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：&quot;</span> + i); <span class="comment">//只能使用Thread.currentThread().getName()来获得线程名</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注</p><ul><li>使用继承Thread类的方法来创建线程类时，多个线程之间无法共享线程类的实例变量。</li><li>Runnable对象仅作为Thread对象的target，Runnable实现类里包含的run方法仅作为线程执行体。而实际的线程对象依然是Thread实例，只是该Thread线程负责执行其target的run方法。</li><li>通过实现Runnable接口来获得当前线程对象，则必须使用Thread.currentThread()方法。</li><li>从Java8开始，Runnable接口使用了@FunctionalInterface，也就是说，可以使用Lambda表达式创建Runnable对象。下面介绍的Callable接口也是函数式接口。</li></ul><h2 id="使用Callable和Future创建线程"><a href="#使用Callable和Future创建线程" class="headerlink" title="使用Callable和Future创建线程"></a>使用Callable和Future创建线程</h2><p>Callable接口提供了一个call方法可以作为线程执行体，但call方法比run方法功能更强大。</p><ul><li>call方法有返回值。</li><li>call可以声明抛出异常。</li></ul><p>完全可以提供一个Callable对象作为Thread的target，而该线程的线程执行体就是该Callable对象的call方法。但Callable接口不是Runnable接口的子接口，所以Callable对象不能直接作为Thread的target。</p><p>Java5提供了Future接口来代表Callable接口里call方法的返回值，并为Future接口提供了一个FutureTask实现类，该实现类实现了Future接口并实现了Runnable接口，可以作为Thread类的target。</p><p><img src="20160713174739239.png" alt="FutureTask"></p><p>Future接口中定义了如下公共方法来控制它关联的Callable任务。</p><ul><li><code>boolean cancel(boolean mayInterroutIfRunning)</code>：试图取消该Future里关联的Callable任务。</li><li><code>V get()</code>：返回Callable任务里的call方法的返回值。调用该方法将导致程序阻塞，必须等待子线程接口后才会得到返回值。</li><li><code>V get(long timeout, TimeUnit unit)</code>：返回Callable任务里的call方法的返回值。该方法让程序最多阻塞timeout和unit指定的时间，如果经过指定时间后Callable任务依然没有返回值，将会抛出TimeoutException异常。</li><li><code>boolean isCancelled()</code>如果Callable任务正常完成前被取消，则返回true。</li><li><code>boolean isDone()</code>如果Callable任务已完成，则返回true。</li></ul><p>创建并启动有返回值的线程步骤如下：</p><ol><li>创建Callable接口的实现类，并实现call方法（注意泛型），该call方法将作为线程执行体，且该call方法有返回值，再创建Callable实现类的实例。</li><li>使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call方法的返回值。</li><li>使用FutureTask对象作为Thread对象的target创建并启动新线程。</li><li>调用FutureTask对象的get方法来获得子线程执行结束后的返回值。</li></ol><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableTester</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">thirdThread</span>()); <span class="comment">//也可以使用lambda表达式生成Callable对象</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(task, <span class="string">&quot;有返回值的线程1&quot;</span>).start();</span><br><span class="line"><span class="comment">//        new Thread(task, &quot;有返回值的线程2&quot;).start(); // 不生效，task对象只能用一次？</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程返回值：&quot;</span>+task.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">thirdThread</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span>(; i &lt; <span class="number">10</span> ; i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：Callable接口有泛型限制，Callable接口里的泛型形参类型与call方法返回值类型相同。</p><h2 id="三种创建线程的方式对比"><a href="#三种创建线程的方式对比" class="headerlink" title="三种创建线程的方式对比"></a>三种创建线程的方式对比</h2><ul><li>实现Runnable接口和实现Callable接口的方式基本相同，只是Callable接口里定义的方法有返回值，可以声明抛出异常而已。</li><li>采用实现Runnable、Callable接口的方式的优点是<ul><li>线程类还可以继承其他类</li><li>多个线程可以共享一个target对象，非常适合多个相同线程来处理同一份资源的情况。</li></ul></li><li>采用继承Thread类方式创建多线程的优点是：<ul><li>编写简单</li></ul></li></ul><h1 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h1><p>一个线程要经过新建（New）、就绪（Ready）、运行（Running）、阻塞（Blocked）、死亡（Dead）5种状态。</p><p>线程状态以及转换图如下：</p><p><img src="image-20210709151939392.png" alt="线程生命周期"></p><h2 id="新建和就绪状态"><a href="#新建和就绪状态" class="headerlink" title="新建和就绪状态"></a>新建和就绪状态</h2><p>当程序使用了new关键字创建了一个线程之后，该线程就处于新建状态。</p><p>当线程调用了start方法后，该线程就处于就绪状态。处于就绪状态的线程并没有开始运行，只是表示该线程可以运行了。</p><h2 id="运行和阻塞状态"><a href="#运行和阻塞状态" class="headerlink" title="运行和阻塞状态"></a>运行和阻塞状态</h2><p>如果处于就绪状态的线程获得了CPU，开始执行run方法的线程执行体，则该线程就处于运行状态。</p><p>线程在运行过程种需要被中断，目的是使其他线程获得执行的机会。当前执行的线程被阻塞后，其他线程就可以获得执行的机会。被阻塞的线程会在合适的时候将重新进入<strong>就绪状态</strong>。</p><p>比较特殊的情况，调用yield方法可以让运行状态的线程转入就绪状态。、</p><h2 id="线程死亡"><a href="#线程死亡" class="headerlink" title="线程死亡"></a>线程死亡</h2><p>线程可以以如上图三种方式死亡。</p><p>为了测试某个线程是否死亡，可以调用线程对象的isAlive方法，当线程处于就绪、运行、阻塞三种状态时，该方法将返回true；当线程处于新建、死亡两种状态时，该方法将返回false。</p><p>注意：</p><ul><li>当主线程结束时，其他线程不受影响，并不会随之结束。一旦子线程启动起来后，他就拥有和主线程相同的地位，他不会受主线程的影响。</li><li>不要试图对一个已经死亡的线程调用start方法使他重新启动。</li><li>对于新建状态的线程两次调用start方法也是错误的。</li></ul><h1 id="控制线程"><a href="#控制线程" class="headerlink" title="控制线程"></a>控制线程</h1><h2 id="join线程"><a href="#join线程" class="headerlink" title="join线程"></a>join线程</h2><p>Thread提供了一个让线程等待另一个线程完成的方法——join方法。当在某个车光绪执行流中调用其他线程的join方法时，调用线程将被阻塞，直到被join方法加入的join线程执行完为止。</p><p>join方法通常由使用线程的程序调用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JoinTester</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">jt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">joinThread</span>();</span><br><span class="line">        jt.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">20</span>) &#123;</span><br><span class="line">                jt.join();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">joinThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="image-20210709163027111.png" alt="join 运行结果"></p><p>由于在主线程调用了子线程的join方法，则主线程必须等到子线程（被Join的线程）执行完毕才能继续执行。</p><h2 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h2><p>有一种线程，他是在后台运行的，他的任务是为其他线程提供服务，这种线程被称为“后台线程（Daemon Thread）”，又称为守护线程或精灵线程。</p><p>后台线程有个特征：<strong>如果前台线程都死亡，后台线程会自动死亡。</strong></p><p>调用Thread的setDaemon(true)方法可将指定线程设置为后台线程。</p><p>Thread类还提供一个isDaemon方法，用于判断指定线程是否为后台线程。</p><p>前台线程创建的子线程默认就是前台线程，后台线程创建的子程序默认是后台线程。</p><p>注意：要将某个线程设置为后台线程，必须在该线程启动之前设置，也就是说setDaemon(true)比如在start方法之前调用。否则会引发异常。</p><h2 id="线程睡眠sleep"><a href="#线程睡眠sleep" class="headerlink" title="线程睡眠sleep"></a>线程睡眠sleep</h2><p><code>Thread.sleep(long milis)</code></p><p>Thread提供了一个与sleep方法有点相似的yield方法，后者也可以让当前正在执行的线程暂停，但他不会阻塞该线程，他只是将该线程转入就绪状态。yield只是让当前线程暂停一下。让系统的线程调度器重新调度一次。</p><p>关于sleep方法和yield方法的区别如下：</p><ul><li>sleep方法暂停当前线程后，会给其他线程执行机会，不会理会其他线程的优先级；但yield方法只会给同优先级相同，或优先级更高的线程执行机会。</li><li>sleep方法会将线程转入阻塞状态，直到经过阻塞时间才会转入就绪状态；而yield不会讲线程转入阻塞状态，他只是强制当前线程进入就绪状态。因此完全有可能某个线程被yield方法暂停之后，立即再次获得处理器资源被执行。</li><li>sleep方法声明抛出了异常，所以调用sleep方法必须捕捉或者显式声明抛出该异常；而yield没有声明抛出任何异常。</li><li>sleep方法比yield方法具有更好的移植性，更推荐用于控制并发线程的执行。</li></ul><h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><p>每个线程执行都具有一定的优先级，优先级高的线程获得较多的执行机会，而优先级低的线程则获得较少的执行机会。</p><p>每个线程默认的优先级都与创建它的父线程的优先级相同，在默认情况下，main线程具有普通优先级，由main线程创建的子线程也具有普通优先级。</p><p>Thread类提供了setPriority(int newPriority)、getPriority方法来指定或返回指定线程的优先级。其中setPriority的参数可以是一个整数，范围是1~10之间，也可以使用Thread类的如下三个静态常量。</p><ul><li>MAX_PRIORITY：其值为10</li><li>MIN_PRIORITY：其值为1</li><li>NORM_PRIORITY：其值为5</li></ul><p>这些优先级需要操作系统的支持，因此应该尽量避免直接为线程指定优先级，而应该使用上述三个静态常量。</p><h1 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h1><h2 id="抢占式调度"><a href="#抢占式调度" class="headerlink" title="抢占式调度"></a>抢占式调度</h2><h2 id="协同式调度"><a href="#协同式调度" class="headerlink" title="协同式调度"></a>协同式调度</h2><h2 id="Java的线程调度方式：抢占式"><a href="#Java的线程调度方式：抢占式" class="headerlink" title="Java的线程调度方式：抢占式"></a>Java的线程调度方式：抢占式</h2><h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><p>线程安全的经典问题：银行取钱问题。下面使用两个线程模拟两个人从一个银行账户中取钱。接下来定义一个账户类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String accountNo;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> balance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Account</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(String accountNo, <span class="type">double</span> balance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.accountNo = accountNo;</span><br><span class="line">        <span class="built_in">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略getter、setter</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBalance</span><span class="params">(<span class="type">double</span> balance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> (Account) o;</span><br><span class="line">        <span class="keyword">return</span> account.accountNo.equals(accountNo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> accountNo.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后是取钱线程类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DrawThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="comment">//账户</span></span><br><span class="line">    <span class="keyword">private</span> Account account;</span><br><span class="line">    <span class="comment">//取得钱数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> drawAmount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DrawThread</span><span class="params">(String name, Account account, <span class="type">double</span> drawAmount)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.account = account;</span><br><span class="line">        <span class="built_in">this</span>.drawAmount = drawAmount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(account.getBalance() &gt;= drawAmount) &#123;</span><br><span class="line">            System.out.println(getName() + <span class="string">&quot;取钱成功，吐出钞票：&quot;</span> + drawAmount);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            account.setBalance(account.getBalance() - drawAmount);</span><br><span class="line">            System.out.println(<span class="string">&quot;余额为：&quot;</span>+ account.getBalance());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(getName() + <span class="string">&quot;取钱失败，余额不足&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是主程序</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DrawTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个账户</span></span><br><span class="line">        <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>(<span class="string">&quot;0001&quot;</span>, <span class="number">1000</span>);</span><br><span class="line">        <span class="comment">//模拟两个线程取钱</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DrawThread</span>(<span class="string">&quot;甲&quot;</span>, account, <span class="number">800</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DrawThread</span>(<span class="string">&quot;乙&quot;</span>, account, <span class="number">800</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果<strong>可能</strong>为如下：</p><p><img src="image-20210710000053047.png" alt="线程同步 运行结果"></p><p>这就涉及了线程同步问题。</p><h2 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h2><p>之所以出现上述结果，是因为run方法的方法体不具有线程安全性，程序有两个并发线程在修改Account对象。</p><p>为了解决这样的问题，Java的多线程支持引入了同步监视器来解决这个问题，使用让同步监视器的通用方法就是同步代码块，语法格式如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(obj) &#123;</span><br><span class="line">    <span class="comment">//此处的代码就是同步代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：</p><ol><li>上述obj就是同步监视器，上面代码的含义是线程开始执行同步代码块之前必须先获得对同步监视器的锁定。</li><li>任何时刻只能有一个线程可以获得对同步监视器的锁定，当同步代码块执行完成后，该线程会释放对同步监视器的锁定。</li><li>通常推荐使用可能被并发访问的共享资源充当同步监视器。</li></ol><blockquote><p>synchronized属于独占式的悲观锁，同时属于可重入锁。</p><p>Synchronized的实现原理：详见《Offer来了 原理篇》P87</p></blockquote><p>根据上述修改代码考虑使用Account作为同步监视器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DrawThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="comment">//账户</span></span><br><span class="line">    <span class="keyword">private</span> Account account;</span><br><span class="line">    <span class="comment">//取得钱数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> drawAmount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DrawThread</span><span class="params">(String name, Account account, <span class="type">double</span> drawAmount)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.account = account;</span><br><span class="line">        <span class="built_in">this</span>.drawAmount = drawAmount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//同步代码块：使用account作为同步监视器，任何线程进入下面同步代码块之前，必须先获得对account账户的锁定，其他线程无法获得锁也就无法修改它，这种做法符合“加锁，修改，释放锁”的逻辑</span></span><br><span class="line">        <span class="keyword">synchronized</span> (account) &#123;</span><br><span class="line">            <span class="keyword">if</span>(account.getBalance() &gt;= drawAmount) &#123;</span><br><span class="line">                System.out.println(getName() + <span class="string">&quot;取钱成功，吐出钞票：&quot;</span> + drawAmount);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                account.setBalance(account.getBalance() - drawAmount);</span><br><span class="line">                System.out.println(<span class="string">&quot;余额为：&quot;</span>+ account.getBalance());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(getName() + <span class="string">&quot;取钱失败，余额不足&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这种方式就可以保证并发线程在任一时刻只有一个线程可以进入修改共享资源的代码区（也被称为临界区），所以同一时刻只有一个线程处于临界区内，从而保证了线程安全性。</p><h2 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h2><p>同步方法就是使用synchronized关键字来修饰某个方法，则该方法称为同步方法，对于synchronized修饰的实例方法（而非静态方法），无需显式指定同步监视器，同步方法的同步监视器是this，也就是调用该方法的对象。</p><p>下面将Account的balance的访问设置成线程安全的，那么只要把修改balance的方法编程同步方法即可。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String accountNo;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> balance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Account</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(String accountNo, <span class="type">double</span> balance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.accountNo = accountNo;</span><br><span class="line">        <span class="built_in">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//getter、setter</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAccountNo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> accountNo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    public void setBalance(double balance) &#123;</span></span><br><span class="line"><span class="comment">//        this.balance = balance;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//账户余额不允许修改，所以只为balance提供getter方法，</span></span><br><span class="line">    <span class="comment">//提供一线程安全的draw方法来完成取钱操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(<span class="type">double</span> drawAmount)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(balance &gt;= drawAmount) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;取钱成功！吐出钞票：&quot;</span>+drawAmount);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            balance -= drawAmount;</span><br><span class="line">            System.out.println(<span class="string">&quot;余额为：&quot;</span>+ balance);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;取钱失败，余额不足&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略equals和hashCode方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>因为Account提供了draw方法，而且取消了setBalance方法，DrawThread的run方法需要改写。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    account.draw(drawAmount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：</p><ol><li>synchronized关键字可以修饰方法，代码块但是布恩那个修饰构造器、成员变量等。</li><li>经过上述修改，DrawThread类无需自己实现取钱操作，而是直接调用account的draw方法。由于draw方法使用了synchronized修饰，同步方法的监视器是this。在上面的示例种，this是account，因此多个线程并发访问同一份account之前必须先对account加锁。这就保证了线程安全。</li><li>在Account里定义draw方法，而不是直接在run方法种实现取钱逻辑，这种做法更符合面向对象的规则。在面向对象里有一种流行的设计：Domain Driven Design（<strong>领域驱动设计</strong>，DDD），这种方式认为每个类都应该是完备的领域对象，例如账户类应该提供账户的相关方法。</li><li>为了减少线程安全带来的降低程序运行效率的影响应该：不要对线程安全类的所有方法进行同步，只对那些改变京城资源的方法进行同；如果可变类有两种运行环境：单线程运行环境和多线程运行环境，则应该为可变类提供两种版本。</li></ol><h2 id="释放同步监视器的锁定"><a href="#释放同步监视器的锁定" class="headerlink" title="释放同步监视器的锁定"></a>释放同步监视器的锁定</h2><p>程序无法显式释放对同步监视器的锁定，线程会在如下几种情况下释放对同步监视器的锁定。</p><ul><li>当前线程的同步方法、同步代码块执行结束。</li><li>当前线程在同步代码块，同步方法中遇到了break、return终止了该代码块、该方法的继续执行。</li><li>当前线程在同步代码块，同步方法中遇到了未处理的Error或Exception</li><li>程序执行了同步监视器对象的wait方法，则当前线程暂停，并释放同步监视器。</li></ul><p>在如下情况下，线程不会释放同步监视器。</p><ul><li>程序调用了Thread.sleep、Thread.yield方法来暂停当前线程的执行，</li><li>其他线程调用了该线程的suspend方法将线程挂起。</li></ul><h2 id="同步锁"><a href="#同步锁" class="headerlink" title="同步锁"></a>同步锁</h2><p>Lock提供了比synchronized方法和synchronized代码块更广泛更灵活的操作。</p><p>Lock是控制多个线程对共享资源进行访问的工具，通常，锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。</p><p>Lock接口的主要方法：</p><ul><li><code>void lock();</code> 加锁</li><li><code>void lockInterruptibly()</code> 当前线程未被中断则获取该锁。</li><li><code>boolean tryLock();</code>试图加锁，但不会阻塞</li><li><code>boolean tryLock(long time, TimeUnit unit)</code> 创建定时锁</li><li><code>void unlock();</code> 释放锁</li><li><code>Condition newCondition();</code> 创建条件对象，获取等待通知组件。</li></ul><p>Lock、ReadWriteLock是J5提供的两个根接口，并为Lock提供了ReentrantLock（可重入锁）【常用】实现类，为ReadWriteLock提供了ReentrantReadWriteLock实现类。</p><p>J8新增了StampedLock类，在大多数场景下可以替代传统的ReentrantReadWriteLock。ReentrantReadWriteLock为读写操作提供了三种锁模式：Writing、ReadingOptimistic、Reading</p><p>通常使用ReentrantLock的代码格式如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="comment">//定义需要保证线程安全的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//需要保证线程安全的代码</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ReentrantLock是一个可重入的独占锁。通过AQS来实现锁的获取和释放。</p><p>ReentrantLock不但提供了Synchronized对锁的操作功能。还提供了诸如可响应中断锁、可轮询锁请求，定时锁等避免多线程死锁的方法。</p></blockquote><p>根据Lock的使用修改Account的代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String accountNo;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> balance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Account</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(String accountNo, <span class="type">double</span> balance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.accountNo = accountNo;</span><br><span class="line">        <span class="built_in">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//getter、setter</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAccountNo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> accountNo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    public void setBalance(double balance) &#123;</span></span><br><span class="line"><span class="comment">//        this.balance = balance;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//账户余额不允许修改，所以只为balance提供getter方法，</span></span><br><span class="line">    <span class="comment">//提供一线程安全的draw方法来完成取钱操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(<span class="type">double</span> drawAmount)</span>&#123;</span><br><span class="line">        lock.lock(); <span class="comment">//加锁</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(balance &gt;= drawAmount) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;取钱成功！吐出钞票：&quot;</span>+drawAmount);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                balance -= drawAmount;</span><br><span class="line">                System.out.println(<span class="string">&quot;余额为：&quot;</span>+ balance);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;取钱失败，余额不足&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">//释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//省略hashCode、equals</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用Lock与使用同步方法有点相似，只是使用Lock时显式使用Lock对象作为同步锁，而使用同步方法时系统隐式使用当前对象作为同步监视器。</p><p>同步方法或同步代码块使用竞争资源相关的、隐式的同步监视器，并且强制要求加锁和释放锁要出现在一个块结构中。并且获取了多个锁时，他们必须以相反的顺序释放。所以同步方法或同步代码块的范围机制使得多线程安全编程非常方便，可以避免很多锁的常见编程错误。</p><p>Lock提供了同步方法或同步代码块所没有的其他功能，包括tryLock方法，以及试图获取可中断锁的lockInterruptibly方法，还可以获取超时失效锁的tryLock(long, TimeUnit)方法</p><p>ReentrantLock锁具有可重入性，也就是说，一个线程可以对已加锁的ReentrantLock锁再次加锁，ReentrantLock对象会维持一个计数器来追踪lock方法的嵌套调用，线程在每次调用lock加锁后，必须显式调用unlock来释放锁，所以一段被所保护的代码可以调用另一个被相同锁保护的方法。</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>编写程序时应尽量避免死锁。</p><ul><li>避免多次锁定：尽量避免同一个线程对多个同步监视器进行锁定</li><li>具有相同的加锁顺序：如果多个线程需要对多个同步监视器进行锁定，则应该保证他们以相同的顺序请求加锁。</li><li>使用定时锁：设置锁的超时时间。</li><li>依靠算法进行死锁检测。</li></ul><h1 id="Java锁详解"><a href="#Java锁详解" class="headerlink" title="Java锁详解"></a>Java锁详解</h1><p>Java中的锁主要保障多并发线程情况下的数据一致性。</p><p>锁从乐观和悲观的角度可分为乐观锁和悲观锁，从获取资源的公平性角度可分为公平锁和非公平锁，从是否共享资源的角度可分为共享锁和独占锁，从锁的状态可分为偏向锁，轻量级锁和重量级锁。此外JVM还设计了自旋锁来更快的使用CPU。</p><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>乐观锁，在每次读取数据时都认为别人不会修改数据，所以不会上锁，但在更新时会判断在此期间别人有没有更新该数据，通常在写时先读出当前版本号然后加锁的方法。具体过程是，比较当前版本号和上一版本号，如果版本号一致，则更新，否则重复进行读、比较、写操作。</p><p>Java中的乐观锁大部分是通过CAS算法实现的。</p><h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p>悲观锁，在每次读取数据时都认为别人会修改数据，所以每次在读写数据都会上锁，这样别人像读写这个数据就会阻塞、等待直到拿到锁。</p><p>Java中的悲观锁大部分是通过AQS架构实现的。许多同步类的实现都依赖于它，例如Synchronized、ReentrantLock、Semaphore、CountDownLatch。该框架下的锁先尝试以乐观锁去获取锁，如果获取不到，则会转为悲观锁。</p><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>自旋锁认为，如果持有锁的线程能够在很短时间内释放锁，那么等待竞争的锁线程不需要阻塞、挂起状态切换，只需要等一等（内旋），在持有锁的线程释放锁之后即可立即获得锁，这样减少了时间损耗。</p><p>线程自选时会占用CPU，所以需要设置一个自选等待的最大时间。</p><p>自旋锁的优缺点：</p><ul><li>优点：减少了CPU上下文的切换，对于占用锁的时间非常短或锁竞争不激烈的代码块来说，性能大幅提升。</li><li>缺点：线程如果在自旋过程中长时间获取不到锁资源，将会引起CPU的浪费。</li></ul><h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><p>可重入锁是指该锁支持一个线程对同一个资源多次加锁。Synchronized、ReentrantLock都是可重入锁。</p><h2 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h2><p>允许多个线程同时获取该锁，并发访问共享资源。ReentrantReadWriteLock中的读锁为共享锁的实现。</p><p>共享锁采用了乐观的加锁策略，允许多个执行读操作的线程同时访问共享资源。</p><h2 id="独占锁"><a href="#独占锁" class="headerlink" title="独占锁"></a>独占锁</h2><p>也叫互斥锁。每次只允许一个线程持有该锁。ReentrantLock为独占锁的实现。</p><p>独占锁是一种悲观的加锁策略。同一时刻只允许一个读线程读取锁资源，限制了读操作的并发性。</p><h2 id="重量级锁、轻量级锁和偏向锁"><a href="#重量级锁、轻量级锁和偏向锁" class="headerlink" title="重量级锁、轻量级锁和偏向锁"></a>重量级锁、轻量级锁和偏向锁</h2><p>以后再说。</p><h2 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h2><ul><li>公平锁指再分配锁之前检查是否有线程在排队等待获取锁，优先将锁分配给排队时间最长的线程。</li><li>非公平锁指在分配锁时不考虑线程排队的情况，直接尝试获取锁，在获取不到锁时在排到队尾等待。</li></ul><p>公平锁需要在多核的情况下维护一个锁线程等待队列，基于该队列进行锁的分配，因此效率比非公平锁低很多。</p><p>Java中的Synchronized、ReentrantLock默认lock方法都是非公平锁。</p><h2 id="读写锁：ReadWriteLock"><a href="#读写锁：ReadWriteLock" class="headerlink" title="读写锁：ReadWriteLock"></a>读写锁：ReadWriteLock</h2><p>Lock接口及对象加的锁是普通锁，这种锁不区分读写。为了提高性能，Java提供了读写锁。</p><p>读写锁分为读锁和写锁。多个读锁不互斥，读锁和写锁互斥。在没有写锁的情况下，读是无阻塞的。</p><p>一般做法是分别定义一个读锁和写锁。在Java中使用ReentrantReadWriteLock来完成对读写锁的定义和使用。</p><h2 id="分段锁"><a href="#分段锁" class="headerlink" title="分段锁"></a>分段锁</h2><p>分段锁是一种思想。用于将数据分段并在每个分段上都单独加锁，把锁进一步细粒度化，以提高并发效率。例如：ConcurrentHashMap</p><h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><ul><li>减少锁的持有时间</li><li>减少锁粒度</li><li>锁分离</li><li>锁粗化</li><li>锁消除</li></ul><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>不再赘述。</p><h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h2><p>不再赘述。</p><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>以后再说</p><h2 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h2><p>以后再说</p><h1 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h1><p>通过一个案例，来学习线程通信部分的知识。</p><p>假设系统有一个特殊的需求：系统要求存款者和取款者不断重复地存款取款，而且要求每当存款者将钱存入账户，取款者就立刻去除这笔钱，不允许连续两次存钱，也不允许连续两次取钱。</p><h2 id="传统的线程通信"><a href="#传统的线程通信" class="headerlink" title="传统的线程通信"></a>传统的线程通信</h2><p>为了实现上述功能，可以借助Object类提供的wait、notify、notifyAll方法。这三个方法不属于Thread，但是这三个方法必须由同步监视器对象来调用。</p><ul><li>对于synchronized修饰的同步方法，this就是同步监视器对象，所以可以直接在同步方法中直接调用这三个方法。</li><li>对于synchronized修饰的同步代码块，同步监视器是synchronized后括号里的对象，必须使用该对象调用这三个方法。</li></ul><p>下面介绍这三个方法：</p><ul><li>wait：导致当前线程等待，直到其他线程调用该同步监视器的notify或notifyAll来唤醒该线程。无参数的wait方法会一直等待，带时间参数的wait方法线程会在指定时间后自动苏醒。</li><li>notify：唤醒在此同步监视器上等待的单个线程。唤醒是任意的。只有当前线程放弃对该同步监视器的锁定后，才可以执行被唤醒的线程。</li><li>notifyAll：唤醒在此同步监视器上等待的所有线程。</li></ul><p>本程序为Account类提供了draw方法和deposit方法，分别对应账户的取钱和存钱操作。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String accountNo;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> balance; <span class="comment">//账户余额</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">//是否已有存款</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Account</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(String accountNo, <span class="type">double</span> balance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.accountNo = accountNo;</span><br><span class="line">        <span class="built_in">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//getter、setter</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAccountNo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> accountNo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    public void setBalance(double balance) &#123;</span></span><br><span class="line"><span class="comment">//        this.balance = balance;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//账户余额不允许修改，所以只为balance提供getter方法，</span></span><br><span class="line">    <span class="comment">//提供一线程安全的draw方法来完成取钱操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(<span class="type">double</span> drawAmount)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!flag) &#123; <span class="comment">//无存款，则取钱线程阻塞</span></span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;取钱：&quot;</span> + drawAmount);</span><br><span class="line">                balance -= drawAmount;</span><br><span class="line">                System.out.println(<span class="string">&quot;账户余额：&quot;</span>+ balance);</span><br><span class="line">                flag = <span class="literal">false</span>; <span class="comment">//存款标志设置为false</span></span><br><span class="line">                notifyAll(); <span class="comment">//唤醒其他线程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">deposit</span><span class="params">(<span class="type">double</span> depositAmount)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag) &#123; <span class="comment">//有存款，则存款线程阻塞</span></span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;存款：&quot;</span> + depositAmount);</span><br><span class="line">                balance += depositAmount;</span><br><span class="line">                System.out.println(<span class="string">&quot;账户余额：&quot;</span>+ balance);</span><br><span class="line">                flag = <span class="literal">true</span>; <span class="comment">//存款标志设置为false</span></span><br><span class="line">                notifyAll(); <span class="comment">//唤醒其他线程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略hashCode、equals</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来是取款者和存款者线程</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取款线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DrawThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="comment">//账户</span></span><br><span class="line">    <span class="keyword">private</span> Account account;</span><br><span class="line">    <span class="comment">//取得钱数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> drawAmount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DrawThread</span><span class="params">(String name, Account account, <span class="type">double</span> drawAmount)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.account = account;</span><br><span class="line">        <span class="built_in">this</span>.drawAmount = drawAmount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            account.draw(drawAmount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//存款线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DepositThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="comment">//账户</span></span><br><span class="line">    <span class="keyword">private</span> Account account;</span><br><span class="line">    <span class="comment">//取得钱数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> depositAmount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DepositThread</span><span class="params">(String name, Account account, <span class="type">double</span> depositAmount)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.account = account;</span><br><span class="line">        <span class="built_in">this</span>.depositAmount = depositAmount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            account.deposit(depositAmount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后是主程序：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//创建一个账户</span></span><br><span class="line">    <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>(<span class="string">&quot;0001&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//一个取款线程，两个存款线程</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">DrawThread</span>(<span class="string">&quot;取款者&quot;</span>, account, <span class="number">800</span>).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">DepositThread</span>(<span class="string">&quot;存款者1&quot;</span>, account, <span class="number">800</span>).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">DepositThread</span>(<span class="string">&quot;存款者2&quot;</span>, account, <span class="number">800</span>).start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主程序设置了一个取款者和两个存款者，最后线程会阻塞这是因为两个存款者会有200次存款操作，而一个取款者只有100次取款操作。运行程序可以发现，存取款线程交替执行。</p><h2 id="使用Condition控制线程通信"><a href="#使用Condition控制线程通信" class="headerlink" title="使用Condition控制线程通信"></a>使用Condition控制线程通信</h2><p>如果程序不使用synchronized关键字来保证同步，而是使用Lock对象来保证同步，则系统中不存在隐式的同步监视器，也就不能使用wait、notify、notifyAll方法进行通信了。</p><p>当使用Lock对象来保证同步时，Java提供了一个Condition类来保持协调，使用Condition可以让那些已经得到Lock对象却无法继续执行的线程释放Lock对象，Condition对象也可以唤醒其他处于等待的线程。</p><p>Condition实例被绑定在一个Lock对象上。要获得Lock实例的Condition实例，需要调用Lock都西昂的newCondition方法。Condition提供了如下三个方法</p><ul><li>await：类似于wait方法，导致线程等待，直到其他线程调用该Condition的signal、signalAll方法来唤醒该线程。</li><li>signal：唤醒此Lock对象上等待的单个线程。只有当前线程放弃对该Lock对象的锁定后，才可以执行被唤醒的进程。</li><li>signalAll：唤醒此Lock对象上等待的所有线程。</li></ul><p>根据上面改写Account类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(); <span class="comment">//定义Lock对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();<span class="comment">//获得指定的Condition</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String accountNo;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> balance; <span class="comment">//账户余额</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">//是否已有存款</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Account</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(String accountNo, <span class="type">double</span> balance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.accountNo = accountNo;</span><br><span class="line">        <span class="built_in">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//getter、setter</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAccountNo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> accountNo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    public void setBalance(double balance) &#123;</span></span><br><span class="line"><span class="comment">//        this.balance = balance;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//账户余额不允许修改，所以只为balance提供getter方法，</span></span><br><span class="line">    <span class="comment">//提供一线程安全的draw方法来完成取钱操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(<span class="type">double</span> drawAmount)</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!flag) &#123; <span class="comment">//无存款，则取钱线程阻塞</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;取钱：&quot;</span> + drawAmount);</span><br><span class="line">                balance -= drawAmount;</span><br><span class="line">                System.out.println(<span class="string">&quot;账户余额：&quot;</span>+ balance);</span><br><span class="line">                flag = <span class="literal">false</span>; <span class="comment">//存款标志设置为false</span></span><br><span class="line">                condition.signalAll(); <span class="comment">//唤醒其他线程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">deposit</span><span class="params">(<span class="type">double</span> depositAmount)</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag) &#123; <span class="comment">//有存款，则存款线程阻塞</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;存款：&quot;</span> + depositAmount);</span><br><span class="line">                balance += depositAmount;</span><br><span class="line">                System.out.println(<span class="string">&quot;账户余额：&quot;</span>+ balance);</span><br><span class="line">                flag = <span class="literal">true</span>; <span class="comment">//存款标志设置为false</span></span><br><span class="line">                condition.signalAll(); <span class="comment">//唤醒其他线程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//忽略hashCode、equals</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用阻塞队列控制线程通信"><a href="#使用阻塞队列控制线程通信" class="headerlink" title="使用阻塞队列控制线程通信"></a>使用阻塞队列控制线程通信</h2><p>Java5提供了一个BlockingQueue接口，它主要用作线程同步工具，而非容器。</p><p>BlockingQueue有一个特征：当生产者线程试图向BlockingQueue中放入元素时，如果该队列已满，则该线程被阻塞。当消费者线程试图从BlockingQueue取出元素时，如果该队列已空，则该线程被阻塞。</p><p>程序的两个线程通过交替向BlockingQueue放入取出元素，即可很好的控制线程的通信。</p><p>BlockingQueue包含的方法对应关系如图：</p><div class="table-container"><table><thead><tr><th></th><th>抛出异常</th><th>返回boolean</th><th>阻塞线程</th><th>指定超时市场</th></tr></thead><tbody><tr><td>队尾插入元素</td><td>add(e)</td><td>offer(e)</td><td>put(e)</td><td>offer(e, time, unit)</td></tr><tr><td>队头删除元素</td><td>remove()</td><td>poll()</td><td>take()</td><td>poll(time, unit)</td></tr><tr><td>获取、不删除元素</td><td>element()</td><td>peek()</td><td>无</td><td>无</td></tr></tbody></table></div><p>BlockingQueue与实现类之间类图如下：</p><p><img src="image-20210710181645057.png" alt="BlockingQueue 类图"></p><p>可以看到BlockingQueue的五个实现类</p><p>下面使用BlockingQueue来实现生产者消费者的线程通信。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockingQueueTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        BlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Producer</span>(<span class="string">&quot;产品A&quot;</span>, queue).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Producer</span>(<span class="string">&quot;产品B&quot;</span>, queue).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Consumer</span>(queue).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;String&gt; queue;</span><br><span class="line">    <span class="keyword">private</span> String productName ;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(String productName, BlockingQueue&lt;String&gt; queue)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.productName = productName;</span><br><span class="line">        <span class="built_in">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(productName + i); <span class="comment">//尝试放入元素，如果队列满，则阻塞</span></span><br><span class="line">                System.out.println(getName() + <span class="string">&quot;生产完成：&quot;</span> + queue);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;String&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(BlockingQueue&lt;String&gt; queue)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(getName() + <span class="string">&quot;消费元素：&quot;</span> + queue.take());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>该程序不符合预期，原因不明。</strong></p><p><img src="image-20210710190620858.png" alt="阻塞队列 运行结果"></p><h1 id="多线程共享数据"><a href="#多线程共享数据" class="headerlink" title="多线程共享数据"></a>多线程共享数据</h1><h2 id="将数据抽象成一个类，并将这个数据的操作封装到这个类中"><a href="#将数据抽象成一个类，并将这个数据的操作封装到这个类中" class="headerlink" title="将数据抽象成一个类，并将这个数据的操作封装到这个类中"></a>将数据抽象成一个类，并将这个数据的操作封装到这个类中</h2><h2 id="将Runnable对象作为一个类的内部类，将共享数据作为这个类的成员变量"><a href="#将Runnable对象作为一个类的内部类，将共享数据作为这个类的成员变量" class="headerlink" title="将Runnable对象作为一个类的内部类，将共享数据作为这个类的成员变量"></a>将Runnable对象作为一个类的内部类，将共享数据作为这个类的成员变量</h2><h1 id="线程组和未处理的异常"><a href="#线程组和未处理的异常" class="headerlink" title="线程组和未处理的异常"></a>线程组和未处理的异常</h1><h2 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h2><p>Java使用ThreadGroup来表示线程组，Java允许程序对线程组进行控制。用户创建的所有线程都属于指定线程组。如果程序没有显式指定线程属于哪个线程组，则该线程属于默认线程组。默认情况下， 子线程和创建它的父线程处于同一个线程组。</p><p>线程运行中途不能改变它所属的线程组。</p><p>下面是Thread类提供的构造器来设置线程属于哪个线程组：</p><ul><li>Thread(ThreadGroup group, Runnable target)：以target的run方法作为线程执行体创建新线程，属于group线程组。</li><li>Thread(ThreadGroup group, Runnable target, String name)</li><li>Thread(ThreadGroup group, String name)</li></ul><p>Thread提供了一个getThreadGroup方法来返回线程所属的线程组。</p><p>ThreadGroup提供了两个构造器来创建实例。</p><ul><li>ThreadGroup(String name)</li><li>ThreadGroup(ThreadGroup parent, String name)：以指定名字、指定父线程组创建一个新线程组。</li></ul><p>其中name参数是指定线程组的名字，线程组的名字可以通过getName方法得到，但是不能修改。</p><p>ThreadGroup的常用方法：</p><ul><li>int activeCount()</li><li>void isDaemon()</li><li>void interrupt()</li><li>void setDaemon(boolean daemon)</li><li>void setMaxPriority(int pri)</li></ul><p>ThreadGroup内定义了一个很有用的方法：<code>void uncaughtException(Thread t, Throwable e)</code>，该方法可以处理该线程组内的任意线程所抛出的未处理异常。</p><h2 id="线程异常"><a href="#线程异常" class="headerlink" title="线程异常"></a>线程异常</h2><p>Java5之后，如果线程执行过程中抛出了一个未处理的异常，JVM在结束之前会自动查找是否有对应的Thread.UncaughtExceptionHandler对象，如果有，则会调用该对象的<code>uncaughtException(Thread t, Throwable e)</code>来处理异常。</p><p>Thread类提供了两个方法来设置异常处理器：</p><ul><li>setUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh)：为指定线程实例设置默认的异常处理器</li><li>static setDefaultUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh)：为该线程类的所有实例设置默认的异常处理器。</li></ul><p>ThreadGroup类实现了Thread.UncaughtExceptionHandler接口。</p><p>所以线程处理异常的流程如下：</p><ol><li>如果线程设置了异常处理器，则调用该异常处理器处理异常</li><li>查找线程是否属于线程组：<ol><li>如果所属线程组有父线程组，则调用父线程组的uncaughtException方法</li><li>如果该线程组有异常处理器，则使用该异常处理器处理异常。</li></ol></li></ol><p>注意：当使用catch捕获异常时，异常不会向上传播给上一级调用者；但使用异常处理器对异常进行处理后，异常依然会传播给上一级调用者。</p><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>当程序需要创建大量生存期很短暂的线程时，更应该考虑使用线程池。</p><p>线程池在系统启动时即创建大量空闲线程，程序将一个Runnable/Callable对象传给线程池，线程池就会启动一个空闲线程来执行run/call方法，方法执行完毕后，线程不会死亡而是返回线程池成为空闲状态。</p><p>线程池的主要作用是线程复用，线程资源管理，控制操作系统的最大并发数，以保证系统高效（通过线程资源复用实现）且安全（通过控制最大线程并发数实现）的运行。</p><h2 id="线程池的核心组件和核心类"><a href="#线程池的核心组件和核心类" class="headerlink" title="线程池的核心组件和核心类"></a>线程池的核心组件和核心类</h2><p>Java线程池主要由4个核心组件组成。</p><ul><li>线程池管理器：用于创建并管理线程</li><li>工作线程：线程池中执行具体任务的线程。</li><li>任务接口：用于定义工作线程的调度和执行策略，只有线程实现了该接口，线程中的任务才能够被线程池调度。</li><li>任务队列：存放待处理的任务，新的任务将会不断被加入队列中，执行完成的任务将被从队列中移除。</li></ul><p>Java线程池用到了Executor、Executors、ExecutorService、ThreadPoolExecutor、Callable、Future、FutureTask这几个核心类，具体继承关系如下：</p><p><img src="image-20210803000256474.png" alt="线程池核心类 类图"></p><p>ThreadPoolExecutor是构建线程池的核心实现。</p><h2 id="使用Executors管理线程"><a href="#使用Executors管理线程" class="headerlink" title="使用Executors管理线程"></a>使用Executors管理线程</h2><p>Java5以前，开发者必须实现自己的线程池，从Java5开始，新增了一个Executors工厂类来产生线程池。它包含如下静态工厂方法：</p><ul><li>ExecutorService newCachedThreadPool()：创建一个具有缓存功能的线程池</li><li>ExecutorService newFixedThreadPool(int nThreads)：创建一个可重用的、具有固定线程数的线程池</li><li>ExecutorService newSingleThreadExecutor()：创建一个只有单线程的线程池，相当于newFixedThreadPool(1)</li><li>ScheduledExecutorService newScheduledThreadPool(int corePoolSize)：创建具有指定线程数的线程池。参数指出池中所保存的线程数。</li><li>ScheduledExecutorService newSingleThreadScheduledExecutor()：创建只有一个现成的线程池</li><li>ExecutorService newWorkStealingPool(int parallelism)：创建持有足够的线程的线程池来支持给定的并行级别</li><li>ExecutorService newWorkStealingPool()：相当于前一个方法的简化版本，假设当前机器有4个CPU，则相当于前一个方法传入4</li></ul><p>前面介绍的方法中返回值类型中ExecutorService代表线程池，它可以执行Runnable/Callable所代表的线程；ScheduledExecutorService 是ExecutorService的子类，它可以在指定延迟后执行线程任务。</p><p>最后两个方法是J8新增，他们成分利用了多CPU的并行能力，这两个方法创建的相当于后台线程池。</p><p>ExecutorService代表尽快执行线程的线程池：</p><ul><li><code>Future&lt;?&gt; submit(Runnable task)</code>：将一个Runnable对象提交给线程池，线程池将在有空闲线程时执行Runnable对象代表的任务。其中Future对象代表Runnable的返回值，但是run方法没有返回值，所以Future对象将在run方法执行结束后返回null</li><li><code>&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result)</code>：同上一个方法类似，但本方法将在run方法结束后返回result</li><li><code>&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)</code></li></ul><p>ScheduledExecutorService 代表在指定延迟后或周期性的执行线程任务，它提供了四个主要方法：</p><ul><li><code>&lt;V&gt; ScheduledFuture&lt;V&gt; schedule(Callable&lt;V&gt; callable, long delay, TimeUnit unit)</code>：</li><li><code>ScheduledFuture&lt;?&gt; schedule(Runnable command, long delay, TimeUnit unit)</code></li><li><code>ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)</code>：可设定频率重复执行线程任务</li><li><code>ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)</code>：每一次执行终止和下一次执行开始之间都存在一个给定的延迟。</li></ul><p>当用完一个线程池后，应该调用该线程池的shutdown方法，调用shutdown方法后，线程池不再接受新的任务，但会将以前所有已提交任务执行完成。</p><p>使用线程池执行线程任务的步骤如下：</p><ol><li>调用Executors类的静态工厂方法创建一个线程池</li><li>创建Runnable/Callable实例</li><li>调用submit方法提交Runnable/Callable实例</li><li>调用线程池的shutdown方法关闭线程池。</li></ol><p>举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个固定线程处的线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">6</span>);</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;的i值为：&quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//向线程池提交两个线程</span></span><br><span class="line">        pool.submit(target);</span><br><span class="line">        pool.submit(target);</span><br><span class="line"></span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用ForkJoinPool利用多CPU"><a href="#使用ForkJoinPool利用多CPU" class="headerlink" title="使用ForkJoinPool利用多CPU"></a>使用ForkJoinPool利用多CPU</h2><p>Java7提供了ForkJoinPool来支持多CPU计算。ForkJoinPool是ExecutorService的实现类，因此是一个特殊的线程池。</p><p>ForkJoinPool有两个构造器：</p><ul><li>ForkJoinPool(int parallelism)：创建一个包含parallelism个并行线程的ForkJoinPool</li><li>ForkJoinPool()：以Runtime.availableProcessors方法的返回值作为parallelism参数创建ForkJoinPool</li></ul><p>J8进一步扩展了ForkJoinPool的功能。J8通过提供如下两个静态方法为ForkJoinPool增加了通用池功能。</p><ul><li>ForkJoinPool commonPool()：该方法返回一个通用池，通用池不会受到shutdown或shutdownNow方法的影响。</li><li>int getCommonPoolParallelism：该方法返回通用池的并行级别。</li></ul><p>在创建ForkJoinPool实例之后就可以调用它的submit(ForkJoinTask<T> task)方法来执行指定任务。ForkJoinTask是一个抽象类，他代表一个可并行、合并的任务。他有两个抽象子类。RecursiveAction和RecursiveTask。RecursiveAction代表无返回值的任务，RecursiveTask代表有返回值的任务。</p><p>举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForkJoinPoolTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">ForkJoinPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100</span>];</span><br><span class="line">        <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> rand.nextInt(<span class="number">20</span>);</span><br><span class="line">            total += (arr[i] = tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;单线程累加的结果为：&quot;</span> + total);</span><br><span class="line"></span><br><span class="line">        Future&lt;Integer&gt; future = pool.submit(<span class="keyword">new</span> <span class="title class_">CalTask</span>(arr, <span class="number">0</span>, arr.length));</span><br><span class="line">        System.out.println(<span class="string">&quot;并行CPU累加的结果为：&quot;</span> + future.get());</span><br><span class="line"></span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CalTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THRESHOLD</span> <span class="operator">=</span> <span class="number">20</span>; <span class="comment">//每个小人物最多累加20个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CalTask</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.arr = arr;</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(end - start &lt; THRESHOLD) &#123; <span class="comment">//当数组数量小于THRESHOLD时开始累加</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; end; i++) &#123;</span><br><span class="line">                sum += arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (start + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//分解成子任务</span></span><br><span class="line">            <span class="type">CalTask</span> <span class="variable">left</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CalTask</span>(arr, start, mid);</span><br><span class="line">            <span class="type">CalTask</span> <span class="variable">right</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CalTask</span>(arr, mid, end);</span><br><span class="line">            left.fork();<span class="comment">//执行任务</span></span><br><span class="line">            right.fork();</span><br><span class="line">            <span class="keyword">return</span> left.join() + right.join(); <span class="comment">//返回结果</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="*ThreadPoolExecutor"></a>*ThreadPoolExecutor</h2><p>Java提供了Excutors工具类，适用于小项目，对于一些大型程序还是需要自己创建ThreadPoolExecutor类。这样做的好处有：</p><ul><li>使用ThreadPoolExecutor更加明确线程池的运行规则，规避资源耗尽的风险。</li><li>Excutors的newFixedThreadPool和newSingleThreadExecutor的主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至OOM；Excutors的newCachedThreadPool和newScheduledThreadPool主要问题是线程最大数为Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至OOM。</li></ul><p>ThreadPoolExecutor是构建线程池的核心实现，定义如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                              TimeUnit unit,</span></span><br><span class="line"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                              ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                              RejectedExecutionHandler handler)</span> &#123;</span><br><span class="line">    <span class="comment">//code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体参数如表格：</p><div class="table-container"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>corePoolSize</td><td>线程池中核心线程的数量</td></tr><tr><td>maximumPoolSize</td><td>线程池中最大线程数量</td></tr><tr><td>keepAliveTime</td><td>当前线程数量超过corePoolSize时，空闲线程的存活时间</td></tr><tr><td>unit</td><td>keepAliveTime的时间单位</td></tr><tr><td>workQueue</td><td>任务队列，被提交但尚未被执行的任务存放的地方</td></tr><tr><td>threadFactory</td><td>线程工厂，用于创建线程，可使用默认的线程工厂或自定义</td></tr><tr><td>handler</td><td>由于任务过多或其他原因导致线程池无法处理时的任务拒绝策略</td></tr></tbody></table></div><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>通过调用ThreadPoolExecutor的构造方法来创建一个线程池。线程池刚被创建时，只是向系统申请一个用于执行线程队列和管理线程池的线程资源。在添加一个任务时，当前现有线程数（设为n）：</p><ol><li>n&lt;corePoolSize，线程池就会立刻创建线程并执行该线程任务。</li><li>n&gt;=corePoolSize，该任务就会进入阻塞队列。</li><li>如果队列已满，且n&lt;maximumPoolSize时，线程池会创建非核心线程立刻执行该线程任务。</li><li>如果队列已满，且n&gt;=maximumPoolSize时，线程池将拒绝执行该线程任务并抛出RejectExecutionException异常。</li><li>线程任务执行完毕，该任务将从线程池队列中移除，线程池将从队列中取出下一个线程任务继续执行。</li><li>在线程处于空闲状态的实践超过keepAliveTime时，正在运行的线程数量超过corePoolSize，该线程将被认定为空闲线程并停止。因此，在线程池中所有线程任务都执行完毕，线程池会收缩到corePoolSize大小。</li></ol><h3 id="入队策略"><a href="#入队策略" class="headerlink" title="入队策略"></a>入队策略</h3><ol><li>直接传递：SynchronousQueue（待补充）</li><li>无界队列：使用无界队列（LinkedBlockingQueue）作为等待队列，当所有核心线程都在处理任务时，新提交的任务都会进入等待队列。此时maximumPoolSize将失去作用。</li><li>有界队列：有界队列（ArrayBlockingQueue）可以防止资源耗尽，但是难以调整和控制。队列大小和线程池大小可以相互作用，使用大队列和小线程数可以减少CPU使用率、系统资源和上下文切换的开销，但是会导致吞吐量变低，如果任务频繁阻塞，系统就能为更多的线程调度执行时间。使用小队列通常需要更多的线程数，这样可以最大化CPU使用率。但可能会需要更大的调度开销，从而降低吞吐量。</li></ol><h3 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h3><p>JDK内置的拒绝策略有AbortPolicy、CallerRunsPolicy、DiscardOldestPolicy、DiscardPolicy这四种。</p><ul><li>AbortPolicy：默认策略，抛出RejectExecutionException异常</li><li>CallerRunsPolicy：在execute方法的调用线程中运行被拒绝的任务，如果线程已关闭，任务将被丢弃。</li><li>DiscardOldestPolicy：丢弃队列中等待时间最长的任务并执行当前提交的任务。</li><li>DiscardPolicy：直接丢弃任务。</li><li>自定义拒绝策略需要实现RejectedExecutionHandler接口，实现<code>rejectedExecution(Runnable r, ThreadPoolExecutor executor)</code>方法。</li></ul><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">corePoolSize</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maximumPoolSize</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">keepAliveTime</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="type">TimeUnit</span> <span class="variable">unit</span> <span class="operator">=</span> TimeUnit.SECONDS;</span><br><span class="line">    BlockingQueue&lt;Runnable&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">    <span class="type">ThreadPoolExecutor</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    pool = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, queue);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> i+<span class="number">1</span>;</span><br><span class="line">        pool.submit(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我是线程&quot;</span> + index);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//每个任务提交后休眠500ms在执行下一个任务，用于保证提交顺序。</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pool.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是运行结果。</p><p><img src="image-20210730173914926.png" alt="拒绝策略 运行截图"></p><p>对该运行结果进行分析：</p><ol><li>由于corePoolSize设置的为3，所以任务1、2、3正常提交且开始执行。</li><li>提交任务4，5时，任务123还在运行，所以任务4，5进入到阻塞队列。</li><li>提交任务6，7，8时，正在运行的任务等于corePoolSize且小于maximumPoolSize，阻塞队列满，所以会立即创建非核心线程执行任务678</li><li>当任务1执行完毕后，取出队列中的任务4开始执行。</li><li>当任务2执行完毕后，取出队列中的任务5开始执行。</li></ol><p>为了演示默认的拒绝策略，将上述案例增加一个线程。结果如图</p><p><img src="image-20210730174640219.png" alt="拒绝策略 截图"></p><h1 id="线程相关类"><a href="#线程相关类" class="headerlink" title="线程相关类"></a>线程相关类</h1><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>ThreadLocal是Therad的局部变量的维护类，在Java中是作为一个特殊的变量存储在。当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。</p><p>因为每个Thread内有自己的实例副本，且该副本只能由当前Thread使用，也就不存在多线程间共享的问题。</p><p>总的来说，ThreadLocal适用于每个线程需要自己独立的实例且该实例需要在多个方法中被使用，也即变量在线程间隔离而在方法或类间共享的场景。</p><p>比如，有一个变量count，在多线程并发时操作count++会出现线程安全问题。但是通过ThreadLocal就可以为每个线程创建只属于当前线程的count副本，各自操作各自的副本，不会影响到其他线程。</p><p>使用示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; HOLDER = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ThreadLocalTest</span>().execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        HOLDER.set(<span class="string">&quot;main&quot;</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程ThreadLocal中的值：&quot;</span> + HOLDER.get());</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程ThreadLocal中的值：&quot;</span> + HOLDER.get());</span><br><span class="line">            HOLDER.set(<span class="string">&quot;thread&quot;</span>); <span class="comment">//设置当前线程的值</span></span><br><span class="line">            System.out.println(<span class="string">&quot;重新设置后，&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;线程ThreadLocal中的值：&quot;</span> + HOLDER.get());</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程执行结束&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程ThreadLocal中的值：&quot;</span> + HOLDER.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行程序，打印结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main线程ThreadLocal中的值：程序新视界</span><br><span class="line">Thread-0线程ThreadLocal中的值：null</span><br><span class="line">重新设置之后，Thread-0线程ThreadLocal中的值：《程序新视界》</span><br><span class="line">Thread-0线程执行结束</span><br><span class="line">main线程ThreadLocal中的值：程序新视界</span><br></pre></td></tr></table></figure><p>对照程序和输出结果，你会发现，主线程和Thread-0各自独享自己的变量存储。主线程并没有因为Thread-0调用了HOLDER的set方法而被改变。</p><p>之所以能达到这个效果，正是因为在ThreadLocal中，每个线程Thread拥有一份自己的副本变量，多个线程互不干扰。</p><p>ThreadLocal和其他同步机制一样，都是为了解决多线程对同一变量的访问冲突。在普通的同步机制中，试图用过对对象枷锁来实现多个线程对同一变量的安全访问的。ThreadLocal从另一个角度来解决多线程并发访问，ThreadLocal将需要并发访问的资源复制多分，每个线程拥有一份资源，从而就没有必要再对该变量进行同步了。在编写多线程代码时，可以把不安全的整个变量封装进ThreadLocal，或者把该对象与线程相关的状态使用ThreadLocal保存。</p><p>ThreadLocal不能代替同步机制，两者面向的领域不同。同步机制是为了同步多个线程对相同资源的并发访问，是多个线程之间通信的有效方式；而ThreadLocal是为了隔离多个线程的数据共享，从根本上避免了多个线程对共享资源的竞争。</p><p><em>参考资料：<a href="https://zhuanlan.zhihu.com/p/368293603">https://zhuanlan.zhihu.com/p/368293603</a></em></p><h2 id="包装线程不安全集合"><a href="#包装线程不安全集合" class="headerlink" title="包装线程不安全集合"></a>包装线程不安全集合</h2><p>在Java集合中所讲的ArrayList、LinkedList、HashSet、TreeSet、HashMap、TreeMap都是线程不安全的。Collections提供的类方法可以把这些集合包装成线程安全的集合。</p><ul><li>static <T> Collection<T> synchronizedCollection(Collection<T> c)</li><li>static <T> List<T> synchronizedList(List<T> list)</li><li>static <K,V> Map<K,V> synchronizedMap(Map<K,V> m)</li><li>static <T> Set<T> synchronizedSet(Set<T> s)</li><li>static <K,V> SortedMap<K,V> synchronizedSortedMap(SortedMap<K,V> m)</li><li>static <T> SortedSet<T> synchronizedSortedSet(SortedSet<T> s)</li></ul><p>例如需要使用线程安全的HashMap对象，则采用下面的代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = Collections.synchronizedMap(<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;()); <span class="comment">//在创建后立即包装</span></span><br></pre></td></tr></table></figure><h2 id="线程安全集合类"><a href="#线程安全集合类" class="headerlink" title="线程安全集合类"></a>线程安全集合类</h2><p><img src="image-20210711190905713.png" alt="线程安全的集合类"></p><p>线程安全的集合类可以分为两种：</p><ul><li>以Concurrent开头的集合类：代表了支持并发访问的集合，对这种集合的写入操作都是线程安全的，但读取操作不必锁定。</li><li>以CopyOnWrite开头的集合类：采用了更复杂的算法（复制底层数组的方式实现写操作）来保证永远不会锁住集合，因此并发写入时有较好的性能。</li></ul><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><ul><li>默认支持16个线程并发写入，可以通过设置构造参数来支持更多的并发。</li><li>J8扩展了ConcurrentHashMap的功能，新增的方法分为如下三类<ul><li>forEach</li><li>search</li><li>reduce</li></ul></li></ul><h2 id="J9新增的发布-订阅框架"><a href="#J9新增的发布-订阅框架" class="headerlink" title="J9新增的发布-订阅框架"></a>J9新增的发布-订阅框架</h2><p>略</p><h1 id="Java并发关键字"><a href="#Java并发关键字" class="headerlink" title="Java并发关键字"></a>Java并发关键字</h1><h2 id="CountDownLacth"><a href="#CountDownLacth" class="headerlink" title="CountDownLacth"></a>CountDownLacth</h2><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><h2 id="Semaphore-1"><a href="#Semaphore-1" class="headerlink" title="Semaphore"></a>Semaphore</h2><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><h1 id="补充：进程调度算法"><a href="#补充：进程调度算法" class="headerlink" title="补充：进程调度算法"></a>补充：进程调度算法</h1><h2 id="优先调度算法"><a href="#优先调度算法" class="headerlink" title="优先调度算法"></a>优先调度算法</h2><h2 id="高优先权优先调度算法"><a href="#高优先权优先调度算法" class="headerlink" title="高优先权优先调度算法"></a>高优先权优先调度算法</h2><h2 id="时间片的轮转调度算法"><a href="#时间片的轮转调度算法" class="headerlink" title="时间片的轮转调度算法"></a>时间片的轮转调度算法</h2><h1 id="补充：CAS、ABA、AQS"><a href="#补充：CAS、ABA、AQS" class="headerlink" title="补充：CAS、ABA、AQS"></a>补充：CAS、ABA、AQS</h1><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>《疯狂Java讲义》 多线程篇</li><li><a href="https://mp.weixin.qq.com/s/F8PbZ5PnwGNI4jRiylCRpQ">为什么阿里不允许用Executors创建线程池，而是通过ThreadPoolExecutor的方式？</a></li><li>《Offer 来了 Java面试核心知识点讲解 原理篇》 多线程</li><li><a href="https://zhuanlan.zhihu.com/p/368293603">ThreadLocal全攻略：使用实战，源码分析，内存泄露分析</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>_Python实现一个简单的多线程程序</title>
      <link href="/2022/01/20/Python%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%A8%8B%E5%BA%8F/"/>
      <url>/2022/01/20/Python%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文是一个知识碎片，以后再做详细整理。</p></blockquote><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>我尝试使用多线程批量下载图片。代码框架如下，</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing.pool <span class="keyword">import</span> ThreadPool</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">下载输入的url保存为图片</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">download_urls</span>(<span class="params">url</span>):</span><br><span class="line">    r = requests.request(<span class="string">&#x27;GET&#x27;</span>, url, headers=&#123;&#125;)</span><br><span class="line">    <span class="keyword">if</span> r.status_code == <span class="number">200</span>:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;save_path&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(r.content)</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># urls</span></span><br><span class="line">url_list = [<span class="string">&#x27;...&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 单线程</span></span><br><span class="line"><span class="comment">#  for url in url_list:</span></span><br><span class="line"><span class="comment">#      download_urls(url)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 多线程</span></span><br><span class="line"><span class="comment"># 设置线程池线程数</span></span><br><span class="line">pool = ThreadPool(<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 传入下载函数和下载list</span></span><br><span class="line">pool.imap_unordered(download_urls, url_list)</span><br><span class="line"></span><br><span class="line">pool.close()</span><br><span class="line">pool.join()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>目前我不明白的是，</p><ul><li><strong>不能使用main函数将代码包含进去，否则起不来多线程，为什么？</strong></li><li>Python多线程的基本知识；</li><li>Python GIL等。</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://blog.csdn.net/weixin_36896856/article/details/108016558">Python下载文件的11种方式</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《动手学深度学习》读书笔记（二）从全连接层到卷积层</title>
      <link href="/2022/01/20/%E3%80%8A%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E4%BB%8E%E5%85%A8%E8%BF%9E%E6%8E%A5%E5%B1%82%E5%88%B0%E5%8D%B7%E7%A7%AF%E5%B1%82/"/>
      <url>/2022/01/20/%E3%80%8A%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E4%BB%8E%E5%85%A8%E8%BF%9E%E6%8E%A5%E5%B1%82%E5%88%B0%E5%8D%B7%E7%A7%AF%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文FROM《动手学深度学习》第六章 卷积神经网络 6.1和6.2小节</p></blockquote><h1 id="从全连接层到卷积"><a href="#从全连接层到卷积" class="headerlink" title="从全连接层到卷积"></a>从全连接层到卷积</h1><p>假设我们使用之前的全连接层来训练图片数据集。一张普通图像都是百万像素，如果把图像的每一个像素作为一个特征传入MLP，那么网络的每次输入都是百万维度，这是不可接受的；其次，之前我们处理二维图像时，把二维图像的所有像素作为一个一维向量输入MLP，丢失了图像的结构特征。</p><p><strong>卷积神经网络</strong>（convolutional neural networks，CNN）应运而生，它是机器学习利用自然图像中一些已知结构的创造性方法。</p><h2 id="自然图像的两个性质"><a href="#自然图像的两个性质" class="headerlink" title="自然图像的两个性质"></a>自然图像的两个性质</h2><p>我们根据自然图像的两个性质，来设计适合于计算机视觉的神经网络架构：</p><ol><li><em>平移不变性</em>（translation invariance）：不管检测对象出现在图像中的哪个位置，神经网络的前面几层应该对相同的图像区域具有相似的反应，即为“平移不变性”。</li><li><em>局部性</em>（locality）：神经网络的前面几层应该只探索输入图像中的局部区域，而不过度在意图像中相隔较远区域的关系，这就是“局部性”原则。最终，可以聚合这些局部特征，以在整个图像级别进行预测。</li></ol><h2 id="MLP的限制"><a href="#MLP的限制" class="headerlink" title="MLP的限制"></a>MLP的限制</h2><p>首先，多层感知机的输入是二维图像$\mathbf{X}$，其隐藏表示 $\mathbf{H}$ 在数学上是一个矩阵，在代码中表示为二维张量。其中 $\mathbf{X}$ 和 $\mathbf{H}$ 具有相同的形状。</p><p>为了方便理解，我们可以认为，无论是输入还是隐藏表示都拥有空间结构。</p><blockquote><p>所谓隐藏表示是指输入经过MLP的一层后得到的输出。</p></blockquote><p>使用  $[\mathbf{X}]<em>{i, j}$ 和 $[\mathbf{H}]</em>{i, j}$ 分别表示输入图像和隐藏表示中位置($i$, $j$)处的像素。</p><p>为了使每个隐藏神经元都能接收到每个输入像素的信息，我们将参数从权重矩阵（如同我们先前在多层感知机中所做的那样）替换为四阶权重张量 $\mathsf{W}$。假设 $\mathbf{U}$ 包含偏置参数，我们可以将全连接层形式化地表示为</p><blockquote><p>在之前输入输出都是一维张量时，权重为二维张量。现在输入输出都是二维张量，则权重为四维张量。</p></blockquote><script type="math/tex; mode=display">\begin{aligned} \left[\mathbf{H}\right]_{i, j} &= [\mathbf{U}]_{i, j} + \sum_k \sum_l[\mathsf{W}]_{i, j, k, l}  [\mathbf{X}]_{k, l}\\ &=  [\mathbf{U}]_{i, j} +\sum_a \sum_b [\mathsf{V}]_{i, j, a, b}  [\mathbf{X}]_{i+a, j+b}.\end{aligned}</script><blockquote><p>这里 $\mathsf{W}$ 和 $\mathsf{V}$ 的转换仅仅是重新进行了索引。我们只需重新索引下标 $(k, l)$，使 $k = i+a$、$l = j+b$， 由此可得 $[\mathsf{V}]<em>{i, j, a, b} = [\mathsf{W}]</em>{i, j, i+a, j+b}$。</p><p>索引 $a$ 和 $b$ 通过在正偏移和负偏移之间移动覆盖了整个图像。对于隐藏表示中任意给定位置（$i$, $j$）处的像素值$[\mathbf{H}]<em>{i, j}$，可以通过在 $x$ 中以 $(i, j)$ 为中心对像素进行加权求和得到，加权使用的权重为 $[\mathsf{V}]</em>{i, j, a, b}$ 。</p></blockquote><h3 id="平移不变性"><a href="#平移不变性" class="headerlink" title="平移不变性"></a>平移不变性</h3><p>现在引用上述的第一个原则：平移不变性。这意味着检测对象在输入 $\mathbf{X}$ 中的平移，应该仅仅导致隐藏表示 $\mathbf{H}$ 中的平移。也就是说， $\mathsf{V}$ 和 $\mathbf{U}$ 实际上不依赖于 $(i, j)$ 的值，即 $[\mathsf{V}]<em>{i, j, a, b} = [\mathbf{V}]</em>{a, b}$。并且  $\mathbf{U}$ 是一个常数，比如 $u$。因此，我们可以简化 $\mathbf{H}$ 定义为：</p><script type="math/tex; mode=display">[\mathbf{H}]_{i, j} = u + \sum_a\sum_b [\mathbf{V}]_{a, b} [\mathbf{X}]_{i+a, j+b}.</script><p>这就是 <em>卷积</em> （convolution）。我们是在使用系数 $[\mathbf{V}]<em>{a, b}$ 对位置 $(i, j)$ 附近的像素 $(i+a, j+b)$ 进行加权得到$[\mathbf{H}]</em>{i, j}$。</p><p>注意，$[\mathbf{V}]<em>{a, b}$ 的系数比 $[\mathsf{V}]</em>{i, j, a, b}$ 少很多，因为前者不再依赖于图像中的位置。这就是显著的进步！</p><h3 id="局部性"><a href="#局部性" class="headerlink" title="局部性"></a>局部性</h3><p>现在引用上述的第二个原则：局部性。如上所述，为了收集用来训练参数 $[\mathbf{H}]<em>{i, j}$ 的相关信息，我们不应偏离到距 $(i, j)$ 很远的地方。这意味着在 $|a|&gt; \Delta$ 或 $|b| &gt; \Delta$ 的范围之外，我们可以设置 $[\mathbf{V}]</em>{a, b} = 0$。因此，我们可以将 $[\mathbf{H}]_{i, j}$ 重写为</p><script type="math/tex; mode=display">[\mathbf{H}]_{i, j} = u + \sum_{a = -\Delta}^{\Delta} \sum_{b = -\Delta}^{\Delta} [\mathbf{V}]_{a, b}  [\mathbf{X}]_{i+a, j+b}. \tag{$1$}</script><p>简而言之， 公式（1）代表的是一个 <em>卷积层</em> （convolutional layer），而卷积神经网络是包含卷积层的一类特殊的神经网络。</p><p>在深度学习研究社区中， $\mathbf{V}$ 被称为 <em>卷积核</em> （convolution kernel） 或者  <em>滤波器</em> （filter），它仅仅是可学习的一个层的权重。</p><p>当图像处理的局部区域很小时，卷积神经网络与多层感知机的训练差异可能是巨大的：以前，多层感知机可能需要数十亿个参数来表示网络中的一层，而现在卷积神经网络通常只需要几百个参数，而且不需要改变输入或隐藏表示的维数。</p><p>参数大幅减少的代价是，我们的特征现在是平移不变的，并且当确定每个隐藏激活的值时，每一层只能包含局部的信息。</p><p>以上所有的权重学习都将依赖于归纳偏置。当这种偏置与现实相符时，我们就能得到样本有效的模型，并且这些模型能很好地泛化到未知数据中。</p><p>但如果这偏置与现实不符时，比如当图像不满足平移不变时，我们的模型可能难以拟合我们的训练数据。</p><h2 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h2><p>在进一步讨论之前，我们先简要回顾一下为什么上面的操作被称为卷积。在数学中，两个函数（比如 $f, g: \mathbb{R}^d \to \mathbb{R}$）之间的“卷积”被定义为</p><script type="math/tex; mode=display">(f * g)(\mathbf{x}) = \int f(\mathbf{z}) g(\mathbf{x}-\mathbf{z}) d\mathbf{z}.</script><p>也就是说，卷积是测量 $f$ 和 $g$ 之间（把其中一个函数“翻转”并移位 $\mathbf{x}$ 时）的重叠。</p><p>当我们有离散对象时，积分就变成求和。例如：对于由索引为$\mathbb{Z}$的、平方可和的、无限维向量集合中抽取的向量，我们得到以下定义：</p><script type="math/tex; mode=display">(f * g)(i) = \sum_a f(a) g(i-a).</script><p>对于二维张量，则为 $f$ 的索引 $(a, b)$ 和 $g$ 的索引 $(i-a, j-b)$ 上的对应和：</p><script type="math/tex; mode=display">(f * g)(i, j) = \sum_a\sum_b f(a, b) g(i-a, j-b).  \tag{$2$}</script><p>这看起来类似于公式（1），但有一个主要区别：这里不是使用 $(i+a, j+b)$ ，而是使用差值。然而，这种区别主要是装饰性的，因为我们总是可以匹配公式（1）和公式（2）之间的符号。我们在公式（1）中的原始定义更正确地描述了<em>互相关</em>（cross-correlation）。</p><h2 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h2><p>然而（上述）这种方法有一个问题：我们忽略了图像一般包含三个通道/三种原色（红色、绿色和蓝色）。实际上，图像不是二维张量，而是一个由高度、宽度和颜色组成的三维张量，比如包含 $1024 \times 1024 \times 3$ 个像素。前两个轴与像素的空间位置有关，而第三个轴可以看作是每个像素的多维表示。因此，我们将 $\mathsf{X}$ 索引为 $[\mathsf{X}]<em>{i, j, k}$ 。由此卷积相应地调整为 $[\mathsf{V}]</em>{a,b,c}$ ，而不是 $[\mathbf{V}]_{a,b}$ 。</p><p>此外，由于输入图像是三维的，我们的隐藏表示 $\mathsf{H}$ 也最好采用三维张量。换句话说，对于每一个空间位置，我们想要采用一组而不是一个隐藏表示。这样一组隐藏表示可以想象成一些互相堆叠的二维网格。因此，我们可以把隐藏表示想象为一系列具有二维张量的 <em>通道</em> （channel）。这些通道有时也被称为 <em>特征映射</em> （feature maps），因为每个通道都向后续层提供一组空间化的学习特征。直观上你可以想象在靠近输入的底层，一些通道专门识别边，而其他通道专门识别纹理。</p><p>为了支持输入 $\mathsf{X}$ 和隐藏表示 $\mathsf{H}$ 中的多个通道，我们可以在 $\mathsf{V}$ 中添加第四个坐标，即 $[\mathsf{V}]_{a, b, c, d}$ 。综上所述，</p><script type="math/tex; mode=display">[\mathsf{H}]_{i,j,d} = \sum_{a = -\Delta}^{\Delta} \sum_{b = -\Delta}^{\Delta} \sum_c [\mathsf{V}]_{a, b, c, d} [\mathsf{X}]_{i+a, j+b, c}, \tag{$3$}</script><p>其中隐藏表示 $\mathsf{H}$ 中的 $d$ 索引表示输出通道，而随后的输出将继续以三维张量 $\mathsf{H}$ 作为输入进入下一个卷积层。所以，公式（3）可以定义具有多个通道的卷积层，而其中 $\mathsf{V}$ 是该卷积层的权重。</p><h1 id="图像卷积"><a href="#图像卷积" class="headerlink" title="图像卷积"></a>图像卷积</h1><h2 id="互相关运算"><a href="#互相关运算" class="headerlink" title="互相关运算"></a>互相关运算</h2><p>严格来说，卷积层是个错误的叫法，因为它所表达的运算其实是 <em>互相关运算</em> (cross-correlation)，而不是卷积运算。为了与深度学习文献中的标准术语保持一致，我们将继续把“互相关运算”称为卷积运算，尽管严格地说，它们略有不同.此外，对于卷积核张量上的权重，我们称其为<em>元素</em>。</p><p>根据上一节的描述，在卷积层中，输入张量和核张量通过(<strong>互相关运算</strong>)产生输出张量。</p><p>首先，我们暂时忽略通道（第三维）这一情况，看看如何处理二维图像数据和隐藏表示。在下图中，输入是高度为 $3$、宽度为 $3$ 的二维张量（即形状为 $3 \times 3$ ）。卷积核的高度和宽度都是 $2$。</p><p><img src="correlation.svg" alt="图1: 二维互相关运算。阴影部分是第一个输出元素，以及用于计算这个输出的输入和核张量元素：$0\times0+1\times1+3\times2+4\times3=19$."></p><p>在二维互相关运算中，卷积窗口从输入张量的左上角开始，从左到右、从上到下滑动。当卷积窗口滑动到新一个位置时，包含在该窗口中的部分张量与卷积核张量进行按元素相乘，得到的张量再求和得到一个单一的标量值，由此我们得出了这一位置的输出张量值。</p><p>在如上例子中，输出张量的四个元素由二维互相关运算得到，这个输出高度为 $2$ 、宽度为 $2$ ，如下所示：</p><script type="math/tex; mode=display">0\times0+1\times1+3\times2+4\times3=19,\\1\times0+2\times1+4\times2+5\times3=25,\\3\times0+4\times1+6\times2+7\times3=37,\\4\times0+5\times1+7\times2+8\times3=43.</script><p>注意，输出大小略小于输入大小。这是因为卷积核的宽度和高度大于1，而卷积核只与图像中每个大小完全适合的位置进行互相关运算。所以，输出大小等于输入大小 $n_h \times n_w$ 减去卷积核大小 $k_h \times k_w$，即：</p><script type="math/tex; mode=display">(n_h-k_h+1) \times (n_w-k_w+1).</script><p>这是因为我们需要足够的空间在图像上“移动”卷积核。稍后，我们将看到如何通过在图像边界周围填充零来保证有足够的空间移动内核，从而保持输出大小不变。接下来，我们在 <code>corr2d</code> 函数中实现如上过程，该函数接受输入张量 <code>X</code> 和卷积核张量  <code>K</code> ，并返回输出张量 <code>Y</code> 。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br><span class="line"><span class="comment"># 输入张量X和卷积核张量K</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">corr2d</span>(<span class="params">X, K</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算二维互相关运算&quot;&quot;&quot;</span></span><br><span class="line">    h, w = K.shape</span><br><span class="line">    <span class="comment"># 根据X和K得到输出Y的形状</span></span><br><span class="line">    Y = torch.zeros((X.shape[<span class="number">0</span>] - h + <span class="number">1</span>, X.shape[<span class="number">1</span>] - w + <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(Y.shape[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(Y.shape[<span class="number">1</span>]):</span><br><span class="line">            Y[i, j] = (X[i:i + h, j:j + w] * K).<span class="built_in">sum</span>()</span><br><span class="line">    <span class="keyword">return</span> Y</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对上述函数进行验证</span></span><br><span class="line">X = torch.tensor([[<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>], [<span class="number">3.0</span>, <span class="number">4.0</span>, <span class="number">5.0</span>], [<span class="number">6.0</span>, <span class="number">7.0</span>, <span class="number">8.0</span>]])</span><br><span class="line">K = torch.tensor([[<span class="number">0.0</span>, <span class="number">1.0</span>], [<span class="number">2.0</span>, <span class="number">3.0</span>]])</span><br><span class="line">corr2d(X, K)</span><br></pre></td></tr></table></figure><pre><code>tensor([[19., 25.],        [37., 43.]])</code></pre><h2 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h2><p>卷积层对输入和卷积核权重进行互相关运算，并在添加标量偏置之后产生输出。所以，卷积层中的两个被训练的参数是<strong>卷积核权重</strong>和<strong>标量偏置</strong>。就像我们之前随机初始化全连接层一样，在训练基于卷积层的模型时，我们也随机初始化卷积核权重。</p><p>基于上面定义的 <code>corr2d</code> 函数[<strong>实现二维卷积层</strong>]。在 <code>__init__</code> 构造函数中，将 <code>weight</code> 和 <code>bias</code> 声明为两个模型参数。前向传播函数调用 <code>corr2d</code> 函数并添加偏置。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Conv2D</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, kernel_size</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.weight = nn.Parameter(torch.rand(kernel_size))</span><br><span class="line">        self.bias = nn.Parameter(torch.zeros(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="keyword">return</span> corr2d(x, self.weight) + self.bias</span><br></pre></td></tr></table></figure><p>高度和宽度分别为 $h$ 和 $w$的卷积核可以被称为 $h \times w$ 卷积或 $h \times w$ 卷积核。我们也将带有 $h \times w$ 卷积核的卷积层称为 $h \times w$ 卷积层。</p><h2 id="图像中目标的边缘检测"><a href="#图像中目标的边缘检测" class="headerlink" title="图像中目标的边缘检测"></a>图像中目标的边缘检测</h2><p>如下是<strong>卷积层的一个简单应用：</strong>通过找到像素变化的位置，来<strong>检测图像中不同颜色的边缘</strong>。<br>首先，我们构造一个 $6\times 8$ 像素的黑白图像。中间四列为黑色（$0$），其余像素为白色（$1$）。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = torch.ones((<span class="number">6</span>, <span class="number">8</span>))</span><br><span class="line">X[:, <span class="number">2</span>:<span class="number">6</span>] = <span class="number">0</span></span><br><span class="line">X</span><br></pre></td></tr></table></figure><pre><code>tensor([[1., 1., 0., 0., 0., 0., 1., 1.],        [1., 1., 0., 0., 0., 0., 1., 1.],        [1., 1., 0., 0., 0., 0., 1., 1.],        [1., 1., 0., 0., 0., 0., 1., 1.],        [1., 1., 0., 0., 0., 0., 1., 1.],        [1., 1., 0., 0., 0., 0., 1., 1.]])</code></pre><p>接下来，我们构造一个高度为 $1$ 、宽度为 $2$ 的卷积核 <code>K</code> 。当进行互相关运算时，如果水平相邻的两元素相同，则输出为零，否则输出为非零。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">K = torch.tensor([[<span class="number">1.0</span>, -<span class="number">1.0</span>]])</span><br></pre></td></tr></table></figure><p>现在，我们对参数 <code>X</code> （输入）和 <code>K</code> （卷积核）执行互相关运算。如下所示，<strong>输出<code>Y</code>中的1代表从白色到黑色的边缘，-1代表从黑色到白色的边缘</strong>，其他情况的输出为 $0$。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Y = corr2d(X, K)</span><br><span class="line">Y</span><br></pre></td></tr></table></figure><pre><code>tensor([[ 0.,  1.,  0.,  0.,  0., -1.,  0.],        [ 0.,  1.,  0.,  0.,  0., -1.,  0.],        [ 0.,  1.,  0.,  0.,  0., -1.,  0.],        [ 0.,  1.,  0.,  0.,  0., -1.,  0.],        [ 0.,  1.,  0.,  0.,  0., -1.,  0.],        [ 0.,  1.,  0.,  0.,  0., -1.,  0.]])</code></pre><p>现在我们将输入的二维图像转置，再进行如上的互相关运算。其输出如下，之前检测到的垂直边缘消失了。不出所料，这个<strong>卷积核<code>K</code>只可以检测垂直边缘</strong>，无法检测水平边缘。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">corr2d(X.t(), K)</span><br></pre></td></tr></table></figure><pre><code>tensor([[0., 0., 0., 0., 0.],        [0., 0., 0., 0., 0.],        [0., 0., 0., 0., 0.],        [0., 0., 0., 0., 0.],        [0., 0., 0., 0., 0.],        [0., 0., 0., 0., 0.],        [0., 0., 0., 0., 0.],        [0., 0., 0., 0., 0.]])</code></pre><h2 id="学习卷积核"><a href="#学习卷积核" class="headerlink" title="学习卷积核"></a>学习卷积核</h2><p>在卷积神经网络中，卷积核是需要学习的参数。</p><p>现在让我们看看是否可以通过仅查看“输入-输出”对来学习由 <code>X</code> 生成 <code>Y</code> 的卷积核。我们先构造一个卷积层，并将其卷积核初始化为随机张量。接下来，在每次迭代中，我们比较  <code>Y</code> 与卷积层输出的平方误差，然后计算梯度来更新卷积核。为了简单起见，我们在此使用内置的二维卷积层，并忽略偏置。</p><blockquote><p><strong>这一段有几个问题</strong>：</p><ol><li>conv2d是什么，是nn.Conv2d函数本身，还是nn.Conv2d的返回值</li><li>为什么要将XY转换为四维。</li><li>l（loss）和conv2d之间是怎么建立起联系的？</li></ol></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 构造一个二维卷积层，它具有1个输出通道和形状为（1，2）的卷积核</span></span><br><span class="line"><span class="comment"># 第一二个参数指明了输入、输出的通道数</span></span><br><span class="line">conv2d = nn.Conv2d(<span class="number">1</span>,<span class="number">1</span>, kernel_size=(<span class="number">1</span>, <span class="number">2</span>), bias=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个二维卷积层使用四维输入和输出格式（批量大小、通道、高度、宽度），</span></span><br><span class="line"><span class="comment"># 其中批量大小和通道数都为1</span></span><br><span class="line">X = X.reshape((<span class="number">1</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">8</span>))</span><br><span class="line">Y = Y.reshape((<span class="number">1</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">7</span>))</span><br><span class="line">lr = <span class="number">3e-2</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">    Y_hat = conv2d(X)</span><br><span class="line">    l = (Y_hat - Y) ** <span class="number">2</span></span><br><span class="line">    conv2d.zero_grad()</span><br><span class="line">    l.<span class="built_in">sum</span>().backward()</span><br><span class="line">    <span class="comment"># 根据梯度迭代卷积核</span></span><br><span class="line">    conv2d.weight.data[:] -= lr * conv2d.weight.grad</span><br><span class="line">    <span class="keyword">if</span> (i + <span class="number">1</span>) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;epoch <span class="subst">&#123;i+<span class="number">1</span>&#125;</span>, loss <span class="subst">&#123;l.<span class="built_in">sum</span>():<span class="number">.3</span>f&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>epoch 2, loss 7.561epoch 4, loss 2.024epoch 6, loss 0.649epoch 8, loss 0.236epoch 10, loss 0.091epoch 12, loss 0.037epoch 14, loss 0.015epoch 16, loss 0.006epoch 18, loss 0.002epoch 20, loss 0.001</code></pre><p>查看我们所学到的卷积核权重张量，可以发现我们学习到的卷积核权重非常接近我们之前定义的卷积核K。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">conv2d.weight.data.reshape((<span class="number">1</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure><pre><code>tensor([[ 0.9966, -1.0032]])</code></pre><h2 id="特征映射和感受野"><a href="#特征映射和感受野" class="headerlink" title="特征映射和感受野"></a>特征映射和感受野</h2><p>输出的卷积层有时被称为 <em>特征映射</em> （Feature Map），因为它可以被视为一个输入映射到下一层的空间维度的转换器。在CNN中，对于某一层的任意元素 $x$ ，其 <em>感受野</em> （Receptive Field）是指在前向传播期间可能影响 $x$ 计算的所有元素（来自所有先前层）。</p><p>注意，感受野的覆盖率可能大于某层输入的实际区域大小。让我们用<em>图1</em>为例来解释感受野：给定 $2 \times 2$ 卷积核，阴影输出元素值 $19$ 的接收域是输入阴影部分的四个元素。假设之前输出为 $\mathbf{Y}$ ，其大小为 $2 \times 2$ ，现在我们在其后附加一个卷积层，该卷积层以 $\mathbf{Y}$ 为输入，输出单个元素 $z$。在这种情况下， $\mathbf{Y}$ 上的 $z$ 的接收字段包括 $\mathbf{Y}$ 的所有四个元素，而输入的感受野包括最初所有九个输入元素。因此，当一个特征图中的任意元素需要检测更广区域的输入特征时，我们可以构建一个更深的网络。</p><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p><a href="https://github.com/guoyujian/blog-resource/blob/main/d2l-notebooks/conv-layer.ipynb">https://github.com/guoyujian/blog-resource/blob/main/d2l-notebooks/conv-layer.ipynb</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="http://zh-v2.d2l.ai/chapter_convolutional-neural-networks/why-conv.html">《动手学深度学习》6.1. 从全连接层到卷积</a></li><li><a href="http://zh-v2.d2l.ai/chapter_convolutional-neural-networks/conv-layer.html">《动手学深度学习》6.2. 图像卷积</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
          <category> 动手学深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Win10系统下配置深度学习环境</title>
      <link href="/2022/01/16/Win10%E7%B3%BB%E7%BB%9F%E4%B8%8B%E9%85%8D%E7%BD%AE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83/"/>
      <url>/2022/01/16/Win10%E7%B3%BB%E7%BB%9F%E4%B8%8B%E9%85%8D%E7%BD%AE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<blockquote><p>之前在本机配置深度学习环境时候踩了很多坑，这里稍作记录备忘。</p></blockquote><h1 id="Anaconda"><a href="#Anaconda" class="headerlink" title="Anaconda"></a>Anaconda</h1><h2 id="安装Anaconda"><a href="#安装Anaconda" class="headerlink" title="安装Anaconda"></a>安装Anaconda</h2><p>在anaconda官网下载安装。</p><p>安装完成后，1. 配置环境变量；2. 修改anaconda的安装源</p><p>验证conda：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda -V</span><br><span class="line">conda env list</span><br></pre></td></tr></table></figure><h2 id="创建conda环境"><a href="#创建conda环境" class="headerlink" title="创建conda环境"></a>创建conda环境</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建一个名称为common的虚拟环境并指定python版本为3.6.8</span><br><span class="line">conda create -n common python=3.6.8</span><br><span class="line"># 激活虚拟环境</span><br><span class="line">activate common</span><br><span class="line"># 列出所有的虚拟环境</span><br><span class="line">conda env list</span><br><span class="line"># 退出虚拟环境</span><br><span class="line">conda deactivate</span><br><span class="line"># 删除虚拟环境</span><br><span class="line">conda remove -n common --all</span><br></pre></td></tr></table></figure><h1 id="安装NVIDIA显卡驱动"><a href="#安装NVIDIA显卡驱动" class="headerlink" title="安装NVIDIA显卡驱动"></a>安装NVIDIA显卡驱动</h1><p>官网选择电脑相应的显卡版本进行下载：<a href="https://www.nvidia.cn/geforce/drivers/">https://www.nvidia.cn/geforce/drivers/</a></p><h1 id="安装CUDA"><a href="#安装CUDA" class="headerlink" title="安装CUDA"></a>安装CUDA</h1><p>nvidia官网下载对应版本：</p><p><a href="https://developer.nvidia.cn/cuda-toolkit-archive">https://developer.nvidia.cn/cuda-toolkit-archive</a></p><p>安装完毕后，1. 添加环境变量（如果安装时自动添加则跳过这一步）2. 检查CUDA是否安装成功</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nvcc -V</span><br></pre></td></tr></table></figure><h1 id="安装CUDNN"><a href="#安装CUDNN" class="headerlink" title="安装CUDNN"></a>安装CUDNN</h1><p>NVIDIA cuDNN是用于深度神经网络的GPU加速库。</p><p>官网地址：<a href="https://developer.nvidia.com/rdp/cudnn-archive">https://developer.nvidia.com/rdp/cudnn-archive</a></p><p>选择和CUDA版本相对应的进行下载。</p><p>下载万恒后，把解压得到的文件夹内的bin、include、lib目录下的dll文件与h文件分别复制到相应的CUDA的安装目录下。</p><p>通过NVIDIA提供的 <code>deviceQuery.exe</code> 和 <code>bandwidthTest.exe</code> 来查看GPU的状态，两者均在安装目录的 <code>extras\demo_suite</code>文件夹中</p><h1 id="安装Pytorch"><a href="#安装Pytorch" class="headerlink" title="安装Pytorch"></a>安装Pytorch</h1><p>在<a href="https://pytorch.org/get-started/previous-versions/">https://pytorch.org/get-started/previous-versions/</a> 中选择与CUDA版本对应的Pytorch版本，执行给出的命令进行安装。</p><blockquote><p>这里推荐pip安装，在尝试的时候发现使用conda命令固然可以安装，但是安装之后<code>torch.cuda.is_available()</code>为False</p><p>后来选择pip安装，报错，后选择Pytorch低一点的版本，成功<code>torch.cuda.is_available()==True</code>。</p></blockquote><p>安装完成后，进入Python命令行，执行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import torch</span><br><span class="line">print(torch.cuda.is_available())</span><br></pre></td></tr></table></figure><p>结果为True则torch-GPU可用。</p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ol><li><strong>从显卡型号到显卡驱动，到CUDA，到CUDNN，到Pytorch，到torchvision，到cudatoolkit这些版本一定要对应好。</strong></li><li>安装pytorch选择命令时，选择pip手动下载whl文件安装较保险。</li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://mp.weixin.qq.com/s/-oNZfkYdOb_UiWPPZCk1Nw">给win11装个深度学习环境</a></li><li><a href="https://www.zhihu.com/question/370243934">为何torch.version.cuda返回None？</a></li><li><a href="https://blog.csdn.net/yinxian9019/article/details/106763892">pytorch gpu不可用 原因核查</a></li><li><a href="https://www.zhihu.com/question/59184480">显卡、显卡驱动、cuda 之间的关系是什么？</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
          <category> 环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库之分析函数</title>
      <link href="/2022/01/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8B%E5%88%86%E6%9E%90%E5%87%BD%E6%95%B0/"/>
      <url>/2022/01/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8B%E5%88%86%E6%9E%90%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文主要还是参考了Oracle相关资料，所以文中的语法细节和某些函数在其他DB不会生效。</p><p>我并不希望过多关注语法细节和具体函数（这些都可以自行百度），而更希望对分析函数这块的知识进行抽象。</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>分析函数，也称为窗口函数。</p><p>使用分析函数的查询，基于数据行的分组来计算总量值。尽管与一般的聚合函数提供的分组统计类似，但其主要不同点是，分析函数为每个分组返回多行数据。不同于每个分组只得到一行数据，分析函数可以同时得到所有行的详细数据。区分分析函数和聚合函数的一种方法就是，在体积分析函数中使用的一组数据时，使用数据：<strong>窗口</strong>。</p><p>“窗口”（windows）是通过分析子句定义的。每一行限定在一个滑动窗口中，这些滑动窗口确定了用来计算当前行的数据行范围。</p><p>可以把窗口理解为一个集合，一个窗口就是一个集合，在统计分析中有需要不同的「窗口」，比如一个部门分成不同组，在统计时会按组进行平均、排名等操作。再比如，在一些像时间这种有顺序的数据，我们可能5天分一组、一月分一组再进行排序、求中位数等计算。</p><p><strong>分析函数在SQL执行的顺序</strong>：除了ORDER BY子句，分析函数在查询中是最后执行的运算。</p><h2 id="示例数据"><a href="#示例数据" class="headerlink" title="示例数据"></a>示例数据</h2><p>为了方便讲解和更加直观，我建立了一张数据表，该表名为scores，存放了各班级各学生的数学成绩。建表语句如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table math_scores(</span><br><span class="line">student_id string,</span><br><span class="line">class_num int,</span><br><span class="line">score float);</span><br><span class="line">insert into math_scores(student_id, class_num, score) values(</span><br><span class="line">(&#x27;1&#x27;,1,84),</span><br><span class="line">(&#x27;2&#x27;,1,76),</span><br><span class="line">(&#x27;3&#x27;,1,85),</span><br><span class="line">(&#x27;4&#x27;,1,92),</span><br><span class="line">(&#x27;5&#x27;,2,89),</span><br><span class="line">(&#x27;6&#x27;,2,91),</span><br><span class="line">(&#x27;7&#x27;,2,63),</span><br><span class="line">(&#x27;8&#x27;,3,83),</span><br><span class="line">(&#x27;9&#x27;,3,63),</span><br><span class="line">(&#x27;10&#x27;,3,84)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h1 id="剖析"><a href="#剖析" class="headerlink" title="剖析"></a>剖析</h1><h2 id="与聚合的不同"><a href="#与聚合的不同" class="headerlink" title="与聚合的不同"></a>与聚合的不同</h2><p>窗口函数会按当前所在的分组进行聚合计算，并将聚合计算结果追加在当前行对应的新列，它表达的是当前行与这所在分组的关系。</p><p><img src="sql-windows-functions-01.png" alt="聚合函数与窗口函数"></p><p>窗口函数和 Group By 聚合函数区别在于：窗口函数仅仅只会将结果附加到当前的结果上，它不会对已有的行或列做任何修改。而 Group By 的做法完全不同：对于各个 Group 它仅仅会保留一行聚合结果。</p><p><img src="window-functions-partitioning.jpg" alt="窗口函数计算过程"></p><h2 id="与-group-by-的区别"><a href="#与-group-by-的区别" class="headerlink" title="与 group by 的区别"></a>与 group by 的区别</h2><ul><li>结果数据形式<ul><li>窗口函数可以在保留原表中的全部数据</li><li>group by 只能保留与分组字段聚合的结果</li></ul></li><li>排序范围不同<ul><li>窗口函数中的 order by 只是决定着窗口里的数据的排序方式</li><li>普通的 order by 决定查询出的数据以什么样的方式整体排序</li></ul></li><li>SQL 顺序<ul><li>group by 先进行计算</li><li>窗口函数在 group by 后进行计算</li></ul></li></ul><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>分析函数有三个基本组成部分：分区子句、排序子句以及开窗子句。分析函数的基本语法是：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">function1(argument1, argument2,...argumentN) <span class="keyword">over</span>([<span class="keyword">partition</span><span class="operator">-</span><span class="keyword">by</span><span class="operator">-</span>clause] [<span class="keyword">order</span><span class="operator">-</span><span class="keyword">by</span><span class="operator">-</span>clause] [windowing<span class="operator">-</span>clause])</span><br></pre></td></tr></table></figure><h3 id="function1"><a href="#function1" class="headerlink" title="function1"></a>function1</h3><p>function1是所调用的接收0个或多个参数的分析函数。下表列举了常用的分析函数。（不需要纠结每个函数具体怎么用，大致了解功能，用的时候再细看。）</p><div class="table-container"><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>lag</td><td>访问一个分区或结果集中之前的一行</td></tr><tr><td>lead</td><td>访问一个分区或结果集中之后的一行</td></tr><tr><td>first_value</td><td>访问一个分区或结果集中第一行</td></tr><tr><td>last_value</td><td>访问一个分区或结果集中最后一行</td></tr><tr><td>nth_value</td><td>访问一个分区或结果集中任意一行</td></tr><tr><td>rank</td><td>将数据行值按照排序后的顺序进行排名，在有并列的情况下排名值将被跳过</td></tr><tr><td>dense_rank</td><td>将数据行值按照排序后的顺序进行排名，在有并列的情况下也不跳过排名值</td></tr><tr><td>row_number</td><td>对行进行排序并为每一行增加唯一编号。这是一个非确定函数</td></tr><tr><td>ratio_to_report</td><td>计算报告中值得比例</td></tr><tr><td>percent_rank</td><td>将计算得到的排名值标准化为0-1之间的值</td></tr><tr><td>percentile_cont</td><td>取出与指定的排名百分比相匹配的值。是percent_rank的反函数</td></tr><tr><td>percentile_dist</td><td>取出与指定的排名百分比相匹配的值。采用谨慎分布模型</td></tr><tr><td>ntile</td><td>将数据行分组为单元</td></tr><tr><td>listagg</td><td>将来自不同行的列值转化为列表格式</td></tr></tbody></table></div><p><strong>除了上述分析函数，function1还可以是min/max/avg/count等聚合函数</strong>。</p><h3 id="分区子句"><a href="#分区子句" class="headerlink" title="分区子句"></a>分区子句</h3><p>分区子句按照分区列的值对数据行进行分组。所有分区列的值相同的数据行被组合为一个数据分区。例如<code>partition by class_num</code>就是按班级进行分区。</p><h3 id="排序子句"><a href="#排序子句" class="headerlink" title="排序子句"></a>排序子句</h3><p>排序子句对数据分区中的行进行排序。排序可以按照升序或者降序，使用<code>NULLS FIRST</code>或<code>NULLS LAST</code>子句可以将空值放到数据分区的最上面或最下面。</p><h3 id="开窗子句"><a href="#开窗子句" class="headerlink" title="开窗子句"></a>开窗子句</h3><p>之前的窗口是固定的数据分组窗口，但有时候我们需要根据数据的前后再分配窗口，比如在股票、气温等数据场景下，数据的前后会有影响，就适用于移动窗口计算。</p><p>开窗子句指定了分析函数进行运算的数据子集。这个窗口可以是动态的，他有一个很恰当的名字——<strong>滑动窗口</strong>。使用窗口说明子句来指定滑动窗口的上下边界条件。窗口子句的语法如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">ROWS</span> <span class="operator">|</span> <span class="keyword">RANGE</span>] <span class="keyword">BETWEEN</span> <span class="operator">&lt;</span><span class="keyword">start</span> expr<span class="operator">&gt;</span> <span class="keyword">AND</span> <span class="operator">&lt;</span><span class="keyword">end</span> expr<span class="operator">&gt;</span></span><br><span class="line">Whereas</span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">start</span> expr<span class="operator">&gt;</span> <span class="keyword">is</span> [UNBOUNDED PRECEDING <span class="operator">|</span> <span class="keyword">CURRENT</span> <span class="type">ROW</span> <span class="operator">|</span> n PRECEDING <span class="operator">|</span> n FOLLOWING]</span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">end</span> expr<span class="operator">&gt;</span> <span class="keyword">is</span> [UNBOUNDED PRECEDING <span class="operator">|</span> <span class="keyword">CURRENT</span> <span class="type">ROW</span> <span class="operator">|</span> n PRECEDING <span class="operator">|</span> n FOLLOWING]</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>移动范围设定<ul><li>rows: 物理窗口，rows 后的 n 是指相对当前行偏移n位（当前行也参与计算），可以与 between 搭配使用表达范围</li><li>range: 逻辑窗口，是指定当前行对应值的范围取值。</li><li>rows和range的区别见<em>参考资料3</em></li></ul></li><li>偏移方向<ul><li>precending: 向当前行之前</li><li>following: 向当前行之后</li></ul></li></ul><p>同时，preceding 与 following 可以相结合，例1：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">rows</span> <span class="keyword">between</span> <span class="number">1</span> precending <span class="keyword">and</span> <span class="number">2</span> following</span><br></pre></td></tr></table></figure><p>表示当前行的前一行和后两行，共 4 行（包括当前行）作为汇总的依据。</p><p>例2：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">rows</span> <span class="keyword">between</span> unbounded preceding <span class="keyword">and</span> <span class="keyword">current</span> <span class="type">row</span></span><br></pre></td></tr></table></figure><p>表示窗口最上一行是当前分区中的第一行而窗口最下一行是当前的数据行。</p><blockquote><p>并不是所有的分析函数都支持开窗子句；</p><p>分析函数不能嵌套。</p><p>窗口子句不能单独存在，必须有order by子句时才能出现。</p><p><strong>默认窗口</strong>分两种情况：</p><ul><li>有order by时，无窗口子句，则默认的窗口是<code>unbounded preceding and current row</code>，即当前组的第一行到当前行</li><li>无order by时，无窗口子句，则默认的窗口是<code>unbounded preceding and unbounded following</code>，即整个组</li></ul></blockquote><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><ul><li>下面sql指出了每位学生所在班级的平均数学成绩</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> student_id, class_num, <span class="built_in">AVG</span>(score) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> class_num) <span class="keyword">AS</span> math_avg</span><br><span class="line"><span class="keyword">FROM</span> math_scores</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">student_idclass_numscorealg_avg</span><br><span class="line">118484.25</span><br><span class="line">217684.25</span><br><span class="line">318584.25</span><br><span class="line">419284.25</span><br><span class="line">528981</span><br><span class="line">629181</span><br><span class="line">726381</span><br><span class="line">838376.67</span><br><span class="line">936376.67</span><br><span class="line">1038476.67</span><br></pre></td></tr></table></figure><ul><li>计算每位同学数学成绩的班级排名</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> student_id, class_num, score, <span class="built_in">RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> class_num <span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">DESC</span>) <span class="keyword">AS</span> rankk</span><br><span class="line"><span class="keyword">FROM</span> math_scores</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">student_idclass_numscorerankk</span><br><span class="line">41921</span><br><span class="line">31852</span><br><span class="line">11843</span><br><span class="line">21764</span><br><span class="line">62911</span><br><span class="line">52892</span><br><span class="line">72633</span><br><span class="line">103841</span><br><span class="line">83832</span><br><span class="line">93633</span><br></pre></td></tr></table></figure><h1 id="lead和lag"><a href="#lead和lag" class="headerlink" title="lead和lag"></a>lead和lag</h1><p>lead函数支持访问结果集中后面的行，lag能够访问结果集中前面的行。</p><p>lead和lag的语法如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">lag</span>(expr [, <span class="keyword">offset</span>] [, <span class="keyword">default</span>]) <span class="keyword">OVER</span> ([partition_by_clause] order_by_clause)</span><br><span class="line"><span class="built_in">lead</span>(expr [, <span class="keyword">offset</span>] [, <span class="keyword">default</span>]) <span class="keyword">OVER</span>([partition_by_clause] order_by_clause)</span><br></pre></td></tr></table></figure><p>lead和lag<strong>不支持开窗子句</strong>。这两个函数仅支持partition_by子句和order_by子句。</p><p>下面的sql给出当前数据行前一行的数学成绩（成绩从大到小排序）</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> student_id, class_num, score, <span class="built_in">lag</span>(score, <span class="number">1</span>) <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">DESC</span>) <span class="keyword">AS</span> last_score</span><br><span class="line"><span class="keyword">FROM</span> math_scores</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">student_idclass_numscorelast_score</span><br><span class="line">4192NULL</span><br><span class="line">629192</span><br><span class="line">528991</span><br><span class="line">318589</span><br><span class="line">1038485</span><br><span class="line">118484</span><br><span class="line">838384</span><br><span class="line">217683</span><br><span class="line">936376</span><br><span class="line">726363</span><br></pre></td></tr></table></figure><p>由于第一行没有前一行，所以第一行last_score为NULL，如果不想让它为NULL ，可以使用lag/lead的第三个参数指定默认值。</p><blockquote><p>理解offset是行偏移，而不是数据值偏移</p></blockquote><h1 id="first-value和last-value"><a href="#first-value和last-value" class="headerlink" title="first_value和last_value"></a>first_value和last_value</h1><p>first_value和last_value分别从数据行窗口返回第一行的列值和最后一行的列值。其语法如下</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">first_value</span>(expr) <span class="keyword">over</span>([<span class="keyword">partition</span><span class="operator">-</span><span class="keyword">by</span><span class="operator">-</span>clause] [<span class="keyword">order</span><span class="operator">-</span><span class="keyword">by</span><span class="operator">-</span>clause] [windowing<span class="operator">-</span>clause])</span><br><span class="line"><span class="built_in">last_value</span>(expr) <span class="keyword">over</span>([<span class="keyword">partition</span><span class="operator">-</span><span class="keyword">by</span><span class="operator">-</span>clause] [<span class="keyword">order</span><span class="operator">-</span><span class="keyword">by</span><span class="operator">-</span>clause] [windowing<span class="operator">-</span>clause])</span><br></pre></td></tr></table></figure><p>例如，使用first_value可以实现计算<em>每个班级的数学成绩最高分</em>。（自行思考）</p><p>使用开窗语句，可以为这些函数运算定义动态滑动窗口，例如计算到<em>目前为止的最大销售额</em></p><h2 id="处理空值"><a href="#处理空值" class="headerlink" title="处理空值"></a>处理空值</h2><p>空值通过[RESPECT NULLS | IGNORE NULLS]处理。RESPECT NULLS子句是默认值。默认情况下，如果第一行的列值为空，first_value函数就会返回空值。如果指定了IGNORE NULLS子句，则first_value函数将会返回在窗口中第一个列值不为空的行的值。</p><h1 id="rank-dense-rank-row-number"><a href="#rank-dense-rank-row-number" class="headerlink" title="rank/dense_rank/row_number"></a>rank/dense_rank/row_number</h1><p>这三个函数都是返回排名，不同之处在于他们对排名相同行的处理。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rank</span>() <span class="keyword">OVER</span>([partition_by_clause] order_by_clause); <span class="comment">-- 间断，相同值同序号，如 1、1、3、4、5</span></span><br><span class="line"><span class="built_in">row_number</span>() <span class="keyword">OVER</span>([partition_by_clause] order_by_clause); <span class="comment">-- 不间断，序号不重复，如 1、2、3、4、5</span></span><br><span class="line"><span class="built_in">dense_rank</span>() <span class="keyword">OVER</span>([partition_by_clause] order_by_clause) <span class="comment">-- 不间断，相同值同序号，如 1、1、2、3、3</span></span><br></pre></td></tr></table></figure><p>row_number是一个非确定函数，如果数据分区中的两行具有同样的值，row_number的值是不确定的。</p><p>这三个函数都不能使用开窗子句</p><h1 id="其他分析函数"><a href="#其他分析函数" class="headerlink" title="其他分析函数"></a>其他分析函数</h1><h2 id="nth-value"><a href="#nth-value" class="headerlink" title="nth_value"></a>nth_value</h2><p>first_value和last_value函数能够获取排序过的结果集中第一行或最后一行的数据。使用nth_value函数，可以获取排过序的结果集中的任意一行。</p><p>语法如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">nth_value</span>(measure, n) [<span class="keyword">FROM</span> <span class="keyword">FIRST</span> <span class="operator">|</span> <span class="keyword">FROM</span> <span class="keyword">LAST</span> ] [RESPECT NULLS <span class="operator">|</span> IGNORE NULLS] <span class="keyword">OVER</span>(...)</span><br></pre></td></tr></table></figure><p>其中第一个参数是列名，第二个参数为窗口位移量。</p><h2 id="ratio-to-report"><a href="#ratio-to-report" class="headerlink" title="ratio_to_report"></a>ratio_to_report</h2><p>ratio_to_report计算数据分区中某个值与和值的比率。</p><h2 id="listagg-Oracle"><a href="#listagg-Oracle" class="headerlink" title="listagg(Oracle)"></a>listagg(Oracle)</h2><p>这是Oracle 11gR2中引入的分析函数。这个分析函数能够将来自多个行的列值转化为列表格式。</p><p>listagg语法如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">listagg</span>(string, separator) <span class="keyword">within</span> <span class="keyword">group</span> (<span class="keyword">order</span><span class="operator">-</span><span class="keyword">by</span><span class="operator">-</span>clause) <span class="keyword">over</span>(<span class="keyword">partition</span><span class="operator">-</span><span class="keyword">by</span><span class="operator">-</span>clause)</span><br></pre></td></tr></table></figure><blockquote><p>在HIVE中可以使用<code>collect_list</code>或<code>collect_set</code>以及数组转字符串函数<code>concat_ws(&#39;,&#39;, COLLECT_LIST(&lt;cloumn&gt;))</code>来实现相同的效果。</p><p>listagg函数的一个<strong>局限</strong>就是，他的结果强制为VARCHAR2数据类型的最大长度。</p></blockquote><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>《精通Oracle SQL》 第八章</li><li><a href="https://www.gairuo.com/p/hive-sql-tutorial">HIVE SQL教程</a> 窗口计算 </li><li><a href="http://blog.itpub.net/21251711/viewspace-1068855/">分析函数用法及窗口子句 range/rows差别</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> 分析函数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> 分析函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP协议的幂等性</title>
      <link href="/2022/01/15/HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7/"/>
      <url>/2022/01/15/HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>基于HTTP协议的Web API是时下最为流行的一种分布式服务提供方式。无论是在大型互联网应用还是企业级架构中，我们都见到了越来越多的SOA或RESTful的Web API。为什么Web API如此流行呢？我认为很大程度上应归功于简单有效的HTTP协议。</p><p>HTTP协议是一种分布式的面向资源的网络<strong>应用层协议</strong>，无论是服务器端提供Web服务，还是客户端消费Web服务都非常简单。再加上浏览器、Javascript、AJAX、JSON以及HTML5等技术和工具的发展，互联网应用架构设计表现出了从传统的PHP、JSP、ASP.NET等服务器端动态网页向Web API + RIA（富互联网应用）过渡的趋势。Web API专注于提供业务服务，RIA专注于用户界面和交互设计，从此两个领域的分工更加明晰。在这种趋势下，Web API设计将成为服务器端程序员的必修课。然而，正如简单的Java语言并不意味着高质量的Java程序，简单的HTTP协议也不意味着高质量的Web API。要想设计出高质量的Web API，还需要深入理解分布式系统及HTTP协议的特性。</p><h1 id="幂等性定义"><a href="#幂等性定义" class="headerlink" title="幂等性定义"></a>幂等性定义</h1><p>本文所要探讨的正是HTTP协议涉及到的一种重要性质：幂等性(Idempotence)。在HTTP/1.1规范中幂等性的定义是：</p><blockquote><p>Methods can also have the property of “idempotence” in that (aside from error or expiration issues) the side-effects of N &gt; 0 identical requests is the same as for a single request.</p></blockquote><p>从定义上看，<strong>HTTP方法的幂等性是指一次和多次请求某一个资源应该具有同样的副作用。</strong>幂等性属于语义范畴，正如编译器只能帮助检查语法错误一样，HTTP规范也没有办法通过消息格式等语法手段来定义它，这可能是它不太受到重视的原因之一。但实际上，幂等性是分布式系统设计中十分重要的概念，而HTTP的分布式本质也决定了它在HTTP中具有重要地位。</p><h1 id="分布式事务-vs-幂等设计"><a href="#分布式事务-vs-幂等设计" class="headerlink" title="分布式事务 vs 幂等设计"></a>分布式事务 vs 幂等设计</h1><p>为什么需要幂等性呢？我们先从一个例子说起，假设有一个从账户取钱的远程API（可以是HTTP的，也可以不是），我们暂时用类函数的方式记为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool withdraw(account_id, amount)</span><br></pre></td></tr></table></figure><p>withdraw的语义是从account_id对应的账户中扣除amount数额的钱；如果扣除成功则返回true，账户余额减少amount；如果扣除失败则返回false，账户余额不变。值得注意的是：和本地环境相比，我们不能轻易假设分布式环境的可靠性。一种典型的情况是withdraw请求已经被服务器端正确处理，但服务器端的返回结果由于网络等原因被掉丢了，导致客户端无法得知处理结果。如果是在网页上，一些不恰当的设计可能会使用户认为上一次操作失败了，然后刷新页面，这就导致了withdraw被调用两次，账户也被多扣了一次钱。如图1所示：</p><p><img src="20110810171503575.png" alt="图1"></p><p>这个问题的<strong>解决方案一</strong>是采用分布式事务，通过引入支持分布式事务的中间件来保证withdraw功能的事务性。分布式事务的优点是对于调用者很简单，复杂性都交给了中间件来管理。缺点则是一方面架构太重量级，容易被绑在特定的中间件上，不利于异构系统的集成；另一方面分布式事务虽然能保证事务的ACID性质，而但却无法提供性能和可用性的保证。</p><p>另一种更<strong>轻量级的解决方案</strong>是幂等设计。我们可以通过一些技巧把withdraw变成幂等的，比如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int create_ticket() </span><br><span class="line">bool idempotent_withdraw(ticket_id, account_id, amount)</span><br></pre></td></tr></table></figure><p>create_ticket的语义是获取一个服务器端生成的唯一的处理号ticket_id，它将用于标识后续的操作。idempotent_withdraw和withdraw的区别在于关联了一个ticket_id，<strong>一个ticket_id表示的操作至多只会被处理一次</strong>，每次调用都将返回第一次调用时的处理结果。这样，idempotent_withdraw就符合幂等性了，客户端就可以放心地多次调用。</p><p>基于幂等性的解决方案中一个完整的取钱流程被分解成了两个步骤：1.调用create_ticket()获取ticket_id；2.调用idempotent_withdraw(ticket_id, account_id, amount)。虽然create_ticket不是幂等的，但在这种设计下，它对系统状态的影响可以忽略，加上idempotent_withdraw是幂等的，所以任何一步由于网络等原因失败或超时，客户端都可以重试，直到获得结果。如图2所示：</p><p><img src="201106042051069339.png" alt="图2"></p><p>和分布式事务相比，幂等设计的优势在于它的轻量级，容易适应异构环境，以及性能和可用性方面。在某些性能要求比较高的应用，幂等设计往往是唯一的选择。</p><h1 id="HTTP的幂等性"><a href="#HTTP的幂等性" class="headerlink" title="HTTP的幂等性"></a>HTTP的幂等性</h1><p>HTTP协议本身是一种面向资源的应用层协议，但对HTTP协议的使用实际上存在着两种不同的方式：<strong>一种是RESTful的，它把HTTP当成应用层协议，比较忠实地遵守了HTTP协议的各种规定；另一种是SOA的，它并没有完全把HTTP当成应用层协议，而是把HTTP协议作为了传输层协议，</strong>然后在HTTP之上建立了自己的应用层协议。本文所讨论的HTTP幂等性主要针对RESTful风格的，不过正如上一节所看到的那样，幂等性并不属于特定的协议，它是分布式系统的一种特性；所以，不论是SOA还是RESTful的Web API设计都应该考虑幂等性。下面将介绍HTTP GET、DELETE、PUT、POST四种主要方法的语义和幂等性。</p><p><strong>HTTP GET方法用于获取资源，不应有副作用，所以是幂等的。</strong>比如：GET <code>http://www.bank.com/account/123456</code>，不会改变资源的状态，不论调用一次还是N次都没有副作用。请注意，这里强调的是一次和N次具有相同的副作用，而不是每次GET的结果相同。GET <code>http://www.news.com/latest-news</code>这个HTTP请求可能会每次得到不同的结果，但它本身并没有产生任何副作用，因而是满足幂等性的。</p><p><strong>HTTP DELETE方法用于删除资源，有副作用，但它应该满足幂等性。</strong>比如：DELETE <code>http://www.forum.com/article/4231</code>，调用一次和N次对系统产生的副作用是相同的，即删掉id为4231的帖子；因此，调用者可以多次调用或刷新页面而不必担心引起错误。</p><p>比较容易混淆的是HTTP POST和PUT。POST和PUT的区别容易被简单地误认为“POST表示创建资源，PUT表示更新资源”；而实际上，二者均可用于创建资源，更为本质的差别是在幂等性方面。在HTTP规范中对POST和PUT是这样定义的：</p><blockquote><p>The POST method is used to request that the origin server accept the entity enclosed in the request as a new subordinate of the resource identified by the Request-URI in the Request-Line …… If a resource has been created on the origin server, the response SHOULD be 201 (Created) and contain an entity which describes the status of the request and refers to the new resource, and a Location header.</p><p>The PUT method requests that the enclosed entity be stored under the supplied Request-URI. If the Request-URI refers to an already existing resource, the enclosed entity SHOULD be considered as a modified version of the one residing on the origin server. If the Request-URI does not point to an existing resource, and that URI is capable of being defined as a new resource by the requesting user agent, the origin server can create the resource with that URI.</p></blockquote><p><strong>POST所对应的URI并非创建的资源本身，而是资源的接收者。</strong>比如：POST <code>http://www.forum.com/articles</code>的语义是在<code>http://www.forum.com/articles</code>下创建一篇帖子，HTTP响应中应包含帖子的创建状态以及帖子的URI。两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI；所以，<strong>POST方法不具备幂等性</strong>。而PUT所对应的URI是要创建或更新的资源本身。比如：PUT<code>http://www.forum/articles/4231</code>的语义是创建或更新ID为4231的帖子。对同一URI进行多次PUT的副作用和一次PUT是相同的；因此，<strong>PUT方法具有幂等性。</strong></p><p><strong>在介绍了几种操作的语义和幂等性之后，我们来看看如何通过Web API的形式实现前面所提到的取款功能。很简单，用POST /tickets来实现create_ticket；用PUT /accounts/account_id/ticket_id?amount=xxx来实现idempotent_withdraw。值得注意的是严格来讲amount参数不应该作为URI的一部分，真正的URI应该是/accounts/account_id/ticket_id，而amount应该放在请求的body中。这种模式可以应用于很多场合，比如：论坛网站中防止意外的重复发帖。</strong></p><h2 id="如何防范-POST-重复提交"><a href="#如何防范-POST-重复提交" class="headerlink" title="如何防范 POST 重复提交"></a>如何防范 POST 重复提交</h2><p>HTTP POST 操作既不是安全的，也不是幂等的（至少在 HTTP 规范里没有保证）。当我们因为反复刷新浏览器导致多次提交表单，多次发出同样的 POST 请求，导致远端服务器重复创建出了资源。</p><p>为了避免这种情形，有以下几种解决方法：</p><ol><li>上述所说的幂等性设计；</li><li>PRG(Post/Redirect/Get模式)：服务器端收到 POST 请求，在操作成功后必须 302 跳转到另外一个页面，这样即使用户刷新页面，也不会重复提交表单。</li><li>用JavaScript的方式在客户端处理：表单提交之后，将提交按钮设置为不可用；</li><li>后端 WebService 一定要做到幂等性：<ol><li>使用Session设置令牌。客户端请求页面时，服务器为每次产生的Form表单分配唯一的随机标识号，并且在orm的一个隐藏字段中设置这个标识号，同时在当前用户的Session中保存这个标识号。当提交表单时，服务器比较hidden和session中的标识号是否相同，相同则继续，处理完后清空Session，否则服务器忽略请求。注意：恶意用户可利用这一性质，不断重复访问页面，以致Session中保存的标识号不断增多，最终严重消耗服务器内存。可以采用在Session中记录用户发帖的时间，然后通过一个时间间隔来限制用户连续发帖的数量来解决这一问题。</li><li>在数据库添加唯一字段。在数据库建表的时候在ID字段添加主键约束，账号，名称的信息添加唯一性约束。确保数据库只可以添加一条数据。</li></ol></li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://www.cnblogs.com/weidagang2046/archive/2011/06/04/idempotence.html">理解HTTP幂等性</a></li><li><a href="https://blog.csdn.net/qq_33945246/article/details/104613726">HTTP协议的补充（POST、GET请求方法、幂等性）</a></li><li><a href="https://juejin.cn/post/6968747879682801672">防止表单重复提交的解决方案整理</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> HTTP协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> HTTP协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>神经网络训练初体验: 房价预测比赛</title>
      <link href="/2022/01/12/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E8%AE%AD%E7%BB%83%E5%88%9D%E4%BD%93%E9%AA%8C-%E6%88%BF%E4%BB%B7%E9%A2%84%E6%B5%8B%E6%AF%94%E8%B5%9B/"/>
      <url>/2022/01/12/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E8%AE%AD%E7%BB%83%E5%88%9D%E4%BD%93%E9%AA%8C-%E6%88%BF%E4%BB%B7%E9%A2%84%E6%B5%8B%E6%AF%94%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文FROM《动手学深度学习》第四章第十节，链接详见<em>参考资料1</em></p></blockquote><h1 id="工作环境"><a href="#工作环境" class="headerlink" title="工作环境"></a>工作环境</h1><div class="table-container"><table><thead><tr><th>软件名称</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td>anaconda</td><td>Python环境和开源模块管理工具</td><td>默认</td></tr><tr><td>Python</td><td>开发语言</td><td>3.8</td></tr><tr><td>torch、torchvision</td><td>深度学习框架</td><td>默认</td></tr><tr><td>d2l</td><td>动手学深度学习官方模块</td><td>默认</td></tr><tr><td>VS Code</td><td>开发IDE</td><td>默认</td></tr></tbody></table></div><h1 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h1><p>创建项目文件夹<code>kaggle-house-prices</code>（自定义命名）以及<code>code</code>子文件夹，<code>code/</code>下创建Jupyter notebook，所有代码写在这里面。</p><p>生成的项目结构如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kaggle-house-prices/</span><br><span class="line">code/</span><br><span class="line">kaggle-house-prices.ipynb</span><br></pre></td></tr></table></figure><h1 id="下载数据集"><a href="#下载数据集" class="headerlink" title="下载数据集"></a>下载数据集</h1><p>数据集来自于Kaggle上的一个竞赛。网址：<a href="https://www.kaggle.com/c/house-prices-advanced-regression-techniques/data">https://www.kaggle.com/c/house-prices-advanced-regression-techniques/data</a></p><p>你可以直接从上面下载数据集；（包含训练集、测试集、数据描述和提交样例）</p><p>或者你可以使用书中的方式下载代码，这里我把完整的代码贴一下。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> tarfile</span><br><span class="line"><span class="keyword">import</span> zipfile</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个二元组包含数据集的url和验证文件完整性的sha-1密钥</span></span><br><span class="line">DATA_HUB = <span class="built_in">dict</span>()</span><br><span class="line">DATA_URL = <span class="string">&#x27;http://d2l-data.s3-accelerate.amazonaws.com/&#x27;</span></span><br><span class="line">DATA_HUB[<span class="string">&#x27;kaggle_house_train&#x27;</span>] = (</span><br><span class="line">    DATA_URL + <span class="string">&#x27;kaggle_house_pred_train.csv&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;585e9cc93e70b39160e7921475f9bcd7d31219ce&#x27;</span>)</span><br><span class="line"></span><br><span class="line">DATA_HUB[<span class="string">&#x27;kaggle_house_test&#x27;</span>] = (</span><br><span class="line">    DATA_URL + <span class="string">&#x27;kaggle_house_pred_test.csv&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;fa19780a7b011d9b009e8bff8e99922a8ee2eb90&#x27;</span>)</span><br><span class="line"></span><br><span class="line">DATA_URL = <span class="string">&#x27;http://d2l-data.s3-accelerate.amazonaws.com/&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">定义了一堆下载、解压的函数</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">download</span>(<span class="params">name, cache_dir=os.path.join(<span class="params"><span class="string">&#x27;..&#x27;</span>, <span class="string">&#x27;data&#x27;</span></span>)</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;下载一个DATA_HUB中的文件，返回本地文件名&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">assert</span> name <span class="keyword">in</span> DATA_HUB, <span class="string">f&quot;<span class="subst">&#123;name&#125;</span> 不存在于 <span class="subst">&#123;DATA_HUB&#125;</span>&quot;</span></span><br><span class="line">    url, sha1_hash = DATA_HUB[name]</span><br><span class="line">    os.makedirs(cache_dir, exist_ok=<span class="literal">True</span>)</span><br><span class="line">    fname = os.path.join(cache_dir, url.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">if</span> os.path.exists(fname):</span><br><span class="line">        sha1 = hashlib.sha1()</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(fname, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                data = f.read(<span class="number">1048576</span>)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                sha1.update(data)</span><br><span class="line">        <span class="keyword">if</span> sha1.hexdigest() == sha1_hash:</span><br><span class="line">            <span class="keyword">return</span> fname  <span class="comment"># 命中缓存</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;正在从<span class="subst">&#123;url&#125;</span>下载<span class="subst">&#123;fname&#125;</span>...&#x27;</span>)</span><br><span class="line">    r = requests.get(url, stream=<span class="literal">True</span>, verify=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(fname, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(r.content)</span><br><span class="line">    <span class="keyword">return</span> fname</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">download_extract</span>(<span class="params">name, folder=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;下载并解压zip/tar文件&quot;&quot;&quot;</span></span><br><span class="line">    fname = download(name)</span><br><span class="line">    base_dir = os.path.dirname(fname)</span><br><span class="line">    data_dir, ext = os.path.splitext(fname)</span><br><span class="line">    <span class="keyword">if</span> ext == <span class="string">&#x27;.zip&#x27;</span>:</span><br><span class="line">        fp = zipfile.ZipFile(fname, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> ext <span class="keyword">in</span> (<span class="string">&#x27;.tar&#x27;</span>, <span class="string">&#x27;.gz&#x27;</span>):</span><br><span class="line">        fp = tarfile.<span class="built_in">open</span>(fname, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">assert</span> <span class="literal">False</span>, <span class="string">&#x27;只有zip/tar文件可以被解压缩&#x27;</span></span><br><span class="line">    fp.extractall(base_dir)</span><br><span class="line">    <span class="keyword">return</span> os.path.join(base_dir, folder) <span class="keyword">if</span> folder <span class="keyword">else</span> data_dir</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">download_all</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;下载DATA_HUB中的所有文件&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> DATA_HUB:</span><br><span class="line">        download(name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载训练集和测试集</span></span><br><span class="line">download_all()</span><br></pre></td></tr></table></figure><pre><code>正在从http://d2l-data.s3-accelerate.amazonaws.com/kaggle_house_pred_train.csv下载..\data\kaggle_house_pred_train.csv...正在从http://d2l-data.s3-accelerate.amazonaws.com/kaggle_house_pred_test.csv下载..\data\kaggle_house_pred_test.csv...</code></pre><p>使用书中的代码下载的数据集存放在<code>../data/</code>中。结构目录如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kaggle-house-prices/</span><br><span class="line">code/</span><br><span class="line">kaggle-house-prices.ipynb</span><br><span class="line">    data/</span><br><span class="line">    kaggle_house_pred_train.csv</span><br><span class="line">    kaggle_house_pred_test.csv</span><br></pre></td></tr></table></figure><p>下面进行数据读取和预处理。</p><h1 id="读取数据集"><a href="#读取数据集" class="headerlink" title="读取数据集"></a>读取数据集</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果pandas没有被安装，请取消下一句的注释。</span></span><br><span class="line"><span class="comment"># !pip install pandas</span></span><br><span class="line"></span><br><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train_data = pd.read_csv(<span class="string">&quot;../data/kaggle_house_pred_train.csv&quot;</span>)</span><br><span class="line">test_data = pd.read_csv(<span class="string">&quot;../data/kaggle_house_pred_train.csv&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打印他们的行列数，这里test_data的列比train_data少1，少的是标签一列</span></span><br><span class="line"><span class="built_in">print</span>(train_data.shape)</span><br><span class="line"><span class="built_in">print</span>(test_data.shape)</span><br></pre></td></tr></table></figure><pre><code>(1460, 81)(1460, 81)</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># print train_data 两个参数分别指出打印的行（样本）和列（特征）</span></span><br><span class="line"><span class="built_in">print</span>(train_data.iloc[<span class="number">0</span>:<span class="number">4</span>, [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, -<span class="number">3</span>, -<span class="number">2</span>, -<span class="number">1</span>]])</span><br></pre></td></tr></table></figure><pre><code>   Id  MSSubClass MSZoning  LotFrontage SaleType SaleCondition  SalePrice0   1          60       RL         65.0       WD        Normal     2085001   2          20       RL         80.0       WD        Normal     1815002   3          60       RL         68.0       WD        Normal     2235003   4          70       RL         60.0       WD       Abnorml     140000</code></pre><p>将train_data和test_data去掉第一个特征（第一个特征是ID，对训练无意义）的所有特征都放到all_features中：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">all_features = pd.concat((train_data.iloc[:, <span class="number">1</span>:-<span class="number">1</span>], test_data.iloc[:, <span class="number">1</span>:]))</span><br></pre></td></tr></table></figure><h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><p>在开始建模之前，我们需要对数据进行预处理。</p><p>对于数字特征，首先，<strong>将所有缺失的值替换为相应特征的平均值；</strong></p><p>然后，为了将所有特征放在一个共同的尺度上，我们<strong>通过将特征重新缩放到零均值和单位方差来标准化数据</strong>：</p><script type="math/tex; mode=display">x \leftarrow \frac{x - \mu}{\sigma}.</script><p>此时，特征即具有零均值和单位方差，即 $E[\frac{x-\mu}{\sigma}] = \frac{\mu - \mu}{\sigma} = 0$和$E[(x-\mu)^2] = (\sigma^2 + \mu^2) - 2\mu^2+\mu^2 = \sigma^2$。</p><p>标准化数据有两个原因：</p><ul><li>方便优化；</li><li>我们不知道哪些特征是相关的，所以我们不想让惩罚分配给一个特征的系数比分配给其他任何特征的系数更大；</li><li>取消由于量纲不同、自身变异或者数值相差较大所引起的误差。</li></ul><p>更多关于标准化的知识请见<em>参考资料2</em></p><p>这里可以看到，书中提到的是先处理缺失值，再标准化；而实际代码是先标准化，再处理缺失值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 若无法获得测试数据，则可根据训练数据计算均值和标准差</span></span><br><span class="line"><span class="comment"># 取出数字类型的特征索引</span></span><br><span class="line">numeric_features = all_features.dtypes[all_features.dtypes != <span class="string">&#x27;object&#x27;</span>].index</span><br><span class="line"><span class="comment"># 将数字类型的特征标准化</span></span><br><span class="line">all_features[numeric_features] = all_features[numeric_features].apply(</span><br><span class="line">    <span class="keyword">lambda</span> x: (x - x.mean()) / (x.std()))</span><br><span class="line"><span class="comment"># 在标准化数据之后，所有均值消失，因此我们可以将缺失值设置为0</span></span><br><span class="line">all_features[numeric_features] = all_features[numeric_features].fillna(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>对于离散值，我们使用one-hot编码，就是特征的离散值转换为向量。例如，特征“type”的值包括cat，dog，rat，那么经过one-hot编码后会生成三个特征“type_cat”，“type_dog”，“type_rat”。如果原来“type”=cat，则“type_cat”=1，“type_dog”=0，“type_rat”=0。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># “Dummy_na=True”将“na”（缺失值）视为有效的特征值，并为其创建指示符特征</span></span><br><span class="line">all_features = pd.get_dummies(all_features, dummy_na=<span class="literal">True</span>)</span><br><span class="line">all_features.shape</span><br></pre></td></tr></table></figure><pre><code>(2920, 332)</code></pre><p>可以看到，此转换会将特征的总数量从79个增加到331个。 最后，通过values属性，我们可以 从pandas格式中提取NumPy格式，并将其转换为张量表示用于训练。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n_train = train_data.shape[<span class="number">0</span>]  <span class="comment"># 取得train_data的行数</span></span><br><span class="line"><span class="comment"># 取出all_features的train_data转换成tensor</span></span><br><span class="line">train_features = torch.tensor(all_features[:n_train].values, dtype=torch.float32)</span><br><span class="line"><span class="comment"># 取出all_features的test_data转换成tensor</span></span><br><span class="line">test_features = torch.tensor(all_features[n_train:].values, dtype=torch.float32)</span><br><span class="line"><span class="comment"># train_labels.shape[0] == n_train</span></span><br><span class="line"><span class="comment"># reshape(-1, 1)相当于把labels一行转为一列和train_features一一对应</span></span><br><span class="line">train_labels = torch.tensor(</span><br><span class="line">    train_data.SalePrice.values.reshape(-<span class="number">1</span>, <span class="number">1</span>), dtype=torch.float32)</span><br></pre></td></tr></table></figure><h1 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h1><p>首先，我们训练一个带有损失平方的线性模型。如果一切顺利，线性模型将作为基线（baseline）模型， 让我们直观地知道最好的模型有超出简单的模型多少。</p><p>损失函数：MSE Loss</p><p>基线模型：（个人理解）最先想到的、最简单的、结果比较差、一般在此基础上进行优化的模型。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">loss = nn.MSELoss()</span><br><span class="line">in_features = train_features.shape[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_net</span>():</span><br><span class="line">    net = nn.Sequential(nn.Linear(in_features,<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> net</span><br></pre></td></tr></table></figure><p>对于房价，就像股票价格一样，我们关心的是相对数量，而不是绝对数量。因此，[<strong>我们更关心相对误差$\frac{y - \hat{y}}{y}$，</strong>]而不是绝对误差$y - \hat{y}$。例如，如果我们在俄亥俄州农村地区估计一栋房子的价格时，我们的预测偏差了10万美元，在那里一栋典型的房子的价值是12.5万美元，那么我们可能做得很糟糕。另一方面，如果我们在加州豪宅区的预测出现了这个数字的偏差，这可能是一个惊人的准确预测（在那里，房价均值超过400万美元）。</p><p>(<strong>解决这个问题的一种方法是用价格预测的对数来衡量差异</strong>)。事实上，这也是比赛中官方用来评价提交质量的误差指标。即将 $\delta$ for $|\log y - \log \hat{y}| \leq \delta$转换为$e^{-\delta} \leq \frac{\hat{y}}{y} \leq e^\delta$。这使得预测价格的对数与真实标签价格的对数之间出现以下均方根误差：</p><script type="math/tex; mode=display">\sqrt{\frac{1}{n}\sum_{i=1}^n\left(\log y_i -\log \hat{y}_i\right)^2}.</script><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">log_rmse</span>(<span class="params">net, features, labels</span>):</span><br><span class="line">    <span class="comment"># 为了在取对数时进一步稳定该值，将小于1的值设置为1</span></span><br><span class="line">    <span class="comment"># clamp方法说明详见 参考资料5</span></span><br><span class="line">    clipped_preds = torch.clamp(net(features), <span class="number">1</span>, <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>))</span><br><span class="line">    rmse = torch.sqrt(loss(torch.log(clipped_preds),</span><br><span class="line">                           torch.log(labels)))</span><br><span class="line">    <span class="keyword">return</span> rmse.item()</span><br></pre></td></tr></table></figure><blockquote><p>在这里，我一开始对损失函数（loss）和评价指标（metrics）没有理解，所以我对loss和log_rmse纠结了很久。</p><p>这里我的理解是，</p><p>loss是需要丢到网络里的，是网络优化的目标函数；因为需要通过梯度下降来反向传播，所以必须是可导的；</p><p>metrics是评价网络的一种指标，不参与优化；不需要可导。</p><p>更多关于损失函数和评价指标请参见<em>参考资料3</em>，<em>参考资料4</em></p></blockquote><hr><p>我们的训练函数将借助Adam优化器。</p><p>Adam优化器的主要吸引力在于它对初始学习率不那么敏感。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">net, train_features, train_labels, test_features, test_labels,</span></span><br><span class="line"><span class="params">          num_epochs, learning_rate, weight_decay, batch_size</span>):</span><br><span class="line">    train_ls, test_ls = [], []</span><br><span class="line">    train_iter = d2l.load_array((train_features, train_labels), batch_size)</span><br><span class="line">    <span class="comment"># 这里使用的是Adam优化算法</span></span><br><span class="line">    optimizer = torch.optim.Adam(net.parameters(),</span><br><span class="line">                                 lr = learning_rate,</span><br><span class="line">                                 weight_decay = weight_decay)</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">        <span class="keyword">for</span> X, y <span class="keyword">in</span> train_iter:</span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            l = loss(net(X), y)</span><br><span class="line">            l.backward()</span><br><span class="line">            optimizer.step()</span><br><span class="line">        train_ls.append(log_rmse(net, train_features, train_labels))</span><br><span class="line">        <span class="keyword">if</span> test_labels <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            test_ls.append(log_rmse(net, test_features, test_labels))</span><br><span class="line">    <span class="keyword">return</span> train_ls, test_ls</span><br></pre></td></tr></table></figure><h1 id="K-折交叉验证"><a href="#K-折交叉验证" class="headerlink" title="K-折交叉验证"></a>K-折交叉验证</h1><p>所谓K-折交叉验证就是把train data分为K份，每次1/K份作为验证集，把另外的1 - 1/K份作为训练集。事实上，<code>get_k_fold_data</code>就是在做这件事。</p><p>K-折交叉验证有助于模型选择和超参数调整。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_k_fold_data</span>(<span class="params">k, i, X, y</span>):</span><br><span class="line">    <span class="keyword">assert</span> k &gt; <span class="number">1</span></span><br><span class="line">    fold_size = X.shape[<span class="number">0</span>] // k</span><br><span class="line">    X_train, y_train = <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">        <span class="comment"># slice方法说明详见参考资料6</span></span><br><span class="line">        idx = <span class="built_in">slice</span>(j * fold_size, (j + <span class="number">1</span>) * fold_size)</span><br><span class="line">        X_part, y_part = X[idx, :], y[idx]</span><br><span class="line">        <span class="keyword">if</span> j == i:</span><br><span class="line">            X_valid, y_valid = X_part, y_part</span><br><span class="line">        <span class="keyword">elif</span> X_train <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            X_train, y_train = X_part, y_part</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            X_train = torch.cat([X_train, X_part], <span class="number">0</span>) <span class="comment"># 将已有的X_train和X_part连接起来</span></span><br><span class="line">            y_train = torch.cat([y_train, y_part], <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> X_train, y_train, X_valid, y_valid</span><br></pre></td></tr></table></figure><p><code>k_fold</code>中先求每一折得到的trian-loss, valid-loss，注意train_ls和valid_ls是一个list，存放了每次迭代后loss值，我们取train_ls[-1]，也就是最终的那个loss</p><p>最后把所有K-折得到的train-loss的平均和valid-loss的平均</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">k_fold</span>(<span class="params">k, X_train, y_train, num_epochs, learning_rate, weight_decay,</span></span><br><span class="line"><span class="params">           batch_size</span>):</span><br><span class="line">    train_l_sum, valid_l_sum = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">        <span class="comment"># 这里data实际是一个元组(X_train, y_train, X_valid, y_valid)</span></span><br><span class="line">        data = get_k_fold_data(k, i, X_train, y_train)</span><br><span class="line">        net = get_net()</span><br><span class="line">        <span class="comment"># 把data这个元组传入，对应train中的train_features, train_labels, test_features, test_labels四个参数</span></span><br><span class="line">        train_ls, valid_ls = train(net, *data, num_epochs, learning_rate,</span><br><span class="line">                                   weight_decay, batch_size)</span><br><span class="line">        train_l_sum += train_ls[-<span class="number">1</span>]</span><br><span class="line">        valid_l_sum += valid_ls[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">            d2l.plot(<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, num_epochs + <span class="number">1</span>)), [train_ls, valid_ls],</span><br><span class="line">                     xlabel=<span class="string">&#x27;epoch&#x27;</span>, ylabel=<span class="string">&#x27;rmse&#x27;</span>, xlim=[<span class="number">1</span>, num_epochs],</span><br><span class="line">                     legend=[<span class="string">&#x27;train&#x27;</span>, <span class="string">&#x27;valid&#x27;</span>], yscale=<span class="string">&#x27;log&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;折<span class="subst">&#123;i + <span class="number">1</span>&#125;</span>，训练log rmse<span class="subst">&#123;<span class="built_in">float</span>(train_ls[-<span class="number">1</span>]):f&#125;</span>, &#x27;</span></span><br><span class="line">              <span class="string">f&#x27;验证log rmse<span class="subst">&#123;<span class="built_in">float</span>(valid_ls[-<span class="number">1</span>]):f&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> train_l_sum / k, valid_l_sum / k</span><br></pre></td></tr></table></figure><h1 id="模型选择"><a href="#模型选择" class="headerlink" title="模型选择"></a>模型选择</h1><p>下面是一组超参数，后面我们可以对此进行调优（改改数， run run code）</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">k, num_epochs, lr, weight_decay, batch_size = <span class="number">5</span>, <span class="number">100</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">64</span></span><br><span class="line">train_l, valid_l = k_fold(k, train_features, train_labels, num_epochs, lr,</span><br><span class="line">                          weight_decay, batch_size)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;k&#125;</span>-折验证: 平均训练log rmse: <span class="subst">&#123;<span class="built_in">float</span>(train_l):f&#125;</span>, &#x27;</span></span><br><span class="line">      <span class="string">f&#x27;平均验证log rmse: <span class="subst">&#123;<span class="built_in">float</span>(valid_l):f&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>折1，训练log rmse0.168934, 验证log rmse0.158768折2，训练log rmse0.162051, 验证log rmse0.186553折3，训练log rmse0.163633, 验证log rmse0.167966折4，训练log rmse0.167716, 验证log rmse0.154111折5，训练log rmse0.161381, 验证log rmse0.1841885-折验证: 平均训练log rmse: 0.164743, 平均验证log rmse: 0.170317</code></pre><p><img src="kaggle-house-prices_31_1.svg" alt="svg"></p><p>请注意，有时一组超参数的训练误差可能非常低，但 K 折交叉验证的误差要高得多， 这表明模型过拟合了。 在整个训练过程中，你将希望监控训练误差和验证误差这两个数字。 较少的过拟合可能表明现有数据可以支撑一个更强大的模型， 较大的过拟合可能意味着我们可以通过正则化技术来获益。</p><h1 id="提交Kaggle预测"><a href="#提交Kaggle预测" class="headerlink" title="提交Kaggle预测"></a>提交Kaggle预测</h1><p>当我们用上面的K-折交叉验证确定参数后，我们将超参数固定住，把所有的train data拿来train。</p><p>如果测试集上的预测与 K 倍交叉验证过程中的预测相似， 那就是时候把它们上传到Kaggle了。 下面的代码将生成一个名为submission.csv的文件。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">train_and_pred</span>(<span class="params">train_features, test_feature, train_labels, test_data,</span></span><br><span class="line"><span class="params">                   num_epochs, lr, weight_decay, batch_size</span>):</span><br><span class="line">    net = get_net()</span><br><span class="line">    train_ls, _ = train(net, train_features, train_labels, <span class="literal">None</span>, <span class="literal">None</span>,</span><br><span class="line">                        num_epochs, lr, weight_decay, batch_size)</span><br><span class="line">    d2l.plot(np.arange(<span class="number">1</span>, num_epochs + <span class="number">1</span>), [train_ls], xlabel=<span class="string">&#x27;epoch&#x27;</span>,</span><br><span class="line">             ylabel=<span class="string">&#x27;log rmse&#x27;</span>, xlim=[<span class="number">1</span>, num_epochs], yscale=<span class="string">&#x27;log&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;训练log rmse：<span class="subst">&#123;<span class="built_in">float</span>(train_ls[-<span class="number">1</span>]):f&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="comment"># 将网络应用于测试集。</span></span><br><span class="line">    preds = net(test_features).detach().numpy()</span><br><span class="line">    <span class="comment"># 将其重新格式化以导出到Kaggle</span></span><br><span class="line">    test_data[<span class="string">&#x27;SalePrice&#x27;</span>] = pd.Series(preds.reshape(<span class="number">1</span>, -<span class="number">1</span>)[<span class="number">0</span>])</span><br><span class="line">    submission = pd.concat([test_data[<span class="string">&#x27;Id&#x27;</span>], test_data[<span class="string">&#x27;SalePrice&#x27;</span>]], axis=<span class="number">1</span>)</span><br><span class="line">    submission.to_csv(<span class="string">&#x27;submission.csv&#x27;</span>, index=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">train_and_pred(train_features, test_features, train_labels, test_data,</span><br><span class="line">               num_epochs, lr, weight_decay, batch_size)</span><br></pre></td></tr></table></figure><pre><code>训练log rmse：0.162150</code></pre><p><img src="kaggle-house-prices_34_1.svg" alt="svg"></p><p>接下来我们将生成的<code>submission.csv</code>文件提交到Kaggle：</p><ul><li>访问<a href="https://www.kaggle.com/c/house-prices-advanced-regression-techniques/data">https://www.kaggle.com/c/house-prices-advanced-regression-techniques/data</a></li><li>点击“Submit Predictions”</li><li>选择你要上传的预测文件<code>submission.csv</code></li><li>点击页面底部的“Make Submission”按钮，即可查看结果。</li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul><li>真实数据通常混合了不同的数据类型，需要进行预处理。</li><li>常用的预处理方法：将实值数据重新缩放为零均值和单位方法；用均值替换缺失值。</li><li>将类别特征转化为指标特征，可以使我们把这个特征当作一个独热向量来对待。</li><li>我们可以使用 K 折交叉验证来选择模型并调整超参数。</li><li>对数对于相对误差很有用。</li></ul><h1 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h1><p>这里是书中给出的一些思考问题，我没做，但是依然列出来供参考：</p><ol><li>将试图预测价格改为试图预测价格的对数，会发生什么？</li><li>用平均值替换缺失值总是好主意吗？提示：你能构造一个不随机丢失值的情况吗？</li><li>通过 K 折交叉验证调整超参数，从而提高Kaggle的得分。</li><li>通过改进模型（例如，层、权重衰减和dropout）来提高分数。</li><li>如果我们没有像本节所做的那样标准化连续的数值特征，会发生什么？</li></ol><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>我仔细阅读原文，捋了一边代码。</p><p>基础比较差，有些地方认识不太清晰，全凭自己理解，如有错误，请多包涵，或直接邮箱联系我。</p><p>我原以为会有训练模型错误率不断降低的成就感。。但实际上全是复制粘贴run code。</p><p>好像学到了又好像没学到。🤦‍</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="http://zh-v2.d2l.ai/chapter_multilayer-perceptrons/kaggle-house-price.html#id6">《动手学深度学习》 4.10. 实战Kaggle比赛：预测房价</a></li><li><a href="https://www.cnblogs.com/wangqiang9/p/9285594.html">数据预处理之中心化（零均值化）与标准化（归一化）</a></li><li><a href="https://zhuanlan.zhihu.com/p/373032887">机器学习——损失函数(loss)与评价指标(metric)的区别？</a></li><li><a href="https://codeantenna.com/a/7p6uOqnNhx">keras中compile方法的 loss 和 metrics 区别</a></li><li><a href="https://pytorch.org/docs/stable/generated/torch.clamp.html">torch.clamp方法说明</a></li><li><a href="https://www.runoob.com/python/python-func-slice.html">Python slice方法说明</a></li><li><a href="https://blog.csdn.net/m0_37871195/article/details/79829488">深度学习中iteration、epoch、batchsize的定义</a></li><li><a href="https://pytorch.org/docs/1.9.1/generated/torch.Tensor.detach.html">torch.detach方法说明</a></li><li><a href="https://pytorch.org/docs/stable/generated/torch.cat.html#torch.cat">torch.cat方法说明</a></li><li><a href="https://csbwang.github.io/dl_ch2">机器学习基础</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
          <category> 动手学深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《动手学深度学习》读书笔记（一） 前言</title>
      <link href="/2022/01/10/%E3%80%8A%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89-%E5%89%8D%E8%A8%80/"/>
      <url>/2022/01/10/%E3%80%8A%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89-%E5%89%8D%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<p><em>本博客记录阅读《动手学深度学习》的读书笔记。</em></p><blockquote><p>原文地址：<a href="http://zh-v2.d2l.ai/chapter_introduction/index.html">http://zh-v2.d2l.ai/chapter_introduction/index.html</a></p></blockquote><h1 id="日常生活中的机器学习"><a href="#日常生活中的机器学习" class="headerlink" title="日常生活中的机器学习"></a>日常生活中的机器学习</h1><p>我们可以把<strong>参数</strong>看作旋钮，我们可以转动旋钮来调整程序的行为。</p><p>任一调整参数后的程序，我们称为<strong>模型</strong>（model）。</p><p>通过操作参数而生成的所有不同程序（输入-输出映射）的集合称为“<strong>模型族</strong>”。</p><p>使用数据集来选择参数的元程序被称为<strong>学习算法</strong>（learning algorithm）。</p><p>在我们开始用机器学习算法解决问题之前，我们必须精确地定义问题，确定<strong>输入（input）和输出（output）</strong>的性质，并选择合适的模型族。</p><p>在机器学习中，<strong>学习</strong>（learning）是一个训练模型的过程。 通过这个过程，我们可以发现正确的参数集，从而使模型强制执行所需的行为。 换句话说，我们用数据<strong>训练</strong>（train）我们的模型。 </p><p>训练过程通常包含如下步骤：</p><ol><li>从一个随机初始化参数的模型开始，这个模型基本毫不“智能”。</li><li>获取一些数据样本（例如，音频片段以及对应的{是,否}标签）。</li><li>调整参数，使模型在这些样本中表现得更好。</li><li>重复第2步和第3步，直到模型在任务中的表现令你满意。</li></ol><p><img src="ml-loop.png" alt="典型的训练过程"></p><h1 id="关键组件"><a href="#关键组件" class="headerlink" title="关键组件"></a>关键组件</h1><p>无论我们遇到什么类型的机器学习问题，这些组件都将伴随我们左右：</p><ol><li>我们可以学习的<strong>数据</strong>（data）。</li><li>如何转换数据的<strong>模型</strong>（model）。</li><li>一个<strong>目标函数</strong>（objective function），用来量化模型的有效性。</li><li>调整模型参数以优化目标函数的<strong>算法</strong>（algorithm）。</li></ol><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p>每个数据集由一个个<strong>样本</strong>（example, sample）组成，大多时候，它们遵循独立同分布(independently and identically distributed, i.i.d.)。 样本有时也叫做<strong>数据点</strong>（data point）或者<strong>数据实例</strong>（data instance），通常每个样本由一组称为<strong>特征</strong>（features，或<strong>协变量</strong>（covariates））的属性组成。 机器学习模型会根据这些属性进行预测。 </p><p><strong>标签</strong>：预测的一个特殊属性，例如是/否，猫/狗等。</p><p>当每个样本的特征类别数量都是相同的时候，其特征向量是固定长度的，这个长度被称为数据的维数（dimensionality）。 固定长度的特征向量是一个方便的属性，它有助于我们量化学习大量样本。</p><p>然而，并不是所有的数据都可以用“固定长度”的向量表示。例如不同的图片大小，文本长度。与传统机器学习方法相比，深度学习的一个主要优势是可以处理不同长度的数据。</p><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><h2 id="目标函数"><a href="#目标函数" class="headerlink" title="目标函数"></a>目标函数</h2><p>在机器学习中，我们需要定义模型的优劣程度的度量，这个度量在大多数情况是“可优化”的，我们称之为<strong>目标函数</strong>（objective function）。 我们通常定义一个目标函数，并希望优化它到最低点。 因为越低越好，所以这些函数有时被称为<strong>损失函数</strong>（loss function，或cost function）。</p><p>当任务在试图预测数值时，最常见的损失函数是<strong>平方误差</strong>（squared error），即预测值与实际值之差的平方。 当试图解决分类问题时，最常见的目标函数是最小化错误率，即预测与实际情况不符的样本比例。 有些目标函数（如平方误差）很容易被优化，有些目标（如错误率）由于不可微性或其他复杂性难以直接优化。 在这些情况下，通常会优化替代目标。</p><p> 在一个数据集上，我们通过最小化总损失来学习模型参数的最佳值。 该数据集由一些为训练而收集的样本组成，称为<strong>训练数据集</strong>（training dataset，或称为训练集（training set））。 然而，在训练数据上表现良好的模型，并不一定在“新数据集”上有同样的效能，这里的“新数据集”通常称为测试数据集（test dataset，或称为<strong>测试集</strong>（test set））。</p><p>综上所述，我们通常将可用数据集分成两部分：<strong>训练数据集用于拟合模型参数，测试数据集用于评估拟合的模型。</strong> 然后我们观察模型在这两部分数据集的效能。 你可以把“一个模型在训练数据集上的效能”想象成“一个学生在模拟考试中的分数”。 这个分数用来为一些真正的期末考试做参考，即使成绩令人鼓舞，也不能保证期末考试成功。 换言之，测试性能可能会显著偏离训练性能。 当一个模型在训练集上表现良好，但不能推广到测试集时，我们说这个模型是“<strong>过拟合</strong>”（overfitting）的。</p><h2 id="优化算法"><a href="#优化算法" class="headerlink" title="优化算法"></a>优化算法</h2><p>一旦我们获得了一些数据源及其表示、一个模型和一个合适的损失函数，我们接下来就需要一种算法，它能够搜索出最佳参数，以最小化损失函数。 深度学习中，大多流行的优化算法通常基于一种基本方法–<strong>梯度下降</strong>（gradient descent）。 简而言之，在每个步骤中，梯度下降法都会检查每个参数，看看如果你仅对该参数进行少量变动，训练集损失会朝哪个方向移动。 然后，它在可以减少损失的方向上优化参数。</p><h1 id="各种机器学习问题"><a href="#各种机器学习问题" class="headerlink" title="各种机器学习问题"></a>各种机器学习问题</h1><h2 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h2><p>监督学习（supervised learning）擅长在“<strong>给定输入特征</strong>”的情况下预测标签。</p><p>监督学习举例：根据计算机断层扫描（CT）肿瘤图像，预测是否为癌症；根据本月的财务报告数据，预测下个月股票的价格。</p><p>在工业中，大部分机器学习的成功应用都是监督学习。 这是因为在一定程度上，许多重要的任务可以清晰地描述为：在给定一组特定的可用数据的情况下，估计未知事物的概率。</p><p><img src="supervised-learning.png" alt="监督学习"></p><h3 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h3><p>回归（regression）是最简单的监督学习任务之一。</p><p>当标签取任意数值时，我们称之为回归问题。 我们的目标是生成一个模型，它的预测非常接近实际标签值。</p><p>回归问题举例：预测房价；预测用户对一部电影的评分。</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>二分类，多分类。</p><p>分类可能变得比二元分类、多元分类复杂得多。 例如，有一些分类任务的变体可以用于寻找层次结构，层次结构假定在许多类之间存在某种关系。因此，并不是所有的错误都是均等的。 我们宁愿错误地分入一个相关的类别，也不愿错误地分入一个遥远的类别，这通常被称为<strong>层次分类</strong>(hierarchical classification)。</p><h3 id="标记问题"><a href="#标记问题" class="headerlink" title="标记问题"></a>标记问题</h3><p>学习预测不相互排斥的类别的问题称为<strong>多标签分类</strong>（multi-label classification）。</p><p> 举个例子，人们在技术博客上贴的标签，比如“机器学习”、“技术”、“小工具”、“编程语言”、“Linux”、“云计算”。 一篇典型的文章可能会用5-10个标签，因为这些概念是相互关联的。</p><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>在信息检索领域，我们希望对一组项目进行排序。 以网络搜索为例，我们的目标不是简单的“查询（query）-网页（page）”分类，而是在海量搜索结果中找到用户最需要的那部分。</p><h3 id="推荐系统"><a href="#推荐系统" class="headerlink" title="推荐系统"></a>推荐系统</h3><h3 id="序列学习"><a href="#序列学习" class="headerlink" title="序列学习"></a>序列学习</h3><p>有些时候，输入是连续的。我们的模型可能就需要拥有“记忆”功能。</p><p>比如文字序列，图像序列（视频）</p><p>以下是序列学习的特殊情况：</p><ul><li><strong>标记和解析</strong></li><li><strong>语音识别</strong></li><li><strong>文本到语音</strong></li><li><strong>机器翻译</strong></li></ul><h2 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h2><p> 比如，你的老板可能会给你一大堆数据，然后让你用它做一些数据科学研究，却没有对结果有要求。 我们称这类数据中不含有“目标”的机器学习问题为<strong>无监督学习</strong>（unsupervised learning）</p><p>以下列举了集中无监督学习：</p><ul><li><strong>聚类</strong>（clustering）问题：没有标签的情况下，我们是否能给数据分类</li><li><strong>主成分分析</strong>（principal component analysis）问题：我们能否找到少量的参数来准确地捕捉数据的线性相关属性？比如，一个球的运动轨迹可以用球的速度、直径和质量来描述。</li><li><strong>因果关系</strong>（causality）和概率图模型（probabilistic graphical models）问题：我们能否描述观察到的许多数据的根本原因？</li><li><strong>生成对抗性网络</strong>（generative adversarial networks）：为我们提供一种合成数据的方法，甚至像图像和音频这样复杂的结构化数据。</li></ul><h3 id="与环境互动"><a href="#与环境互动" class="headerlink" title="与环境互动"></a>与环境互动</h3><p>到目前为止，不管是监督学习还是无监督学习，我们都会预先获取大量数据，然后启动模型，不再与环境交互。 这里所有学习都是在算法与环境断开后进行的，被称为<strong>离线学习</strong>（offline learning）。</p><p>这种简单的离线学习有它的魅力。 好的一面是，我们可以孤立地进行模式识别，而不必分心于其他问题。 但缺点是，解决的问题相当有限。 与预测不同，“与真实环境互动”实际上会影响环境。 这里的人工智能是“智能代理”，而不仅是“预测模型”。 因此，我们必须考虑到它的行为可能会影响未来的观察结果。</p><p>考虑“与真实环境互动”将打开一整套新的建模问题。以下只是几个例子：</p><ul><li>环境还记得我们以前做过什么吗？</li><li>环境是否有助于我们建模？例如，用户将文本读入语音识别器。</li><li>环境是否想要打败模型？例如，一个对抗性的设置，如垃圾邮件过滤或玩游戏？</li><li>环境是否重要？</li><li>环境是否变化？例如，未来的数据是否总是与过去相似，还是随着时间的推移会发生变化？是自然变化还是响应我们的自动化工具而发生变化？</li></ul><p>当训练和测试数据不同时，最后一个问题提出了<strong>分布偏移</strong>（distribution shift）的问题。 接下来，我们将简要描述强化学习问题，这是一类明确考虑与环境交互的问题。</p><h3 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h3><p><em>不是太懂</em></p><p>在强化学习问题中，agent在一系列的时间步骤上与环境交互。 在每个特定时间点，agent从环境接收一些观察（observation），并且必须选择一个动作（action），然后通过某种机制（有时称为执行器）将其传输回环境，最后agent从环境中获得奖励（reward）。 此后新一轮循环开始，agent接收后续观察，并选择后续操作，依此类推。</p><p><img src="rl-environment.png" alt="强化学习"></p><p>强化学习框架的通用性十分强大。 例如，我们可以将任何监督学习问题转化为强化学习问题。</p><p>当然，强化学习还可以解决许多监督学习无法解决的问题。 例如，在监督学习中，我们总是希望<strong>输入与正确的标签相关联</strong>。 但在强化学习中，我们<strong>并不假设环境告诉agent每个观测的最优动作</strong>。 一般来说，agent只是得到一些奖励。 此外，环境甚至可能不会告诉我们是哪些行为导致了奖励。</p><p>强化学习可能还必须处理部分可观测性问题。 也就是说，当前的观察结果可能无法阐述有关当前状态的所有信息。 比方说，一个清洁机器人发现自己被困在一个许多相同的壁橱的房子里。 推断机器人的精确位置（从而推断其状态），需要在进入壁橱之前考虑它之前的观察结果。</p><p>最后，在任何时间点上，强化学习agent可能知道一个好的策略，但可能有许多更好的策略从未尝试过的。 强化学习agent必须不断地做出选择：是应该利用当前最好的策略，还是探索新的策略空间（放弃一些短期回报来换取知识）。</p><p>一般的强化学习问题是一个非常普遍的问题。 agent的动作会影响后续的观察，而奖励只与所选的动作相对应。 环境可以是完整观察到的，也可以是部分观察到的，解释所有这些复杂性可能会对研究人员要求太高。 此外，并不是每个实际问题都表现出所有这些复杂性。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
          <category> 动手学深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Scrapy的网络爬虫案例</title>
      <link href="/2022/01/09/%E5%9F%BA%E4%BA%8EScrapy%E7%9A%84%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E6%A1%88%E4%BE%8B/"/>
      <url>/2022/01/09/%E5%9F%BA%E4%BA%8EScrapy%E7%9A%84%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这是在公司实习时，领导给出的一个数据爬取需求。（所以涉及法律问题请找公司的麻烦，不要联系我😂）</p><p>虽然我之前也干过网络爬虫，但都是在比较完整的框架下进行实现：以前只需要实现URL解析和网页源码抽取接口，其他像网络爬虫配置，数据存储，数据抽取，数据导出，任务启动和停止等模块只需要鼠标click一下或者根本就是“黑盒”的，不需要我操心。。</p><p>这一次，我基本是从“0”开始。所以在完成任务的过程中学到了很多。（当然也还不够多）</p><p>由于爬取的网站是一个经典的“列表-详情”结构，且爬取难度不难（网站没有设置反爬），作为爬虫初学者很合适，所以我把该任务的实现过程记录下来，方便自己学习。</p><p>本篇博客将记录我在实现该任务时，学到的知识、遇到的困难、对应的解决方案。</p><p>通过阅读本篇博客你将获得</p><ul><li>使用Scrapy进行简单的网页数据爬取</li><li>使用BeautifulSoup解析HTML</li><li>使用Pandas做简单的数据读取、去重、分析操作</li></ul><p>不能获得：</p><ul><li>Scrapy高级使用、框架结构、底层原理</li><li>破解数据采集时遇到的反爬</li></ul><p>废话比较多。先来看一下阅读本文需要的前置知识。</p><h1 id="阅读本文需要的前置知识"><a href="#阅读本文需要的前置知识" class="headerlink" title="阅读本文需要的前置知识"></a>阅读本文需要的前置知识</h1><p>阅读本篇博客需要一定的前置知识。我将列举一些，可能不全。</p><ul><li>网络爬虫：什么是网络爬虫</li><li>//Conda：什么是Conda，Conda安装、环境创建等</li><li>Python 基础：基础数据结构及操作、文件I/O操作</li><li>PyCharm使用：如何配置开发环境，连接远程环境进行开发等</li><li>//Linux 服务器基本命令</li><li>HTML基础、CSS选择器等前端基础知识。</li><li>XPath数据定位、正则表达式匹配等知识。</li></ul><p>如果你有以上基础，那么阅读本篇博客基本没有障碍。</p><p>下面介绍我的工作环境。</p><h1 id="工作环境"><a href="#工作环境" class="headerlink" title="工作环境"></a>工作环境</h1><div class="table-container"><table><thead><tr><th>软件名称</th><th>备注</th><th>版本</th></tr></thead><tbody><tr><td>Windows</td><td>操作系统</td><td>10</td></tr><tr><td>PyCharm</td><td>开发IDE</td><td>2019.3.5</td></tr><tr><td>Ananconda</td><td>Python环境管理和包管理工具</td><td>懒得写了</td></tr><tr><td>Scrapy</td><td>Python开源模块，爬虫框架</td><td>懒得写了</td></tr><tr><td>BeautifulSoup</td><td>Python开源模块，解析HTML</td><td>懒得写了</td></tr><tr><td>Pandas</td><td>Python开源模块，这里用它做简单的数据提取</td><td>懒得写了</td></tr></tbody></table></div><p>下面介绍具体需求。</p><h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>爬取网站 <a href="https://www.yunyubaike.com/">孕育百科</a> 各分类下的孕育问答。结果以CSV格式给出。</p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>打开 <a href="https://www.yunyubaike.com/">孕育百科</a> 可以看到有很多孕育百科的分类，选择一个分类，比如，这里我们选择【准备怀孕】。</p><p><img src="image-20220107161453957.png" alt="分类"></p><p>新打开的网页为<a href="https://www.yunyubaike.com/beiyun/">https://www.yunyubaike.com/beiyun/</a></p><p>可以看到这里有一些子分类：</p><p><img src="image-20220107162138428.png" alt="分类和子分类"></p><p>这些分类和子分类下有很多孕育百科问答，我们点击一个问题的超链接，在弹出的详情页中给出问题的答案，如图：</p><p><img src="image-20220107162808046.png" alt="孕育百科-详情页"></p><p>把这些问题和答案“抽取”到到CSV文件中，作为最终结果。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先我们需要分析该网站，例如网站数据量大小，网站网页结构，网站跳转方式，数据传输方式，数据是否加密，网站反爬严不严重等等。</p><p>可以抓包、写网页下载代码测试一下。</p><p>据此指定网站采集策略，是使用本地IP就可以采集还是需要设置一批代理IP，数据文件是存放到本地还是需要存放到Hadoop，是否需要可视化（Selenium）采集等等。</p><h2 id="采集策略"><a href="#采集策略" class="headerlink" title="采集策略"></a>采集策略</h2><ol><li>先采集分类（首页）URL；</li><li>根据分类（首页）URL不断循环生成分页（列表页）；</li><li>爬取每个列表页中的详情URL；</li><li>下载详情URL的HTML文件，保存到本地；</li><li>解析本地HTML，生成CSV文件。</li></ol><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="采集分类"><a href="#采集分类" class="headerlink" title="采集分类"></a>采集分类</h2><p>仔细分析网站可以发现，在采集分类存在两个坑。</p><ul><li>不是所有分类都是孕育百科：对于不是分类的URL可以直接丢弃。</li><li>子分类下和分类存在重复：去重。</li></ul><p>由于子分类和分类不是很多，这里使用的手工采集。</p><p>虽说手工采集，但还是需要一点小小的技巧。这里不是挨个复制网页源码中的分类连接，而是通过Chrome的一个插件<a href="https://chrome.google.com/webstore/detail/xpath-helper/hgimnogjllphhhkhlmebbmlgjoejdpjl?utm_source=chrome-ntp-icon">XPath Helper</a>。</p><p>该插件支持通过写XPath的方式批量获得信息。</p><p>例如我们要获取上图【分类和子分类】中的子分类。先查看这部分的网页源码</p><p><img src="image-20220107165203546.png" alt="子分类网页源码"></p><p>打开XPath Helper，写入XPath获得结果。</p><p><img src="image-20220107165324295.png" alt="XPath Helper截图"></p><p>最终获得大小分类共72个。</p><h2 id="列表页翻页采集详情页URL"><a href="#列表页翻页采集详情页URL" class="headerlink" title="列表页翻页采集详情页URL"></a>列表页翻页采集详情页URL</h2><p>每个分类下有很多翻页，通过不断的翻页采集所有的详情URL。</p><p><img src="image-20220107165646544.png" alt="翻页"></p><p>这里我一开始偷懒，用的“八爪鱼采集器”。后来发现这软件虽然不需要写代码，但是对于大于1W的数据需要收费，就放弃了。</p><p>后续我基于Scrapy爬虫框架完成采集。</p><h3 id="新建Scrapy项目"><a href="#新建Scrapy项目" class="headerlink" title="新建Scrapy项目"></a>新建Scrapy项目</h3><p>首先我们需要新建一个Scrapy项目（前提是已经安装了Scrapy）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scrapy startproject yybkSpider</span><br></pre></td></tr></table></figure><p>其中， yybkSpider为项目名称，可以看到将会创建一个yybkSpider文件夹，目录结构大致如下：</p><p>下面来简单介绍一下各个主要文件的作用：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yybkSpider/</span><br><span class="line">    scrapy.cfg</span><br><span class="line">    yybkSpider/</span><br><span class="line">        __init__.py</span><br><span class="line">        items.py</span><br><span class="line">        pipelines.py</span><br><span class="line">        settings.py</span><br><span class="line">        spiders/</span><br><span class="line">            __init__.py</span><br></pre></td></tr></table></figure><p>这里介绍我认为比较重要的文件：</p><ul><li>settings.py: 项目的配置文件，默认下载的网页是Unicode，需要在这里配置为UTF-8编码。</li><li>yybkSpider/: 项目的Python模块，将会从这里引用代码。</li><li>yybkSpider/items.py: 保存数据的实体，有点像Java Bean。</li><li>yybkSpider/yybkSpider/: 存储爬虫代码目录。</li></ul><h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><p>这里默认下载的网页为UTF-8，所以需要在<code>settings.py</code>中增加配置<code>FEED_EXPORT_ENCODING = &#39;utf-8&#39;</code></p><p>还可以修改下载的线程数。但是我查阅了网上的相关资料，好像作用并不大。由于对Python和Scrapy不是很了解，这里直接给出连接：</p><ul><li><a href="https://www.zhihu.com/question/23474039">为什么有人说 Python 的多线程是鸡肋呢？</a></li><li><a href="https://www.zhihu.com/question/26062225">scrapy在爬网页的时候是自动采用多线程的吗？</a></li></ul><h3 id="制作爬虫"><a href="#制作爬虫" class="headerlink" title="制作爬虫"></a>制作爬虫</h3><p>紧接着，制作一个爬虫：</p><ul><li>Input：所有分类首页</li><li>Output：<ul><li>所有列表页</li><li>每个列表页的详情URL和其他信息。</li></ul></li></ul><p>进入<code>yybkSpider/</code>目录下，输入命令创建爬虫：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scrapy genspider yybk_list &quot;yunyubaike.com&quot;</span><br></pre></td></tr></table></figure><ul><li><code>yybk_list</code>是爬虫的名称</li><li><code>&quot;yunyubaike.com&quot;</code>指出该爬虫爬取的域名，超出域名的不会爬取。</li></ul><p>之后可以看到在<code>yybkSpider/yybkSpider/</code>生成了一个文件<code>yybk_list.py</code>，它默认增加了下列代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">YybkListSpider</span>(scrapy.Spider):</span><br><span class="line">    name = <span class="string">&#x27;yybk_list&#x27;</span></span><br><span class="line">    allowed_domains = [<span class="string">&#x27;yunyubaike.com&#x27;</span>]</span><br><span class="line">    start_urls = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, response</span>):</span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>name = “” ：这个爬虫的识别名称，必须是唯一的，在不同的爬虫必须定义不同的名字。</p><p>allow_domains = [] 是搜索的域名范围，也就是爬虫的约束区域，规定爬虫只爬取这个域名下的网页，不存在的URL会被忽略。</p><p>start_urls = [] ：爬取的URL列表。爬虫从这里开始抓取数据，所以，第一次下载的数据将会从这些urls开始。其他子URL将会从这些起始URL中继承性生成。</p><p>parse(self, response) ：解析的方法，每个初始URL完成下载后将被调用，调用的时候传入从每一个URL传回的Response对象来作为唯一参数，主要作用如下：</p><ul><li>负责解析返回的网页数据(response.body)，提取结构化数据(生成item)</li><li>生成需要下一页的URL请求。</li></ul><p>接下来我们完成该爬虫。首先start_urls不是一个而是72个分类首页URL。再者我们要在parse方法中完成两件事：</p><ol><li>不断生成下一页</li><li>对于每个列表页解析其中的数据。</li></ol><p>下面是完整代码，这部分参考了官方文档：<a href="https://docs.scrapy.org/en/latest/intro/overview.html。">https://docs.scrapy.org/en/latest/intro/overview.html。</a></p><p>这里有几个地方值得注意：</p><ol><li>通过<code>response.url</code>获得当前采集的URL</li><li><code>response.xpath(&#39;&#39;)</code>返回的是一组元素</li><li>我把<code>response.xpath(&#39;&#39;)[0].get()</code>都改写了，原因是如果<code>response.xpath(&#39;&#39;)</code>为空在执行<code>[0]</code>操作就会报错，导致爬取失败</li><li>使用<code>get()</code>而不是<code>exract()</code>。原因如下： </li></ol><blockquote><p>get() 、getall() 是新版本的方法，extract() 、extract_first()是旧版本的方法。</p><p>前者更好用，取不到就返回None，后者取不到就raise一个错误。</p></blockquote><ol><li>想要在当前元素下继续通过XPath选取元素，需要在XPath开头加一个<code>.</code></li><li>注意<code>yield</code>的使用</li><li>这里采集了很多“多余”的字段，例如页码，总数，当前url。这是为了后续验证采集的数据是否完整正确而增加的冗余字段。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">YybkListSpider</span>(scrapy.Spider):</span><br><span class="line">    name = <span class="string">&#x27;yybk_list&#x27;</span></span><br><span class="line">    allowed_domains = [<span class="string">&#x27;yunyubaike.com&#x27;</span>]</span><br><span class="line">    <span class="comment"># 一共是72个URL，这里没有列全</span></span><br><span class="line">    start_urls = [<span class="string">&#x27;https://www.yunyubaike.com/yunqi/&#x27;</span>,</span><br><span class="line">                  <span class="string">&#x27;https://www.yunyubaike.com/yichuanyousheng/&#x27;</span>,</span><br><span class="line">                  <span class="string">&#x27;https://www.yunyubaike.com/beiyun/&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, response</span>):</span><br><span class="line">        domain_url = <span class="string">&quot;https://www.yunyubaike.com&quot;</span></span><br><span class="line">        <span class="comment"># items = []</span></span><br><span class="line">        this_url = response.url</span><br><span class="line">        page_nums = response.xpath(<span class="string">&quot;//div[@class=&#x27;pagebar&#x27;]/b/text()&quot;</span>)</span><br><span class="line">        page_num = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> page_nums:</span><br><span class="line">            page_num = page_nums[<span class="number">0</span>].get()</span><br><span class="line">        <span class="comment"># page_num = response.xpath(&quot;//div[@class=&#x27;pagebar&#x27;]/b/text()&quot;)[0].get()</span></span><br><span class="line">        counts = response.xpath(<span class="string">&quot;//div[@class=&#x27;pagebar&#x27;]/a[@title]/b/text()&quot;</span>)</span><br><span class="line">        count=<span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> counts:</span><br><span class="line">            count = counts[<span class="number">0</span>].get()</span><br><span class="line">        <span class="comment"># count = response.xpath(&quot;//div[@class=&#x27;pagebar&#x27;]/a[@title]/b/text()&quot;)[0].get()</span></span><br><span class="line">        <span class="keyword">for</span> li <span class="keyword">in</span> response.xpath(<span class="string">&quot;//div[@class=&#x27;list&#x27;]/ul/li&quot;</span>):</span><br><span class="line">            titles = li.xpath(<span class="string">&#x27;.//h2/a/text()&#x27;</span>)</span><br><span class="line">            title = <span class="string">&#x27;&#x27;</span></span><br><span class="line">            <span class="keyword">if</span> titles:</span><br><span class="line">                title = titles[<span class="number">0</span>].get()</span><br><span class="line">            detail_urls = li.xpath(<span class="string">&#x27;.//h2/a/@href&#x27;</span>)</span><br><span class="line">            detail_url = <span class="string">&#x27;&#x27;</span></span><br><span class="line">            <span class="keyword">if</span> detail_urls:</span><br><span class="line">                detail_url = detail_urls[<span class="number">0</span>].get()</span><br><span class="line">            <span class="comment"># detail_url = li.xpath(&#x27;.//h2/a/@href&#x27;)[0].get()</span></span><br><span class="line">            <span class="keyword">yield</span> &#123;</span><br><span class="line">                <span class="string">&#x27;this_url&#x27;</span>: this_url,  <span class="comment"># 当前采集的URL</span></span><br><span class="line">                <span class="string">&#x27;page_num&#x27;</span>: page_num,  <span class="comment"># 第几页</span></span><br><span class="line">                <span class="string">&#x27;count&#x27;</span>: count,  <span class="comment"># 该分类下的问答总数</span></span><br><span class="line">                <span class="string">&#x27;title&#x27;</span>: title,  <span class="comment"># 问答标题</span></span><br><span class="line">                <span class="string">&#x27;detail_url&#x27;</span>: domain_url + detail_url  <span class="comment"># 详情URL</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment"># 生成下一页</span></span><br><span class="line">        next_pages = response.xpath(<span class="string">&quot;//a[text()=&#x27;下一页&#x27;]/@href&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> next_pages:</span><br><span class="line">            next_page = next_pages[<span class="number">0</span>].get()</span><br><span class="line">            <span class="comment"># next_page = response.xpath(&quot;//a[text()=&#x27;下一页&#x27;]/@href&quot;)[0].get()</span></span><br><span class="line">            <span class="keyword">if</span> next_page <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">yield</span> response.follow(domain_url + next_page, self.parse)  <span class="comment"># 将下一页的连接传递给爬虫继续解析。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h3 id="启动爬虫"><a href="#启动爬虫" class="headerlink" title="启动爬虫"></a>启动爬虫</h3><p>最后启动爬虫，保存数据。在项目根目录下运行</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scrapy crawl yybk_list -o urls.json</span><br></pre></td></tr></table></figure><p>可以发现，在项目根目录多出了urls.json文件，里面是我们保存的所有列表数据。</p><p>我们也可以保存为其他格式。这里不再赘述。</p><p>这样我们就得到了大约27W的详情连接。下面我们把这些连接对应的HTML保存到本地。</p><h2 id="下载详情网页源码"><a href="#下载详情网页源码" class="headerlink" title="下载详情网页源码"></a>下载详情网页源码</h2><h3 id="制作爬虫-1"><a href="#制作爬虫-1" class="headerlink" title="制作爬虫"></a>制作爬虫</h3><p>进入<code>yybkSpider/</code>目录下，输入命令创建爬虫：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scrapy genspider yybk_detail_down &quot;yunyubaike.com&quot;</span><br></pre></td></tr></table></figure><p>和上面类似，在<code>yybkSpider/yybkSpider/yybk_detail_down.py</code>写入代码：</p><p>这里需要注意：</p><ol><li>start_urls是需要从文件中读取的</li><li>为了读数据、取数据方便，我使用了pands</li><li>获得网页源码，使用<code>response.text</code></li><li>这里没有对网页源码直接解析，而是先保存，再在后续解析。提高容错。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">YybkDetailDownSpider</span>(scrapy.Spider):</span><br><span class="line">    name = <span class="string">&#x27;yybk_detail_down&#x27;</span></span><br><span class="line">    allowed_domains = [<span class="string">&#x27;yunyubaike.com&#x27;</span>]</span><br><span class="line">    df = pd.read_json(<span class="string">&quot;yybkSpider/urls.json&quot;</span>)</span><br><span class="line">    <span class="comment"># 273179条数据</span></span><br><span class="line">    <span class="comment"># 取detail_url列，去重，转换成list</span></span><br><span class="line">    start_urls = df[<span class="string">&#x27;detail_url&#x27;</span>].drop_duplicates().tolist()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, response</span>):</span><br><span class="line">        url = response.url</span><br><span class="line">        <span class="comment"># 获得网页源码</span></span><br><span class="line">        content = response.text</span><br><span class="line"></span><br><span class="line">        file_name = url.replace(<span class="string">&quot;https://www.yunyubaike.com/&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        file_name = <span class="string">&#x27;html/&#x27;</span> + file_name.replace(<span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;_&#x27;</span>)   <span class="comment"># html/huaiyun_wiki_270163.html</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;保存文件：&quot;</span> + file_name)</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(file_name, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(content)</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>此外，我担心detail_url格式是否一致，所以在Python Shell中执行了如下代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df = pd.read_json(<span class="string">&quot;yybkSpider/urls.json&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df[df[<span class="string">&#x27;detail_url&#x27;</span>].<span class="built_in">str</span>.match(<span class="string">r&#x27;https://www.yunyubaike.com/\w+/\d+\.html&#x27;</span>) == <span class="literal">False</span>]</span><br></pre></td></tr></table></figure><p>执行结果为空，这证明detail_url格式一致。</p><h3 id="启动爬虫-1"><a href="#启动爬虫-1" class="headerlink" title="启动爬虫"></a>启动爬虫</h3><p>紧接着启动爬虫，和上面类似：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scrapy crawl yybk_detail_down</span><br></pre></td></tr></table></figure><p>由于这里不需要生成文件，所以没有<code>-o</code></p><p>等待代码执行完毕后，可以发现在项目根目录产生了一个<code>html/</code>文件夹，下面保存了所有详情页的网页源码。</p><h2 id="解析详情页"><a href="#解析详情页" class="headerlink" title="解析详情页"></a>解析详情页</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>打开一个详情页：</p><p><img src="image-20220109124722467.png" alt="详情页"></p><p>可以定位到：在<code>&lt;div class=&#39;article_content&#39; /&gt;</code>标签下，所有的带文字的p标签是我们需要的。每个p标签是一个段落，在保存的时候，段落信息是不能丢失的。也就是说换行符是需要的。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>这一步是脱离于Scrapy框架的。</p><p>自定义一个Python脚本：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">input_dir = <span class="string">&#x27;html/&#x27;</span>  <span class="comment"># 上一步保存源码的文件夹路径</span></span><br><span class="line">output_file_base_name = <span class="string">&#x27;yybkSpider/output/yybk_&#123;&#125;.csv&#x27;</span>  <span class="comment"># 生成的CSV文件的保存路径</span></span><br><span class="line">MAX_ROWS = <span class="number">50000</span>    <span class="comment"># 单个csv文件写入的最大行数</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">解析方法，传入文件名</span></span><br><span class="line"><span class="string">返回需要的字段</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">file_name</span>):</span><br><span class="line">    soup = BeautifulSoup(<span class="built_in">open</span>(file_name, encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    <span class="comment"># title解析</span></span><br><span class="line">    title = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    h1 = soup.find_all(<span class="string">&quot;h1&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> h1:</span><br><span class="line">        title = h1[<span class="number">0</span>].get_text()</span><br><span class="line">    <span class="comment"># content解析</span></span><br><span class="line">    p_list = soup.select(<span class="string">&quot;div.article_content &gt; p&quot;</span>)</span><br><span class="line">    content = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> p_list:</span><br><span class="line">        p_text = p.get_text()</span><br><span class="line">        <span class="keyword">if</span> p_text != <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">            <span class="comment"># 为了避免csv解析失败</span></span><br><span class="line">            p_text = p_text.replace(<span class="string">&quot;,&quot;</span>, <span class="string">&quot;，&quot;</span>).replace(<span class="string">&#x27;&quot;&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            content += p_text + <span class="string">&quot;\n&quot;</span></span><br><span class="line">    content = content.rstrip().lstrip()</span><br><span class="line">    <span class="keyword">return</span> title, content</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    htmls = os.listdir(input_dir)</span><br><span class="line">    <span class="comment"># 计算最终生成的文件个数</span></span><br><span class="line">    file_num = (<span class="built_in">len</span>(htmls) + MAX_ROWS - <span class="number">1</span>) // MAX_ROWS</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(file_num):</span><br><span class="line">        <span class="comment"># i从0开始</span></span><br><span class="line">        <span class="comment"># 第i个文件保存 i*MAX_ROWS[下标] 到 (i+1)*MAX_ROWS - 1</span></span><br><span class="line">        start_index = i*MAX_ROWS</span><br><span class="line">        end_index = (i+<span class="number">1</span>)*MAX_ROWS - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> end_index &gt; <span class="built_in">len</span>(htmls):</span><br><span class="line">            end_index = <span class="built_in">len</span>(htmls)</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(output_file_base_name.<span class="built_in">format</span>(i), <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;parsing :start_index:&#123;&#125;, end_index:&#123;&#125;; saving as &#123;&#125;&quot;</span></span><br><span class="line">                  .<span class="built_in">format</span>(start_index, end_index, output_file_base_name.<span class="built_in">format</span>(i)))</span><br><span class="line">            f.write(<span class="string">&quot;article_id,content,title\n&quot;</span>)</span><br><span class="line">            <span class="keyword">for</span> html_name <span class="keyword">in</span> htmls[start_index: end_index]:</span><br><span class="line">                title, content = parse(os.path.join(input_dir, html_name))</span><br><span class="line">                f.write(html_name + <span class="string">&#x27;,&quot;&#x27;</span> + content + <span class="string">&#x27;&quot;,&#x27;</span> + title + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在<code>parse</code>方法中需要注意以下几点：</p><ol><li><code>soup.select(&quot;div.article_content &gt; p&quot;)</code>这里使用了CSS选择器，制定了div下的直接子标签；</li><li><code>p.get_text()</code>获得p标签下的所有文字；</li><li>为了避免CSV解析失败，这里把英文逗号换成中文逗号，把英文的引号全部去掉。（CSV文件用英文逗号做字段分割；当我们需要把多行数据保存在一个字段中时，需要把多行数据用英文引号包起来）；</li><li>使用BeautifulSoup解析HTML。</li></ol><p>在<code>main</code>方法中需要注意：</p><ol><li>27W行保存到一个CSV文件中，我担心不好把控，所以我将27W行数据每5W行保存为一个CSV</li><li>当需要对除法结果四舍五入时，这样做比较简单：<code>(被除数+除数-1)/除数</code></li></ol><h3 id="运行脚本"><a href="#运行脚本" class="headerlink" title="运行脚本"></a>运行脚本</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python xxx.py</span><br></pre></td></tr></table></figure><p>最终导出6个CSV文件。任务完成。</p><h1 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h1><p><a href="https://github.com/guoyujian/blog-resource/tree/main/yybkSpider">https://github.com/guoyujian/blog-resource/tree/main/yybkSpider</a></p><h1 id="此外…"><a href="#此外…" class="headerlink" title="此外…"></a>此外…</h1><h2 id="Scrapy-Shell快速测试"><a href="#Scrapy-Shell快速测试" class="headerlink" title="Scrapy Shell快速测试"></a>Scrapy Shell快速测试</h2><p>在使用Scrapy的过程中，我想先传入一条URL测试返回的resonpse。经过查阅使用如下命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scrapy shell &lt;url&gt;</span><br></pre></td></tr></table></figure><p>执行后，进入Python Console，内置的response对象即是\<url\>的response</p><h2 id="在服务器运行"><a href="#在服务器运行" class="headerlink" title="在服务器运行"></a>在服务器运行</h2><p>如果在本机执行爬虫代码，会占用较多的资源，也不方便。此时可以把爬虫代码同步到服务器运行。我使用PyChram连接远程服务器，在本机编写爬虫代码，然后同步到服务器中执行。（具体请自行百度）</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://docs.scrapy.org/en/latest/intro/overview.html">Scrapy at a glance</a></li><li><a href="https://www.runoob.com/w3cnote/scrapy-detail.html">Scrapy 入门教程</a></li><li><a href="https://www.runoob.com/cssref/css-selectors.html">CSS选择器</a></li><li><a href="https://scrapy-chs.readthedocs.io/zh_CN/1.0/topics/shell.html">Scrapy shell</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 网络爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络爬虫 </tag>
            
            <tag> Scrapy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解HTTP协议</title>
      <link href="/2022/01/05/%E8%AF%A6%E8%A7%A3HTTP%E5%8D%8F%E8%AE%AE/"/>
      <url>/2022/01/05/%E8%AF%A6%E8%A7%A3HTTP%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p><strong>超文本传输协议</strong>（HTTP，HyperText Transfer Protocol）是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。1960年美国人Ted Nelson构思了一种通过计算机处理文本信息的方法，并称之为超文本（hypertext）,这成为了HTTP超文本传输协议标准架构的发展根基。Ted Nelson组织协调万维网协会（World Wide Web Consortium）和互联网工程工作小组（Internet Engineering Task Force ）共同合作研究，最终发布了一系列的RFC，其中著名的RFC 2616定义了HTTP 1.1。</p><h1 id="HTTP协议的作用及特点"><a href="#HTTP协议的作用及特点" class="headerlink" title="HTTP协议的作用及特点"></a>HTTP协议的作用及特点</h1><p>HTTP是一个客户端和服务器端请求和应答的标准（TCP）。客户端是终端用户，服务器端是网站。</p><p>通过使用Web浏览器、网络爬虫或者其它的工具，客户端发起一个到服务器上指定端口（<strong>默认端口为80</strong>）的HTTP请求。（我们称这个客户端）叫<strong>用户代理（user agent）</strong>。应答的服务器上存储着（一些）资源，比如HTML文件和图像。（我们称）这个应答服务器为源服务器（origin server）。在用户代理和源服务器中间可能存在多个中间层，比如代理，网关，或者隧道（tunnels）。尽管TCP/IP协议是互联网上最流行的应用，HTTP协议并没有规定必须使用它和（基于）它支持的层。 事实上，HTTP可以在任何其他互联网协议上，或者在其他网络上实现。HTTP只假定（其下层协议提供）可靠的传输，任何能够提供这种保证的协议都可以被其使用。</p><p>通常，由HTTP客户端发起一个请求，建立一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端发送过来的请求。一旦收到请求，服务器（向客户端）发回一个状态行，比如”HTTP/1.1 200 OK”，和（响应的）消息，消息的消息体可能是请求的文件、错误消息、或者其它一些信息。<strong>HTTP使用TCP而不是UDP的原因在于（打开）一个网页必须传送很多数据，而TCP协议提供传输控制，按顺序组织数据，和错误纠正。</strong></p><p>通过HTTP或者HTTPS协议请求的资源由<strong>统一资源标示符</strong>（Uniform Resource Identifiers）（或者，更准确一些，URLs）来标识。</p><ol><li>基于请求/响应模型的协议。请求和响应必须成对，先有请求后有响应</li><li>HTTP协议默认端口:80</li><li>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST等。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</li><li>灵活：<strong>HTTP允许传输任意类型的数据对象。</strong>正在传输的类型由Content-Type加以标记。</li><li><strong>无连接</strong>：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li><li><strong>无状态</strong>：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</li></ol><h1 id="协议功能"><a href="#协议功能" class="headerlink" title="协议功能"></a>协议功能</h1><p>HTTP协议是用于从WWW服务器传输超文本到本地浏览器的传输协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。</p><p>HTTP是客户端浏览器或其他程序与Web服务器之间的<strong>应用层通信协议</strong>。在Internet上的Web服务器上存放的都是超文本信息，客户机需要通过HTTP协议传输所要访问的超文本信息。HTTP包含命令和传输信息，不仅可用于Web访问，也可以用于其他因特网/内联网应用系统之间的通信，从而实现各类应用资源超媒体访问的集成。</p><p>我们在浏览器的地址栏里输入的网站地址叫做URL (Uniform Resource Locator，统一资源定位符)。就像每家每户都有一个门牌地址一样，每个网页也都有一个Internet地址。当你在浏览器的地址框中输入一个URL或是单击一个超级链接时，URL就确定了要浏览的地址。浏览器通过超文本传输协议(HTTP)，将Web服务器上站点的网页代码提取出来，并翻译成漂亮的网页。</p><h1 id="HTTP协议的版本"><a href="#HTTP协议的版本" class="headerlink" title="HTTP协议的版本"></a>HTTP协议的版本</h1><p>HTTP/1.0，发送请求，创建一次连接，获得<strong>一个</strong>web资源，连接断开</p><p>HTTP/1.1，发送请求，创建一次连接，获得<strong>多个</strong>web资源，连接断开</p><p>HTTP/2.0</p><h1 id="HTTP协议的组成"><a href="#HTTP协议的组成" class="headerlink" title="HTTP协议的组成"></a>HTTP协议的组成</h1><p>HTTP协议由<strong>HTTP请求</strong>和<strong>HTTP响应</strong>组成，当在浏览器中输入网址访问某个网站时， 你的浏览器会将你的请求封装成一个HTTP请求发送给服务器站点，服务器接收到请  求后会组织响应数据封装成一个HTTP响应返回给浏览器。即没有请求就没有响应。</p><p><strong>HTTP请求包括：请求行、请求头、请求体</strong></p><p><strong>HTTP响应包括：响应行、响应头、响应体</strong></p><h1 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h1><p>HTTP请求报文由3部分组成（请求行+请求头+请求体）：</p><p><img src="HTTP请求报文.png" alt="HTTP请求报文"></p><h2 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h2><p>例如：<code>POST /chapter17/user.html HTTP/1.1</code></p><p>格式：<code>请求方式 资源路径 协议/版本</code></p><p>请求行必须在HTTP请求格式的第一行。</p><blockquote><p>GET请求</p></blockquote><ul><li>将请求参数追加在URL后面，不安全</li><li>URL长度限制GET请求方式数据的大小</li><li>没有请求体</li><li>一般的HTTP请求大多都是GET。</li><li>常见GET请求：地址栏直接访问、<code>&lt;a href=&quot;&quot;&gt;</code>、<code>&lt;img src=&quot;&quot;&gt;</code>等</li></ul><blockquote><p>POST请求</p></blockquote><p>请求参数在请求体处，较安全。</p><p>请求数据大小没有限制</p><p>只有表单设置为method=“post”才是POST请求，其他都是GET请求</p><blockquote><p>HEAD请求</p></blockquote><p>HEAD跟GET相似，不过服务端接收到HEAD请求时<strong>只返回响应头</strong>，不发送响应内容。所以，如果只需要查看某个页面的状态时，用HEAD更高效，因为省去了传输页面内容的时间。</p><blockquote><p>DELETE请求</p></blockquote><p>删除某一个资源。</p><blockquote><p>OPTIONS请求</p></blockquote><p>用于获取当前URL所支持的方法。若请求成功，会在HTTP头中包含一个名为“Allow”的头，值是所支持的方法，如”GET, POST”。</p><blockquote><p>PUT请求</p></blockquote><p>把一个资源存放在指定的位置上。</p><p>本质上来讲， PUT和POST极为相似，都是向服务器发送数据，但它们之间有一个重要区别，PUT通常指定了资源的存放位置，而POST则没有，POST的数据存放位置由服务器自己决定。</p><blockquote><p>TRACE请求</p></blockquote><p>回显服务器收到的请求，主要用于测试或诊断。</p><blockquote><p>CONNECT请求</p></blockquote><p>CONNECT方法是HTTP/1.1协议预留的，能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接与非加密的HTTP代理服务器的通信。</p><p><strong>在 REST 架构风格中，有严格规定对于不同的请求类型要设置合适的请求方法。</strong></p><p>也是避免出现因为乱用导致混乱的问题。这里提到了REST架构，现在很多同学都在写REST，有没有人能够明白为什么要定义REST这个架构风格？（使用REST）</p><ol><li>随着服务化架构的普及，HTTP协议的使用频率越来越高</li><li>很多人在错误的使用HTTP协议定义接口，比如各种各样的命名，什么 getUserInfoById， deleteById 之类的、<strong>有状态和无状态请求混用。</strong></li><li>对于 http 协议本身提供的规则并没有很好的利用</li></ol><p>所以，为了更好的解决这些问题，干脆就定义一套规则，这套规则并没有引入新的东西，无非就是对 http 协议本身的使用做了一些约束，比如说</p><ol><li><strong>REST是面向资源</strong>，每一个 URI 代表一个资源</li><li>强调<strong>无状态化</strong>，服务器端不能存储来自某个客户的某个请求中的信息，并在该客户的其他 请求中使用</li><li>强调 URL 暴露资源时，<strong>不要在 URI 中出现动词</strong></li><li>合理的利用 http 状态码、请求方法。</li></ol><p>因此大家在参照这种标准去使用 REST 风格时，要明白你遵循的是什么以及要解决什么问题。</p><h2 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h2><p>例如：Host: 39.108.107.149:8080</p><p>请求头从第二行开始，到第一个空格结束。请求头和请求体之间存在一个空格(如下)</p><p>例如：Host: 39.108.107.149:8080</p><p>请求头从第二行开始，到第一个空格结束。请求头和请求体之间存在一个空格(如下)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST http://39.108.107.149:8080/vk/app/rest/ddp/iModelServiceImpl/findModelByType HTTP/1.1</span><br><span class="line">User-Agent: Fiddler</span><br><span class="line">Host: 39.108.107.149:8080</span><br><span class="line">Content-Length: 11</span><br><span class="line"> </span><br><span class="line">name=城市</span><br></pre></td></tr></table></figure><p>请求头通常以键值对{key:value}方式传递数据。</p><p>key为规范的固定值</p><p>value为key对应的取值，通常是一个值，可能是一组。</p><h3 id="常见的请求头属性"><a href="#常见的请求头属性" class="headerlink" title="常见的请求头属性"></a>常见的请求头属性</h3><p><strong>Referer:</strong> 表示这个请求是从哪个url跳过来的，通过百度来搜索淘宝网,那么在进入淘宝网的请求报文中，Referer的值就是:www.baidu.com。 如果是直接访问就不会有这个头。</p><p>常用于：防盗链。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Referer: no-referrer-when-downgrade</span><br></pre></td></tr></table></figure><p><strong>Accept:</strong> 告诉服务端，该请求所能支持的响应数据类型，专业术语称为MIME 类型(文件类型的一种描述方式)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8</span><br></pre></td></tr></table></figure><p>MIME格式：大类型/小类型[;参数]</p><p>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,<em>/</em>;q=0.8</p><p>例如:</p><p>text/html,html文件</p><p>text/css,css文件</p><p>text/javascript,js文件</p><p>image/*，所有图片文件</p><p><strong>Cookie:</strong> 客户端的Cookie就是通过这个报文头属性传给服务端的哦！</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cookie: JSESSIONID=15982C27F7507C7FDAF0F97161F634B5</span><br></pre></td></tr></table></figure><p>这里就出了一个问题,网站A怎么保证自己请求体中保存的cookie就是网站A的cookie而不是网站B的cookie呢,这就和cookie里面的jsessionid有关系了，关于cookie,session,sessionid,jsessionid的区别联系，可以参考这个博文:</p><p><a href="http://www.cnblogs.com/fnng/archive/2012/08/14/2637279.html">http://www.cnblogs.com/fnng/archive/2012/08/14/2637279.html</a></p><p><strong>User-Agent:</strong> 浏览器通知服务器，客户端浏览器与操作系统相关信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36</span><br></pre></td></tr></table></figure><p><strong>Connection:</strong> 表示客户端与服务连接类型；Keep-Alive表示持久连接，close已关闭</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure><p><strong>Host:</strong> 请求的服务器主机名</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host: sczpkj.f3322.net:3000</span><br></pre></td></tr></table></figure><p><strong>Content-Length:</strong> 请求体的长度</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST http://39.108.107.149:8080/vk/app/rest/ddp/iModelServiceImpl/findModelByType HTTP/1.1</span><br><span class="line">User-Agent: Fiddler</span><br><span class="line">Host: 39.108.107.149:8080</span><br><span class="line">Content-Length: 11</span><br><span class="line"> </span><br><span class="line">name=城市</span><br></pre></td></tr></table></figure><p><strong>Content-Type:</strong> 请求的与实体对应的MIME信息。如果是POST请求,会有这个头,默认值为application/x-www-form-urlencoded，表示请求体内容使用url编码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Content-Type: application/x-www-form-urlencoded</span><br></pre></td></tr></table></figure><blockquote><h4 id="Content-Type详解"><a href="#Content-Type详解" class="headerlink" title="Content-Type详解"></a>Content-Type详解</h4><p>常见的Content-Type：</p><div class="table-container"><table><thead><tr><th>Content-Type</th><th>解释</th></tr></thead><tbody><tr><td>text/html</td><td>html格式</td></tr><tr><td>text/plain</td><td>纯文本格式</td></tr><tr><td>text/css</td><td>CSS格式</td></tr><tr><td>text/javascript</td><td>js格式</td></tr><tr><td>image/gif</td><td>gif图片格式</td></tr><tr><td>image/jpeg</td><td>jpg图片格式</td></tr><tr><td>image/png</td><td>png图片格式</td></tr><tr><td>application/x-www-form-urlencoded</td><td>POST专用：普通的表单提交默认是通过这种方式。form表单数据被编码为key/value格式发送到服务器。</td></tr><tr><td>application/json</td><td>POST专用：用来告诉服务端消息主体是序列化后的 JSON 字符串</td></tr><tr><td>text/xml</td><td>POST专用：发送xml数据</td></tr><tr><td>multipart/form-data</td><td>POST专用：下面讲解</td></tr></tbody></table></div><p><strong>application/x-www-form-urlencoded</strong> </p><p>最常见的post提交数据的方式。浏览器原生的form表单，如果不设置<strong>enctype属性</strong>，那么最终就会以application/x-www-form-urlencoded 方式提交数据</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST http://39.108.107.149:8080/vk/app/rest/ddp/iModelServiceImpl/findModelByType HTTP/1.1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">cache-control: no-cache</span><br><span class="line">Postman-Token: 8e602802-b4f5-4d05-96d7-e1c7a1951719</span><br><span class="line">User-Agent: PostmanRuntime/7.1.1</span><br><span class="line">Accept: */*</span><br><span class="line">Host: 39.108.107.149:8080</span><br><span class="line">cookie: JSESSIONID=6CD80B7028062D9190717CEE001C3194</span><br><span class="line">accept-encoding: gzip, deflate</span><br><span class="line">content-length: 32</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line">name=%E5%9F%8E%E5%B8%82&amp;status=1</span><br></pre></td></tr></table></figure><p>首先，Content-Type 被指定为 application/x-www-form-urlencoded；其次，提交的数据按照 key1=val1&amp;key2=val2 的方式进行编码，key 和 val 都进行了 URL 转码。大部分服务端语言都对这种方式有很好的支持。</p><p>很多时候，我们用 Ajax 提交数据时，也是使用这种方式。例如 JQuery 和 QWrap 的 Ajax，Content-Type 默认「application/x-www-form-urlencoded;charset=utf-8」。 </p><p><strong>multipart/form-data</strong> </p><p>这又是一个常见的 POST 数据提交的方式。我们<strong>使用表单上传文件</strong>时，必须让 form 的 enctyped 等于这个值。</p><p>此时（当使用表单上传文件时），HTTP请求报文格式如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST http://39.108.107.149:8080/vk/app/rest/ddp/iDataSourcesBaseService/file HTTP/1.1</span><br><span class="line">Content-Type: multipart/form-data; boundary=--------------------------629236571647111133881449</span><br><span class="line">cache-control: no-cache</span><br><span class="line">Postman-Token: 2146b4b3-2d30-469c-bbcd-fbc4693934d9</span><br><span class="line">User-Agent: PostmanRuntime/7.1.1</span><br><span class="line">Accept: */*</span><br><span class="line">Host: 39.108.107.149:8080</span><br><span class="line">cookie: JSESSIONID=6CD80B7028062D9190717CEE001C3194</span><br><span class="line">accept-encoding: gzip, deflate</span><br><span class="line">content-length: 435</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line">----------------------------629236571647111133881449</span><br><span class="line">Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;test.txt&quot;</span><br><span class="line">Content-Type: text/plain</span><br><span class="line"></span><br><span class="line">test upload</span><br><span class="line">----------------------------629236571647111133881449</span><br><span class="line">Content-Disposition: form-data; name=&quot;extCode&quot;</span><br><span class="line"></span><br><span class="line">test</span><br><span class="line">----------------------------629236571647111133881449</span><br><span class="line">Content-Disposition: form-data; name=&quot;extId&quot;</span><br><span class="line"></span><br><span class="line">3306</span><br><span class="line">----------------------------629236571647111133881449--  //结束标识</span><br></pre></td></tr></table></figure><p>首先生成了一个 boundary 用于分割不同的字段，为了避免与正文内容重复，boundary 很长很复杂。然后 Content-Type 里指明了数据是以 mutipart/form-data 来编码，本次请求的 boundary 是什么内容。</p><p>消息主体里按照字段个数又分为多个结构类似的部分，每部分都是<strong>以—boundary开始</strong>，紧接着内容描述信息，然后是回车，最后是最后是字段具体内容（文本或二进制），如果传输的是文件，还要包含文件名和文件类型信息。消息主体最后<strong>以—boundary—标示结束</strong>。</p><p>上面提到的这两种 POST 数据的方式，都是浏览器原生支持的，而且现阶段原生 form 表单也只支持这两种方式。但是随着越来越多的 Web 站点，尤其是 WebApp，全部使用 Ajax 进行数据交互之后，我们完全可以定义新的数据提交方式，给开发带来更多便利。 </p><p><strong>application/json</strong></p><p>application/json 这个 Content-Type 作为响应头大家肯定不陌生。实际上，现在越来越多的人把它作为请求头，用来告诉服务端消息主体是序列化后的 JSON 字符串。由于 JSON 规范的流行，除了低版本 IE 之外的各大浏览器都原生支持 JSON.stringify，服务端语言也都有处理 JSON 的函数，使用 JSON 不会遇上什么麻烦。 <strong>JSON 格式支持比键值对复杂得多的结构化数据，这一点也很有用。</strong></p><p>当<code>Content-Type: application/json</code>时请求报文如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST http://39.108.107.149:8080/vk/app/rest/ddp/vkIndexsService/queryVkIndxs HTTP/1.1</span><br><span class="line">Content-Type: application/json</span><br><span class="line">cache-control: no-cache</span><br><span class="line">Postman-Token: 5014bc39-0777-49d5-bb8a-73db9a981e49</span><br><span class="line">User-Agent: PostmanRuntime/7.1.1</span><br><span class="line">Accept: */*</span><br><span class="line">Host: 39.108.107.149:8080</span><br><span class="line">cookie: JSESSIONID=6CD80B7028062D9190717CEE001C3194</span><br><span class="line">accept-encoding: gzip, deflate</span><br><span class="line">content-length: 132</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"> &quot;name&quot;:&quot;828验证继承&quot;,</span><br><span class="line"> &quot;getresultType&quot;:&quot;2&quot;,</span><br><span class="line"> &quot;createTime&quot;:&quot;Tue Sep 11 2018 00:00:00 GMT+0800 (中国标准时间)&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方案，可以方便的提交复杂的结构化数据，特别适合 RESTful 的接口。各大抓包工具如 Chrome 自带的开发者工具、Firebug、Fiddler，都会以树形结构展示 JSON 数据，非常友好。</p></blockquote><p><strong>Accept-Encoding:</strong> 浏览器通知服务器，浏览器支持的数据压缩格式。如GZIP压缩</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Accept-Encoding: gzip, deflate</span><br></pre></td></tr></table></figure><p><strong>Accept-Language:</strong> 浏览器通知服务器，浏览器支持的语言。各国语言(国际化i18n)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br></pre></td></tr></table></figure><p><strong>Cache-Control:</strong> 指定请求和响应遵循的缓存机制</p><p>对缓存进行控制，如一个请求希望响应返回的内容在客户端要被缓存一年，或不希望被缓存就可以通过这个报文头达到目的。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cache-Control: no-cache</span><br></pre></td></tr></table></figure><p>更多请求头属性可以参考这篇文章:<a href = "http://tools.jb51.net/table/http_header">HTTP响应头和请求头信息对照表</a></p><h2 id="请求体"><a href="#请求体" class="headerlink" title="请求体"></a>请求体</h2><p>当请求方式是post的时，请求体会有请求的参数，格式如下：</p><p>username=zhangsan&amp;password=123</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST http://39.108.107.149:8080/vk/app/rest/ddp/iModelServiceImpl/findModelByType HTTP/1.1</span><br><span class="line">User-Agent: Fiddler</span><br><span class="line">Host: 39.108.107.149:8080</span><br><span class="line">Content-Length: 20</span><br><span class="line"> </span><br><span class="line">name=城市&amp;status=1</span><br></pre></td></tr></table></figure><h1 id="HTTP响应报文"><a href="#HTTP响应报文" class="headerlink" title="HTTP响应报文"></a>HTTP响应报文</h1><p>HTTP的响应报文也由三部分组成（响应行+响应头+响应体）</p><p><img src="HTTP响应报文.png" alt="HTTP响应报文"></p><h2 id="响应行"><a href="#响应行" class="headerlink" title="响应行"></a>响应行</h2><p>例如：<code>HTTP/1.1 200 OK</code></p><p>格式：<code>报文协议及版本 状态码及状态描述</code></p><h3 id="常见的状态码"><a href="#常见的状态码" class="headerlink" title="常见的状态码"></a>常见的状态码</h3><p>状态码：由3位数字组成，第一个数字定义了响应的类别</p><p>1xx：指示信息，表示请求已接收，继续处理</p><p>2xx：成功，表示请求已被成功接受，处理。</p><ul><li>200 OK：客户端请求成功</li><li>204 No Content：无内容。服务器成功处理，但未返回内容。一般用在只是客户端向服务器发送信息，而服务器不用向客户端返回什么信息的情况。不会刷新页面。</li><li>206 Partial Content：服务器已经完成了部分GET请求（客户端进行了范围请求）。响应报文中包含Content-Range指定范围的实体内容</li></ul><p>3xx：重定向</p><ul><li>301 Moved Permanently：永久重定向，表示请求的资源已经永久的搬到了其他位置。</li><li>302 Found：临时重定向，表示请求的资源临时搬到了其他位置</li><li>303 See Other：临时重定向，应使用GET定向获取请求资源。303功能与302一样，区别只是303明确客户端应该使用GET访问</li><li>307 Temporary Redirect：临时重定向，和302有着相同含义。POST不会变成GET</li><li>304 Not Modified：表示客户端发送附带条件的请求（GET方法请求报文中的IF…）时，条件不满足。返回304时，不包含任何响应主体。虽然304被划分在3XX，但和重定向一毛钱关系都没有</li></ul><p>4xx：客户端错误</p><ul><li>400 Bad Request：客户端请求有语法错误，服务器无法理解。</li><li>401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用。</li><li>403 Forbidden：服务器收到请求，但是拒绝提供服务</li><li>404 Not Found：请求资源不存在。比如，输入了错误的url</li><li>415 Unsupported media type：不支持的媒体类型</li></ul><p>5xx：服务器端错误，服务器未能实现合法的请求。</p><ul><li>500 Internal Server Error：服务器发生不可预期的错误。</li><li>503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常，</li></ul><h2 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h2><p>响应报文头，也是由多个属性组成；</p><p>响应头也是用键值对；</p><p>服务器通过响应头来控制浏览器的行为，不同的头浏览器操作不同</p><div class="table-container"><table><thead><tr><th>常见请求头</th><th>描述</th></tr></thead><tbody><tr><td>Location</td><td>指定响应的路径，需要与状态码302配合使用，完成跳转。</td></tr><tr><td>Content-Type</td><td>响应正文的类型（MIME类型）；取值：text/html;charset=UTF-8</td></tr><tr><td>Content-Disposition</td><td>通过浏览器以下载方式解析正文；  取值：attachment;filename=xx.zip</td></tr><tr><td>Set-Cookie</td><td>与会话相关技术。服务器向浏览器写入Cookie</td></tr><tr><td>Content-Encoding</td><td>服务器使用的压缩格式；取值：gzip</td></tr><tr><td>Content-length</td><td>响应正文的长度</td></tr><tr><td>Refresh</td><td>定时刷新，格式：秒数;url=路径。url可省略，默认值为当前页。取值：3;url=www.itcast.cn    //三秒刷新页面到www.itcast.cn</td></tr><tr><td>Server</td><td>指的是服务器名称，默认值：Apache-Coyote/1.1。可以通过conf/server.xml配置进行修改。<Connector port="8080" ... server="itcast"/></td></tr><tr><td>Last-Modified</td><td>服务器通知浏览器，文件的最后修改时间。与If-Modified-Since一起使用。</td></tr><tr><td>Cache-Control</td><td>响应输出到客户端后，服务端通过该报文头属告诉客户端如何控制响应内容的缓存。常见的取值有常见的取值有private、public、no-cache、max-age，no-store，默认为private。缓存时间为31536000秒（365天）</td></tr></tbody></table></div><p>更多请求头属性可以参考这篇文章：<a href="http://tools.jb51.net/table/http_header">HTTP响应头和请求头信息对照表</a></p><h2 id="响应体"><a href="#响应体" class="headerlink" title="响应体"></a>响应体</h2><p>响应报文体，服务器发送给浏览器的正文，即我们真正要的“干货” ；</p><p>响应体，响应体是服务器回写给客户端的页面正文，浏览器将正文加载到内存，然后解析渲染，显示页面内容。</p><h1 id="HTTP协议扩展"><a href="#HTTP协议扩展" class="headerlink" title="HTTP协议扩展"></a>HTTP协议扩展</h1><blockquote><p><strong>如果传输的文件过大怎么办</strong></p></blockquote><p>服务器上返回的资源文件比较大，比如有些 js 文件大小可能就有几兆。文件过大就会影响传 输的效率，同时也会带来带宽的消耗。怎么办呢？</p><ol><li>常见的手段是，对文件进行<strong>压缩</strong>，减少文件大小。那压缩和解压缩的流程怎么实现呢？ 首先服务端需要能支持文件的压缩功能，其次浏览器能够针对被压缩的文件进行解压缩。浏览器可以指定 Accept-Encoding 来高速服务器我当前支持的编码类型 Accept-Encoding:gzip,deflate 那服务端会根据支持的编码类型，选择合适的类型进行压缩。常见的编码方式有：gzip/deflate</li><li><strong>分割</strong>传输 在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面。这种把实体主体分块的功能称为分块传输编码（Chunked Transfer Coding）。</li></ol><blockquote><p><strong>每次请求都要建立连接吗？</strong></p></blockquote><p>在最早的 HTTP 协议中，每进行一次 HTTP 通信，就需要做一次 TCP 的连接。而一次连接需要进行 3 次握手，这种通信方式会增加通信量的开销。</p><p><img src="HTTP一次通信.png" alt="HTTP一次通信"></p><p>所以在 <strong>HTTP/1.1 中改用了持久连接</strong>，就是在一次连接建立之后，只要客户端或者服务端没有 明确提出断开连接，那么这个 tcp 连接会一直保持连接状态 持久连接的一个最大的好处是：大大减少了连接的建立以及关闭时延。 HTTP1.1 中有一个 Transport 段。会携带一个 <strong>Connection:Keep-Alive</strong>，表示希望将此条连接 作为持久连接。</p><p>HTTP/1.1 持久连接在默认情况下是激活的，除非特别指明，否则 HTTP/1.1 假定所有的连接都 是持久的，要在事务处理结束之后将连接关闭，HTTP/1.1 应用程序必须向报文中显示地添加 一个 Connection：close 首部。</p><p>HTTP1.1 客户端加载在收到响应后，除非响应中包含了 Connection：close 首部，不然 HTTP/1.1 连接就仍然维持在打开状态。但是，客户端和服务器仍然可以随时关闭空闲的连接。不发送 Connection：close 并不意味这服务器承诺永远将连接保持在打开状态。</p><p><strong>管道化连接</strong>：http/1.1 允许在持久连接上使用请求管道。以前发送请求后需等待并收到响应， 才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。这样就 能够做到同时并行发送多个请求，而不需要一个接一个地等待响应了。</p><p><img src="管道化连接.png" alt="管道化连接"></p><blockquote><p><strong>HTTP协议如何解决无状态问题</strong></p></blockquote><p>HTTP 协议是无状态的，什么是无状态呢？就是说 HTTP 协议本身不会对请求和响应之间的 通信状态做保存。 但是现在的应用都是有状态的，如果是无状态，那这些应用基本没人用，你想想，访问一个电商网站，先登录，然后去选购商品，当点击一个商品加入购物车以后又提示你登录。这种用户体验根本不会有人去使用。那我们是如何实现带状态的协议呢？</p><ol><li><strong>客户端支持的 cookie</strong></li></ol><p>HTTP 协议中引入了 Cookie 技术，用来解决HTTP协议无状态的问题。通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态；Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。</p><ol><li><strong>服务端支持的 session</strong></li></ol><p>服务端是通过什么方式来保存状态的呢？ 在基于 tomcat 这类的 jsp/servlet 容器中，会提供 session 这样的机制来保存服务端的对象状态，服务器使用一种类似于散列表的结构来保存信息，当程序需要为某个客户端的请求创建一个 session 的时候，服务器首先检查这个客户端 的请求是否包含了一个 session 标识- session id； 如果已包含一个 session id 则说明以前已经为客户端创建过 session，服务器就按照 session id 把这个 session 检索出来使用（如果检索不到，会新建一个）； 如果客户端请求不包含 sessionid，则为此客户端创建一个 session 并且生成一个与此 session 相关联的 session id， session id 的值是一个既不会重复，又不容易被找到规律的仿造字符 串，这个 session id 将会返回给客户端保存</p><p><img src="Session实现原理.png" alt="Session实现原理"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://blog.csdn.net/weixin_38087538/article/details/82838762">Http协议详解(深入理解)</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> HTTP协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> HTTP协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从堆排序到优先级队列</title>
      <link href="/2021/12/29/%E4%BB%8E%E5%A0%86%E6%8E%92%E5%BA%8F%E5%88%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/"/>
      <url>/2021/12/29/%E4%BB%8E%E5%A0%86%E6%8E%92%E5%BA%8F%E5%88%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文包含以下几部分内容</p><ul><li>[x] 二叉堆</li><li>[x] 堆排序</li><li>[x] 二叉堆应用：优先级队列</li><li>[x] Java PriorityQueue</li></ul><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h2><p>二叉堆是堆排序实现的底层逻辑结构。二叉堆是一种特殊的二叉树（完全二叉树），一般存储在数组中。</p><p>对于链表二叉树，一般是操作节点指针，而对于二叉堆，我们使用数组索引作为指针。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父节点的索引</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">parent</span><span class="params">(<span class="type">int</span> root)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> root / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 左孩子的索引</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">left</span><span class="params">(<span class="type">int</span> root)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> root * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 右孩子的索引</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">right</span><span class="params">(<span class="type">int</span> root)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> root * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是二叉堆物理存储结构示意图，注意这里索引0空着不用。</p><p><img src="1.png" alt="二叉堆示意图"></p><p>二叉堆设计的巧妙之处就在于，对于一个节点，只需要通过简单的运算就可以得到其父、左右孩子节点。</p><p>二叉堆分为大顶堆和小顶堆。大顶堆的性质是<strong>每个节点都大于等于他的两个子节点</strong>，小顶堆的性质相反。</p><p>本文以大顶堆为例。此外，为了更加直观，下面会画的图都是二叉树结构。由于大顶堆的性质，堆顶元素arr[1]一定是所有元素中最大的元素。</p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆排序就是利用堆这种数据结构设计的一种排序算法。</p><blockquote><p><strong>堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了</strong></p></blockquote><p>堆排序是一种<strong>选择排序，</strong>它的最坏，最好，平均时间复杂度均为<strong>O(nlogn)</strong>，它是<a href="https://baike.baidu.com/item/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%A8%B3%E5%AE%9A%E6%80%A7/9763250"><strong>不稳定排序</strong></a>。</p><p>下面通过一个例子来了解堆排序的过程。</p><p>序列：4，6，8，5，9。</p><p><strong>步骤一</strong>： 构造初始堆。</p><p><img src="2.png" alt="初始堆"></p><p><strong>步骤二</strong>：由<strong>下向上，由右向左</strong>不断调整，使其满足大顶堆的要求。</p><p><img src="3.png" alt="构造大顶堆的过程示意"></p><ol><li>先看【6，5，9】，9为这棵树的最大值节点，因此将9和根节点6互换；</li><li>再看【4，9，8】，9为这棵树的最大值节点，因此将9和根节点4互换；</li><li>由于刚才的交换，【4，5，6】不再满足大顶堆的性质，6为这棵树的最大值节点，因此将4和根节点6互换。</li><li>此时整棵树都满足了大顶堆的性质。</li></ol><p><strong>步骤三</strong>：将堆顶元素与末尾元素进行交换，使末尾元素最大。弹出末尾最大元素。重复<strong>步骤二</strong>使其满足大顶堆。如此反复进行交换、重建、交换……直到堆空，元素弹出堆的顺序即为排序后的顺序。</p><p><img src="4.png" alt="步骤三示意"></p><p>总结堆排序算法步骤：</p><ol><li>将无需序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆；</li><li>由下向上，由右向左不断调整，使初始堆满足大顶堆的要求。</li><li>将堆顶元素与末尾元素进行交换，使末尾元素最大。弹出末尾最大元素。重复<strong>步骤二</strong>使其满足大顶堆。如此反复进行交换、重建、交换……直到堆空。元素弹出堆的顺序即为排序后的顺序。</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>//TODO</p><h2 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h2><p>优先级队列的性质是，出队元素总是优先级最高的元素。优先级队列的底层就是使用二叉堆和堆排序实现了这一性质。当元素插入/删除时，优先级队列的元素会自动排序。</p><h3 id="代码框架"><a href="#代码框架" class="headerlink" title="代码框架"></a>代码框架</h3><p>优先级队列有两个主要 API，分别是<code>insert</code>插入一个元素和<code>delMax</code>删除最大元素。</p><p>下面给出优先级队列的代码框架。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxPQ</span> &lt;Key <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;Key&gt;&gt; &#123; <span class="comment">//Key是可比较大小的泛型</span></span><br><span class="line">    <span class="comment">//二叉堆，大顶堆</span></span><br><span class="line">    <span class="keyword">private</span> Key[] pq;</span><br><span class="line">    <span class="comment">//当前priority queue中元素个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MaxPQ</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">        <span class="comment">//索引0不用，所以多一个分配空间</span></span><br><span class="line">        pq = (Key[]) <span class="keyword">new</span> <span class="title class_">Comparable</span>[cap + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回当前队列中的最大元素</span></span><br><span class="line">    <span class="keyword">public</span> Key <span class="title function_">max</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pq[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//插入元素e</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span> <span class="params">(Key e)</span> &#123;</span><br><span class="line">        <span class="comment">//TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除并返回当前队列中的最大元素</span></span><br><span class="line">    <span class="keyword">public</span> Key <span class="title function_">delMax</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//上浮第k个元素，以维护最大堆的性质</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line"><span class="comment">//TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//下沉第k个元素，以维护最大堆的性质</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line"><span class="comment">//TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交换数组的两个元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">Key</span> <span class="variable">tmp</span> <span class="operator">=</span> pq[i];</span><br><span class="line">        pq[i] = pq[j];</span><br><span class="line">        pq[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//pq[i]是否比pq[j]小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">less</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pq[i].compareTo(pq[j]) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现swim和sink"><a href="#实现swim和sink" class="headerlink" title="实现swim和sink"></a>实现swim和sink</h3><p>元素的swim（上浮）和sink（下沉）都是为了维护堆的性质。</p><p>我们要讲的是最大堆，每个节点都比它的两个子节点大，但是在插入元素和删除元素时，难免破坏堆的性质，这就需要通过这两个操作来恢复堆的性质了。</p><p>对于最大堆，会破坏堆性质的有有两种情况：</p><ol><li>如果某个节点 A 比它的子节点（中的一个）小，那么 A 就不配做父节点，应该下去，下面那个更大的节点上来做父节点，这就是对 A 进行<strong>下沉</strong>。</li><li>如果某个节点 A 比它的父节点大，那么 A 不应该做子节点，应该把父节点换下来，自己去做父节点，这就是对 A 的<strong>上浮</strong>。</li></ol><p>swim代码实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="comment">//如果浮到了堆顶，就不需要再上浮了</span></span><br><span class="line">    <span class="keyword">while</span>(k &gt; <span class="number">1</span> &amp;&amp; less(parent(k), k)) &#123;</span><br><span class="line">        <span class="comment">//如果第k个元素比上层大，就将k换上去</span></span><br><span class="line">        exch(parent(k), k);</span><br><span class="line">        k = parent(k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sink代码实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下沉第k个元素，以维护最大堆性质</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="comment">//如果沉到堆底，就沉不下去了</span></span><br><span class="line">    <span class="keyword">while</span>(left(k) &lt;= N) &#123;</span><br><span class="line">        <span class="comment">//假设左边节点比较大</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">older</span> <span class="operator">=</span> left(k);</span><br><span class="line">        <span class="comment">//如果右边节点存在，则左右节点比一下大小</span></span><br><span class="line">        <span class="keyword">if</span>(right(k) &lt;= N &amp;&amp; less(older, right(k))) &#123;</span><br><span class="line">            older = right(k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//节点k比左右孩子都大，就不必下沉了</span></span><br><span class="line">        <span class="keyword">if</span>(less(older, k))  <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//否则，不符合大顶堆性质，下沉k节点</span></span><br><span class="line">        exch(k, older);</span><br><span class="line">        k = older;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现delMax和insert"><a href="#实现delMax和insert" class="headerlink" title="实现delMax和insert"></a>实现delMax和insert</h3><p>delMax和insert就是建立在swim和sink基础上。</p><p><code>insert</code>方法先把要插入的元素添加到堆底的最后，然后让其上浮到正确位置。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(Key e)</span> &#123;</span><br><span class="line">    N++;</span><br><span class="line">    <span class="comment">// 先把新元素加到最后</span></span><br><span class="line">    pq[N] = e;</span><br><span class="line">    <span class="comment">// 然后让它上浮到正确的位置</span></span><br><span class="line">    swim(N);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>delMax</code>方法先把堆顶元素 A 和堆底最后的元素 B 对调，然后删除 A，最后让 B 下沉到正确位置。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Key <span class="title function_">delMax</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 最大堆的堆顶就是最大元素</span></span><br><span class="line">    <span class="type">Key</span> <span class="variable">max</span> <span class="operator">=</span> pq[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 把这个最大元素换到最后，删除之</span></span><br><span class="line">    exch(<span class="number">1</span>, N);</span><br><span class="line">    pq[N] = <span class="literal">null</span>;</span><br><span class="line">    N--;</span><br><span class="line">    <span class="comment">// 让 pq[1] 下沉到正确位置</span></span><br><span class="line">    sink(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，一个优先级队列就实现了，插入和删除元素的时间复杂度为 <em>O(logK)</em>，K为当前二叉堆（优先级队列）中的元素总数。因为我们时间复杂度主要花费在<code>sink</code>或者<code>swim</code>上，而不管上浮还是下沉，最多也就树（堆）的高度，也就是 log 级别。</p><h2 id="Java-PriorityQueue"><a href="#Java-PriorityQueue" class="headerlink" title="Java PriorityQueue"></a>Java PriorityQueue</h2><p>Java PriorityQueue的介绍请看我的另一篇博客<a href="https://gmet233.gitee.io/2021/12/19/PriorityQueue-%E6%A6%82%E8%BF%B0/#%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8">PriorityQueue 概述</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://mp.weixin.qq.com/s/o7tdyLiYm668dpUWd-x7Lg">labuladong: 图文详解二叉堆，实现优先级队列</a></li><li>《算法（第4版）》</li><li><a href="https://www.cnblogs.com/chengxiao/p/6129630.html">图解排序算法(三)之堆排序</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 排序 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>统计文件夹下各种后缀名的文件个数</title>
      <link href="/2021/12/29/%E7%BB%9F%E8%AE%A1%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E5%90%84%E7%A7%8D%E5%90%8E%E7%BC%80%E5%90%8D%E7%9A%84%E6%96%87%E4%BB%B6%E4%B8%AA%E6%95%B0/"/>
      <url>/2021/12/29/%E7%BB%9F%E8%AE%A1%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E5%90%84%E7%A7%8D%E5%90%8E%E7%BC%80%E5%90%8D%E7%9A%84%E6%96%87%E4%BB%B6%E4%B8%AA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>test文件夹组织结构如下：</p><blockquote><p>test/<br>   -1.jpg<br>   -dd/<br>       -2.jpg<br>       -e/<br>           -3.jpg<br>           -4.jpg<br>           -5.txt<br>   -ll.dir/<br>       -5.rar</p></blockquote><p>现在想统计test目录下不同<strong>文件</strong>后缀名的个数。</p><p>下面通过两种方案解决。</p><h1 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h1><p>shell一行命令搞定，<strong>但对于带点号的目录，这种方法会出Bug</strong>。应该可以对此改进，但后面找到了Python的方式。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find -type f -name &quot;*.*&quot; | cut -f3 -d&#x27;.&#x27; | sort | uniq -c -i  (递归查找当前文件夹下的所有子文件夹)</span><br></pre></td></tr></table></figure><p>下面对该命令进行分解解释。</p><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>find命令参数说明</p><blockquote><p>  -type c<br>        File is of type c:<br>            d      directory<br>            f      regular file<br>  -name pattern<br>        Base of file name (the path with the leading directories  removed)  matches  shell  pattern  pattern.  </p></blockquote><ul><li>只查找文件，而不需要关心文件夹，所以使用-type f参数(注意，在linux上会有链接文件、块文件等其它格式的文件类型，而且Window系统上的快捷方式其格式也是一般文件)</li><li>只过滤出有后缀名的文件，所以使用-name “<em>.</em>“参数(注意，使用-name “<em>.</em>“参数也会过滤出.name和name.这样的文件，因此要严格过滤出<em>.</em>且”.”前后都有字符的文件，可以使用-regex “./.+..+”参数，具体作用请百度“find正则表达式”)</li></ul><h2 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h2><p>cut命令参数说明</p><blockquote><p>   -f, —fields=LIST<br>          select  only  these fields;  also print any line that contains no delimiter character, unless the -s option is specified<br>   -d, —delimiter=DELIM<br>          use DELIM instead of TAB for field delimiter</p></blockquote><ul><li>-f3表示截取第三部分</li></ul><h2 id="sort和uniq"><a href="#sort和uniq" class="headerlink" title="sort和uniq"></a>sort和uniq</h2><p>sort命令很好理解，就是对前面的输出进行一下排序，以便与uniq命令操作。</p><p>uniq命令说明</p><blockquote><p>uniq - report or omit repeated lines</p><p>-c, —count<br>   prefix lines by the number of occurrences<br>-i, —ignore-case<br>   ignore differences in case when comparing</p></blockquote><ul><li>uniq的作用就是找到<strong>连续重复的行</strong></li><li>-c 统计次数</li><li>-i 忽略大小写</li></ul><h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">&quot;count suffix from dir&quot;</span>)</span><br><span class="line"><span class="comment"># 设置脚本传参，传入需要统计后缀名的文件夹</span></span><br><span class="line">parser.add_argument(<span class="string">&#x27;-d&#x27;</span>, <span class="string">&#x27;--directory&#x27;</span>, required=<span class="literal">True</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, <span class="built_in">help</span>=<span class="string">&#x27;need a full path&#x27;</span>)</span><br><span class="line">args = parser.parse_args()</span><br><span class="line">directory = args.directory</span><br><span class="line"><span class="comment"># 结果dict</span></span><br><span class="line">res = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;suffix : count&quot;</span>)</span><br><span class="line"><span class="comment"># print(directory)</span></span><br><span class="line"><span class="comment"># 如果目录不存在则退出</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(directory):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;dir does not exist&quot;</span>)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 如果传递的不是目录则退出</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.isdir(directory):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;need a dir not a file&quot;</span>)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">os.walk得到的三元组列表：分别指出了目录，目录下目录列表，目录下的文件列表</span></span><br><span class="line"><span class="string">(&#x27;.&#x27;, [&#x27;dd&#x27;, &#x27;ll.dir&#x27;], [&#x27;1.jpg&#x27;])</span></span><br><span class="line"><span class="string">(&#x27;./dd&#x27;, [&#x27;e&#x27;], [&#x27;2.jpg&#x27;])</span></span><br><span class="line"><span class="string">(&#x27;./dd/e&#x27;, [], [&#x27;3.jpg&#x27;, &#x27;4.jpg&#x27;, &#x27;5.txt&#x27;])</span></span><br><span class="line"><span class="string">(&#x27;./ll.dir&#x27;, [], [&#x27;5.rar&#x27;])</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> path, dirs, files <span class="keyword">in</span> os.walk(directory):</span><br><span class="line">    <span class="comment"># print(str(files))</span></span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">        file = file.lower()  <span class="comment"># 都统一转换成小写</span></span><br><span class="line">        <span class="comment"># 如果没有后缀名则不纳入统计范围</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> re.match(<span class="string">r&#x27;[\s\S]*\.[\s\S]*&#x27;</span>, file):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="comment"># 得到后缀字符串</span></span><br><span class="line">        suffix = file.split(<span class="string">&quot;.&quot;</span>)[-<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># 从字典中取出后缀对应的count，如果没有则默认为0</span></span><br><span class="line">        count = res.setdefault(suffix, <span class="number">0</span>)</span><br><span class="line">        <span class="comment"># count ++</span></span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 将更新的count放回字典</span></span><br><span class="line">        res[suffix] = count</span><br><span class="line"></span><br><span class="line"><span class="comment"># print</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> res.keys():</span><br><span class="line">    <span class="built_in">print</span>(key + <span class="string">&quot; : &quot;</span> + <span class="built_in">str</span>(res[key]))</span><br></pre></td></tr></table></figure><p>将上述代码保存为<code>.py</code>文件，然后命令行执行<code>python xxx.py -d &lt;目录&gt;</code></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文涉及到的知识点：</p><ul><li>Shell<ul><li>find命令，查询目录/文件</li><li>cut命令，分割字符串</li><li>sort命令，排序</li><li>uniq命令，找到连续重复的行</li></ul></li><li>Python<ul><li>dict 基本操作</li><li>argparse库，脚本传参</li><li>os库，读目录/文件</li><li>re库，正则匹配</li></ul></li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://blog.csdn.net/nfer_zhuang/article/details/42582425">一句话脚本系列之统计文件夹下各种后缀名的文件个数</a></li><li><a href="https://www.runoob.com/python/os-walk.html">Python os.walk() 方法</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Scripts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python dict 笔记</title>
      <link href="/2021/12/28/Python-dict-%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/12/28/Python-dict-%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>字典（dict）是Python内置提供的一种常用数据结构，他用于存放具有映射（mapping）关系的数据。</p><p>可变对象。</p><h1 id="dict-常用操作"><a href="#dict-常用操作" class="headerlink" title="dict 常用操作"></a>dict 常用操作</h1><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>两种方式，使用dict()函数创建字典；使用花括号语法创建字典。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;&#125;</span><br><span class="line">dict2 = <span class="built_in">dict</span>()  <span class="comment"># 创建了一个空字典</span></span><br></pre></td></tr></table></figure><blockquote><p>dict的key必须为不可变类型，所以字符串、元组等类型可以作为dict的key，但像列表这种可变类型，不能作为dict的key</p></blockquote><p>在使用 dict() 函数创建字典时，可以传入多个列表或元组参数作为 key-value 对，每个列表或元组将被当成一个 key-value 对，因此这些列表或元组都只能包含两个元素。例如如下代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>person = [(<span class="string">&#x27;age&#x27;</span>, <span class="number">18</span>), (<span class="string">&#x27;sex&#x27;</span>, <span class="string">&#x27;male&#x27;</span>), (<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;gyj&#x27;</span>)]  <span class="comment"># 这里换成person = [[&#x27;age&#x27;, 18], [&#x27;sex&#x27;, &#x27;male&#x27;], [&#x27;name&#x27;, &#x27;gyj&#x27;]]也是可以的</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict3 = <span class="built_in">dict</span>(person)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict3</span><br><span class="line">&#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;male&#x27;</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;gyj&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="通过key访问value"><a href="#通过key访问value" class="headerlink" title="通过key访问value"></a>通过key访问value</h2><p>三种方式：</p><ul><li>通过方括号语法访问</li><li>使用get方法</li><li>使用setdefault()方法</li></ul><p>这三者不同的地方在于：</p><ul><li>使用方括号语法访问并不存在的key时，字典会引发KeyError错误</li><li>但如果使用get()方法访问不存在的key，该方法会简单地返回None，不会导致错误</li><li>使用setdefault()，当程序要获取的 key 在字典中不存在时，该方法会先为这个不存在的 key 设置一个默认的 value，然后再返回该 key 对应的 value。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">scores = &#123;<span class="string">&#x27;语文&#x27;</span>: <span class="number">89</span>&#125;</span><br><span class="line"><span class="comment"># 通过key访问value</span></span><br><span class="line">scores.get(<span class="string">&#x27;语文&#x27;</span>) <span class="comment"># 89</span></span><br><span class="line">scores.get(<span class="string">&#x27;数学&#x27;</span>) <span class="comment"># None</span></span><br><span class="line">scores[<span class="string">&#x27;数学&#x27;</span>] <span class="comment"># KeyError</span></span><br><span class="line">scores.setdefault(<span class="string">&#x27;数学&#x27;</span>, <span class="number">0</span>)  <span class="comment"># 0</span></span><br><span class="line">scores.setdefault(<span class="string">&#x27;语文&#x27;</span>, <span class="number">0</span>)  <span class="comment"># 89</span></span><br></pre></td></tr></table></figure><h2 id="通过key添加k-v对"><a href="#通过key添加k-v对" class="headerlink" title="通过key添加k-v对"></a>通过key添加k-v对</h2><p>例如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">scores[<span class="string">&#x27;数学&#x27;</span>] = <span class="number">93</span></span><br></pre></td></tr></table></figure><h2 id="通过key删除k-v对"><a href="#通过key删除k-v对" class="headerlink" title="通过key删除k-v对"></a>通过key删除k-v对</h2><p>使用del语句删除k-v对</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">del</span> scores[<span class="string">&#x27;语文&#x27;</span>]</span><br></pre></td></tr></table></figure><h2 id="通过key修改k-v对"><a href="#通过key修改k-v对" class="headerlink" title="通过key修改k-v对"></a>通过key修改k-v对</h2><p>两种方式：对存在的key-value对赋值，改变key-value对；使用update方法</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">scores[<span class="string">&#x27;数学&#x27;</span>] = <span class="number">95</span></span><br><span class="line">scores.update(&#123;<span class="string">&#x27;数学&#x27;</span>:<span class="number">100</span>&#125;)  <span class="comment"># 如果update的key不存在，那么会增加一个新的k-v对</span></span><br></pre></td></tr></table></figure><h2 id="判断指定key是否存在"><a href="#判断指定key是否存在" class="headerlink" title="判断指定key是否存在"></a>判断指定key是否存在</h2><p>使用in或not in 运算符判断key是否存在</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;数学&#x27;</span> <span class="keyword">in</span> scores  <span class="comment"># True</span></span><br><span class="line"><span class="string">&#x27;数学&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> scores    <span class="comment"># False</span></span><br></pre></td></tr></table></figure><h2 id="清空字典中所有的k-v对"><a href="#清空字典中所有的k-v对" class="headerlink" title="清空字典中所有的k-v对"></a>清空字典中所有的k-v对</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">scores.clear()</span><br></pre></td></tr></table></figure><h2 id="获取dict所有k-v对，所有key，所有value"><a href="#获取dict所有k-v对，所有key，所有value" class="headerlink" title="获取dict所有k-v对，所有key，所有value"></a>获取dict所有k-v对，所有key，所有value</h2><p>items()：获取字典中的所有 key-value 对</p><p>keys()：获取字典中的所有 key</p><p>values()：获取字典中的所有 value</p><p>这三个方法依次返回 dict_items、dict_keys 和 dict_values 对象，Python 不希望用户直接操作这几个方法，但可通过 list() 函数把它们转换成列表。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>scores = &#123;<span class="string">&#x27;数学&#x27;</span>: <span class="number">96</span>, <span class="string">&#x27;英语&#x27;</span>: <span class="number">88</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>scores.items()</span><br><span class="line">dict_items([(<span class="string">&#x27;数学&#x27;</span>, <span class="number">96</span>), (<span class="string">&#x27;英语&#x27;</span>, <span class="number">88</span>)])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(scores.items())</span><br><span class="line">[(<span class="string">&#x27;数学&#x27;</span>, <span class="number">96</span>), (<span class="string">&#x27;英语&#x27;</span>, <span class="number">88</span>)]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="弹出指定key的k-v对"><a href="#弹出指定key的k-v对" class="headerlink" title="弹出指定key的k-v对"></a>弹出指定key的k-v对</h2><p>pop() 方法用于获取指定 key 对应的 value，并删除这个 key-value 对。例如</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">math_score = scores.pop(<span class="string">&#x27;数学&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="随机弹出k-v对"><a href="#随机弹出k-v对" class="headerlink" title="随机弹出k-v对"></a>随机弹出k-v对</h2><p>popitem() 方法用于随机弹出字典中的一个 key-value 对。</p><blockquote><p>此处的随机其实是假的，正如列表的 pop() 方法总是弹出列表中最后一个元素，实际上字典的 popitem() 其实也是弹出字典中最后一个 key-value 对。由于字典存储 key-value 对的顺序是不可知的，因此开发者感觉字典的 popitem() 方法是“随机”弹出的，但实际上字典的 popitem() 方法总是弹出底层存储的最后一个 key-value 对。</p></blockquote><h2 id="根据给定的多个key创建字典"><a href="#根据给定的多个key创建字典" class="headerlink" title="根据给定的多个key创建字典"></a>根据给定的多个key创建字典</h2><p>fromkeys() 方法使用给定的多个 key 创建字典，参数可以是list也可以是tuple，这些 key 对应的 value 默认都是 None；也可以额外传入一个参数作为默认的 value。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用列表创建包含2个key的字典</span></span><br><span class="line">a_dict = <span class="built_in">dict</span>.fromkeys([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(a_dict) <span class="comment"># &#123;&#x27;a&#x27;: None, &#x27;b&#x27;: None&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用元组创建包含2个key的字典，指定默认的value</span></span><br><span class="line">c_dict = <span class="built_in">dict</span>.fromkeys((<span class="number">13</span>, <span class="number">17</span>), <span class="string">&#x27;good&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(c_dict) <span class="comment"># &#123;13: &#x27;good&#x27;, 17: &#x27;good&#x27;&#125;</span></span><br></pre></td></tr></table></figure><h2 id="使用字典格式化字符串"><a href="#使用字典格式化字符串" class="headerlink" title="使用字典格式化字符串"></a>使用字典格式化字符串</h2><p>举例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 字符串模板中使用key</span></span><br><span class="line">temp = <span class="string">&#x27;教程是:%(name)s, 价格是:%(price)010.2f, 出版社是:%(publish)s&#x27;</span></span><br><span class="line">book = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;Python基础教程&#x27;</span>, <span class="string">&#x27;price&#x27;</span>: <span class="number">99</span>, <span class="string">&#x27;publish&#x27;</span>: <span class="string">&#x27;C语言中文网&#x27;</span>&#125;</span><br><span class="line"><span class="comment"># 使用字典为字符串模板中的key传入值</span></span><br><span class="line"><span class="built_in">print</span>(temp % book)</span><br><span class="line">book = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;C语言小白变怪兽&#x27;</span>, <span class="string">&#x27;price&#x27;</span>:<span class="number">159</span>, <span class="string">&#x27;publish&#x27;</span>: <span class="string">&#x27;C语言中文网&#x27;</span>&#125;</span><br><span class="line"><span class="comment"># 使用字典为字符串模板中的key传入值</span></span><br><span class="line"><span class="built_in">print</span>(temp % book)</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="http://c.biancheng.net/view/2212.html">Python字典及基本操作（超级详细）</a></li><li>《Python 学习手册（第四版）》</li></ol>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LRU: 缓存淘汰算法</title>
      <link href="/2021/12/26/LRU-%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95/"/>
      <url>/2021/12/26/LRU-%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在使用缓存时，由于缓存容量有限，当缓存容量到达上限，就需要删除部分数据挪出空间。但是缓存数据不能随机删除，一般情况下需要根据某种算法删除缓存数据。</p><p>常用的淘汰算法有LRU, LFU, FIFO，本篇介绍LRU算法并重点讲述LRU的实现。完整代码也是<a href="https://leetcode-cn.com/problems/lru-cache/">LeetCode 146. LRU缓存</a>的答案。</p><h1 id="LRU-简介"><a href="#LRU-简介" class="headerlink" title="LRU 简介"></a>LRU 简介</h1><p>LRU是Least recently used的缩写，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。当缓存容量满的时候，优先淘汰最近最少被使用的数据。</p><p>根据以上策略，给出使用LRU淘汰算法时的示例。</p><p><img src="LRU淘汰算法示例.jpg" alt="LRU淘汰算法示例"></p><p>通过上图可以看到LRU算法的具体步骤是：</p><ol><li>新数据直接插入到列表头部</li><li>缓存数据被命中，将数据移动到链表头部</li><li>缓存已满，移除列表尾部数据。</li></ol><h1 id="LRU-算法实现"><a href="#LRU-算法实现" class="headerlink" title="LRU 算法实现"></a>LRU 算法实现</h1><p>上面看到LRU算法需要添加头节点，删除尾节点。而链表添加/删除节点的时间复杂度为O(1)，但这里不能使用普通的单向链表，原因在于：</p><ul><li>虽然单向链表添加/删除/移动元素比较方便，但是再查询元素时的时间复杂度为O(N)</li><li>移动中间节点到头节点需要知道前一个节点和后一个节点的信息，单向链表就不得不再次遍历获取信息。</li></ul><p>针对以上问题的解决方案是：</p><ul><li>使用散列表存储节点，获取节点的复杂度将为O(1)，</li><li>使用双向链表用来获得前驱节点的信息。</li></ul><p><img src="LRU数据结构.png" alt="LRU数据结构"></p><p>在这里，增加了两个【哨兵】节点，不用来存储任何数据，目的是再增加、删除结点的时候不用考虑节点不存在的情况。简化编程难度。</p><p>在算法实现的过程中，我发现LeetCode 146是类似的题目，故把该题直接拿来使用。</p><p>该题的算法签名是</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(key);</span></span><br><span class="line"><span class="comment"> * obj.put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>通过调用put\get方法实现存取缓存的目的。下面是对代码的逐步分析。</p><h2 id="双向链表数据结构"><a href="#双向链表数据结构" class="headerlink" title="双向链表数据结构"></a>双向链表数据结构</h2><p>这里使用一个内部类作为双向链表的数据结构。比较简单，直接给出代码。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">//定义一个内部类，作为缓存列表</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&#123;</span><br><span class="line">       <span class="keyword">public</span> Entry pre; <span class="comment">//指向前驱的指针</span></span><br><span class="line">       <span class="keyword">public</span> Entry next; <span class="comment">//指向后继的指针</span></span><br><span class="line">       <span class="keyword">public</span> <span class="type">int</span> key; <span class="comment">//缓存的key</span></span><br><span class="line">       <span class="keyword">public</span> <span class="type">int</span> value; <span class="comment">//缓存的value</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> <span class="title function_">Entry</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">           <span class="built_in">this</span>.key = key;</span><br><span class="line">           <span class="built_in">this</span>.value = value;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">public</span> <span class="title function_">Entry</span><span class="params">()</span> &#123;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="定义成员变量和构造函数"><a href="#定义成员变量和构造函数" class="headerlink" title="定义成员变量和构造函数"></a>定义成员变量和构造函数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Entry head, tail; <span class="comment">//头尾两个哨兵节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> capacity; <span class="comment">// 容量</span></span><br><span class="line"><span class="type">int</span> size; <span class="comment">//当前缓存大小</span></span><br><span class="line">Map&lt;Integer, Entry&gt; cache; <span class="comment">//缓存散列表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    <span class="comment">//初始化操作</span></span><br><span class="line">    initLinkedList();</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化操作函数<code>initLinkedList()</code>的实现是将head和tail通过指针连接起来。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">       head = <span class="keyword">new</span> <span class="title class_">Entry</span>();</span><br><span class="line">       tail = <span class="keyword">new</span> <span class="title class_">Entry</span>();</span><br><span class="line"></span><br><span class="line">       head.next = tail;</span><br><span class="line">       tail.pre = head;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="put操作"><a href="#put操作" class="headerlink" title="put操作"></a>put操作</h2><p>put操作可以分三种情况：</p><ol><li>如果key已经存在与缓存中，则将key对应的节点移动到链表头部，并重设value</li><li>如果key在缓存中不存在，那么检查缓存是否已满<ol><li>如果未满，就直接将新节点加入到链表头部</li><li>如果已满，就先删除尾节点，再将新节点加入到链表头部</li></ol></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="type">Entry</span> <span class="variable">node</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">    <span class="comment">//如果key在缓存中已经存在，则移动到头部</span></span><br><span class="line">    <span class="keyword">if</span>(node != <span class="literal">null</span>) &#123;</span><br><span class="line">        node.value = value;</span><br><span class="line">        move2Head(node);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//容量已满先删除尾节点</span></span><br><span class="line">    <span class="keyword">if</span>(size == capacity) &#123;</span><br><span class="line">        <span class="type">Entry</span> <span class="variable">lastNode</span> <span class="operator">=</span> tail.pre;</span><br><span class="line">        deleteNode(lastNode);</span><br><span class="line">        cache.remove(lastNode.key);</span><br><span class="line">        size --;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//add new Node</span></span><br><span class="line">    <span class="type">Entry</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Entry</span>();</span><br><span class="line">    newNode.key = key;</span><br><span class="line">    newNode.value = value;</span><br><span class="line">    addNode(newNode);</span><br><span class="line">    cache.put(key, newNode);</span><br><span class="line">    size ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于<code>move2Head</code>操作，无非是先删除原来的节点关系<code>deleteNode</code>，再添加到队列头部<code>addNode</code></p><p>而<code>deleteNode</code>和<code>addNode</code>是比较基础的双向链表操作，这里就不再做过多解释。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addNode</span><span class="params">(Entry node)</span> &#123;</span><br><span class="line">    head.next.pre = node;</span><br><span class="line">    node.next = head.next;</span><br><span class="line"></span><br><span class="line">    node.pre = head;</span><br><span class="line">    head.next = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">deleteNode</span><span class="params">(Entry node)</span> &#123;</span><br><span class="line">    node.pre.next = node.next;</span><br><span class="line">    node.next.pre = node.pre;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">move2Head</span><span class="params">(Entry node)</span> &#123;</span><br><span class="line">    <span class="comment">//删除原来的节点关系</span></span><br><span class="line">    deleteNode(node);</span><br><span class="line">    addNode(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="get-操作"><a href="#get-操作" class="headerlink" title="get 操作"></a>get 操作</h2><p>当key不在缓存中，返回-1，当key存在于缓存时，就将该元素移动到链表头部，并返回对应的value。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">       <span class="type">Entry</span> <span class="variable">node</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">       <span class="keyword">if</span>(node == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       move2Head(node);</span><br><span class="line">       <span class="keyword">return</span> node.value;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Entry head, tail;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity; <span class="comment">// 容量</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    Map&lt;Integer, Entry&gt; cache;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="comment">//初始化操作</span></span><br><span class="line">        initLinkedList();</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(capacity + <span class="number">2</span>); <span class="comment">//这里为什么要+2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">Entry</span>();</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">Entry</span>();</span><br><span class="line"></span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.pre = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">Entry</span> <span class="variable">node</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        move2Head(node);</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将节点插入到头节点，如果容量已满，则会删除尾节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="type">Entry</span> <span class="variable">node</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">        <span class="comment">//如果key在缓存中已经存在，则移动到头部</span></span><br><span class="line">        <span class="keyword">if</span>(node != <span class="literal">null</span>) &#123;</span><br><span class="line">            node.value = value;</span><br><span class="line">            move2Head(node);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//容量已满先删除尾节点</span></span><br><span class="line">        <span class="keyword">if</span>(size == capacity) &#123;</span><br><span class="line">            <span class="type">Entry</span> <span class="variable">lastNode</span> <span class="operator">=</span> tail.pre;</span><br><span class="line">            deleteNode(lastNode);</span><br><span class="line">            cache.remove(lastNode.key);</span><br><span class="line">            size --;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//add new Node</span></span><br><span class="line">        <span class="type">Entry</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Entry</span>();</span><br><span class="line">        newNode.key = key;</span><br><span class="line">        newNode.value = value;</span><br><span class="line">        addNode(newNode);</span><br><span class="line">        cache.put(key, newNode);</span><br><span class="line">        size ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addNode</span><span class="params">(Entry node)</span> &#123;</span><br><span class="line">        head.next.pre = node;</span><br><span class="line">        node.next = head.next;</span><br><span class="line"></span><br><span class="line">        node.pre = head;</span><br><span class="line">        head.next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">deleteNode</span><span class="params">(Entry node)</span> &#123;</span><br><span class="line">        node.pre.next = node.next;</span><br><span class="line">        node.next.pre = node.pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">move2Head</span><span class="params">(Entry node)</span> &#123;</span><br><span class="line">        <span class="comment">//删除原来的节点关系</span></span><br><span class="line">        deleteNode(node);</span><br><span class="line">        addNode(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个内部类，作为缓存链表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> Entry pre; <span class="comment">//指向前驱的指针</span></span><br><span class="line">        <span class="keyword">public</span> Entry next; <span class="comment">//指向后继的指针</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> key; <span class="comment">//缓存的key</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> value; <span class="comment">//缓存的value</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Entry</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Entry</span><span class="params">()</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://www.bilibili.com/video/BV1Va411677h">手写LRU算法 - IT老哥</a></li><li><a href="https://zhuanlan.zhihu.com/p/34133067">LRU原理和Redis实现——一个今日头条的面试题</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tmux 简介</title>
      <link href="/2021/12/26/Tmux-%E7%AE%80%E4%BB%8B/"/>
      <url>/2021/12/26/Tmux-%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是Tmux"><a href="#什么是Tmux" class="headerlink" title="什么是Tmux"></a>什么是Tmux</h1><p>打开一个终端窗口（terminal window，以下简称”窗口”），在里面输入命令。</p><p>用户与计算机的这种临时的交互，称为一次”会话”（session） 。</p><p>会话的一个重要特点是，窗口与其中启动的进程是<a href="https://www.ruanyifeng.com/blog/2016/02/linux-daemon.html">连在一起</a>的。打开窗口，会话开始；关闭窗口，会话结束。</p><p>一个典型的例子，打开一个远程窗口执行命令，这时关闭窗口，那么会话也就终止，里面的进程也随之终止。</p><p>为了解决这个问题，会话与窗口可以”解绑”：窗口关闭时，会话并不终止，而是继续运行，等到以后需要的时候，再让会话”绑定”其他窗口。</p><p><strong>Tmux 就是会话与窗口的”解绑”工具</strong>。</p><h1 id="使用Tmux"><a href="#使用Tmux" class="headerlink" title="使用Tmux"></a>使用Tmux</h1><h2 id="安装Tmux"><a href="#安装Tmux" class="headerlink" title="安装Tmux"></a>安装Tmux</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Ubuntu 或 Debian</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get install tmux</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">CentOS 或 Fedora</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo yum install tmux</span></span><br></pre></td></tr></table></figure><h2 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h2><p>直接给出最常用的操作流程如下：</p><ul><li>新建会话<code>tmux new -s &lt;session_name&gt;</code>。（第一个启动的 Tmux 窗口，编号是0，第二个窗口的编号是1，以此类推。）</li><li>在 Tmux 窗口运行所需的程序。</li><li>按下快捷键<code>Ctrl+b d</code>将会话分离。</li><li>下次使用时，重新连接到会话<code>tmux a -t &lt;session_name&gt;</code>。</li></ul><h2 id="其他Tricks"><a href="#其他Tricks" class="headerlink" title="其他Tricks"></a>其他Tricks</h2><ul><li><code>Ctrl+b s</code>：列出所有会话。</li><li><code>tmux rename-session -t 0 &lt;new-name&gt;</code>：重命名会话。</li><li><code>tmux kill-session -t &lt;session-name&gt;</code>：杀死会话。</li><li><code>Ctrl+b [</code>：进入会话后，使用该快捷命令查看控制台历史消息，可通过键盘上的上下左右键来滚动历史输出信息。如果要退出查看模式，按下q即可。</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://www.ruanyifeng.com/blog/2019/10/tmux.html">Tmux 使用教程</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 开发工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>火车站台数量问题</title>
      <link href="/2021/12/25/%E7%81%AB%E8%BD%A6%E7%AB%99%E5%8F%B0%E6%95%B0%E9%87%8F%E9%97%AE%E9%A2%98/"/>
      <url>/2021/12/25/%E7%81%AB%E8%BD%A6%E7%AB%99%E5%8F%B0%E6%95%B0%E9%87%8F%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="题干"><a href="#题干" class="headerlink" title="题干"></a>题干</h1><p>假设已知某个火车站的所有过往列车的到达arrival和离开departure时间（同一天），如果要求所有列车都不等待直接进站，问至少需要多少个站台。无需考虑晚点等特殊情况。</p><p>例如，<br> Input：<br> 到达时间：  arr[]  = {9:00,  9:40, 9:50,  11:00, 15:00, 18:00}<br> 离开时间：  dep[]  = {9:10, 12:00, 11:20, 11:30, 19:00, 20:00}</p><p><em>注：方便起见，输入为int，例如：9:00的输入是900</em></p><p>Output：<br> 3  （最多有3辆列车同时进站（在11:00到11:20之间））</p><h1 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h1><p>暴力解法。逐个检查每个车辆的<strong>停发时间段</strong>，然后看有多少个时间段区间与其有重合，记录最多的重合区间数目，即为待求解的答案。易知，此方法的时间复杂度为O(n^2)。</p><p>下面给出代码，<em>代码只经过简单测试，如有误请通过邮箱联系我</em></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"><span class="keyword">from</span> traitlets <span class="keyword">import</span> Int</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxPlatform</span>(<span class="params">self, arr: <span class="type">List</span>[Int], dep: <span class="type">List</span>[Int]</span>) -&gt; Int:</span><br><span class="line">        n = <span class="built_in">len</span>(arr)</span><br><span class="line">        max_platform = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            now_platform = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> dep[i] &gt; arr[j]:</span><br><span class="line">                    now_platform += <span class="number">1</span></span><br><span class="line">                max_platform = <span class="built_in">max</span>(max_platform, now_platform)</span><br><span class="line">        <span class="keyword">return</span> max_platform</span><br></pre></td></tr></table></figure><h1 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h1><p>将所有的<strong>事件</strong> (到达或离开)按时间顺序排序，然后只记录当前还在车站（未离开的）列车。所有时间点中最多数量列车即待求解的答案。该解法的时间复杂度为O(n·logn)</p><p>例如上述出发到达时间排序得到下表：</p><div class="table-container"><table><thead><tr><th>时间</th><th>事件</th><th>站台数</th></tr></thead><tbody><tr><td>9:00</td><td>Arrival</td><td>1</td></tr><tr><td>9:10</td><td>Departure</td><td>0</td></tr><tr><td>9:40</td><td>Arrival</td><td>1</td></tr><tr><td>9:50</td><td>Arrival</td><td>2</td></tr><tr><td>11:00</td><td>Arrival</td><td><strong>3</strong></td></tr><tr><td>11:20</td><td>Departure</td><td>2</td></tr><tr><td>11:30</td><td>Departure</td><td>1</td></tr><tr><td>12:00</td><td>Departure</td><td>0</td></tr><tr><td>15:00</td><td>Arrival</td><td>1</td></tr><tr><td>18:00</td><td>Arrival</td><td>2</td></tr><tr><td>19:00</td><td>Departure</td><td>1</td></tr><tr><td>20:00</td><td>Departure</td><td>0</td></tr></tbody></table></div><p>最多需要3站台。</p><p>在算法实现时，只需要对arr、dep数组单独排序，然后在进行有序数组的归并排序。下面给出代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxPlatform</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span>[] dep)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        Arrays.sort(dep); <span class="comment">//分别对到达和离开排序</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">numPlatform</span> <span class="operator">=</span> <span class="number">0</span>, maxPlatform = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>; <span class="comment">//两个指针</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; n || j &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; n &amp;&amp; j &lt; n) &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i] &lt; dep[j]) &#123;</span><br><span class="line">                    numPlatform++;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(arr[i] &gt; dep[j])&#123;</span><br><span class="line">                    numPlatform--;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(j&gt;=n) &#123; <span class="comment">// 此时还将继续有火车进站</span></span><br><span class="line">                numPlatform++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 此时只有火车出站</span></span><br><span class="line">                numPlatform--;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            maxPlatform = Math.max(maxPlatform, numPlatform);</span><br><span class="line"><span class="comment">//            System.out.println(numPlatform);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxPlatform;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这是之前遇到的一道面试题，挺巧妙的。当时没做出来，故做一个小结。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://www.jianshu.com/p/3948fda91d3d">火车站台数量问题</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-初识注解</title>
      <link href="/2021/12/23/Java-%E5%88%9D%E8%AF%86%E6%B3%A8%E8%A7%A3/"/>
      <url>/2021/12/23/Java-%E5%88%9D%E8%AF%86%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="初识注解"><a href="#初识注解" class="headerlink" title="初识注解"></a>初识注解</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>Annotation提供了一种为恒旭元素设置元数据的方法。</li><li>类似于修饰符，可用于修饰包、类、构造器、方法、成员变量、参数、局部变量的声明。</li><li>Annotation是一个接口，程序可以通过反射来获取指定程序元素的Annotation对象。</li><li>Annotation不影响程序代码的运行。</li><li>如果希望Annotation在程序运行时起作用，只有通过某种配套工具对Annotation的信息进行访问和处理。访问和处理Annotation的工具统称为APT。</li></ul><h2 id="内置注解"><a href="#内置注解" class="headerlink" title="内置注解"></a>内置注解</h2><p>Java定义了一套注解如下。</p><ul><li>以下注解在java.lang中：<ul><li><strong>@Override</strong> - 检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。</li><li><strong>@Deprecated</strong> - 标记过时方法。如果使用该方法，会报编译警告。</li><li><strong>@SuppressWarnings</strong> - 指示编译器去忽略注解中声明的警告。</li><li>@SafeVarargs - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。</li><li><strong>@FunctionalInterface</strong> - Java 8 开始支持，标识一个匿名函数或函数式接口。</li></ul></li><li>以下注解在java.lang.annotation中，他们作用在其他注解中，也成为<strong>元注解</strong>：<ul><li><strong>@Retention</strong> - 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。</li><li>@Documented - 标记这些注解是否包含在用户文档中。</li><li><strong>@Target</strong> - 标记这个注解应该是哪种 Java 成员。</li><li><strong>@Inherited</strong> - 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类)<ul><li>详解：假设，我们定义了某个 Annotaion，它的名称是 MyAnnotation，并且 MyAnnotation 被标注为 @Inherited。现在，某个类 Base 使用了MyAnnotation，则 Base “具有了注解 MyAnnotation”；现在，Sub 继承了 Base，由于 MyAnnotation 是 @Inherited的(具有继承性)，所以，Sub 也 “具有了注解 MyAnnotation”。</li></ul></li><li>@Repeatable - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。</li></ul></li></ul><h2 id="Annotation架构"><a href="#Annotation架构" class="headerlink" title="Annotation架构"></a>Annotation架构</h2><p><img src="1.jpg" alt="Annotation架构"></p><p>从中可以看出：</p><ol><li>1个Annotation对象，都会有唯一的RetentionPolicy属性。</li><li>1 个 Annotation 对象，可以有若干个 ElementType 属性。</li><li>Annotation 有许多实现类，包括：Deprecated, Documented, Inherited, Override 等等。</li></ol><p>下面介绍，在java Annotation的组成中，有三个重要的主干类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Annotation.java</span></span><br><span class="line"><span class="keyword">package</span> java.lang.annotation;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Annotation</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">toString</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; annotationType();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ElementType.java</span></span><br><span class="line"><span class="keyword">package</span> java.lang.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ElementType</span> &#123;</span><br><span class="line">    TYPE,               <span class="comment">/* 类、接口（包括注释类型）或枚举声明  */</span></span><br><span class="line"></span><br><span class="line">    FIELD,              <span class="comment">/* 字段声明（包括枚举常量）  */</span></span><br><span class="line"></span><br><span class="line">    METHOD,             <span class="comment">/* 方法声明  */</span></span><br><span class="line"></span><br><span class="line">    PARAMETER,          <span class="comment">/* 参数声明  */</span></span><br><span class="line"></span><br><span class="line">    CONSTRUCTOR,        <span class="comment">/* 构造方法声明  */</span></span><br><span class="line"></span><br><span class="line">    LOCAL_VARIABLE,     <span class="comment">/* 局部变量声明  */</span></span><br><span class="line"></span><br><span class="line">    ANNOTATION_TYPE,    <span class="comment">/* 注释类型声明  */</span></span><br><span class="line"></span><br><span class="line">    PACKAGE             <span class="comment">/* 包声明  */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//RetentionPolicy.java</span></span><br><span class="line"><span class="keyword">package</span> java.lang.annotation;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">RetentionPolicy</span> &#123;</span><br><span class="line">    SOURCE,            <span class="comment">/* Annotation信息仅存在于编译器处理期间，编译器处理完之后就没有该Annotation信息了  */</span></span><br><span class="line"></span><br><span class="line">    CLASS,             <span class="comment">/* 编译器将Annotation存储于类对应的.class文件中。默认行为  */</span></span><br><span class="line"></span><br><span class="line">    RUNTIME            <span class="comment">/* 编译器将Annotation存储于class文件中，并且可由JVM读入 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ol><li>Annotation是一个接口，继承这个接口的就是注解。</li><li><strong>ElementType 是 Enum 枚举类型，它用来指定 Annotation 的类型。</strong><ol><li>例如，若一个 Annotation 对象是 METHOD 类型，则该 Annotation 只能用来修饰方法。</li></ol></li><li><strong>RetentionPolicy 是 Enum 枚举类型，它用来指定 Annotation 的策略。通俗点说，就是不同 RetentionPolicy 类型的 Annotation 的作用域不同。</strong><ol><li>若 Annotation 的类型为 SOURCE，则意味着：Annotation 仅存在于编译器处理期间，编译器处理完之后，该 Annotation 就没用了。 例如，” @Override” 标志就是一个 Annotation。当它修饰一个方法的时候，就意味着该方法覆盖父类的方法；并且在编译期间会进行语法检查！编译器处理完后，”@Override” 就没有任何作用了。</li><li>若 Annotation 的类型为 CLASS，则意味着：编译器将 Annotation 存储于类对应的 .class 文件中，它是 Annotation 的默认行为。</li><li>若 Annotation 的类型为 RUNTIME，则意味着：编译器将 Annotation 存储于 class 文件中，并且可由JVM读入。</li></ol></li></ol><h2 id="注解通用定义"><a href="#注解通用定义" class="headerlink" title="注解通用定义"></a>注解通用定义</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation1 &#123;</span><br><span class="line">    <span class="comment">//属性列表</span></span><br><span class="line">    <span class="comment">//Annotation的成员变量在Annotation定义中以无形参方法形式来声明，其方法名和返回值定义了该成员变量的名字和类型。</span></span><br><span class="line">    <span class="comment">//注解元素的类型可以为：基本类型，String，Class，枚举类型，注解类型，以及前面所述类型组成的数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：上面的作用是定义了一个注解，名为MyAnnotation1。定义了MyAnnotation1之后，我们可以在代码中通过@MyAnnotation1使用它。其他的，@Documented, @Target, @Retention, @interface都是来修饰MyAnnotation1的。</p><ul><li><p><strong>@interface</strong>：使用 @interface <strong>关键字</strong>定义注解时，意味着它实现了java.lang.annotation.Annotation 接口，即该注解就是一个Annotation。</p></li><li><p><strong>@Documented</strong>：类和方法的 Annotation 在缺省情况下是不出现在 javadoc 中的。如果使用 @Documented 修饰该 Annotation，则表示它可以出现在 javadoc 中。定义 Annotation 时，@Documented 可有可无；若没有定义，则 Annotation 不会出现在 javadoc 中。</p></li><li><p><strong>@Target(ElementType.TYPE)</strong>：ElementType 是 Annotation 的类型属性。而 @Target 的作用，就是来指定 Annotation 的类型属性。</p><p>@Target(ElementType.TYPE) 的意思就是指定该 Annotation 的类型是 ElementType.TYPE。这就意味着，MyAnnotation1 是来修饰”类、接口（包括注释类型）或枚举声明”的注解。</p><p>定义 Annotation 时，@Target 可有可无。若有 @Target，则该 Annotation 只能用于它所指定的地方；若没有 @Target，则该 Annotation 可以用于任何地方。</p></li><li><p><strong>@Retention(RetentionPolicy.RUNTIME)</strong>：前面我们说过，RetentionPolicy 是 Annotation 的策略属性，而 @Retention 的作用，就是指定 Annotation 的策略属性。</p><p>@Retention(RetentionPolicy.RUNTIME) 的意思就是指定该 Annotation 的策略是 RetentionPolicy.RUNTIME。这就意味着，编译器会将该 Annotation 信息保留在 .class 文件中，并且能被虚拟机读取。</p><p>定义 Annotation 时，@Retention 可有可无。若没有 @Retention，则默认是 RetentionPolicy.CLASS。</p></li></ul><p>根据注解是否包含成员变量，可以把注解分为</p><ul><li>标记注解：没有成员变量的注解，这种注解仅利用自身是否存在来提供信息。</li><li>元数据注解：包含成员变量的注解，因为它可以接受更多的元数据，所以也被称为元数据注解。</li></ul><h2 id="Annotation作用"><a href="#Annotation作用" class="headerlink" title="Annotation作用"></a>Annotation作用</h2><h3 id="编译检查"><a href="#编译检查" class="headerlink" title="编译检查"></a>编译检查</h3><p>Annotation 具有”让编译器进行编译检查的作用”。@SuppressWarnings, @Deprecated 和 @Override 都具有编译检查作用。</p><h3 id="☆在反射中解析并使用-Annotation"><a href="#☆在反射中解析并使用-Annotation" class="headerlink" title="☆在反射中解析并使用 Annotation"></a>☆在反射中解析并使用 Annotation</h3><p>程序通过反射机制可以解析被修饰的方法中的注解数据，当程序获取特殊标记后，可以做出相应的处理。这在Spring等框架中经常使用。详见下面代码。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AnnotationTest.java</span></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Annotation;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Inherited;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Annotation在反射函数中的使用示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 说明：在这里，我们不能把value()看成一个方法，而是一个同名的变量</span></span><br><span class="line"><span class="comment">     * 在使用的时候可以通过@MyAnnotation(value=&#123;&quot;a&quot;,&quot;b&quot;&#125;来赋值</span></span><br><span class="line"><span class="comment">     * default 给value制定了默认值</span></span><br><span class="line"><span class="comment">     * 如果注解的属性只有一个，且叫value，那么使用该注解时，可以不用指定属性名，因为默认就是给value赋值：</span></span><br><span class="line"><span class="comment">     * @MyAnnotation(&#123;&quot;a&quot;,&quot;b&quot;&#125;) //这样也是可以的</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">    String[] value() default &quot;unknown&quot;;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Person类。它会使用MyAnnotation注解。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * empty()方法同时被 &quot;<span class="doctag">@Deprecated</span>&quot; 和 &quot;<span class="doctag">@MyAnnotation</span>(value=&#123;&quot;a&quot;,&quot;b&quot;&#125;)&quot;所标注</span></span><br><span class="line"><span class="comment">     * (01) <span class="doctag">@Deprecated</span>，意味着empty()方法，不再被建议使用</span></span><br><span class="line"><span class="comment">     * (02) <span class="doctag">@MyAnnotation</span>, 意味着empty() 方法对应的MyAnnotation的value值是默认值&quot;unknown&quot;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@MyAnnotation</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">empty</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;\nempty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * sombody() 被 <span class="doctag">@MyAnnotation</span>(value=&#123;&quot;girl&quot;,&quot;boy&quot;&#125;) 所标注，</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@MyAnnotation</span>(value=&#123;&quot;girl&quot;,&quot;boy&quot;&#125;), 意味着MyAnnotation的value值是&#123;&quot;girl&quot;,&quot;boy&quot;&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@MyAnnotation(value=&#123;&quot;girl&quot;,&quot;boy&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">somebody</span><span class="params">(String name, <span class="type">int</span> age)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;\nsomebody: &quot;</span>+name+<span class="string">&quot;, &quot;</span>+age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 新建Person</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="comment">// 获取Person的Class实例</span></span><br><span class="line">        Class&lt;Person&gt; c = Person.class;</span><br><span class="line">        <span class="comment">// 获取 somebody() 方法的Method实例</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">mSomebody</span> <span class="operator">=</span> c.getMethod(<span class="string">&quot;somebody&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, <span class="type">int</span>.class&#125;);</span><br><span class="line">        <span class="comment">// 执行该方法</span></span><br><span class="line">        mSomebody.invoke(person, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;lily&quot;</span>, <span class="number">18</span>&#125;);</span><br><span class="line">        iteratorAnnotations(mSomebody);</span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 somebody() 方法的Method实例</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">mEmpty</span> <span class="operator">=</span> c.getMethod(<span class="string">&quot;empty&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;&#125;);</span><br><span class="line">        <span class="comment">// 执行该方法</span></span><br><span class="line">        mEmpty.invoke(person, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;&#125;);        </span><br><span class="line">        iteratorAnnotations(mEmpty);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">iteratorAnnotations</span><span class="params">(Method method)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断 somebody() 方法是否包含MyAnnotation注解</span></span><br><span class="line">        <span class="keyword">if</span>(method.isAnnotationPresent(MyAnnotation.class))&#123;</span><br><span class="line">            <span class="comment">// 获取该方法的MyAnnotation注解实例</span></span><br><span class="line">            <span class="type">MyAnnotation</span> <span class="variable">myAnnotation</span> <span class="operator">=</span> method.getAnnotation(MyAnnotation.class);</span><br><span class="line">            <span class="comment">// 获取 myAnnotation的值，并打印出来</span></span><br><span class="line">            String[] values = myAnnotation.value();</span><br><span class="line">            <span class="keyword">for</span> (String str:values)</span><br><span class="line">                System.out.printf(str+<span class="string">&quot;, &quot;</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 获取方法上的所有注解，并打印出来</span></span><br><span class="line">        Annotation[] annotations = method.getAnnotations();</span><br><span class="line">        <span class="keyword">for</span>(Annotation annotation : annotations)&#123;</span><br><span class="line">            System.out.println(annotation);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">somebody: lily, 18</span><br><span class="line">girl, boy, </span><br><span class="line">@com.skywang.annotation.MyAnnotation(value=[girl, boy])</span><br><span class="line"></span><br><span class="line">empty</span><br><span class="line">unknown, </span><br><span class="line">@com.skywang.annotation.MyAnnotation(value=[unknown])</span><br><span class="line">@java.lang.Deprecated()</span><br></pre></td></tr></table></figure><h3 id="根据Annotation生成帮助文档"><a href="#根据Annotation生成帮助文档" class="headerlink" title="根据Annotation生成帮助文档"></a>根据Annotation生成帮助文档</h3><p>@Documented</p><h3 id="帮忙查看代码"><a href="#帮忙查看代码" class="headerlink" title="帮忙查看代码"></a>帮忙查看代码</h3><p>通过 @Override, @Deprecated 等，我们能很方便的了解程序的大致结构。</p><h3 id="附属文件的自动生成"><a href="#附属文件的自动生成" class="headerlink" title="附属文件的自动生成"></a>附属文件的自动生成</h3><p>例如部署描述符或者bean信息类。</p><h3 id="测试、日志等代码的自动生成"><a href="#测试、日志等代码的自动生成" class="headerlink" title="测试、日志等代码的自动生成"></a>测试、日志等代码的自动生成</h3><p>//TODO</p><h2 id="框架中常用的注解"><a href="#框架中常用的注解" class="headerlink" title="框架中常用的注解"></a>框架中常用的注解</h2><h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><p>//TODO</p><h3 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h3><p>//TODO</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li><p>注解就像标签，是程序判断执行的依据。比如，程序读到@Test就知道这个方法是待测试方法，而@Before的方法要在测试方法之前执行</p></li><li><p>注解需要三要素：定义、使用、<strong>读取并执行</strong></p></li><li>注解分为自定义注解、JDK内置注解和第三方注解（框架）。自定义注解一般要我们自己定义、使用、并写程序读取，而JDK内置注解和第三方注解我们只要使用，定义和读取都交给它们</li><li>大多数情况下，三角关系中我们只负责使用注解，无需定义和执行，框架会将注解类和读取注解的程序隐藏起来，除非阅读源码，否则根本看不到。平时见不到定义和读取的过程，光顾着使用注解，久而久之很多人就忘了注解如何起作用了！</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://www.zhihu.com/question/47449512/answer/658228092">怎样理解 Java 注解和运用注解编程？</a></li><li><a href="https://www.runoob.com/w3cnote/java-annotation.html">菜鸟教程-Java 注解（Annotation）</a></li><li>《Java疯狂讲义 第十四章 注解》</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编写脚本读取文件并执行命令</title>
      <link href="/2021/12/21/%E7%BC%96%E5%86%99%E8%84%9A%E6%9C%AC%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E5%B9%B6%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/12/21/%E7%BC%96%E5%86%99%E8%84%9A%E6%9C%AC%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E5%B9%B6%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>最近遇到如下需求：</p><blockquote><p>有一个文件，文件格式大概是这样</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;filename1&gt;\t&lt;download_url1&gt;</span><br><span class="line"></span><br><span class="line">&lt;filename2&gt;\t&lt;download_url2&gt;</span><br></pre></td></tr></table></figure><p>编写一个脚本循环读取该文件的每一行，使用<code>axel</code>命令将<code>download_url</code>下载下来，保存为本地文件<code>filename</code></p></blockquote><h1 id="Bash"><a href="#Bash" class="headerlink" title="Bash"></a>Bash</h1><p>先给出Code：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ./download.sh &lt;filename&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> <span class="variable">$1</span> | <span class="keyword">while</span> <span class="built_in">read</span> line</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="comment"># echo $&#123;line&#125;</span></span><br><span class="line">    array=(<span class="variable">$&#123;line// / &#125;</span>) <span class="comment"># array=($&#123;line//\t/ &#125;) 不生效</span></span><br><span class="line">    <span class="comment"># echo $&#123;array[0]&#125; + &quot;;&quot; + $&#123;array[1]&#125; </span></span><br><span class="line">    cmd=<span class="string">&#x27;axel -o &#x27;</span><span class="variable">$&#123;array[0]&#125;</span><span class="string">&#x27; &quot;&#x27;</span><span class="variable">$&#123;array[1]&#125;</span><span class="string">&#x27;&quot;&#x27;</span></span><br><span class="line">    <span class="built_in">eval</span> <span class="variable">$cmd</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>下面对code逐一解释</p><h2 id="bin-bash"><a href="#bin-bash" class="headerlink" title="#! /bin/bash"></a>#! /bin/bash</h2><p><strong>#!/bin/bash</strong>是指此脚本使用<strong>/bin/bash</strong>来解释执行，Bash脚本首行固定写法。</p><h2 id="Bash注释"><a href="#Bash注释" class="headerlink" title="Bash注释"></a>Bash注释</h2><p>Bash中使用<code>#</code>进行单行注释，见如上代码第三行</p><h2 id="Bash-接收外部参数"><a href="#Bash-接收外部参数" class="headerlink" title="Bash 接收外部参数"></a>Bash 接收外部参数</h2><p>我们可以在执行 Shell 脚本时，向脚本传递参数，脚本内获取参数的格式为：<strong>$n</strong>。<strong>n</strong> 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推……</p><p>特殊的 ，<strong>$0</strong> 表示脚本名称（含路径）。</p><p>另外，<strong>$#</strong> 表示传递参数的个数。</p><p>上面代码中<code>cat $1 |</code>就是将第一个参数作为文件名，读取文件中的内容，通过管道命令<code>|</code>将文件内容传给while循环</p><h2 id="Bash-循环读取每一行"><a href="#Bash-循环读取每一行" class="headerlink" title="Bash 循环读取每一行"></a>Bash 循环读取每一行</h2><p>最简单的</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> line</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$line</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>还可以使用for循环等，详细可参见参考资料1。</p><h2 id="Bash按指定字符分割字符串"><a href="#Bash按指定字符分割字符串" class="headerlink" title="Bash按指定字符分割字符串"></a>Bash按指定字符分割字符串</h2><p>接上文，line是待处理的字符串，则指定分隔符<code>\t</code>将line分割后的字符串数组存放到array，</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">array=(<span class="variable">$&#123;line// / &#125;</span>)</span><br></pre></td></tr></table></figure><p>注意这里<code>//</code>和<code>/</code>之间是一个制表符，而不是空格。</p><p>我也曾使用<code>array=($&#123;line//\t/ &#125;)</code>来进行分割，但是测试后发现它会按照字符<code>t</code>对字符串进行分割。</p><p><em>还没弄明白语法规则</em></p><h2 id="Bash字符串拼接"><a href="#Bash字符串拼接" class="headerlink" title="Bash字符串拼接"></a>Bash字符串拼接</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmd=<span class="string">&#x27;axel -o &#x27;</span><span class="variable">$&#123;array[0]&#125;</span><span class="string">&#x27; &quot;&#x27;</span><span class="variable">$&#123;array[1]&#125;</span><span class="string">&#x27;&quot;&#x27;</span></span><br></pre></td></tr></table></figure><p>这一行就是取array中的值进行字符串拼接，注意取值的语法<code>$&#123;&#125;</code></p><ul><li><p>Bash中对字符串拼接不需要使用<code>+</code>进行连接</p></li><li><p>这里使用单引号是为了避免对双引号转义</p></li></ul><h2 id="Bash执行cmd"><a href="#Bash执行cmd" class="headerlink" title="Bash执行cmd"></a>Bash执行cmd</h2><p><code>eval $cmd</code>是读取变量cmd的值当作一条Shell命令进行执行</p><h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><p>上面的代码先读取每一行，在对行按照制表符进行分割。其实可以更简洁：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> filenameurl</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="comment">#echo $filename</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>同样的需要注意<code>filename</code>，<code>url</code>之间是一个制表符而不是空格。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>当url过长时，该脚本并不能完整的读取url。例如，当文件如下时</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">covid19-image-dataset-collection-volumes-folder.ziphttps://storage.googleapis.com/kaggle-data-sets/862993/1470970/bundle/archive.zip?X-Goog-Algorithm=GOOG4-RSA-SHA256&amp;X-Goog-Credential=gcp-kaggle-com%40kaggle-161607.iam.gserviceaccount.com%2F20211221%2Fauto%2Fstorage%2Fgoog4_request&amp;X-Goog-Date=20211221T052609Z&amp;X-Goog-Expires=259199&amp;X-Goog-SignedHeaders=host&amp;X-Goog-Signature=6549111df89ca0440058e7061ba9a13d72ea22ed7bcfdbcfc56ddadaf7a54ec4d3285487b269808d60cf0568264db1803899989475d8ca0aeec0777891f54df612a6a8f7ba808c8df3899feda1a94ca0507a580e407c0e42371d97e3ce1c75d598bed1f693bf841f7d4660294488e99fc944d6e1498c5ec38b431b969e5f13eda5f2d8029e855ea368c57eab60897a32f7556df116a96bfd321dd4d214dfe847d4c8ca11fdb7c3472ebac9f7a9eb20b44a148df51ecb2f93acdc5459800a894cdc2d62a0cc2c2e42e6711e568827f44b82d6faaa02aa1357c8d93140eb2c72bde9b8c1716e565800ac3ff812df304ce7a54c2a83896696ac5fa935329afa66ef</span><br></pre></td></tr></table></figure><p>读取并拼接后的命令字符串如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">axel -o covid19-image-dataset-collection-volumes-folder.zip &quot;https://storage.googleapis.com/kaggle-data-sets/862993/1470970/bundle/archive.zip?X-Goog-Algorithm=GOOG4-RSA-SHA256&amp;X-Goog-Credential=gcp-kaggle-com%40kaggle-161607.iam.gserviceaccount.com%2F20211221%2Fauto%2Fstorage%2Fgoog4_request&amp;X-Goog-Date=20211221T052609Z&amp;X-Goog-Expires=259199&amp;X-Goog-SignedHeaders=host&amp;X-Goog-Signature=6549111df89ca0440058e7061ba9a13d72ea22ed7bcfdbcfc56ddadaf7a54ec4d3285487b269808d60cf0568264db1803899989475d8ca0aeec0777891f54df612a6a8f7ba808c8df3899feda1a94ca0507a580e407c0e42371d97e3ce1c75d598bed1f693bf841f7d4660294488e99fc944d6e1498c5ec38b431b969e5f13eda5f2d8029e855ea368c57eab60897a32f7556df116a96bfd321dd4d214dfe847d4c8ca11fdb7c3472ebac9f7a9eb20b44a148df51ecb2f93acdc5459800a894cdc2d62a0cc2c2e42e6711e568827f44b82d6faaa02aa1357c8d93140eb2c72bde9b8c1716e565800ac3ff812df304ce7a54c2a83896696ac5fa9353&quot;9afa66ef</span><br></pre></td></tr></table></figure><p>注意引号外面还有数据，这是不符合预期的。</p><p><em>目前还没有解决该问题</em></p><h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><p>由于本人对Bash不是很熟悉，所以改用Python来完成这一需求。</p><p>下面给出完整代码</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#python download.py -f list</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    parser = argparse.ArgumentParser(description=<span class="string">&quot;download kaggle dataset according to file&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;-f&#x27;</span>, <span class="string">&#x27;--filename&#x27;</span>, required=<span class="literal">True</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, <span class="built_in">help</span>=<span class="string">&#x27;filename&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">    filename = args.filename</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        lines = f.readlines()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        arr = line.split(<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">        save_name = arr[<span class="number">0</span>]</span><br><span class="line">        url = arr[<span class="number">1</span>].replace(<span class="string">&quot;\n&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        cmd = <span class="string">&#x27;axel -o &#x27;</span> + save_name + <span class="string">&#x27; &quot;&#x27;</span> + url + <span class="string">&#x27;&quot;&#x27;</span></span><br><span class="line">        <span class="comment"># print(cmd)</span></span><br><span class="line">        res_f = os.popen(cmd)  <span class="comment"># 返回的是一个文件对象</span></span><br><span class="line">        <span class="built_in">print</span>(res_f.read())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="Python-main函数"><a href="#Python-main函数" class="headerlink" title="Python main函数"></a>Python main函数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>这是Python的main函数，Python脚本总会从该“函数“进入。</p><h2 id="Python-接收外部参数"><a href="#Python-接收外部参数" class="headerlink" title="Python 接收外部参数"></a>Python 接收外部参数</h2><p>使用类库<code>argparse</code>来读取外部参数。上述代码给出了一个简单的示例</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">parser = argparse.ArgumentParser(description=<span class="string">&quot;download kaggle dataset according to file&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">第一、二个参数是指定参数名，第一个是简写形式</span></span><br><span class="line"><span class="string">在调用命令的时候，可以使用python script.py -f &lt;param&gt;或者python script.py --filename &lt;param&gt;</span></span><br><span class="line"><span class="string">required=True 表示该参数必填</span></span><br><span class="line"><span class="string">type=str 指定参数类型</span></span><br><span class="line"><span class="string">help=&#x27;filename&#x27; 指定提示语</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">parser.add_argument(<span class="string">&#x27;-f&#x27;</span>, <span class="string">&#x27;--filename&#x27;</span>, required=<span class="literal">True</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, <span class="built_in">help</span>=<span class="string">&#x27;filename&#x27;</span> 指定提示语)</span><br><span class="line"></span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">filename = args.filename  <span class="comment"># filename存放了外部参数的值</span></span><br></pre></td></tr></table></figure><p>详细请参见<code>参考资料2</code></p><h2 id="Python文件、字符串操作"><a href="#Python文件、字符串操作" class="headerlink" title="Python文件、字符串操作"></a>Python文件、字符串操作</h2><p>略</p><h2 id="在Python中执行Shell命令"><a href="#在Python中执行Shell命令" class="headerlink" title="在Python中执行Shell命令"></a>在Python中执行Shell命令</h2><p>有两种方式。使用<code>os.system(&quot;command&quot;)</code>执行无返回值的Shell命令；使用<code>f = os.popen(&quot;command&quot;)</code>执行有输出的Shell命令，其返回值<code>f</code>是一个文件对象，通过<code>f.read()</code>来读取命令输出内容。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="http://c.biancheng.net/shell/">Shell 脚本学习指南</a></li><li><a href="https://docs.python.org/zh-cn/3/howto/argparse.html">Python Argparse 教程</a></li><li><a href="https://blog.csdn.net/qq_27825451/article/details/102909772">python执行shell脚本的几种方法</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Scripts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Linux Bash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>田忌赛马与贪心法则</title>
      <link href="/2021/12/20/%E7%94%B0%E5%BF%8C%E8%B5%9B%E9%A9%AC%E4%B8%8E%E8%B4%AA%E5%BF%83%E6%B3%95%E5%88%99/"/>
      <url>/2021/12/20/%E7%94%B0%E5%BF%8C%E8%B5%9B%E9%A9%AC%E4%B8%8E%E8%B4%AA%E5%BF%83%E6%B3%95%E5%88%99/</url>
      
        <content type="html"><![CDATA[<p>本文涉及<em><a href="https://leetcode-cn.com/problems/advantage-shuffle/">LeetCode 870. 优势洗牌</a></em></p><blockquote><p>给定两个大小相等的数组 A 和 B，A 相对于 B 的优势可以用满足 A[i] &gt; B[i] 的索引 i 的数目来描述。返回 A 的任意排列，使其相对于 B 的优势最大化。</p><p>示例 1：</p><p>输入：A = [2,7,11,15], B = [1,10,4,11]<br>输出：[2,11,7,15]<br>示例 2：</p><p>输入：A = [12,24,8,32], B = [13,25,32,11]<br>输出：[24,32,8,12]</p></blockquote><p>这就像⽥忌赛⻢的情景，nums1 就是⽥忌的⻢，nums2 就是⻬王的⻢，数组中的元素就是⻢的战⽃⼒：</p><p>算法策略是：<strong>将⻬王和⽥忌的⻢按照战⽃⼒排序，然后按照排名⼀⼀对⽐。如果⽥忌的⻢能赢，那就⽐赛，如果赢不了，那就换个垫底的来送⼈头，保存实⼒。</strong></p><p>这里要注意一个问题：是否需要保存实力，即如果⽥忌的⼆号选⼿也能⼲得过⻬王的⼀号选⼿，此时让⼆号选⼿去对决⻬王的⼀号选⼿，不是更节约？</p><p>这种节约的策略是没问题的，但是<strong>没有必要</strong>。</p><p>我们暂且把⽥忌的⼀号选⼿称为 T1，⼆号选⼿称为 T2，⻬王的⼀号选⼿称为 Q1。如果 T2 能赢 Q1，你试图保存⼰⽅实⼒，让 T2 去战 Q1，把 T1 留着是为了对付谁？显然，你担⼼⻬王还有战⼒⼤于 T2 的⻢，可以让 T1 去对付。但是你仔细想想，现在 T2 已经是可以战胜 Q1 的，Q1 可是⻬王的最快的⻢，⻬王剩下的那些⻢⾥，怎么可能还有⽐ T2 更强的⻢？</p><p>所以没必要节约。</p><p>根据上述思路得到的代码逻辑如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对两个数组nums1和nums2排序</span><br><span class="line">对两个数组的元素挨个比较，如果nums1[i]&gt;nums2[i]那就比，否则就换上nums1最小的元素进行比较。</span><br></pre></td></tr></table></figure><p>由于需要对两个数组排序，但是返回结果依赖nums2的顺序，所以不能直接对nums2进行排序，而是利用优先级队列。（将(index, nums2[index]放入优先级队列，出队优先级按照nums2[index]大小，index记录索引值）</p><p>此外，解法还是用到双指针技巧。完整代码如下。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] advantageCount(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">    <span class="comment">// 给 nums2 降序排序</span></span><br><span class="line">    PriorityQueue&lt;<span class="type">int</span>[]&gt; maxpq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(</span><br><span class="line">        (<span class="type">int</span>[] pair1, <span class="type">int</span>[] pair2) -&gt; &#123; </span><br><span class="line">            <span class="keyword">return</span> pair2[<span class="number">1</span>] - pair1[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        maxpq.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i, nums2[i]&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 给 nums1 升序排序</span></span><br><span class="line">    Arrays.sort(nums1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// nums1[left] 是最小值，nums1[right] 是最大值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!maxpq.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span>[] pair = maxpq.poll();</span><br><span class="line">        <span class="comment">// maxval 是 nums2 中的最大值，i 是对应索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> pair[<span class="number">0</span>], maxval = pair[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (maxval &lt; nums1[right]) &#123;</span><br><span class="line">            <span class="comment">// 如果 nums1[right] 能胜过 maxval，那就自己上</span></span><br><span class="line">            res[i] = nums1[right];</span><br><span class="line">            right--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则用最小值去换nums2的最大值</span></span><br><span class="line">            res[i] = nums1[left];</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&amp;mid=2247491139&amp;idx=1&amp;sn=10cb35e0056ac8f8c540fccd0156f333&amp;scene=21&amp;ascene=7&amp;devicetype=iOS15.2&amp;version=1800103a&amp;nettype=WIFI&amp;abtest_cookie=AAACAA%3D%3D&amp;lang=zh_CN&amp;fontScale=100&amp;exportkey=A2t5E2fVKmwEJxWEKsScbfU%3D&amp;pass_ticket=n3zshxiiR8IMf1IfoZgzB%2BPSm6RatluaPa8vtuS3bDtR2ttHhdhxmZkQCXMUyC9L&amp;wx_header=1">labuladong: 算法大师——孙膑</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 数组/链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PriorityQueue 概述</title>
      <link href="/2021/12/19/PriorityQueue-%E6%A6%82%E8%BF%B0/"/>
      <url>/2021/12/19/PriorityQueue-%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><p><code>Queue</code>是一个严格的先进先出（FIFO）的队列。</p><p>但有时候这并不能满足我们的需求。当我们需要对队列中的元素重排，按照重排后的元素顺序出队时，这时候就需要<code>PriorityQueue</code>。</p><p><code>PriorityQueue</code>和<code>Queue</code>的区别在于，它的出队顺序与元素的优先级有关，对<code>PriorityQueue</code>调用<code>remove()</code>或<code>poll()</code>方法，返回的总是优先级最高的元素。</p><p>要使用<code>PriorityQueue</code>，我们就必须给每个元素定义“优先级”。请看下面的例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyPriorityQueue</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Queue&lt;User&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(</span><br><span class="line">                (User user1, User user2) -&gt; &#123;</span><br><span class="line">                    <span class="keyword">return</span> user2.getLevel() - user1.getLevel();</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">        queue.offer(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;sb_1&quot;</span>, <span class="number">1</span>)); <span class="comment">//优先级低</span></span><br><span class="line">        queue.offer(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;vip_1&quot;</span>, <span class="number">2</span>)); <span class="comment">//优先级高</span></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            System.out.println(user.getName());</span><br><span class="line">        &#125; <span class="comment">//出队的顺序是vip_1, sb_1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> level;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, <span class="type">int</span> level)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.level = level;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//getter、setter</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的例子使用lambda表达式实现了排序。你也可以自定义排序器（实现Comparable接口），然后将排序器对象传递给<code>PriorityQueue</code>构造器。构造函数签名如下：</p><p><code>public PriorityQueue(Comparator&lt;? super E&gt; comparator)</code></p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>通过堆实现，具体说是通过完全二叉树（<em>complete binary tree</em>）实现的<strong>小顶堆</strong>（任意一个非叶子节点的权值，都不大于其左右子节点的权值）。</p><p>具体请参考<strong>堆排序</strong>。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1265120632401152">https://www.liaoxuefeng.com/wiki/1252599548343744/1265120632401152</a></li><li><a href="https://www.cnblogs.com/CarpenterLee/p/5488070.html">https://www.cnblogs.com/CarpenterLee/p/5488070.html</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 集合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例设计模式</title>
      <link href="/2021/12/16/%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2021/12/16/%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>单例模式确保一个类只有一个实例，并提供了一个全局访问点。</p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>线程池，数据库连接对象。</p><h1 id="经典单例模式"><a href="#经典单例模式" class="headerlink" title="经典单例模式"></a>经典单例模式</h1><p>一个经典的单例模式实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> This is not thread safe!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> uniqueInstance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该实现是线程不安全的。可以想象有两个线程同时进入了getInstance()方法。</p><h1 id="解决经典单例模式线程安全问题"><a href="#解决经典单例模式线程安全问题" class="headerlink" title="解决经典单例模式线程安全问题"></a>解决经典单例模式线程安全问题</h1><p>解决方案，给getInstance方法加上synchronized关键字，迫使每个线程进入该方法前都需要等待别的线程离开该方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> uniqueInstance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该解决方案得缺点就是只有第一次执行该方法才真正需要线程同步。</p><h1 id="更进一步…"><a href="#更进一步…" class="headerlink" title="更进一步…"></a>更进一步…</h1><p>这里给出三种改善方案：</p><ol><li>如果getInstance得性能对于应用程序不是很关键，就什么也别做。</li><li>使用“急切”创建实例，而不用延迟实例化的做法。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>使用<strong>双重检查加锁</strong>，在getInstance中减少使用同步。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>备注：</p><ul><li>首先检查实例是否存在，如果不存在再进入同步代码块。</li><li>进入区块后在检查一次，如果仍然是null则创建实例。</li><li>volatile关键字确保：当instance变量初始化后，多个线程正确的处理instance变量。</li></ul><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><blockquote><p>两个类加载器可能有机会创建自己的单例实例？</p></blockquote><p>是的。所以如果你的程序有多个类加载器又同时使用了单例模式，请小心。解决方法是自行指定类加载器，并指定同一个类加载器。</p><blockquote><p>类如果能做两件事，就违反了OO设计。单例模式是否违反了这样的观念呢？</p></blockquote><p>单例类不止负责管理自己的实例，还在应用程序中担任角色，所以可以视为是两个责任。但是由类管理自己的实例的做法并不少见，也可以让设计更简单。</p><blockquote><p>我想把单例类当成超类，设计出子类。究竟可不可以继承单例类。</p></blockquote><p>不能。继承单例类遇到的一个问题就是构造器是私有的。你不能用私有构造器来扩展类。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《Head First设计模式》(中文版)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
