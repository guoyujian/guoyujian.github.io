<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>完美解决ChromeDriver与Chrome版本匹配问题</title>
      <link href="/2022/04/11/%E5%AE%8C%E7%BE%8E%E8%A7%A3%E5%86%B3ChromeDriver%E4%B8%8EChrome%E7%89%88%E6%9C%AC%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98/"/>
      <url>/2022/04/11/%E5%AE%8C%E7%BE%8E%E8%A7%A3%E5%86%B3ChromeDriver%E4%B8%8EChrome%E7%89%88%E6%9C%AC%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>在使用Selenium调用Chrome浏览器爬取互联网数据时，会遇到Chrome和ChromeDriver版本不兼容的问题，导致爬取失败。</p><p>一种解决方案是，进行版本匹配。但是随着本机Chrome的更新，每次都需要随之更新ChromeDriver版本。</p><p>更好的方案是，通过使用<code>webdriver-manager</code>来自动匹配ChromeDriver，安装：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install webdriver-manager</span><br></pre></td></tr></table></figure><p>Usage：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> webdriver_manager.chrome <span class="keyword">import</span> ChromeDriverManager</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome(ChromeDriverManager().install())</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://stackoverflow.com/questions/60296873/sessionnotcreatedexception-message-session-not-created-this-version-of-chrome">SessionNotCreatedException: Message: session not created: This version of ChromeDriver only supports Chrome version 81</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 网络爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络爬虫 </tag>
            
            <tag> Selenium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test_slides</title>
      <link href="/2022/04/11/test-slides/"/>
      <url>/2022/04/11/test-slides/</url>
      
        <content type="html"><![CDATA[<h1 id="这是一个slides测试博客"><a href="#这是一个slides测试博客" class="headerlink" title="这是一个slides测试博客"></a>这是一个slides测试博客</h1><p>===</p><p>它可以把markdown渲染的像幻灯片一样</p><p>==</p><p>还有垂直切换</p><p>==</p><p>还可以切换背景等。</p><p>===</p><p>Have Fun~</p>]]></content>
      
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于ResNet的树叶分类任务</title>
      <link href="/2022/04/04/%E5%9F%BA%E4%BA%8EResNet%E7%9A%84%E6%A0%91%E5%8F%B6%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/"/>
      <url>/2022/04/04/%E5%9F%BA%E4%BA%8EResNet%E7%9A%84%E6%A0%91%E5%8F%B6%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本文任务、数据集来源于《动手学深度学习》课程中的树叶分类竞赛。详见参考资料1</p><p>本文代码主要参考kaggle用户nekokiku给出的resnet baseline。详见参考资料2</p><p>通过本次竞赛和代码可以学习到：</p><ul><li>简单的PyTorch深度学习项目代码、结构是怎样的</li><li>如何继承PyTorch中的Dataset, DataLoader实现自己的Dataset, DataLoader类</li><li>如何使用PyTorch快速实现ResNet模型。</li></ul></blockquote><h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><p>分析baseline code，总结一下深度学习的代码流程。</p><ol><li>处理数据：包括元数据和图像数据。比如看看数据的样子，标签的分布，unique 标签的数量等。</li><li>实现自己的Dataset、DataLoader类</li><li>CPU OR GPU</li><li>定义模型</li><li>定义超参数：学习率等</li><li>train&amp;valid</li><li>使用训练好的模型进行预测。</li></ol><h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p>针对本次任务项目结构如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">leaves_classification_competition/</span><br><span class="line">└─data/</span><br><span class="line">    └─classify-leaves/</span><br><span class="line">        └─images/</span><br><span class="line">└─train.csv</span><br><span class="line">└─test.csv</span><br><span class="line">└─script.ipynb</span><br></pre></td></tr></table></figure><p><code>data/</code>目录下是本次任务用到的数据。将从kaggle上下载的数据压缩包解压到本文件夹。</p><p><code>script.ipynb</code>是代码脚本。</p><p>在更大的训练中，代码应该拆分为各种<code>.py</code>文件。</p><h1 id="baseline"><a href="#baseline" class="headerlink" title="baseline"></a>baseline</h1><h2 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 首先导入包</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset, DataLoader</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> torchvision.models <span class="keyword">as</span> models</span><br><span class="line"><span class="comment"># This is for the progress bar.</span></span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br></pre></td></tr></table></figure><h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><p>看一看train.csv长什么样</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DATA_BASE_PATH = <span class="string">&#x27;./data/classify-leaves/&#x27;</span></span><br><span class="line"><span class="comment"># label文件</span></span><br><span class="line">labels_df = pd.read_csv(os.path.join(DATA_BASE_PATH, <span class="string">&#x27;train.csv&#x27;</span>))</span><br><span class="line">labels_df.head()</span><br><span class="line"><span class="comment"># len(labels_df)</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">labels_df.describe()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 把树叶的标签去重映射为数值</span></span><br><span class="line">leaves_labels = <span class="built_in">sorted</span>(<span class="built_in">list</span>(<span class="built_in">set</span>(labels_df[<span class="string">&#x27;label&#x27;</span>])))</span><br><span class="line">n_classes = <span class="built_in">len</span>(leaves_labels)</span><br><span class="line">class2num = <span class="built_in">dict</span>(<span class="built_in">zip</span>(leaves_labels, <span class="built_in">range</span>(n_classes)))</span><br><span class="line">class2num</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#x27;abies_concolor&#x27;: 0,</span><br><span class="line"> &#x27;abies_nordmanniana&#x27;: 1,</span><br><span class="line"> &#x27;acer_campestre&#x27;: 2,</span><br><span class="line">……</span><br><span class="line"> &#x27;zelkova_serrata&#x27;: 175&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 转换成key为数字，val为树叶类型，方便预测。</span></span><br><span class="line">num2class = &#123;v:k <span class="keyword">for</span> k, v <span class="keyword">in</span> class2num.items()&#125;</span><br><span class="line">num2class</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;0: &#x27;abies_concolor&#x27;,</span><br><span class="line"> 1: &#x27;abies_nordmanniana&#x27;,</span><br><span class="line"> 2: &#x27;acer_campestre&#x27;,</span><br><span class="line"> 3: &#x27;acer_ginnala&#x27;,</span><br><span class="line"> 4: &#x27;acer_griseum&#x27;,</span><br><span class="line">……</span><br><span class="line"> 175: &#x27;zelkova_serrata&#x27;&#125;</span><br></pre></td></tr></table></figure><h2 id="实现Dataset"><a href="#实现Dataset" class="headerlink" title="实现Dataset"></a>实现Dataset</h2><p>继承Dataset类，实现自己的Dataset。继承之后，需要实现三个函数</p><ul><li><code>__init__</code>：传入必要的参数，初始化；</li><li><code>__getitem__</code>：返回item，如果是train或者valid则返回img和label，如果是test则返回img</li><li><code>__len__</code>：数据集长度</li><li>更多参见参考资料3</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 继承Dataset类。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LeaveDataSet</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, csv_path, img_path, mode=<span class="string">&#x27;train&#x27;</span>, valid_ratio = <span class="number">0.2</span>, resize_height = <span class="number">256</span>, resize_width = <span class="number">256</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">          csv_path: label文件路径</span></span><br><span class="line"><span class="string">          img_path: 图片存放路径</span></span><br><span class="line"><span class="string">          mode: 训练模式还是测试模式</span></span><br><span class="line"><span class="string">          valid_ratio: 验证集比例</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.img_path = img_path</span><br><span class="line">        self.mode = mode</span><br><span class="line">        self.data_info = pd.read_csv(csv_path)</span><br><span class="line">        self.data_len = <span class="built_in">len</span>(self.data_info)</span><br><span class="line">        self.train_len = <span class="built_in">int</span>(self.data_len * (<span class="number">1</span> - valid_ratio))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> mode == <span class="string">&#x27;train&#x27;</span>:</span><br><span class="line">            <span class="comment"># 为啥要转成nparray</span></span><br><span class="line">            self.train_image = np.asarray(self.data_info.iloc[:self.train_len, <span class="number">0</span>])</span><br><span class="line">            self.train_label = np.asarray(self.data_info.iloc[:self.train_len, <span class="number">1</span>])</span><br><span class="line">            <span class="comment"># 为了在不同模式下统一变量</span></span><br><span class="line">            self.image_arr = self.train_image</span><br><span class="line">            self.label_arr = self.train_label</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> mode == <span class="string">&#x27;valid&#x27;</span>:</span><br><span class="line">            self.valid_image = np.asarray(self.data_info.iloc[self.train_len:,<span class="number">0</span>])</span><br><span class="line">            self.valid_label = np.asarray(self.data_info.iloc[self.train_len:,<span class="number">1</span>])</span><br><span class="line">            self.image_arr = self.valid_image</span><br><span class="line">            self.label_arr = self.valid_label</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.test_image = np.asarray(self.data_info.iloc[:,<span class="number">0</span>])</span><br><span class="line">            self.image_arr = self.test_image</span><br><span class="line">            <span class="comment">#test 没有label</span></span><br><span class="line">        self.real_len = <span class="built_in">len</span>(self.image_arr)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Finished reading the &#123;&#125; set of Leaves Dataset. (&#123;&#125; samples found)&quot;</span>.<span class="built_in">format</span>(mode, self.real_len))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, index</span>):</span><br><span class="line"></span><br><span class="line">        single_image_name = self.image_arr[index]</span><br><span class="line">        img_as_img = Image.<span class="built_in">open</span>(os.path.join(self.img_path, single_image_name))</span><br><span class="line">        <span class="keyword">if</span> self.mode == <span class="string">&#x27;train&#x27;</span>:</span><br><span class="line">            transform = transforms.Compose([</span><br><span class="line">                transforms.Resize((<span class="number">224</span>, <span class="number">224</span>)),</span><br><span class="line">                transforms.RandomHorizontalFlip(p=<span class="number">0.5</span>),   <span class="comment">#随机水平翻转 选择一个概率</span></span><br><span class="line">                transforms.ToTensor()</span><br><span class="line">            ])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># valid和test不做数据增强</span></span><br><span class="line">            transform = transforms.Compose([</span><br><span class="line">                transforms.Resize((<span class="number">224</span>, <span class="number">224</span>)),</span><br><span class="line">                transforms.ToTensor()</span><br><span class="line">            ])</span><br><span class="line">        img_as_img = transform(img_as_img)</span><br><span class="line">        <span class="comment"># 先不做图像裁剪，增强和灰度处理</span></span><br><span class="line">        <span class="keyword">if</span> self.mode == <span class="string">&#x27;test&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> img_as_img</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            label = self.label_arr[index]</span><br><span class="line">            <span class="comment"># label转数字</span></span><br><span class="line">            number_label = class2num[label]</span><br><span class="line">            <span class="keyword">return</span> img_as_img, number_label</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.real_len</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">生成dataset对象</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">train_csv_path = <span class="string">&#x27;./data/classify-leaves/train.csv&#x27;</span></span><br><span class="line">test_csv_path = <span class="string">&#x27;./data/classify-leaves/test.csv&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># csv文件中已经images的路径了，因此这里只到上一级目录</span></span><br><span class="line"></span><br><span class="line">img_path = <span class="string">&#x27;./data/classify-leaves/&#x27;</span></span><br><span class="line"></span><br><span class="line">train_dataset = LeaveDataSet(train_csv_path, img_path, mode=<span class="string">&#x27;train&#x27;</span>)</span><br><span class="line">test_dataset = LeaveDataSet(train_csv_path, img_path, mode=<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line">valid_dataset = LeaveDataSet(train_csv_path, img_path, mode=<span class="string">&#x27;valid&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Finished reading the train set of Leaves Dataset (14681 samples found)</span><br><span class="line">Finished reading the test set of Leaves Dataset (18353 samples found)</span><br><span class="line">Finished reading the valid set of Leaves Dataset (3672 samples found)</span><br></pre></td></tr></table></figure><h2 id="实现Dataloader"><a href="#实现Dataloader" class="headerlink" title="实现Dataloader"></a>实现Dataloader</h2><p>定义train，valid，test的dataloader，参数详见参考资料4</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义 data loader</span></span><br><span class="line"><span class="comment"># dataloader 参数详解：https://blog.csdn.net/qq_36653505/article/details/84728855</span></span><br><span class="line"></span><br><span class="line">train_loader = DataLoader(</span><br><span class="line">    dataset=train_dataset,</span><br><span class="line">    batch_size=<span class="number">8</span>,</span><br><span class="line">    shuffle=<span class="literal">False</span>,</span><br><span class="line">    num_workers=<span class="number">5</span> <span class="comment"># 使用nums_workers个线程读数据</span></span><br><span class="line">)</span><br><span class="line">valid_loader = DataLoader(</span><br><span class="line">    dataset=valid_dataset,</span><br><span class="line">    batch_size=<span class="number">8</span>,</span><br><span class="line">    shuffle=<span class="literal">False</span>,</span><br><span class="line">    num_workers=<span class="number">5</span></span><br><span class="line">)</span><br><span class="line">test_loader = DataLoader(</span><br><span class="line">    dataset=test_dataset,</span><br><span class="line">    batch_size=<span class="number">8</span>,</span><br><span class="line">    shuffle=<span class="literal">False</span>,</span><br><span class="line">    num_workers=<span class="number">5</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="获取GPU"><a href="#获取GPU" class="headerlink" title="获取GPU"></a>获取GPU</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># CPU OR GPU</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_device</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;cuda&#x27;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&#x27;cpu&#x27;</span></span><br><span class="line"></span><br><span class="line">device = get_device()</span><br><span class="line"><span class="built_in">print</span>(device)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cuda</span><br></pre></td></tr></table></figure><h2 id="定义模型"><a href="#定义模型" class="headerlink" title="定义模型"></a>定义模型</h2><p>这里模型使用resnet34</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义resnet34</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">num_classes: 传入分类任务的类别数，由上面的数据可知，一共有176种树叶，所以一会调用该函数返回模型时，传入的num_classes参数为176</span></span><br><span class="line"><span class="string">use_pretrained: 是否使用预训练模型。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">res_model</span>(<span class="params">num_classes, feature_extract = <span class="literal">False</span>, use_pretrained = <span class="literal">False</span></span>):</span><br><span class="line">    model_ft = models.resnet34(pretrained=use_pretrained)</span><br><span class="line">    <span class="comment"># set_parameter_requires_grad(model_ft, feature_extract)</span></span><br><span class="line">    <span class="comment"># 这里是想要把原始模型的最后一层全连接层替换掉，替换成输出类别为num_classes的全连接层。</span></span><br><span class="line">    <span class="comment"># 为了做到这一点我们需要先知道原始模型的全连接层的输入feature维度。</span></span><br><span class="line">    num_ftrs = model_ft.fc.in_features</span><br><span class="line">    model_ft.fc = nn.Sequential(nn.Linear(num_ftrs, num_classes))</span><br><span class="line">    <span class="keyword">return</span> model_ft</span><br></pre></td></tr></table></figure><h2 id="定义超参数"><a href="#定义超参数" class="headerlink" title="定义超参数"></a>定义超参数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 超参数</span></span><br><span class="line">lr = <span class="number">3e-4</span> <span class="comment">#学习率</span></span><br><span class="line">weight_decay = <span class="number">1e-3</span></span><br><span class="line">num_epoch = <span class="number">50</span> <span class="comment">#迭代轮数</span></span><br><span class="line">model_path = <span class="string">&#x27;./pre_res_model.ckpt&#x27;</span> <span class="comment"># 模型保存位置</span></span><br></pre></td></tr></table></figure><h2 id="train-amp-valid"><a href="#train-amp-valid" class="headerlink" title="train&amp;valid"></a>train&amp;valid</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 模型初始化，并放到具体的设备中</span></span><br><span class="line">model = res_model(<span class="number">176</span>)</span><br><span class="line"><span class="comment"># 将模型放到device上。</span></span><br><span class="line">model = model.to(device)</span><br><span class="line">model.device = device <span class="comment"># 这行代码貌似没什么用</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分类任务使用交叉熵损失作为评估标准</span></span><br><span class="line">criterion = nn.CrossEntropyLoss()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Adam优化器</span></span><br><span class="line">optimizer = torch.optim.Adam(model.parameters(), lr = lr, weight_decay= weight_decay)</span><br><span class="line"></span><br><span class="line">n_epochs = num_epoch</span><br><span class="line"></span><br><span class="line">best_acc = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(n_epochs):</span><br><span class="line">    <span class="comment"># ------- train --------</span></span><br><span class="line">    <span class="comment"># 训练的时候，要调用该函数，使模型处于训练模式</span></span><br><span class="line">    model.train()</span><br><span class="line">    <span class="comment"># 记录每次使用一个batch训练后，模型的损失和精确率。</span></span><br><span class="line">    train_loss = []</span><br><span class="line">    train_accs = []</span><br><span class="line">    <span class="comment"># tqdm是一个显示进度条的工具包，不用管。</span></span><br><span class="line">    <span class="keyword">for</span> batch <span class="keyword">in</span> tqdm(train_loader):</span><br><span class="line">        <span class="comment"># A batch consists of image data and corresponding labels.</span></span><br><span class="line">        imgs, labels = batch</span><br><span class="line">        <span class="comment"># 把数据都放到同一个device上</span></span><br><span class="line">        imgs = imgs.to(device)</span><br><span class="line">        labels = labels.to(device)</span><br><span class="line"></span><br><span class="line">        logits = model(imgs)</span><br><span class="line">        <span class="comment"># 计算模型输出和真实label之间的损失，反向传播。。</span></span><br><span class="line">        loss = criterion(logits, labels)</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">        <span class="comment">#这行code不是很懂，大概就是统计预测正确标签的占比</span></span><br><span class="line">        <span class="comment"># 弄明白：https://csbwang.github.io/dl_ch2#2161</span></span><br><span class="line">        acc = (logits.argmax(dim = -<span class="number">1</span>) == labels).<span class="built_in">float</span>().mean()</span><br><span class="line">        </span><br><span class="line">        train_loss.append(loss.item())</span><br><span class="line">        train_accs.append(acc)</span><br><span class="line">    <span class="comment"># 计算本次epoch后的loss和acc</span></span><br><span class="line">    train_loss = <span class="built_in">sum</span>(train_loss) / <span class="built_in">len</span>(train_loss)</span><br><span class="line">    train_acc = <span class="built_in">sum</span>(train_accs) / <span class="built_in">len</span>(train_accs)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;[ Train | <span class="subst">&#123;epoch + <span class="number">1</span>:03d&#125;</span>/<span class="subst">&#123;n_epochs:03d&#125;</span> ] loss = <span class="subst">&#123;train_loss:<span class="number">.5</span>f&#125;</span>, acc = <span class="subst">&#123;train_acc:<span class="number">.5</span>f&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="comment"># ------- valid --------</span></span><br><span class="line">    <span class="comment"># 验证时，把模型调成评估模式</span></span><br><span class="line">    model.<span class="built_in">eval</span>()  <span class="comment"># eval具体是做什么?</span></span><br><span class="line"></span><br><span class="line">    valid_loss = []</span><br><span class="line">    valid_accs = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> batch <span class="keyword">in</span> tqdm(valid_loader):</span><br><span class="line">        imgs, labels = batch</span><br><span class="line">        <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">            logits = model(imgs.to(device))</span><br><span class="line">        loss = criterion(logits, labels.to(device))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># acc = (logits.argmax(dim = -1) == labels).float().mean()</span></span><br><span class="line">        acc = (logits.argmax(dim = -<span class="number">1</span>) == labels.to(device)).<span class="built_in">float</span>().mean()</span><br><span class="line"></span><br><span class="line">        valid_loss.append(loss.item())</span><br><span class="line">        valid_accs.append(acc)</span><br><span class="line">    </span><br><span class="line">    valid_loss = <span class="built_in">sum</span>(valid_loss) / <span class="built_in">len</span>(valid_loss)</span><br><span class="line">    valid_acc = <span class="built_in">sum</span>(valid_accs) / <span class="built_in">len</span>(valid_accs)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;[ Valid | <span class="subst">&#123;epoch + <span class="number">1</span>:03d&#125;</span>/<span class="subst">&#123;n_epochs:03d&#125;</span> ] loss = <span class="subst">&#123;valid_loss:<span class="number">.5</span>f&#125;</span>, acc = <span class="subst">&#123;valid_acc:<span class="number">.5</span>f&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果在验证集得到的acc大于已知最好的acc，则保存模型。</span></span><br><span class="line">    <span class="keyword">if</span> valid_acc &gt; best_acc:</span><br><span class="line">        best_acc = valid_acc</span><br><span class="line">        torch.save(model.state_dict(), model_path)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;saving model with acc &#123;:.3f&#125;&#x27;</span>.<span class="built_in">format</span>(best_acc))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>//控制台输出</p><h2 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h2><p>上面就是训练过程，下面用训练好的模型进行预测</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">################ </span></span><br><span class="line">saveFileName = <span class="string">&#x27;./data/classify-leaves/submission.csv&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## predict</span></span><br><span class="line">model = res_model(<span class="number">176</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># create model and load weights from checkpoint</span></span><br><span class="line">model = model.to(device)</span><br><span class="line">model.load_state_dict(torch.load(model_path))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Make sure the model is in eval mode.</span></span><br><span class="line"><span class="comment"># Some modules like Dropout or BatchNorm affect if the model is in training mode.</span></span><br><span class="line">model.<span class="built_in">eval</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Initialize a list to store the predictions.</span></span><br><span class="line">predictions = []</span><br><span class="line"><span class="comment"># Iterate the testing set by batches.</span></span><br><span class="line"><span class="keyword">for</span> batch <span class="keyword">in</span> tqdm(test_loader):</span><br><span class="line">    </span><br><span class="line">    imgs = batch</span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        logits = model(imgs.to(device))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Take the class with greatest logit as prediction and record it.</span></span><br><span class="line">    predictions.extend(logits.argmax(dim=-<span class="number">1</span>).cpu().numpy().tolist())</span><br><span class="line"></span><br><span class="line">preds = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> predictions:</span><br><span class="line">    preds.append(num2class[i])</span><br><span class="line"></span><br><span class="line">test_data = pd.read_csv(test_path)</span><br><span class="line">test_data[<span class="string">&#x27;label&#x27;</span>] = pd.Series(preds)</span><br><span class="line">submission = pd.concat([test_data[<span class="string">&#x27;image&#x27;</span>], test_data[<span class="string">&#x27;label&#x27;</span>]], axis=<span class="number">1</span>)</span><br><span class="line">submission.to_csv(saveFileName, index=<span class="literal">False</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Done!!!!!!!!!!!!!!!!!!!!!!!!!!!&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="改进模型"><a href="#改进模型" class="headerlink" title="改进模型"></a>改进模型</h1><p>//TODO</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>初学深度学习，代码上犯了很多细节上的错误。其次，很多细节问题不明白，例如，优化器？各种计算公式等。以后要弄懂。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://www.bilibili.com/video/BV1z64y1o7iz">第二部分完结竞赛：图片分类【动手学深度学习v2】</a></li><li><a href="https://www.kaggle.com/code/nekokiku/simple-resnet-baseline">nekokiku/simple-resnet-baseline</a></li><li><a href="https://blog.csdn.net/leviopku/article/details/99958182">Pytorch中的dataset类——创建适应任意模型的数据集接口</a></li><li><a href="https://blog.csdn.net/qq_36653505/article/details/84728855">Pytorch 中的数据类型 torch.utils.data.DataLoader 参数详解</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
          <category> 动手学深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复现ResNet50（PyTorch）</title>
      <link href="/2022/03/29/%E5%A4%8D%E7%8E%B0ResNet50%EF%BC%88PyTorch%EF%BC%89/"/>
      <url>/2022/03/29/%E5%A4%8D%E7%8E%B0ResNet50%EF%BC%88PyTorch%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本篇博客介绍了 ResNet50 网络 PyTorch 复现（复现代码为 PyTorch 源码）</p></blockquote><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>Residual Net：残差网络。</p><p>将靠前若干层的某一层数据输出直接跳过多层引入到后面数据层的输入部分。意味着后面的特征层的内容会有一部分由其前面的某一层线性贡献。</p><p><img src="image-20220329215711900.png" alt="残差块"></p><p>深度残差网络的设计是为了克服由于网络深度加深而产生的学习效率变低与准确率无法有效提升的问题。</p><p>下面这张图来自参考文献[1]，给出了ResNet18、ResNet34、ResNet50、ResNet101、ResNet152的块结构。</p><p><img src="image-20220329220108463.png" alt="ResNet-XX 网络结构"></p><p>根据该图，我们可以画出ResNet50的网络结构，</p><p><img src="image-20220329220245960.png" alt="ResNet-50 网络结构"></p><p>由上述网络结构可以看到，ResNet包含两种Block：分别为<strong>Conv Block</strong>和<strong>Identity Block</strong>。</p><ul><li><strong>Conv Block</strong>输入和输出的维度（通道数和size）是不一样的，所以相同的Conv Block不能连续串联，它的作用是改变网络的维度；</li><li><strong>Identity Block</strong>输入维度和输出维度（通道数和size）相同，可以串联，用于加深网络的。</li></ul><p>下面是两种块的结构：</p><p><img src="image-20220329221454060.png" alt="Conv Block"></p><p><img src="image-20220329221531582.png" alt="Identity Block"></p><p>这两种块的区别在于残差边是否卷积。如果经过$1*1$卷积。经过卷积的是Conv Block，直连的是Identity Block。</p><p>稍后用一个类<code>Bottleneck</code>实现这两种块。</p><p>下面参考PyTorch框架源码，对 ResNet50  一步步复现。</p><h1 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h1><h2 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br></pre></td></tr></table></figure><h2 id="ResNet50-生成函数"><a href="#ResNet50-生成函数" class="headerlink" title="ResNet50 生成函数"></a>ResNet50 生成函数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">resnet50</span>(<span class="params">pretrained = <span class="literal">False</span>, **kwargs</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    Constructs a ResNet-50 model.</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        pretrained:(bool): If True, return a model pretrained on ImageNet</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    model = ResNet(Bottleneck, [<span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>], **kwargs)</span><br><span class="line">    <span class="keyword">if</span> pretrained:</span><br><span class="line">        <span class="comment"># model.load_state_dict(model_zoo.load_url(model_urls[&#x27;resnet50&#x27;]))</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">return</span> model</span><br><span class="line"></span><br><span class="line">net = resnet50()</span><br></pre></td></tr></table></figure><p>通过 <code>model = ResNet(Bottleneck, [3, 4, 6, 3], **kwargs)</code> 构造网络结构，主要分成两个部分即 <code>Bottleneck</code>和 <code>[3,4,6,3]</code> 由这两个参数共同决定了ResNet50的网络结构 ，当<code>pretrained</code>为<code>True</code>时，model加载ImageNet中预训练的参数。（这块本篇文章先不考虑）</p><p><code>[3,4,6,3]</code>对应于上图中ResNet50中 conv2_x中有三个（$1<em>1, 64$，$3</em>3, 64$，$1<em>1, 256$）卷积层的堆叠 ，同理conv3_x中有4个（$1</em>1, 128$，$3<em>3, 128$，$1</em>1, 512$）卷积层的堆叠，ResNet50将卷积层分为4个大层，<code>[3,4,6,3]</code>代表每一个大层中$1<em>1$，$3</em>3$，$1<em>1$卷积层组合的重复次数总共1（第一个卷积层）+1（第一个池化层）+（3+4+6+3）</em>3 = 50层。</p><p>这里<code>Bottleneck</code>类，就是一个基础块。对应上图（$1<em>1$，$3</em>3$，$1*1$）的三个卷积层组合。</p><h2 id="ResNet类"><a href="#ResNet类" class="headerlink" title="ResNet类"></a>ResNet类</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResNet</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_make_layer</span>(<span class="params">self, block, planes, blocks, stride=<span class="number">1</span></span>):</span></span><br><span class="line">        downsample = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> stride != <span class="number">1</span> <span class="keyword">or</span> self.inplanes != planes * block.expansion:</span><br><span class="line">            downsample = nn.Sequential(</span><br><span class="line">                nn.Conv2d(self.inplanes, planes * block.expansion,</span><br><span class="line">                kernel_size=<span class="number">1</span>, stride=stride, bias=<span class="literal">False</span>),</span><br><span class="line">                nn.BatchNorm2d(planes * block.expansion)</span><br><span class="line">            )</span><br><span class="line">        layers = []</span><br><span class="line">        layers.append(block(self.inplanes, planes, stride, downsample))</span><br><span class="line">        self.inplanes = planes * block.expansion</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, blocks): <span class="comment"># for (blocks - 1)</span></span><br><span class="line">            layers.append(block(self.inplanes, planes))</span><br><span class="line">        <span class="keyword">return</span> nn.Sequential(*layers)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, block, layers, num_classes = <span class="number">1000</span></span>):</span></span><br><span class="line">        self.inplanes = <span class="number">64</span></span><br><span class="line">        <span class="built_in">super</span>(ResNet, self).__init__() <span class="comment"># ?</span></span><br><span class="line">        self.conv1 = nn.Conv2d(<span class="number">3</span>, <span class="number">64</span>, kernel_size=<span class="number">7</span>, stride=<span class="number">2</span>, padding=<span class="number">3</span>, bias=<span class="literal">False</span>)</span><br><span class="line">        self.bn1 = nn.BatchNorm2d(<span class="number">64</span>)</span><br><span class="line">        self.relu = nn.ReLU(inplace=<span class="literal">True</span>)</span><br><span class="line">        self.maxpool = nn.MaxPool2d(kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>, padding=<span class="number">1</span>)</span><br><span class="line">        self.layer1 = self._make_layer(block, <span class="number">64</span>, layers[<span class="number">0</span>])</span><br><span class="line">        self.layer2 = self._make_layer(block, <span class="number">128</span>, layers[<span class="number">1</span>], stride=<span class="number">2</span>)</span><br><span class="line">        self.layer3 = self._make_layer(block, <span class="number">256</span>, layers[<span class="number">2</span>], stride=<span class="number">2</span>)</span><br><span class="line">        self.layer4 = self._make_layer(block, <span class="number">512</span>, layers[<span class="number">3</span>], stride=<span class="number">2</span>)</span><br><span class="line">        self.avgpool = nn.AvgPool2d(<span class="number">7</span>, stride=<span class="number">1</span>)</span><br><span class="line">        <span class="comment">#因为最后feature map在输入为224时，经过layer4之后大小为7*7，此时经过nn.AvgPool2d(7, stride=1)大小变为1*1，再经过全连接层时，self.fc = nn.Linear(512 * block.expansion, num_classes) 前者是输出的所有channel数目，实际应该为channel*1*1，后者为分类数</span></span><br><span class="line">        self.fc = nn.Linear(<span class="number">512</span> * block.expansion, num_classes)</span><br><span class="line"><span class="comment"># ?</span></span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> self.modules():</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(m, nn.Conv2d):</span><br><span class="line">                nn.init.kaiming_normal_(m.weight, mode=<span class="string">&#x27;fan_out&#x27;</span>, nonlinearity=<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">isinstance</span>(m, nn.BatchNorm2d):</span><br><span class="line">                nn.init.constant_(m.weight, <span class="number">1</span>)</span><br><span class="line">                nn.init.constant_(m.bias, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">       self.avgpool = nn.AvgPool2d(<span class="number">7</span>, stride=<span class="number">1</span>)</span><br><span class="line">  x = self.avgpool(x)  </span><br><span class="line"></span><br><span class="line">  x = x.view(x.size(<span class="number">0</span>), -<span class="number">1</span>)     </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="comment"># 首先对输入进行7*7的卷积</span></span><br><span class="line">        x = self.conv1(x)</span><br><span class="line">        x = self.bn1(x)</span><br><span class="line">        x = self.relu(x)</span><br><span class="line">        <span class="comment"># 然后对x进行3*3的最大池化</span></span><br><span class="line">        x = self.maxpool(x)</span><br><span class="line"><span class="comment"># 接着进入四个layer/stage</span></span><br><span class="line">        x = self.layer1(x)</span><br><span class="line">        x = self.layer2(x)</span><br><span class="line">        x = self.layer3(x)</span><br><span class="line">        x = self.layer4(x)</span><br><span class="line"><span class="comment">#最后平均池化</span></span><br><span class="line"></span><br><span class="line">        x = self.avgpool(x)</span><br><span class="line">        <span class="comment"># 将数据拉伸成batchsize * channel * 1 * 1 ?</span></span><br><span class="line">        x = x.view(x.size(<span class="number">0</span>), -<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 如果输入大小不为224  那么相应的可以修改AvgPool2d 或者在全连接层第一个参数中乘上最终的width 和height</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><p>ResNet 是由<code>__init__</code>和<code>forward</code>构成，为了方便分析这里首先分析<code>__init__</code>函数。</p><h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><p>在<code>__init__</code>中，最重要的是<code>_make_layer</code>函数，以<code>layer1</code>为例，block为Bottleneck，planes=64（即channel数目）blocks=3 （<code>[3,4,6,3]</code>分别代表每一层的blocks数目）这里要注意<code>layer1</code>的stride为1，其他layer的stride为2。</p><p>对于<code>layer1</code>而言，<code>inplanes=64</code>， <code>planes=64</code>， <code>block.expansion=4</code>，因此需要经过downsample才能够使得残差和经过该层的feature map能够相加，downsample即为右路部分。（可以看<code>Bottleneck</code>的实现）</p><h3 id="forward"><a href="#forward" class="headerlink" title="forward"></a>forward</h3><p>见上面的代码注释。</p><h2 id="Bottleneck"><a href="#Bottleneck" class="headerlink" title="Bottleneck"></a>Bottleneck</h2><p>接着我们看一下Bottleneck的实现。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    Block的各个plane值：</span></span><br><span class="line"><span class="string">        inplanes：输出block的之前的通道数</span></span><br><span class="line"><span class="string">        planes：在block中间处理的时候的通道数（这个值是输出维度的1/4）</span></span><br><span class="line"><span class="string">        midplane*self.expansion：输出的维度</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bottleneck</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="comment">#每个stage中维度拓展的倍数</span></span><br><span class="line">    expansion = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1 * 1卷积核不改变feature map的大小，3 * 3卷积核padding=1&amp;&amp;stride=1也不改变输入feature map的大小，因此经过一个Bottleneck组成的卷积层组操作后feature map大小不会改变</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, inplanes, planes, stride = <span class="number">1</span>, downsample=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Bottleneck, self).__init__()</span><br><span class="line">        self.conv1 = nn.Conv2d(inplanes, planes, kernel_size=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">        self.bn1 = nn.BatchNorm2d(planes)</span><br><span class="line">        self.conv2 = nn.Conv2d(planes, planes, kernel_size=<span class="number">3</span>, stride=stride, padding=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">        self.bn2 = nn.BatchNorm2d(planes)</span><br><span class="line">        self.conv3 = nn.Conv2d(planes, planes * self.expansion, kernel_size=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">        self.bn3 = nn.BatchNorm2d(planes * self.expansion)</span><br><span class="line">        self.relu = nn.ReLU(inplace= <span class="literal">True</span>)</span><br><span class="line">        self.downsample = downsample</span><br><span class="line">        self.stride = stride</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        residual = x</span><br><span class="line">        out = self.conv1(x)</span><br><span class="line">        out = self.bn1(out)</span><br><span class="line">        out = self.conv2(out)</span><br><span class="line">        out = self.bn2(out)</span><br><span class="line">        out = self.conv3(out)</span><br><span class="line">        out = self.bn3(out)</span><br><span class="line">        <span class="keyword">if</span> self.downsample <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            residual = self.downsample(x)</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        out += residual</span><br><span class="line">        out = self.relu(out)</span><br><span class="line">        <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure><p>其中当<code>downsample</code>为None时，残差边直连，此时为Identify Block，当<code>downsample</code>不为None时，残差边进行卷积再相加，此时为Conv Block。</p><blockquote><p>为什么要先卷积再相加呢？</p><p>因为feature map的大小不变 但是在经过Bottleneck 之后channel变成了原来的四倍，因此想要和原始的feature map相加需要将原始的feature map也变为原来的四倍 ，downsample作用是residual+当前feature map时将维度统一。</p></blockquote><h1 id="从输入到layers"><a href="#从输入到layers" class="headerlink" title="从输入到layers"></a>从输入到layers</h1><p>首先输入(3, 224, 224)，即三个通道，224<em>224像素的输入，经过一个输出通道数为64的7\</em>7卷积层，一个3*3池化，得到(64, 56, 56)。然后将其输入到layer1、2、3、4。</p><blockquote><p>解释一下为什么是(64, 56, 56)</p><p>因为ResNet接受的图像大小为224 * 224 经过第一层卷积层<code>self.conv1 = nn.Conv2d(3, 64, kernel_size=7, stride=2, padding=3, bias=False)</code></p><script type="math/tex; mode=display">floor((224-7+3*2)/2)+1=112</script><p>经过第一层池化之后，<code>self.maxpool = nn.MaxPool2d(kernel_size=3, stride=2, padding=1)</code></p><script type="math/tex; mode=display">floor((112+2*1-3)/2)+1=56</script><p>因此在输入到Bottleneck之前得到一个64(channel), 56(height)，56(weight)大小的feature map。</p></blockquote><h2 id="layer1-Bottleneck1"><a href="#layer1-Bottleneck1" class="headerlink" title="layer1/Bottleneck1"></a>layer1/Bottleneck1</h2><p>输入 ：[batch_size,64,56,56]</p><p>调用<code>_make_layer(block, 64, layers[0])</code>构造了layer1，此时<code>self.inplanes</code>为64，<code>planes * block.expansion</code>=64 <em> 4，不相等（之所以要二者相等，是因为在<code>Bottleneck</code>主体分支最后一个卷积层会将<code>channel</code>变为`planes</em>block.expansion<code>，如果</code>inplanes<code>（实际就是输入的channel）与之不相等则不可相加因此构造右路</code>downsample` （1*1卷积核的卷积层扩展channel+BN层）</p><p><img src="20181108104951863.png" alt="主体分支"></p><p><img src="20181108105037539.png" alt="downsample分支"></p><p>更新 inplanes=64*4=256</p><h2 id="layer1-Bottleneck2"><a href="#layer1-Bottleneck2" class="headerlink" title="layer1/Bottleneck2"></a>layer1/Bottleneck2</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">self.conv1 = nn.Conv2d(<span class="number">256</span>, <span class="number">64</span>, kernel_size=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">self.bn1 = nn.BatchNorm2d(<span class="number">64</span>)</span><br><span class="line">self.conv2 = nn.Conv2d(<span class="number">64</span>, <span class="number">64</span>, kernel_size=<span class="number">3</span>, stride=stride, padding=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">self.bn2 = nn.BatchNorm2d(<span class="number">64</span>)</span><br><span class="line">self.conv3 = nn.Conv2d(<span class="number">64</span>,<span class="number">256</span>, kernel_size=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">self.bn3 = nn.BatchNorm2d(planes * self.expansion)</span><br><span class="line">self.relu = nn.ReLU(inplace=<span class="literal">True</span>)</span><br><span class="line">self.downsample = <span class="literal">None</span></span><br><span class="line">self.stride = <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="layer1-Bottleneck3"><a href="#layer1-Bottleneck3" class="headerlink" title="layer1/Bottleneck3"></a>layer1/Bottleneck3</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">self.conv1 = nn.Conv2d(<span class="number">256</span>, <span class="number">64</span>, kernel_size=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">self.bn1 = nn.BatchNorm2d(<span class="number">64</span>)</span><br><span class="line">self.conv2 = nn.Conv2d(<span class="number">64</span>, <span class="number">64</span>, kernel_size=<span class="number">3</span>, stride=stride,padding=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">self.bn2 = nn.BatchNorm2d(<span class="number">64</span>)</span><br><span class="line">self.conv3 = nn.Conv2d(<span class="number">64</span>,<span class="number">256</span>, kernel_size=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">self.bn3 = nn.BatchNorm2d(planes * self.expansion)</span><br><span class="line">self.relu = nn.ReLU(inplace=<span class="literal">True</span>)</span><br><span class="line">self.downsample = <span class="literal">None</span></span><br><span class="line">self.stride = <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="layer2-Bottleneck1"><a href="#layer2-Bottleneck1" class="headerlink" title="layer2/Bottleneck1"></a>layer2/Bottleneck1</h2><p>此时<code>stride</code>=2，<code>self.inplanes</code>=256， <code>planes * block.expansion</code>=128*4，需要生成downsample层</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">downsample = nn.Sequential(</span><br><span class="line">nn.Conv2d(<span class="number">256</span>, <span class="number">512</span>,kernel_size=<span class="number">1</span>, stride=<span class="number">2</span>, bias=<span class="literal">False</span>),</span><br><span class="line">nn.BatchNorm2d(<span class="number">512</span>),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>生成第一个Bottleneck的主干</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">self.conv1 = nn.Conv2d(<span class="number">256</span>, <span class="number">128</span>, kernel_size=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">self.bn1 = nn.BatchNorm2d(planes)</span><br><span class="line"><span class="comment"># 此时feature map 大小由56变成28</span></span><br><span class="line">self.conv2 = nn.Conv2d(<span class="number">128</span>, <span class="number">128</span>, kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>, padding=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">self.bn2 = nn.BatchNorm2d(planes)</span><br><span class="line">self.conv3 = nn.Conv2d(<span class="number">128</span>, <span class="number">512</span>, kernel_size=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">self.bn3 = nn.BatchNorm2d(planes * self.expansion)</span><br><span class="line">self.relu = nn.ReLU(inplace=<span class="literal">True</span>)</span><br><span class="line">self.downsample = downsample</span><br><span class="line">self.stride = stride</span><br></pre></td></tr></table></figure><p>更新inplanes=512</p><h2 id="layer2-Bottleneck234"><a href="#layer2-Bottleneck234" class="headerlink" title="layer2/Bottleneck234"></a>layer2/Bottleneck234</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">self.conv1 = nn.Conv2d(<span class="number">512</span>, <span class="number">128</span>, kernel_size=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">self.bn1 = nn.BatchNorm2d(<span class="number">64</span>)</span><br><span class="line">self.conv2 = nn.Conv2d(<span class="number">128</span>, <span class="number">128</span>, kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>,padding=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">self.bn2 = nn.BatchNorm2d(<span class="number">64</span>)</span><br><span class="line">self.conv3 = nn.Conv2d(<span class="number">128</span>,<span class="number">256</span>, kernel_size=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">self.bn3 = nn.BatchNorm2d(planes * self.expansion)</span><br><span class="line">self.relu = nn.ReLU(inplace=<span class="literal">True</span>)</span><br><span class="line">self.downsample = <span class="literal">None</span></span><br><span class="line">self.stride = <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="layer3-4"><a href="#layer3-4" class="headerlink" title="layer3/4"></a>layer3/4</h2><p>对于layer3和layer4同理。</p><h2 id="打印完整的网络结构"><a href="#打印完整的网络结构" class="headerlink" title="打印完整的网络结构"></a>打印完整的网络结构</h2><p>最后，我们打印完整的网络结构：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">net</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ResNet(</span><br><span class="line">  (conv1): Conv2d(3, 64, kernel_size=(7, 7), stride=(2, 2), padding=(3, 3), bias=False)</span><br><span class="line">  (bn1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">  (relu): ReLU(inplace=True)</span><br><span class="line">  (maxpool): MaxPool2d(kernel_size=3, stride=2, padding=1, dilation=1, ceil_mode=False)</span><br><span class="line">  (layer1): Sequential(</span><br><span class="line">    (0): Bottleneck(</span><br><span class="line">      (conv1): Conv2d(64, 64, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)</span><br><span class="line">      (bn2): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv3): Conv2d(64, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn3): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (relu): ReLU(inplace=True)</span><br><span class="line">      (downsample): Sequential(</span><br><span class="line">        (0): Conv2d(64, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">        (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">    (1): Bottleneck(</span><br><span class="line">      (conv1): Conv2d(256, 64, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)</span><br><span class="line">      (bn2): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv3): Conv2d(64, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn3): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (relu): ReLU(inplace=True)</span><br><span class="line">    )</span><br><span class="line">    (2): Bottleneck(</span><br><span class="line">      (conv1): Conv2d(256, 64, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)</span><br><span class="line">      (bn2): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv3): Conv2d(64, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn3): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (relu): ReLU(inplace=True)</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">  (layer2): Sequential(</span><br><span class="line">    (0): Bottleneck(</span><br><span class="line">      (conv1): Conv2d(256, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv2): Conv2d(128, 128, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False)</span><br><span class="line">      (bn2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv3): Conv2d(128, 512, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn3): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (relu): ReLU(inplace=True)</span><br><span class="line">      (downsample): Sequential(</span><br><span class="line">        (0): Conv2d(256, 512, kernel_size=(1, 1), stride=(2, 2), bias=False)</span><br><span class="line">        (1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">    (1): Bottleneck(</span><br><span class="line">      (conv1): Conv2d(512, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv2): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)</span><br><span class="line">      (bn2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv3): Conv2d(128, 512, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn3): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (relu): ReLU(inplace=True)</span><br><span class="line">    )</span><br><span class="line">    (2): Bottleneck(</span><br><span class="line">      (conv1): Conv2d(512, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv2): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)</span><br><span class="line">      (bn2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv3): Conv2d(128, 512, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn3): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (relu): ReLU(inplace=True)</span><br><span class="line">    )</span><br><span class="line">    (3): Bottleneck(</span><br><span class="line">      (conv1): Conv2d(512, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv2): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)</span><br><span class="line">      (bn2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv3): Conv2d(128, 512, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn3): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (relu): ReLU(inplace=True)</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">  (layer3): Sequential(</span><br><span class="line">    (0): Bottleneck(</span><br><span class="line">      (conv1): Conv2d(512, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False)</span><br><span class="line">      (bn2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv3): Conv2d(256, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn3): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (relu): ReLU(inplace=True)</span><br><span class="line">      (downsample): Sequential(</span><br><span class="line">        (0): Conv2d(512, 1024, kernel_size=(1, 1), stride=(2, 2), bias=False)</span><br><span class="line">        (1): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">    (1): Bottleneck(</span><br><span class="line">      (conv1): Conv2d(1024, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)</span><br><span class="line">      (bn2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv3): Conv2d(256, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn3): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (relu): ReLU(inplace=True)</span><br><span class="line">    )</span><br><span class="line">    (2): Bottleneck(</span><br><span class="line">      (conv1): Conv2d(1024, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)</span><br><span class="line">      (bn2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv3): Conv2d(256, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn3): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (relu): ReLU(inplace=True)</span><br><span class="line">    )</span><br><span class="line">    (3): Bottleneck(</span><br><span class="line">      (conv1): Conv2d(1024, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)</span><br><span class="line">      (bn2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv3): Conv2d(256, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn3): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (relu): ReLU(inplace=True)</span><br><span class="line">    )</span><br><span class="line">    (4): Bottleneck(</span><br><span class="line">      (conv1): Conv2d(1024, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)</span><br><span class="line">      (bn2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv3): Conv2d(256, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn3): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (relu): ReLU(inplace=True)</span><br><span class="line">    )</span><br><span class="line">    (5): Bottleneck(</span><br><span class="line">      (conv1): Conv2d(1024, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)</span><br><span class="line">      (bn2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv3): Conv2d(256, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn3): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (relu): ReLU(inplace=True)</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">  (layer4): Sequential(</span><br><span class="line">    (0): Bottleneck(</span><br><span class="line">      (conv1): Conv2d(1024, 512, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv2): Conv2d(512, 512, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False)</span><br><span class="line">      (bn2): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv3): Conv2d(512, 2048, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn3): BatchNorm2d(2048, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (relu): ReLU(inplace=True)</span><br><span class="line">      (downsample): Sequential(</span><br><span class="line">        (0): Conv2d(1024, 2048, kernel_size=(1, 1), stride=(2, 2), bias=False)</span><br><span class="line">        (1): BatchNorm2d(2048, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">    (1): Bottleneck(</span><br><span class="line">      (conv1): Conv2d(2048, 512, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv2): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)</span><br><span class="line">      (bn2): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv3): Conv2d(512, 2048, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn3): BatchNorm2d(2048, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (relu): ReLU(inplace=True)</span><br><span class="line">    )</span><br><span class="line">    (2): Bottleneck(</span><br><span class="line">      (conv1): Conv2d(2048, 512, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv2): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)</span><br><span class="line">      (bn2): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv3): Conv2d(512, 2048, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn3): BatchNorm2d(2048, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (relu): ReLU(inplace=True)</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">  (avgpool): AvgPool2d(kernel_size=7, stride=1, padding=0)</span><br><span class="line">  (fc): Linear(in_features=2048, out_features=1000, bias=True)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>He K, Zhang X, Ren S, et al. Deep residual learning for image recognition[C]//Proceedings of the IEEE conference on computer vision and pattern recognition. 2016: 770-778.</li><li><a href="https://blog.csdn.net/a940902940902/article/details/83858694">ResNet结构分析</a></li><li><a href="https://www.bilibili.com/video/BV1154y1S7WC">史上最详细ResNet50复现解析（面向小白）</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
          <category> ResNet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> ResNet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【笔记】BFS 算法解题套路框架</title>
      <link href="/2022/03/09/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91BFS-%E7%AE%97%E6%B3%95%E8%A7%A3%E9%A2%98%E5%A5%97%E8%B7%AF%E6%A1%86%E6%9E%B6/"/>
      <url>/2022/03/09/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91BFS-%E7%AE%97%E6%B3%95%E8%A7%A3%E9%A2%98%E5%A5%97%E8%B7%AF%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文FROM《labuladong 算法秘籍》</p></blockquote><h1 id="什么是-BFS"><a href="#什么是-BFS" class="headerlink" title="什么是 BFS"></a>什么是 BFS</h1><p>BFS(Breadth First Search)，广度优先搜索，起源于<strong>树的层次遍历</strong>。其核心是利用<strong>队列</strong>这种数据结构。</p><p>BFS 的核心思想应该不难理解的，就是把⼀些问题抽象成图，从⼀个点开始，向四周开始扩散。 </p><h1 id="BFS-的应用场景"><a href="#BFS-的应用场景" class="headerlink" title="BFS 的应用场景"></a>BFS 的应用场景</h1><p>BFS 算法常见于求最值的场景，因为 BFS 的算法逻辑保证了算法第⼀次到达目标时的代价是最小的（？）。</p><p>举例⼀下 BFS 出现的常见场景好吧，问题的本质就是让你在⼀幅「图」中找到从起点 start 到终点 target 的最近距离。</p><p>这个广义的描述可以有各种变体，比如走迷宫，有的格子是围墙不能走，从起点到终点的最短距离是多少？如果这个迷宫带「传送门」可以瞬间传送呢？再比如说两个单词，要求你通过某些替换，把其中一个变成另一个，每次只能替换一个字符，最少要替换几次？再比如说连连看游戏，两个方块消除的条件不仅仅是图案相同，还得保证两个方块之间的最短连线不能多于两个拐点。你玩连连看，点击两个坐标，游戏是如何判断它俩的最短连线有几个拐点的？</p><h1 id="BFS-框架代码"><a href="#BFS-框架代码" class="headerlink" title="BFS 框架代码"></a>BFS 框架代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算从起点 start 到终点 target 的最近距离</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(Node start, Node target)</span> </span>&#123;</span><br><span class="line">    Queue&lt;Node&gt; q; <span class="comment">// 核心数据结构</span></span><br><span class="line">    Set&lt;Node&gt; visited; <span class="comment">// 避免走回头路</span></span><br><span class="line">    </span><br><span class="line">    q.offer(start); <span class="comment">// 将起点加入队列</span></span><br><span class="line">    visited.add(start);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>; <span class="comment">// 记录扩散的步数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (q not empty) &#123;</span><br><span class="line">        <span class="keyword">int</span> sz = q.size();</span><br><span class="line">        <span class="comment">/* 将当前队列中的所有节点向四周扩散 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            Node cur = q.poll();</span><br><span class="line">            <span class="comment">/* 划重点：这里判断是否到达终点 */</span></span><br><span class="line">            <span class="keyword">if</span> (cur is target)</span><br><span class="line">                <span class="keyword">return</span> step;</span><br><span class="line">            <span class="comment">/* 将 cur 的相邻节点加入队列 */</span></span><br><span class="line">            <span class="keyword">for</span> (Node x : cur.adj()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x not in visited) &#123;</span><br><span class="line">                    q.offer(x);</span><br><span class="line">                    visited.add(x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 划重点：更新步数在这里 */</span></span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>队列 <code>q</code> 就不说了，BFS 的核心数据结构；<code>cur.adj()</code> 泛指 <code>cur</code> 相邻的节点，比如说二维数组中，<code>cur</code> 上下左右四面的位置就是相邻节点；<code>visited</code> 的主要作用是防止走回头路，大部分时候都是必须的，但是像一般的二叉树结构，没有子节点到父节点的指针，不会走回头路就不需要 <code>visited</code>。</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p>LeetCode 111、752</p><h1 id="双向BFS（了解）"><a href="#双向BFS（了解）" class="headerlink" title="双向BFS（了解）"></a>双向BFS（了解）</h1><p>传统的 BFS 框架就是从起点开始向四周扩散，遇到终点时停止；而双向 BFS 则是从起点和终点同时开始扩散，当两边有交集的时候停止。</p><h1 id="BFS-与-DFS"><a href="#BFS-与-DFS" class="headerlink" title="BFS 与 DFS"></a>BFS 与 DFS</h1><blockquote><p>这部分不是很懂，后面再看</p></blockquote><p>BFS 相对 DFS 的最主要的区别是：BFS 找到的路径⼀定是最短的，但代价就是空间复杂度可能比 DFS 大很多。</p><p><strong>1、为什么 BFS 可以找到最短距离，DFS 不行吗</strong>？</p><p>首先，你看 BFS 的逻辑，<code>depth</code> 每增加一次，队列中的所有节点都向前迈一步，这保证了第一次到达终点的时候，走的步数是最少的。</p><p>DFS 不能找最短路径吗？其实也是可以的，但是时间复杂度相对高很多。你想啊，DFS 实际上是靠递归的堆栈记录走过的路径，你要找到最短路径，肯定得把二叉树中所有树杈都探索完才能对比出最短的路径有多长对不对？而 BFS 借助队列做到一次一步「齐头并进」，是可以在不遍历完整棵树的条件下找到最短距离的。</p><p>形象点说，DFS 是线，BFS 是面；DFS 是单打独斗，BFS 是集体行动。这个应该比较容易理解吧。</p><p><strong>2、既然 BFS 那么好，为啥 DFS 还要存在</strong>？</p><p>BFS 可以找到最短距离，但是空间复杂度高，而 DFS 的空间复杂度较低。</p><p>还是拿刚才我们处理二叉树问题的例子，假设给你的这个二叉树是满二叉树，节点数为 <code>N</code>，对于 DFS 算法来说，空间复杂度无非就是递归堆栈，最坏情况下顶多就是树的高度，也就是 <code>O(logN)</code>。</p><p>但是你想想 BFS 算法，队列中每次都会储存着二叉树一层的节点，这样的话最坏情况下空间复杂度应该是树的最底层节点的数量，也就是 <code>N/2</code>，用 Big O 表示的话也就是 <code>O(N)</code>。</p><p>由此观之，BFS 还是有代价的，一般来说在找最短路径的时候使用 BFS，其他时候还是 DFS 使用得多一些（主要是递归代码好写）。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://labuladong.gitee.io/algo/4/30/113/">BFS 算法解题套路框架</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> BFS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是端到端（end-to-end）的学习模型</title>
      <link href="/2022/03/07/%E4%BB%80%E4%B9%88%E6%98%AF%E7%AB%AF%E5%88%B0%E7%AB%AF%EF%BC%88end-to-end%EF%BC%89%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B/"/>
      <url>/2022/03/07/%E4%BB%80%E4%B9%88%E6%98%AF%E7%AB%AF%E5%88%B0%E7%AB%AF%EF%BC%88end-to-end%EF%BC%89%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p><strong>端到端的学习模型</strong>是指将原始数据不做任何的预处理直接将原始数据输入到模型当中，最后得到的输出结果与期望结果有误差，这误差在反向传播模型的各层中，将参数进行优化，一直到期望结果结束。<strong>非端到端</strong>是将原始数据进行标注，得到具有特征的处理后的数据，然后在作为输入，这样的弊端是如果提取数据特征时出现错误，将无法调整。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://www.its203.com/article/qq_42514225/108835224?2022-03-07">什么是端到端的学习模型</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大M对齐子集</title>
      <link href="/2022/03/01/%E6%9C%80%E5%A4%A7M%E5%AF%B9%E9%BD%90%E5%AD%90%E9%9B%86/"/>
      <url>/2022/03/01/%E6%9C%80%E5%A4%A7M%E5%AF%B9%E9%BD%90%E5%AD%90%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>有 N 个点位于一条线上，编号从 0 到 N-1 ，其坐标在数组 A 中给出。对于每个I (0 ≤ l &lt;N)，直线上点数 I 的坐标为 A[l] 。点的坐标可能相同。</p><p>对于给定的整数 M ，如果子集内任意两个点之间的距离可被M整除，则称这些点的子集为M<strong>对齐</strong>。您的任务是查找给定 N 个点集的最大 M 对齐子集的大小。</p><p>例如，考虑整数 M=3 和数组 A，如下所示：</p><blockquote><p>A[0] = -3  A[1] = -2  A[2] = 1  A[3] = 0  A[4] = 8  A[5] = 7  A[6] = 1</p></blockquote><p>包含编号为1、2、5和6的点的子集，坐标分别为-2、1、7和1，是3对齐子集的示例，因为：</p><ul><li>编号为1和2的点之间的距离为abs(A[1] - A[2]) = 3，</li><li>从5号点到编号1和2的点的距离分别为9和6，</li><li>从6号点到编号为1、2和5的点的距离分别为3、0和6，</li></ul><p>这些距离都可以被 M=3 整除。此子集的大小为4，并且没有更大的3对齐子集。</p><p>编写一个函数:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> M)</span></span>;</span><br></pre></td></tr></table></figure><p>给定一个由 N 个整数和一个整数 M 组成的数组 A，返回最大 M 对齐子集的大小。</p><p>例如，给定 M=3 且 A=[-3，-2，1，0，8，7，1]，函数应返回4，如上所述；</p><p>给定 M=8 且 A=[7，1，11，8,4，10]，函数应返回1。</p><h1 id="解"><a href="#解" class="headerlink" title="解"></a>解</h1><p>把所有按 M 的余数存成一组就可以，<strong>同组的刚好把余数消掉就是距离整除</strong>。返回最大即为所求。</p><p><strong>注意</strong>：余数为负的，需要转为最小正余数（+M）</p><h2 id="Java实现"><a href="#Java实现" class="headerlink" title="Java实现"></a>Java实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> M)</span></span>&#123;</span><br><span class="line">    <span class="comment">//remainders[i] = j, 表示余数为i的频次是j</span></span><br><span class="line">    <span class="keyword">int</span>[] remainders = <span class="keyword">new</span> <span class="keyword">int</span>[M];</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>; <span class="comment">// 记录最大的频次</span></span><br><span class="line">    <span class="keyword">int</span> N = A.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> remainder = A[i] % M;</span><br><span class="line">        <span class="keyword">if</span>(remainder &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            remainder += M;</span><br><span class="line">        &#125;</span><br><span class="line">        remainders[remainder] ++;</span><br><span class="line">        ans = Math.max(ans, remainders[remainder]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 数论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>求数字1在所有不超过N的十进制正整数中出现的次数</title>
      <link href="/2022/03/01/%E6%B1%82%E6%95%B0%E5%AD%971%E5%9C%A8%E6%89%80%E6%9C%89%E4%B8%8D%E8%B6%85%E8%BF%87N%E7%9A%84%E5%8D%81%E8%BF%9B%E5%88%B6%E6%AD%A3%E6%95%B4%E6%95%B0%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/"/>
      <url>/2022/03/01/%E6%B1%82%E6%95%B0%E5%AD%971%E5%9C%A8%E6%89%80%E6%9C%89%E4%B8%8D%E8%B6%85%E8%BF%87N%E7%9A%84%E5%8D%81%E8%BF%9B%E5%88%B6%E6%AD%A3%E6%95%B4%E6%95%B0%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>写一个函数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span> N)</span></span>;</span><br></pre></td></tr></table></figure><p>即给定一个整数N，返回数字1在所有不超过 N 的正整数的十进制表示中出现的次数。</p><p>例如，给定N = 13，该函数应返回6，因为：</p><ul><li>所有不超过13的正整数是1、2、3、4、5、6、7、8、9、10、11、12 和13；</li><li>数字1共出现六次：一次在数字1中，一次在数字10中，两次在数字11中，一次在数字12中，一次在数字13中。</li></ul><p>N 是[0.. 100,000,000]范围内的整数。</p><h1 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h1><p>暴力求解：遍历每一个数，对每一个数求1的个数，然后加起来得和。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span> N)</span><span class="comment">//统计1-n中1的个数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&gt;<span class="number">0</span>; j/=<span class="number">10</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(j%<span class="number">10</span>==<span class="number">1</span>)</span><br><span class="line">ans ++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法时间复杂度：$O(nlgn)$</p><h1 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h1><p>考虑两位数。将一个正整数中1的个数分成两部分，一部分是个位上出现1的数目f1(n)，一部分是十位上出现1的数目f2(n) 。</p><p>n=10， f1(10)=1（1-10个位出现的1的个数为1），f2(10)=1（1-10个位出现的1的十数为1）。</p><p>举一些代表性的数：</p><div class="table-container"><table><thead><tr><th>n</th><th>f1(n)</th><th>f2(n)</th><th>f(n)</th></tr></thead><tbody><tr><td>10</td><td>1</td><td>1</td><td>2</td></tr><tr><td>11</td><td>2</td><td>2</td><td>4</td></tr><tr><td>12</td><td>2</td><td>3</td><td>5</td></tr><tr><td>13</td><td>2</td><td>4</td><td>6</td></tr><tr><td>20</td><td>2</td><td>10</td><td>12</td></tr><tr><td>21</td><td>3</td><td>10</td><td>13</td></tr><tr><td>22</td><td>3</td><td>10</td><td>13</td></tr><tr><td>23</td><td>3</td><td>10</td><td>13</td></tr><tr><td>30</td><td>3</td><td>10</td><td>13</td></tr><tr><td>31</td><td>4</td><td>10</td><td>14</td></tr><tr><td>32</td><td>4</td><td>10</td><td>14</td></tr><tr><td>33</td><td>4</td><td>10</td><td>14</td></tr></tbody></table></div><p>先来看十位，当十位上的数为1时，</p><div class="table-container"><table><thead><tr><th>n</th><th>f2(n)</th></tr></thead><tbody><tr><td>10</td><td>1</td></tr><tr><td>11</td><td>2</td></tr><tr><td>12</td><td>3</td></tr><tr><td>13</td><td>4</td></tr></tbody></table></div><p>f2(n)=当前数个位数字+1；</p><p>当十位上的数大于1时，</p><div class="table-container"><table><thead><tr><th>n</th><th>f2(n)</th></tr></thead><tbody><tr><td>20</td><td>10</td></tr><tr><td>21</td><td>10</td></tr><tr><td>22</td><td>10</td></tr><tr><td>23</td><td>10</td></tr><tr><td>30</td><td>10</td></tr><tr><td>31</td><td>10</td></tr><tr><td>32</td><td>10</td></tr><tr><td>33</td><td>10</td></tr></tbody></table></div><p>f2(n) = 10，也就是说此时十位上1的数目仅仅和十位有关系，也就是<strong>十位的位因子</strong>10。</p><p>再来看个位，当个位上的数为1的时候</p><div class="table-container"><table><thead><tr><th>n</th><th>f1(n)</th></tr></thead><tbody><tr><td>11</td><td>2</td></tr><tr><td>21</td><td>3</td></tr><tr><td>31</td><td>4</td></tr></tbody></table></div><p>f1(n) = 当前数十位数字+1；</p><p>当个位上的数大于1时，</p><div class="table-container"><table><thead><tr><th>n</th><th>f1(n)</th></tr></thead><tbody><tr><td>22</td><td>3</td></tr><tr><td>23</td><td>3</td></tr><tr><td>32</td><td>4</td></tr><tr><td>33</td><td>4</td></tr></tbody></table></div><p>f1(n) = 当前数十位数字+1；</p><p>还有当个位上的数等于0时，</p><div class="table-container"><table><thead><tr><th>n</th><th>f1(n)</th></tr></thead><tbody><tr><td>10</td><td>1</td></tr><tr><td>20</td><td>2</td></tr><tr><td>30</td><td>3</td></tr></tbody></table></div><p>f1(n) = 当前数十位数字。</p><p>这还不够，我们还没有分析两位数以上的数字，根据上面的分析，我们将当前位分为三种情况：=0，=1，&gt;1。</p><p>当百位上的数字是0的时候，假设n=12013。此时1-12013的所有整数中，百位上出现1的数是100~199，1100~1199，2100~2199……11100~11199。也就是12个100，1200个。也就是说此时百位上1的数目是由高位（12）决定的，而且等于高位（12）* 当前位因子（100）。</p><p>当百位上的数字是1的时候，假设n=12113。此时1-12113的所有整数中，百位上出现1的数是100~199，1100~1199，2100~2199……11100~11199，12100~12113。也就是13个100，1300个。也就是说此时百位上1的数目是由高位（12）决定的，而且等于（高位（12）+1）* 当前位因子（100）。</p><p>还有一个小问题就是如何求一个数的高位和低位，还有当前位。这和当前位的位因子有关系。</p><p>对于12345，假设当前位是百位（100），则</p><ul><li>低位数字：12345 - (12345 / 100) *100 = 45</li><li>高位数字：12345 / (100 * 10) = 12</li><li>当前位数字：12345 / 100 = 123，123 % 10 = 3。</li></ul><p>以上分析可以写出完整代码。</p><h2 id="Java实现"><a href="#Java实现" class="headerlink" title="Java实现"></a>Java实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> lowNum = <span class="number">0</span>; <span class="comment">// 当前位的低位的数字</span></span><br><span class="line">    <span class="keyword">int</span> currNum = <span class="number">0</span>; <span class="comment">// 当前位数字</span></span><br><span class="line">    <span class="keyword">int</span> highNum = <span class="number">0</span>; <span class="comment">// 当前位的高位的数字</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> factor = <span class="number">1</span>; factor &lt;= N; factor *= <span class="number">10</span>) &#123; <span class="comment">// 位因子</span></span><br><span class="line">        lowNum = N - (N / factor) * factor;</span><br><span class="line">        currNum = (N / factor) % <span class="number">10</span>;</span><br><span class="line">        highNum = N / (factor * <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span>(currNum == <span class="number">0</span>) &#123;</span><br><span class="line">            ans += highNum * factor;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(currNum == <span class="number">1</span>) &#123;</span><br><span class="line">            ans += highNum * factor + lowNum +<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans += (highNum + <span class="number">1</span>) * factor;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度只与N的位数有关，为$O(lgn)$。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://blog.csdn.net/liangbopirates/article/details/9323727">求1-N中十进制正整数1的个数</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【不会做】矩阵路径形成的最大整数</title>
      <link href="/2022/03/01/%E3%80%90%E4%B8%8D%E4%BC%9A%E5%81%9A%E3%80%91%E7%9F%A9%E9%98%B5%E8%B7%AF%E5%BE%84%E5%BD%A2%E6%88%90%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B4%E6%95%B0/"/>
      <url>/2022/03/01/%E3%80%90%E4%B8%8D%E4%BC%9A%E5%81%9A%E3%80%91%E7%9F%A9%E9%98%B5%E8%B7%AF%E5%BE%84%E5%BD%A2%E6%88%90%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B4%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>您将获得一个由 N 行和 M 列组成的板。电路板的每个字段（其实就是数组中的一个坐标点，作者注）都包含一个数字 (0-9)。</p><p>您希望查找由四个相邻字段组成的路径。如果两个字段共享一个共同点，则它们是相邻的。此外，路径中的字段应该是不同的（不能两次访问同一字段）。</p><p>路径的四位数字（按您访问它们的顺序）创建一个 整数。通过这种方式可以实现的最大整数是多少?</p><p>编写函数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span> <span class="params">(<span class="keyword">int</span>[][] board)</span> </span>;</span><br></pre></td></tr></table></figure><p>给定表示为由 N 行和 M 列组成的整数矩阵的板，则返回在长度为 4 的路径中连接值时可以实现的最大整数。<br>例子：给定以下板（N=3, M=5） :</p><p><img src="image-20220228105252210.png" alt="图1"></p><p>该函数应返回9121。您可以选择以下路径（第一 个字段用红色表示)：</p><p><img src="image-20220228105416502.png" alt="图2"></p><h1 id="解"><a href="#解" class="headerlink" title="解"></a>解</h1><p>知道用回溯或者BFS，但是代码写不出来。😓</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 回溯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人比较喜欢的健身动作</title>
      <link href="/2022/02/28/%E4%B8%AA%E4%BA%BA%E6%AF%94%E8%BE%83%E5%96%9C%E6%AC%A2%E7%9A%84%E5%81%A5%E8%BA%AB%E5%8A%A8%E4%BD%9C/"/>
      <url>/2022/02/28/%E4%B8%AA%E4%BA%BA%E6%AF%94%E8%BE%83%E5%96%9C%E6%AC%A2%E7%9A%84%E5%81%A5%E8%BA%AB%E5%8A%A8%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文整理一下个人比较喜欢健身动作。并备注动作要点</p></blockquote><h1 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h1><h2 id="平板支撑"><a href="#平板支撑" class="headerlink" title="平板支撑"></a>平板支撑</h2><p>改善的平板支撑：</p><ol><li>身体后移</li><li>骨盆后倾：收紧臀部，感觉上向后顶</li><li>纠正身体位置。肩膀用力向前推，上肢离地更远。</li></ol><p>新手先做到第二点延长到60秒，再两点一起做。</p><p>禁忌：</p><ol><li>手臂后缩</li><li>提臀或者臀太低。相反要用力收紧骨盆</li></ol><h1 id="臀腿"><a href="#臀腿" class="headerlink" title="臀腿"></a>臀腿</h1><h2 id="深蹲"><a href="#深蹲" class="headerlink" title="深蹲"></a>深蹲</h2><p>使用弹力带加大深蹲的阻力。</p><h2 id="单腿罗马尼亚硬拉"><a href="#单腿罗马尼亚硬拉" class="headerlink" title="单腿罗马尼亚硬拉"></a>单腿罗马尼亚硬拉</h2><p>锻炼臀肌、腘绳肌，锻炼单腿站立的稳定性，膝关节得稳定性。</p><p>视频：<a href="https://www.bilibili.com/video/BV1Ci4y1R72o?spm_id_from=333.999.0.0">https://www.bilibili.com/video/BV1Ci4y1R72o?spm_id_from=333.999.0.0</a></p><h1 id="背部"><a href="#背部" class="headerlink" title="背部"></a>背部</h1><h2 id="引体向上"><a href="#引体向上" class="headerlink" title="引体向上"></a>引体向上</h2><p>如果做不来可以使用弹力绳辅助。</p><h1 id="前锯肌"><a href="#前锯肌" class="headerlink" title="前锯肌"></a>前锯肌</h1><p>待整理：<a href="https://www.bilibili.com/video/BV1qq4y1k7oP?spm_id_from=333.999.0.0">https://www.bilibili.com/video/BV1qq4y1k7oP?spm_id_from=333.999.0.0</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://www.bilibili.com/video/BV1SP4y1j71R?spm_id_from=333.999.0.0">核心太弱，肚子肯定大（3个技巧快速改善）</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 方法论 </category>
          
          <category> 健身 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 健身 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Keep上不错的课程合集</title>
      <link href="/2022/02/28/Keep%E4%B8%8A%E4%B8%8D%E9%94%99%E7%9A%84%E8%AF%BE%E7%A8%8B%E5%90%88%E9%9B%86/"/>
      <url>/2022/02/28/Keep%E4%B8%8A%E4%B8%8D%E9%94%99%E7%9A%84%E8%AF%BE%E7%A8%8B%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文整理了一些适合自己的Keep课程，这些课程都亲自做过一遍。</p><p>本文会不断更新。</p></blockquote><div class="table-container"><table><thead><tr><th>课程名称</th><th>课程链接</th><th>难度</th><th>部位</th><th>器械</th><th>感受</th></tr></thead><tbody><tr><td>HIIT - 腹肌塑造</td><td><a href="https://show.gotokeep.com/course/607fefaa1310a35004149bc4">https://show.gotokeep.com/course/607fefaa1310a35004149bc4</a></td><td>3</td><td>腹部</td><td>不需要</td><td>挺累的，但是不难。做完腹部有明显酸痛</td></tr><tr><td>哑铃全方位胸部刺激-罗洪Ric</td><td><a href="https://show.gotokeep.com/course/6051a1b41310a33405483f53">https://show.gotokeep.com/course/6051a1b41310a33405483f53</a></td><td>4</td><td>胸部</td><td>哑铃</td><td>很有感觉。</td></tr><tr><td>哑铃手臂轰炸</td><td><a href="https://show.gotokeep.com/course/59ddde95a29e342161e42290">https://show.gotokeep.com/course/59ddde95a29e342161e42290</a></td><td>3</td><td>手臂</td><td>哑铃</td><td>练了好几次，快没感觉了，可能需要加大重量</td></tr><tr><td>跃动燃脂强化</td><td><a href="https://show.gotokeep.com/course/5b1e349aa29e343df182c7c0">https://show.gotokeep.com/course/5b1e349aa29e343df182c7c0</a></td><td>4</td><td>全身</td><td>不需要</td><td>挺累的。。</td></tr><tr><td>家庭哑铃增肌特训 · 强力臀腿</td><td><a href="https://show.gotokeep.com/course/601696ae627efb1bdd12ae13">https://show.gotokeep.com/course/601696ae627efb1bdd12ae13</a></td><td>3</td><td>臀腿</td><td>哑铃</td><td>忘记了。</td></tr><tr><td>核心功能强化</td><td><a href="https://show.gotokeep.com/course/5b90af2da29e342ee240c94f">https://show.gotokeep.com/course/5b90af2da29e342ee240c94f</a></td><td>4</td><td>腰腹</td><td>不需要</td><td>和“HIIT - 腹肌塑造”有点重复</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 方法论 </category>
          
          <category> 健身 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 健身 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>银行转账</title>
      <link href="/2022/02/27/%E9%93%B6%E8%A1%8C%E8%BD%AC%E8%B4%A6/"/>
      <url>/2022/02/27/%E9%93%B6%E8%A1%8C%E8%BD%AC%E8%B4%A6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文FROM 微软 软开 笔试题</p></blockquote><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>您将获得两个银行之间的N次转账列表（编号0到N-1）：银行A和银行B，第K次传输由两个值描述：</p><ul><li>R[K]（A或B）代表收款人（转账发送到的银行）；</li><li>V[K]表示通过传输发送的值。</li></ul><p>所有转移均按他们在列表中出现的顺序完成。银行不想负债（即他们的账户余额可能不会低于0）。每家银行的初始账户余额最低是多少才能完成转账？</p><p>编写一个函数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] solution(String R, <span class="keyword">int</span>[] V);</span><br></pre></td></tr></table></figure><p>给定一个字符串R和一个长度均为N的整数数组V，返回一个由两个整数组成的数组。证书应按以下顺序表示银行A和B的最小初始账户余额：[银行A, 银行B]。</p><p>结果数组应作为整数向量返回。</p><p>例子：</p><ol><li>给定R = “BAABA”且V=[2,4,1,1,2]，函数应该返回[2, 4]。每次转账后的银行账户余额如下表所示：</li></ol><div class="table-container"><table><thead><tr><th></th><th>A</th><th>B</th></tr></thead><tbody><tr><td>初始余额</td><td>2</td><td>4</td></tr><tr><td>A -&gt; B：转移 2</td><td>0</td><td>6</td></tr><tr><td>B -&gt; A：转移 4</td><td>4</td><td>2</td></tr><tr><td>B -&gt; A：转移 1</td><td>5</td><td>1</td></tr><tr><td>A -&gt; B：转移 1</td><td>4</td><td>2</td></tr><tr><td>B -&gt; A：转移 2</td><td>6</td><td>0</td></tr></tbody></table></div><ol><li>给定R = “ABAB”且V=[10,5,10,15]，函数应返回[0, 15]。</li><li>给定R = “B”且V=[100]，函数应返回[100, 0]。</li></ol><p>为以下假设编写有效算法。</p><h1 id="解"><a href="#解" class="headerlink" title="解"></a>解</h1><p>以例1为例，设计银行A的初始余额为X，银行B的初始余额为Y。则每一次转账后A的余额分别为：</p><p>X-2, X+2, X+3, X+2, X+4；B的余额分别为：</p><p>Y+2, Y-2, Y-3, Y-2, Y-4；</p><p>根据题目要求得any(X, X-2, X+2, X+3, X+2, X+4) &gt;=0 &amp;&amp; any(Y, Y+2, Y-2, Y-3, Y-2, Y-4)&gt;=0</p><p>即要求X-2&gt;=0; Y-4&gt;=0;</p><p>题目求最小初始余额，可得，X=2； Y=4</p><p>下面是代码实现。</p><h2 id="Java实现"><a href="#Java实现" class="headerlink" title="Java实现"></a>Java实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] solution(String R, <span class="keyword">int</span>[] V) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = V.length;</span><br><span class="line">    <span class="keyword">int</span>[] A = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">int</span>[] B = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span>(R.charAt(<span class="number">0</span>) == <span class="string">&#x27;B&#x27;</span>) &#123;</span><br><span class="line">        B[<span class="number">0</span>] = V[<span class="number">0</span>];</span><br><span class="line">        A[<span class="number">0</span>] = -V[<span class="number">0</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        B[<span class="number">0</span>] = -V[<span class="number">0</span>];</span><br><span class="line">        A[<span class="number">0</span>] = V[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> min_A = A[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> min_B = B[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(R.charAt(i) == <span class="string">&#x27;B&#x27;</span>) &#123;</span><br><span class="line">            A[i] = A[i-<span class="number">1</span>] - V[i];</span><br><span class="line">            B[i] = B[i-<span class="number">1</span>] + V[i];</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            A[i] = A[i-<span class="number">1</span>] + V[i];</span><br><span class="line">            B[i] = B[i-<span class="number">1</span>] - V[i];</span><br><span class="line">        &#125;</span><br><span class="line">        min_A = Math.min(min_A, A[i]);</span><br><span class="line">        min_B = Math.min(min_B, B[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//min_A和min_B不能是负数</span></span><br><span class="line">    min_A = Math.max(<span class="number">0</span>, -min_A);</span><br><span class="line">    min_B = Math.max(<span class="number">0</span>, -min_B);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;min_A, min_B&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>找到数组中比左边元素都大同时比右边元素都小的元素</title>
      <link href="/2022/02/23/%E6%89%BE%E5%88%B0%E6%95%B0%E7%BB%84%E4%B8%AD%E6%AF%94%E5%B7%A6%E8%BE%B9%E5%85%83%E7%B4%A0%E9%83%BD%E5%A4%A7%E5%90%8C%E6%97%B6%E6%AF%94%E5%8F%B3%E8%BE%B9%E5%85%83%E7%B4%A0%E9%83%BD%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/"/>
      <url>/2022/02/23/%E6%89%BE%E5%88%B0%E6%95%B0%E7%BB%84%E4%B8%AD%E6%AF%94%E5%B7%A6%E8%BE%B9%E5%85%83%E7%B4%A0%E9%83%BD%E5%A4%A7%E5%90%8C%E6%97%B6%E6%AF%94%E5%8F%B3%E8%BE%B9%E5%85%83%E7%B4%A0%E9%83%BD%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>求数组中比左边元素都大同时比右边元素都小的元素，返回这些元素的索引。要求时间复杂度$O(N)$</p><blockquote><p>输入：[2, 3, 1, 8, 9, 20, 12]<br>输出：3, 4<br>解释：数组中 8, 9 满足题目要求，他们的索引分别是 3、4</p></blockquote><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>最简单最暴力的就是没从头到尾遍历元素，对于每个元素分别往前、往后遍历一下，看看是否它是否满足条件。</p><p>这种解法的时间复杂度为$O(N^2)$，不符合题目要求。</p><p>通过分析可以得到，对于每个元素，如果它比<strong>左侧最大的值</strong>要大，同时比<strong>右侧最小的值</strong>要小，就满足条件。</p><p>那如果有这样两个数组，</p><p><code>left_max[i]</code> 表示原数组 [0, i) 的最大值</p><p><code>right_min[i]</code> 表示原数组 (i, n) 的最小值</p><p>内循环就可以通过 <code>left_max[i] &lt; nums[i] &amp;&amp; nums[i] &lt; right_min[i]</code> 来判断了。</p><p>对于 left_max 和 right_min 这两数组，提前先算好，每个数组都能$O(N)$得到。</p><p>left_max 和 right_min 递推式如下：</p><blockquote><p>left_max[i] = max(left_max[i-1], nums[i])</p><p>right_min[i] = min(right_min[i-1], nums[i])</p></blockquote><p>总时间复杂度为 $O(N)$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ...</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] left_max = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span>[] right_min = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(left_max, Integer.MIN_VALUE);</span><br><span class="line">        Arrays.fill(right_min, Integer.MAX_VALUE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            left_max[i] = Math.max(left_max[i-<span class="number">1</span>], nums[i-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n-<span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            right_min[i] = Math.min(right_min[i+<span class="number">1</span>], nums[i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; left_max[i] &amp;&amp; nums[i] &lt; right_min[i]) &#123;</span><br><span class="line">                res.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://mp.weixin.qq.com/s/ilOdw4qdu_EJZNXvybqdag">一道热乎的字节三面原创题</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 数组/链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何读论文</title>
      <link href="/2022/02/22/%E5%A6%82%E4%BD%95%E8%AF%BB%E8%AE%BA%E6%96%87/"/>
      <url>/2022/02/22/%E5%A6%82%E4%BD%95%E8%AF%BB%E8%AE%BA%E6%96%87/</url>
      
        <content type="html"><![CDATA[<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>一篇论文往往分为<strong>标题，摘要，导言，算法，实验，结论</strong>。</p><p><strong>算法</strong>就是论文作者提出的新的方法；<strong>实验</strong>是为了证明提出的算法。</p><h2 id="读第一遍"><a href="#读第一遍" class="headerlink" title="读第一遍"></a>读第一遍</h2><p>关注<strong>标题</strong>，<strong>摘要</strong>和<strong>结论</strong>；结论和摘要往往是一个东西，但是结论会把摘要的问题给证明一下；顺便看一下算法和实验部分的图标。</p><p><strong>目的</strong>：</p><ul><li>这篇论文介绍了什么</li><li>是否与自己相关</li><li>质量怎么样</li><li>是否继续读下去</li></ul><h2 id="读第二遍"><a href="#读第二遍" class="headerlink" title="读第二遍"></a>读第二遍</h2><p>如果第一遍认为该论文需要读下去，则进行第二遍通读，可以忽略很细节的部分，例如公式证明。</p><p>圈出引用的重要的相关的文献，例如，作者解决的问题是哪篇论文提出的，作者的方法是哪篇论文改进来的。</p><p><strong>目的：</strong></p><ul><li>掌握论文中的每一个图、表是什么意思；</li><li>作者的方法和别人的方法是怎么对比的，差距有多大</li></ul><h2 id="读第三遍"><a href="#读第三遍" class="headerlink" title="读第三遍"></a>读第三遍</h2><p>详细阅读第三遍，读懂每一句话，每一个细节。感同身受的去读。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://www.bilibili.com/video/BV1H44y1t75x">如何读论文 - 李沐</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 方法论 </category>
          
          <category> 阅读AI论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 方法论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>_Python 抛出异常后程序继续执行</title>
      <link href="/2022/02/22/Python-%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E5%90%8E%E7%A8%8B%E5%BA%8F%E7%BB%A7%E7%BB%AD%E6%89%A7%E8%A1%8C/"/>
      <url>/2022/02/22/Python-%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E5%90%8E%E7%A8%8B%E5%BA%8F%E7%BB%A7%E7%BB%AD%E6%89%A7%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文是一个知识碎片</p></blockquote><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>当遇到异常时，为了让程序继续执行而不中断，代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 可能抛出异常的代码块</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>注：<strong>这样做需要谨慎</strong>，原因如下：</p><ol><li>这样做抛出异常的类型不明确。可能抛出了你并不想忽略的异常；</li><li>这样做过于敷衍（除非你是有目的的这么做）</li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://blog.csdn.net/weixin_43307577/article/details/87710251">Python异常处理 -跳过异常继续执行</a></li><li><a href="https://developer.aliyun.com/article/803360">问题：为什么“except:pass”是一个不好的编程习惯？</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 异常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《动手学深度学习》读书笔记（三）CNN的填充、步幅、通道、池化</title>
      <link href="/2022/02/15/%E3%80%8A%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89CNN%E7%9A%84%E5%A1%AB%E5%85%85%E3%80%81%E6%AD%A5%E5%B9%85%E3%80%81%E9%80%9A%E9%81%93%E3%80%81%E6%B1%A0%E5%8C%96/"/>
      <url>/2022/02/15/%E3%80%8A%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89CNN%E7%9A%84%E5%A1%AB%E5%85%85%E3%80%81%E6%AD%A5%E5%B9%85%E3%80%81%E9%80%9A%E9%81%93%E3%80%81%E6%B1%A0%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文FROM《动手学深度学习》第六章 卷积神经网络 6.3、6.4和6.5小节</p><p>虽然标题中，填充、步幅、通道、池化放在一起，但是实际这四者并非并列关系。</p></blockquote><h1 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h1><p>在卷积神经网络中，卷积的输出形状取决于输入形状和卷积核的形状。</p><p>例如，一个 240×240 像素的图像，经过 10 层 5×5 的卷积后，将减少到 200×200 像素。如此一来，原始图像的边界丢失了许多有用信息。而<strong>填充</strong>是解决此问题最有效的方法。</p><p>下面的图展示了带填充的二维互相关。</p><p><img src="conv-pad.svg" alt="带填充的二维互相关"></p><p>设网络输入宽高分别为 $n_w$ 和 $n_h$，卷积核宽高分别为 $k_w$ 和 $k_h$，如果我们添加 $p_h$ 行填充（大约一半在顶部，一半在底部）和 $p_w$ 列填充（左侧大约一半，右侧一半），则输出形状将为</p><script type="math/tex; mode=display">(n_h-k_h+p_h+1)\times(n_w-k_w+p_w+1)。</script><p>这意味着输出的高度和宽度将分别增加 $p_h$ 和 $p_w$。</p><p>在许多情况下，我们需要设置 $p_h=k_h-1$ 和 $p_w=k_w-1$，使输入和输出具有相同的高度和宽度。这样可以在构建网络时更容易地预测每个图层的输出形状。假设 $k_h$ 是奇数，我们将在高度的两侧填充 $p_h/2$ 行。<br>如果 $k_h$ 是偶数，则一种可能性是在输入顶部填充 $\lceil p_h/2\rceil$ 行，在底部填充 $\lfloor p_h/2\rfloor$ 行。填充宽度的两侧同理。</p><p>卷积神经网络中卷积核的高度和宽度通常为奇数，例如 1、3、5 或 7。选择奇数的好处是，保持空间维度的同时，我们可以在顶部和底部填充相同数量的行，在左侧和右侧填充相同数量的列。</p><p>此外，使用奇数核和填充也提供了书写上的便利。对于任何二维张量 $X$，当满足：</p><ol><li>内核的大小是奇数；</li><li>所有边的填充行数和列数相同；</li><li>输出与输入具有相同高度和宽度</li></ol><p>则可以得出：输出 $Y[i, j]$ 是通过以输入 $X[i, j]$ 为中心，与卷积核进行互相关计算得到的。比如，在下面的例子中，我们创建一个高度和宽度为3的二维卷积层，并<strong>在所有侧边填充1个像素</strong>。给定高度和宽度为8的输入，则输出的高度和宽度也是8。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 为了方便起见，我们定义了一个计算卷积层的函数。</span></span><br><span class="line"><span class="comment"># 此函数初始化卷积层权重，并对输入和输出提高和缩减相应的维数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">comp_conv2d</span>(<span class="params">conv2d, X</span>):</span></span><br><span class="line">    <span class="comment"># 这里的（1，1）表示批量大小和通道数都是1</span></span><br><span class="line">    X = X.reshape((<span class="number">1</span>, <span class="number">1</span>) + X.shape)</span><br><span class="line">    Y = conv2d(X)  <span class="comment"># 将X输入到卷积层中，输出Y</span></span><br><span class="line">    <span class="comment"># 省略前两个维度：批量大小和通道</span></span><br><span class="line">    <span class="keyword">return</span> Y.reshape(Y.shape[<span class="number">2</span>:])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 请注意，这里每边都填充了1行或1列，因此总共添加了2行或2列</span></span><br><span class="line">conv2d = nn.Conv2d(<span class="number">1</span>, <span class="number">1</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>)  <span class="comment"># 这里定义了一个卷积层</span></span><br><span class="line">X = torch.rand(size=(<span class="number">8</span>, <span class="number">8</span>))</span><br><span class="line">comp_conv2d(conv2d, X).shape</span><br></pre></td></tr></table></figure><pre><code>torch.Size([8, 8])</code></pre><p>当卷积核的高度和宽度不同时，我们可以填充不同的高度和宽度，使输出和输入具有相同的高度和宽度。在如下示例中，我们使用高度为5，宽度为3的卷积核，高度和宽度两边的填充分别为2和1。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">conv2d = nn.Conv2d(<span class="number">1</span>, <span class="number">1</span>, kernel_size=(<span class="number">5</span>, <span class="number">3</span>), padding=(<span class="number">2</span>, <span class="number">1</span>))</span><br><span class="line">comp_conv2d(conv2d, X).shape</span><br></pre></td></tr></table></figure><pre><code>torch.Size([8, 8])</code></pre><h1 id="步幅"><a href="#步幅" class="headerlink" title="步幅"></a>步幅</h1><p>在计算互相关时，卷积窗口从输入张量的左上角开始，向下、向右滑动。 在前面的例子中，我们默认每次滑动一个元素。 但是，有时候为了高效计算或是缩减采样次数，卷积窗口可以跳过中间位置，每次滑动多个元素。</p><p>我们将每次滑动元素的数量称为步幅（stride）。下图展示了垂直步幅为 3 ，水平步幅为 2 的二维互相关运算。</p><p><img src="conv-stride.svg" alt="垂直步幅为 $3$，水平步幅为 $2$ 的二维互相关运算"></p><p>可以看到，为了计算输出中第一列的第二个元素和第一行的第二个元素，卷积窗口分别向下滑动三行和向右滑动两列。但是，当卷积窗口继续向右滑动两列时，没有输出，因为输入元素无法填充窗口（除非我们添加另一列填充）。</p><p>通常，当垂直步幅为 $s_h$ 、水平步幅为 $s_w$ 时，输出形状为</p><script type="math/tex; mode=display">\lfloor(n_h-k_h+p_h+s_h)/s_h\rfloor \times \lfloor(n_w-k_w+p_w+s_w)/s_w\rfloor.</script><p>如果我们设置了 $p_h=k_h-1$ 和 $p_w=k_w-1$，则输出形状将简化为 $\lfloor(n_h+s_h-1)/s_h\rfloor \times \lfloor(n_w+s_w-1)/s_w\rfloor$。<br>更进一步，如果输入的高度和宽度可以被垂直和水平步幅整除，则输出形状将为 $(n_h/s_h) \times (n_w/s_w)$。</p><p>下面，我们<strong>将高度和宽度的步幅设置为2</strong>，从而将输入的高度和宽度减半。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">conv2d = nn.Conv2d(<span class="number">1</span>, <span class="number">1</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>, stride=<span class="number">2</span>)</span><br><span class="line">comp_conv2d(conv2d, X).shape</span><br></pre></td></tr></table></figure><pre><code>torch.Size([4, 4])</code></pre><p>为了简洁起见，当输入高度和宽度两侧的填充数量分别为 $p_h$ 和 $p_w$ 时，我们称之为填充 $(p_h, p_w)$。当 $p_h = p_w = p$ 时，填充是 $p$。同理，当高度和宽度上的步幅分别为 $s_h$ 和 $s_w$ 时，我们称之为步幅 $(s_h, s_w)$。当时的步幅为 $s_h = s_w = s$ 时，步幅为 $s$。默认情况下，填充为 0，步幅为 1。<strong>在实践中，我们很少使用不一致的步幅或填充，也就是说，我们通常有 $p_h = p_w$ 和 $s_h = s_w$。</strong></p><h1 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h1><p>当我们添加通道时，我们的输入和隐藏的表示从二维张量变成了三维张量。例如，每个RGB输入图像具有 3×h×w 的形状。我们将这个大小为 3 的轴称为通道（channel）维度。</p><p>通道分为输入通道和输出通道。灰度图的输入通道为1，RGB图的输入通道为3。而输出通道是自定义的。灰度图的输出通道也可以大于1，RGB图的输出通道也可以为1，这取决于如何定义卷积核和输出。</p><h2 id="多输入通道"><a href="#多输入通道" class="headerlink" title="多输入通道"></a>多输入通道</h2><p>当输入包含多个通道时，需要构造一个与输入数据具有相同输入通道数目的卷积核，以便与输入数据进行互相关运算。假设输入的通道数为 $c_i$，那么卷积核的输入通道数也需要为 $c_i$ 。如果卷积核的窗口形状是 $k_h\times k_w$，那么当 $c_i=1$ 时，我们可以把卷积核看作形状为 $k_h\times k_w$ 的二维张量。</p><p>然而，当 $c_i&gt;1$ 时，我们卷积核的每个输入通道将包含形状为 $k_h\times k_w$ 的张量。将这些张量 $c_i$ 连结在一起可以得到形状为 $c_i\times k_h\times k_w$ 的卷积核。由于输入和卷积核都有 $c_i$ 个通道，我们可以对每个通道输入的二维张量和卷积核的二维张量进行互相关运算，再对通道求和（将 $c_i$ 的结果相加）得到二维张量。这是多通道输入和多输入通道卷积核之间进行二维互相关运算的结果。</p><p>下图我们演示了一个具有两个输入通道的二维互相关运算的示例。</p><p><img src="conv-multi-in.svg" alt="两个输入通道的互相关计算。"></p><p>多输入通道互相关运算的实现如下。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">corr2d_multi_in</span>(<span class="params">X, K</span>):</span></span><br><span class="line">    <span class="comment"># 先遍历“X”和“K”的第0个维度（通道维度），再把它们加在一起</span></span><br><span class="line">    <span class="comment"># for x, k in zip(X, K) 拿出X, K对应维度里的矩阵</span></span><br><span class="line">    <span class="comment"># d2l.corr2d()函数：完成互相关运算</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(d2l.corr2d(x, k) <span class="keyword">for</span> x, k <span class="keyword">in</span> <span class="built_in">zip</span>(X, K))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = torch.tensor([[[<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>], [<span class="number">3.0</span>, <span class="number">4.0</span>, <span class="number">5.0</span>], [<span class="number">6.0</span>, <span class="number">7.0</span>, <span class="number">8.0</span>]],</span><br><span class="line">               [[<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>], [<span class="number">4.0</span>, <span class="number">5.0</span>, <span class="number">6.0</span>], [<span class="number">7.0</span>, <span class="number">8.0</span>, <span class="number">9.0</span>]]])</span><br><span class="line">K = torch.tensor([[[<span class="number">0.0</span>, <span class="number">1.0</span>], [<span class="number">2.0</span>, <span class="number">3.0</span>]], [[<span class="number">1.0</span>, <span class="number">2.0</span>], [<span class="number">3.0</span>, <span class="number">4.0</span>]]])</span><br><span class="line"></span><br><span class="line">corr2d_multi_in(X, K)</span><br></pre></td></tr></table></figure><pre><code>tensor([[ 56.,  72.],        [104., 120.]])</code></pre><h2 id="多输出通道"><a href="#多输出通道" class="headerlink" title="多输出通道"></a>多输出通道</h2><p>到目前为止，不论有多少输入通道，我们还只有一个输出通道。然而，这是不够的。在最流行的神经网络架构中，随着神经网络层数的加深，我们常会<strong>增加输出通道的维数，通过减少空间分辨率以获得更大的通道深度</strong>。直观地说，我们可以将每个通道看作是对不同特征的响应。而现实可能更为复杂一些，因为每个通道不是独立学习的，而是为了共同使用而优化的。因此，多输出通道并不仅是学习多个单通道的检测器。</p><p>用 $c_i$ 和 $c_o$ 分别表示输入和输出通道的数目，并让 $k_h$ 和 $k_w$ 为卷积核的高度和宽度。为了获得多个通道的输出，我们可以为每个输出通道创建一个形状为 $c_i\times k_h\times k_w$ 的卷积核张量，这样卷积核的形状是 $c_o\times c_i\times k_h\times k_w$。在互相关运算中，每个输出通道先获取所有输入通道，再以对应该输出通道的卷积核计算出结果。</p><p>如下所示，我们实现一个<strong>计算多个通道的输出的互相关函数</strong>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">corr2d_multi_in_out</span>(<span class="params">X, K</span>):</span></span><br><span class="line">    <span class="comment"># 迭代“K”的第0个维度，每次都对输入“X”执行互相关运算。</span></span><br><span class="line">    <span class="comment"># 最后将所有结果都叠加在一起</span></span><br><span class="line">    <span class="comment"># `corr2d_multi_in(X, k) for k in K`意思是在拿出每一个二维卷积核k，都对完整的输入X做互相关运算</span></span><br><span class="line">    <span class="comment"># torch.stack(…, 0)意思是将结果在0的维度上“堆”起来</span></span><br><span class="line">    <span class="keyword">return</span> torch.stack([corr2d_multi_in(X, k) <span class="keyword">for</span> k <span class="keyword">in</span> K], <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>上面代码中，<code>torch.stack(…, 0)</code>是将结果在0的维度上“堆”起来。下面通过将核张量K与K+1（K中每个元素加 1 ）和K+2连接起来，构造了一个具有 3 个输出通道的卷积核。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">K = torch.stack((K, K + <span class="number">1</span>, K + <span class="number">2</span>), <span class="number">0</span>)</span><br><span class="line">K.shape  <span class="comment"># 原始K的维度是(2,2,2)</span></span><br></pre></td></tr></table></figure><pre><code>torch.Size([3, 2, 2, 2])</code></pre><p>下面，我们对输入张量X与卷积核张量K执行互相关运算。现在的输出包含 3 个通道，</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">corr2d_multi_in_out(X, K)</span><br></pre></td></tr></table></figure><pre><code>tensor([[[ 56.,  72.],         [104., 120.]],        [[ 76., 100.],         [148., 172.]],        [[ 96., 128.],         [192., 224.]]])</code></pre><h2 id="1-times-1-卷积层"><a href="#1-times-1-卷积层" class="headerlink" title="$1\times 1$ 卷积层"></a>$1\times 1$ 卷积层</h2><p>$1\times 1$ 卷积，即 $k_h = k_w = 1$，看起来似乎没有多大意义。<br>毕竟，卷积的本质是有效提取相邻像素间的相关特征，而 $1 \times 1$ 卷积显然没有此作用。<br>尽管如此，$1 \times 1$ 仍然十分流行，时常包含在复杂深层网络的设计中。下面，让我们详细地解读一下它的实际作用。</p><p>因为使用了最小窗口，$1\times 1$ 卷积失去了卷积层的特有能力——在高度和宽度维度上，识别相邻元素间相互作用的能力。<br>其实 $1\times 1$ 卷积的唯一计算发生在通道上。</p><p>下图展示了使用 $1\times 1$ 卷积核与 $3$ 个输入通道和 $2$ 个输出通道的互相关计算。这里输入和输出具有相同的高度和宽度，输出中的每个元素都是从输入图像中同一位置的元素的线性组合。我们可以将 $1\times 1$ 卷积层看作是在每个像素位置应用的全连接层，以 $c_i$ 个输入值转换为 $c_o$ 个输出值。因为这仍然是一个卷积层，所以跨像素的权重是一致的。同时，$1\times 1$ 卷积层需要的权重维度为 $c_o\times c_i$ ，再额外加上一个偏置。</p><p><img src="conv-1x1.svg" alt="互相关计算使用了具有3个输入通道和2个输出通道的 $1\times 1$ 卷积核。其中，输入和输出具有相同的高度和宽度。"></p><p>下面，我们使用全连接层实现 $1 \times 1$ 卷积。请注意，我们需要对输入和输出的数据形状进行微调。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">corr2d_multi_in_out_1x1</span>(<span class="params">X, K</span>):</span></span><br><span class="line">    c_i, h, w = X.shape</span><br><span class="line">    c_o = K.shape[<span class="number">0</span>]</span><br><span class="line">    X = X.reshape((c_i, h * w))</span><br><span class="line">    K = K.reshape((c_o, c_i))</span><br><span class="line">    <span class="comment"># 全连接层中的矩阵乘法</span></span><br><span class="line">    Y = torch.matmul(K, X)</span><br><span class="line">    <span class="keyword">return</span> Y.reshape((c_o, h, w))</span><br></pre></td></tr></table></figure><p>当执行 $1\times 1$ 卷积运算时，上述函数相当于先前实现的互相关函数<code>corr2d_multi_in_out</code>。让我们用一些样本数据来验证这一点。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = torch.normal(<span class="number">0</span>, <span class="number">1</span>, (<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line">K = torch.normal(<span class="number">0</span>, <span class="number">1</span>, (<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Y1 = corr2d_multi_in_out_1x1(X, K)</span><br><span class="line">Y2 = corr2d_multi_in_out(X, K)</span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">float</span>(torch.<span class="built_in">abs</span>(Y1 - Y2).<span class="built_in">sum</span>()) &lt; <span class="number">1e-6</span></span><br></pre></td></tr></table></figure><h1 id="pooling"><a href="#pooling" class="headerlink" title="pooling"></a>pooling</h1><p>通常当我们处理图像时，我们希望逐渐降低隐藏表示的空间分辨率，聚集信息，这样随着我们在神经网络中层叠的上升，每个神经元对其敏感的感受野（输入）就越大。</p><p>而我们的机器学习任务通常会跟全局图像的问题有关（例如，“图像是否包含一只猫呢？”）， 所以我们最后一层的神经元应该对整个输入的全局敏感。通过逐渐聚合信息，生成越来越粗糙的映射，最终实现学习全局表示的目标，同时将卷积图层的所有优势保留在中间层。</p><p>此外，当检测较底层的特征时，我们通常希望这些特征保持某种程度上的平移不变性。例如，如果我们拍摄黑白之间轮廓清晰的图像 $X$，并将整个图像向右移动一个像素，即 $Z[i, j] = X[i, j + 1]$，则新图像 $Z$ 的输出可能大不相同。而在现实中，随着拍摄角度的移动，任何物体几乎不可能发生在同一像素上。即使用三脚架拍摄一个静止的物体，由于快门的移动而引起的相机振动，可能会使所有物体左右移动一个像素。</p><p>本节将介绍 <em>池化</em>（pooling）层，它具有双重目的：降低卷积层对位置的敏感性，同时降低对空间降采样表示的敏感性。</p><h2 id="最大汇聚层和平均汇聚层"><a href="#最大汇聚层和平均汇聚层" class="headerlink" title="最大汇聚层和平均汇聚层"></a>最大汇聚层和平均汇聚层</h2><p>与卷积层类似，汇聚层运算符由一个固定形状的窗口组成，该窗口根据其步幅大小在输入的所有区域上滑动，为固定形状窗口（有时称为 <em>池化窗口</em>）遍历的每个位置计算一个输出。</p><p>然而，不同于卷积层中的输入与卷积核之间的互相关计算，汇聚层不包含参数。<br>相反，池运算符是确定性的，我们通常计算池化窗口中所有元素的最大值或平均值。这些操作分别称为 <em>最大汇聚层</em> （maximum pooling）和 <em>平均汇聚层</em> （average pooling）。</p><p>在这两种情况下，与互相关运算符一样，池化窗口从输入张量的左上角开始，从左到右、从上到下的在输入张量内滑动。在池化窗口到达的每个位置，它计算该窗口中输入子张量的最大值或平均值，具体取决于是使用了最大汇聚层还是平均汇聚层。</p><p><img src="pooling.svg" alt="池化窗口形状为 $2\times 2$ 的最大汇聚层。着色部分是第一个输出元素，以及用于计算这个输出的输入元素: $\max(../img/pooling.svg)=4$."></p><p>上图中输出张量的高度为 $2$，宽度为 $2$。这四个元素为每个池化窗口中的最大值：</p><script type="math/tex; mode=display">\max(0, 1, 3, 4)=4,\\\max(1, 2, 4, 5)=5,\\\max(3, 4, 6, 7)=7,\\\max(4, 5, 7, 8)=8.\\</script><p>池化窗口形状为 $p \times q$ 的汇聚层称为 $p \times q$ 汇聚层，池化操作称为 $p \times q$ 池化。</p><p>回到本节开头提到的对象边缘检测示例，现在我们将使用卷积层的输出作为 $2\times 2$ 最大池化的输入。设置卷积层输入为 $X$，汇聚层输出为 $Y$。无论 $X[i, j]$ 和 $X[i, j + 1]$ 的值是否不同，或 $X[i, j + 1]$ 和 $X[i, j + 2]$ 的值是否不同，汇聚层始终输出 $Y[i, j] = 1$。也就是说，使用 $2\times 2$ 最大汇聚层，即使在高度或宽度上移动一个元素，卷积层仍然可以识别到模式。</p><p>在下面的代码中的 <code>pool2d</code> 函数，我们<strong>实现汇聚层的正向传播</strong>。然而，这里我们没有卷积核，输出为输入中每个区域的最大值或平均值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pool2d</span>(<span class="params">X, pool_size, mode=<span class="string">&#x27;max&#x27;</span></span>):</span></span><br><span class="line">    p_h, p_w = pool_size</span><br><span class="line">    Y = torch.zeros((X.shape[<span class="number">0</span>] - p_h + <span class="number">1</span>, X.shape[<span class="number">1</span>] - p_w + <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(Y.shape[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(Y.shape[<span class="number">1</span>]):</span><br><span class="line">            <span class="keyword">if</span> mode == <span class="string">&#x27;max&#x27;</span>:</span><br><span class="line">                Y[i, j] = X[i: i + p_h, j: j + p_w].<span class="built_in">max</span>()</span><br><span class="line">            <span class="keyword">elif</span> mode == <span class="string">&#x27;avg&#x27;</span>:</span><br><span class="line">                Y[i, j] = X[i: i + p_h, j: j + p_w].mean()</span><br><span class="line">    <span class="keyword">return</span> Y</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 构建输入X，验证最大池化的输出</span></span><br><span class="line">X = torch.tensor([[<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>], [<span class="number">3.0</span>, <span class="number">4.0</span>, <span class="number">5.0</span>], [<span class="number">6.0</span>, <span class="number">7.0</span>, <span class="number">8.0</span>]])</span><br><span class="line">pool2d(X, (<span class="number">2</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure><pre><code>tensor([[4., 5.],        [7., 8.]])</code></pre><h2 id="填充与步幅"><a href="#填充与步幅" class="headerlink" title="填充与步幅"></a>填充与步幅</h2><p>与卷积层一样，汇聚层也可以改变输出形状。和以前一样，我们可以通过填充和步幅以获得所需的输出形状。 下面，我们用深度学习框架中内置的二维最大汇聚层，来演示汇聚层中填充和步幅的使用。 我们首先构造了一个输入张量X，它有四个维度，其中样本数和通道数都是1。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = torch.arange(<span class="number">16</span>, dtype=torch.float32).reshape((<span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">4</span>))</span><br><span class="line">X</span><br></pre></td></tr></table></figure><pre><code>tensor([[[[ 0.,  1.,  2.,  3.],          [ 4.,  5.,  6.,  7.],          [ 8.,  9., 10., 11.],          [12., 13., 14., 15.]]]])</code></pre><p>默认情况下，深度学习框架中的步幅与汇聚窗口的大小相同。 因此，如果我们使用形状为(3, 3)的汇聚窗口，那么默认情况下，我们得到的步幅形状为(3, 3)</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pool2d = nn.MaxPool2d(<span class="number">3</span>)</span><br><span class="line">pool2d(X)</span><br></pre></td></tr></table></figure><pre><code>tensor([[[[10.]]]])</code></pre><p>填充和步幅可以手动设定：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pool2d = nn.MaxPool2d(<span class="number">3</span>, padding=<span class="number">1</span>, stride=<span class="number">2</span>)</span><br><span class="line">pool2d(X)</span><br></pre></td></tr></table></figure><p>当然，我们可以设定一个任意大小的矩形汇聚窗口，并分别设定填充和步幅的高度和宽度。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pool2d = nn.MaxPool2d((<span class="number">2</span>, <span class="number">3</span>), stride=(<span class="number">2</span>, <span class="number">3</span>), padding=(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">pool2d(X)</span><br></pre></td></tr></table></figure><pre><code>tensor([[[[ 5.,  7.],          [13., 15.]]]])</code></pre><h2 id="多个通道"><a href="#多个通道" class="headerlink" title="多个通道"></a>多个通道</h2><p>在处理多通道输入数据时，汇聚层在每个输入通道上单独运算，而不是像卷积层一样在通道上对输入进行汇总。 这意味着汇聚层的输出通道数与输入通道数相同。 下面，我们将在通道维度上连结张量X和X + 1，以构建具有2个通道的输入。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = torch.cat((X, X + <span class="number">1</span>), <span class="number">1</span>)</span><br><span class="line">X</span><br></pre></td></tr></table></figure><pre><code>tensor([[[[ 0.,  1.,  2.,  3.],          [ 4.,  5.,  6.,  7.],          [ 8.,  9., 10., 11.],          [12., 13., 14., 15.]],         [[ 1.,  2.,  3.,  4.],          [ 5.,  6.,  7.,  8.],          [ 9., 10., 11., 12.],          [13., 14., 15., 16.]]]])</code></pre><p>pooling后输出通道的数量仍然是2。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pool2d = nn.MaxPool2d(<span class="number">3</span>, padding=<span class="number">1</span>, stride=<span class="number">2</span>)</span><br><span class="line">pool2d(X)</span><br></pre></td></tr></table></figure><pre><code>tensor([[[[ 5.,  7.],          [13., 15.]],         [[ 6.,  8.],          [14., 16.]]]])</code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>《动手学深度学习》6.3、6.4、6.5节</li></ol>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
          <category> 动手学深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 动手学深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 多线程基础</title>
      <link href="/2022/01/24/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/01/24/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇博客叙述Java多线程的基本知识和基本操作。</p><blockquote><p>待补充的部分：</p><ul><li>[ ] 线程调度</li><li>[ ] AtomicInteger</li><li>[ ] Semaphore</li><li>[ ] 阻塞队列的实现类详解</li><li>[ ] 多线程共享数据的方法</li><li>[ ] ConcurrentHashMap</li><li>[ ] Java并发关键字</li><li>[ ] 进程调度算法</li><li>[ ] CAS/ABA/AQS</li></ul></blockquote><h1 id="线程概述"><a href="#线程概述" class="headerlink" title="线程概述"></a>线程概述</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>当一个程序进入内存运行时，即变成一个进程。进程是处于运行过程中的程序，并且具有一定独立的功能，进程是系统进行资源分配和调度的一个独立单位。</p><p>一般而言，进程包含三个特征：独立性；动态性；并发性。、</p><p>并发和并行是两个概念，并行是指同一时刻，有多条指令在多个处理器上同时执行；并发指在同一时刻只能有一条指令执行，但多个进程指令被快速轮换执行，使得宏观上具有多个进程同时执行的效果。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>多线程扩展了多进程的概念，使得同一个进程可以同时并发处理多个任务。</p><p>线程是进程的执行单元，是进程的组成部分，一个进程可以拥有多个线程，一个线程必须有一个父进程。线程可以拥有自己的堆栈、自己的程序计数器和自己的局部变量。</p><p>多个线程共享父进程里的全部资源，可以与其他线程共享父进程中的共享变量和部分环境。</p><p>线程是独立于运行的，他并不知道进程中是否还有其他线程存在。现成的执行是抢占式的，也就是说，当前运行的线程在任何时候都可能被挂起，以便另一个线程可以运行。</p><p>一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行。</p><p>从逻辑的角度，多线程存在于一个应用程序中，让一个应用程序中可以有多个执行部分同时执行，但操作系统无须将多个线程看作多个独立的应用，对多线程实现调度和管理以及资源分配。线程的调度和管理由进程本身负责完成。</p><h2 id="线程优势"><a href="#线程优势" class="headerlink" title="线程优势"></a>线程优势</h2><p>进程中线程的之间的隔离程度更小。</p><p>多个线程共享同一个进程虚拟空间。线程共享的环境包括：进程代码段、进程的共有数据等。<br>总结起来，使用多线程编程具有如下优点：</p><ul><li>进程之间不能共享内存，但线程之间共享内存很容易</li><li>系统创建进程时，需要位该进程重新分配系统资源，但创建线程则代价小很多，因此使用多线程实现多任务并发比多进程的效率高。</li><li>Java语言内置了多线程功能支持，而不是单纯的作为底层操作系统的调度方式，从而简化了Java的多线程编程。</li></ul><h1 id="线程创建和启动"><a href="#线程创建和启动" class="headerlink" title="线程创建和启动"></a>线程创建和启动</h1><p>有三种方式创建线程类</p><h2 id="继承Thread类创建线程类"><a href="#继承Thread类创建线程类" class="headerlink" title="继承Thread类创建线程类"></a>继承Thread类创建线程类</h2><ol><li>定义Thread的子类，并重写run方法，该run方法的方法题就代表了线程需要完成的任务。（线程执行体）</li><li>创建Thread子类的实例，即创建了线程对象。</li><li>调用线程对象的start方法来启动该线程。</li></ol><h2 id="实现Runnable接口创建线程类"><a href="#实现Runnable接口创建线程类" class="headerlink" title="实现Runnable接口创建线程类"></a>实现Runnable接口创建线程类</h2><ol><li>定义Runnable接口的实现类，并重写该接口的run方法。该run方法的方法体同样是该线程的线程执行体。</li><li>创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。</li></ol><blockquote><p>代码</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTester</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> firstThread().start();</span><br><span class="line">        <span class="keyword">new</span> firstThread().start();</span><br><span class="line">        Runnable tt = <span class="keyword">new</span> secondThread();</span><br><span class="line">        <span class="keyword">new</span> Thread(tt, <span class="string">&quot;新线程1&quot;</span>).start(); <span class="comment">//可以给线程命名</span></span><br><span class="line">        <span class="keyword">new</span> Thread(tt, <span class="string">&quot;新线程2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">firstThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(getName() + <span class="string">&quot;：&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">secondThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：&quot;</span> + i); <span class="comment">//只能使用Thread.currentThread().getName()来获得线程名</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注</p><ul><li>使用继承Thread类的方法来创建线程类时，多个线程之间无法共享线程类的实例变量。</li><li>Runnable对象仅作为Thread对象的target，Runnable实现类里包含的run方法仅作为线程执行体。而实际的线程对象依然是Thread实例，只是该Thread线程负责执行其target的run方法。</li><li>通过实现Runnable接口来获得当前线程对象，则必须使用Thread.currentThread()方法。</li><li>从Java8开始，Runnable接口使用了@FunctionalInterface，也就是说，可以使用Lambda表达式创建Runnable对象。下面介绍的Callable接口也是函数式接口。</li></ul><h2 id="使用Callable和Future创建线程"><a href="#使用Callable和Future创建线程" class="headerlink" title="使用Callable和Future创建线程"></a>使用Callable和Future创建线程</h2><p>Callable接口提供了一个call方法可以作为线程执行体，但call方法比run方法功能更强大。</p><ul><li>call方法有返回值。</li><li>call可以声明抛出异常。</li></ul><p>完全可以提供一个Callable对象作为Thread的target，而该线程的线程执行体就是该Callable对象的call方法。但Callable接口不是Runnable接口的子接口，所以Callable对象不能直接作为Thread的target。</p><p>Java5提供了Future接口来代表Callable接口里call方法的返回值，并为Future接口提供了一个FutureTask实现类，该实现类实现了Future接口并实现了Runnable接口，可以作为Thread类的target。</p><p><img src="20160713174739239.png" alt="FutureTask"></p><p>Future接口中定义了如下公共方法来控制它关联的Callable任务。</p><ul><li><code>boolean cancel(boolean mayInterroutIfRunning)</code>：试图取消该Future里关联的Callable任务。</li><li><code>V get()</code>：返回Callable任务里的call方法的返回值。调用该方法将导致程序阻塞，必须等待子线程接口后才会得到返回值。</li><li><code>V get(long timeout, TimeUnit unit)</code>：返回Callable任务里的call方法的返回值。该方法让程序最多阻塞timeout和unit指定的时间，如果经过指定时间后Callable任务依然没有返回值，将会抛出TimeoutException异常。</li><li><code>boolean isCancelled()</code>如果Callable任务正常完成前被取消，则返回true。</li><li><code>boolean isDone()</code>如果Callable任务已完成，则返回true。</li></ul><p>创建并启动有返回值的线程步骤如下：</p><ol><li>创建Callable接口的实现类，并实现call方法（注意泛型），该call方法将作为线程执行体，且该call方法有返回值，再创建Callable实现类的实例。</li><li>使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call方法的返回值。</li><li>使用FutureTask对象作为Thread对象的target创建并启动新线程。</li><li>调用FutureTask对象的get方法来获得子线程执行结束后的返回值。</li></ol><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableTester</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> thirdThread()); <span class="comment">//也可以使用lambda表达式生成Callable对象</span></span><br><span class="line">        <span class="keyword">new</span> Thread(task, <span class="string">&quot;有返回值的线程1&quot;</span>).start();</span><br><span class="line"><span class="comment">//        new Thread(task, &quot;有返回值的线程2&quot;).start(); // 不生效，task对象只能用一次？</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程返回值：&quot;</span>+task.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">thirdThread</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span>(; i &lt; <span class="number">10</span> ; i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：Callable接口有泛型限制，Callable接口里的泛型形参类型与call方法返回值类型相同。</p><h2 id="三种创建线程的方式对比"><a href="#三种创建线程的方式对比" class="headerlink" title="三种创建线程的方式对比"></a>三种创建线程的方式对比</h2><ul><li>实现Runnable接口和实现Callable接口的方式基本相同，只是Callable接口里定义的方法有返回值，可以声明抛出异常而已。</li><li>采用实现Runnable、Callable接口的方式的优点是<ul><li>线程类还可以继承其他类</li><li>多个线程可以共享一个target对象，非常适合多个相同线程来处理同一份资源的情况。</li></ul></li><li>采用继承Thread类方式创建多线程的优点是：<ul><li>编写简单</li></ul></li></ul><h1 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h1><p>一个线程要经过新建（New）、就绪（Ready）、运行（Running）、阻塞（Blocked）、死亡（Dead）5种状态。</p><p>线程状态以及转换图如下：</p><p><img src="image-20210709151939392.png" alt="线程生命周期"></p><h2 id="新建和就绪状态"><a href="#新建和就绪状态" class="headerlink" title="新建和就绪状态"></a>新建和就绪状态</h2><p>当程序使用了new关键字创建了一个线程之后，该线程就处于新建状态。</p><p>当线程调用了start方法后，该线程就处于就绪状态。处于就绪状态的线程并没有开始运行，只是表示该线程可以运行了。</p><h2 id="运行和阻塞状态"><a href="#运行和阻塞状态" class="headerlink" title="运行和阻塞状态"></a>运行和阻塞状态</h2><p>如果处于就绪状态的线程获得了CPU，开始执行run方法的线程执行体，则该线程就处于运行状态。</p><p>线程在运行过程种需要被中断，目的是使其他线程获得执行的机会。当前执行的线程被阻塞后，其他线程就可以获得执行的机会。被阻塞的线程会在合适的时候将重新进入<strong>就绪状态</strong>。</p><p>比较特殊的情况，调用yield方法可以让运行状态的线程转入就绪状态。、</p><h2 id="线程死亡"><a href="#线程死亡" class="headerlink" title="线程死亡"></a>线程死亡</h2><p>线程可以以如上图三种方式死亡。</p><p>为了测试某个线程是否死亡，可以调用线程对象的isAlive方法，当线程处于就绪、运行、阻塞三种状态时，该方法将返回true；当线程处于新建、死亡两种状态时，该方法将返回false。</p><p>注意：</p><ul><li>当主线程结束时，其他线程不受影响，并不会随之结束。一旦子线程启动起来后，他就拥有和主线程相同的地位，他不会受主线程的影响。</li><li>不要试图对一个已经死亡的线程调用start方法使他重新启动。</li><li>对于新建状态的线程两次调用start方法也是错误的。</li></ul><h1 id="控制线程"><a href="#控制线程" class="headerlink" title="控制线程"></a>控制线程</h1><h2 id="join线程"><a href="#join线程" class="headerlink" title="join线程"></a>join线程</h2><p>Thread提供了一个让线程等待另一个线程完成的方法——join方法。当在某个车光绪执行流中调用其他线程的join方法时，调用线程将被阻塞，直到被join方法加入的join线程执行完为止。</p><p>join方法通常由使用线程的程序调用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinTester</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread jt = <span class="keyword">new</span> joinThread();</span><br><span class="line">        jt.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">20</span>) &#123;</span><br><span class="line">                jt.join();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">joinThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="image-20210709163027111.png" alt="join 运行结果"></p><p>由于在主线程调用了子线程的join方法，则主线程必须等到子线程（被Join的线程）执行完毕才能继续执行。</p><h2 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h2><p>有一种线程，他是在后台运行的，他的任务是为其他线程提供服务，这种线程被称为“后台线程（Daemon Thread）”，又称为守护线程或精灵线程。</p><p>后台线程有个特征：<strong>如果前台线程都死亡，后台线程会自动死亡。</strong></p><p>调用Thread的setDaemon(true)方法可将指定线程设置为后台线程。</p><p>Thread类还提供一个isDaemon方法，用于判断指定线程是否为后台线程。</p><p>前台线程创建的子线程默认就是前台线程，后台线程创建的子程序默认是后台线程。</p><p>注意：要将某个线程设置为后台线程，必须在该线程启动之前设置，也就是说setDaemon(true)比如在start方法之前调用。否则会引发异常。</p><h2 id="线程睡眠sleep"><a href="#线程睡眠sleep" class="headerlink" title="线程睡眠sleep"></a>线程睡眠sleep</h2><p><code>Thread.sleep(long milis)</code></p><p>Thread提供了一个与sleep方法有点相似的yield方法，后者也可以让当前正在执行的线程暂停，但他不会阻塞该线程，他只是将该线程转入就绪状态。yield只是让当前线程暂停一下。让系统的线程调度器重新调度一次。</p><p>关于sleep方法和yield方法的区别如下：</p><ul><li>sleep方法暂停当前线程后，会给其他线程执行机会，不会理会其他线程的优先级；但yield方法只会给同优先级相同，或优先级更高的线程执行机会。</li><li>sleep方法会将线程转入阻塞状态，直到经过阻塞时间才会转入就绪状态；而yield不会讲线程转入阻塞状态，他只是强制当前线程进入就绪状态。因此完全有可能某个线程被yield方法暂停之后，立即再次获得处理器资源被执行。</li><li>sleep方法声明抛出了异常，所以调用sleep方法必须捕捉或者显式声明抛出该异常；而yield没有声明抛出任何异常。</li><li>sleep方法比yield方法具有更好的移植性，更推荐用于控制并发线程的执行。</li></ul><h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><p>每个线程执行都具有一定的优先级，优先级高的线程获得较多的执行机会，而优先级低的线程则获得较少的执行机会。</p><p>每个线程默认的优先级都与创建它的父线程的优先级相同，在默认情况下，main线程具有普通优先级，由main线程创建的子线程也具有普通优先级。</p><p>Thread类提供了setPriority(int newPriority)、getPriority方法来指定或返回指定线程的优先级。其中setPriority的参数可以是一个整数，范围是1~10之间，也可以使用Thread类的如下三个静态常量。</p><ul><li>MAX_PRIORITY：其值为10</li><li>MIN_PRIORITY：其值为1</li><li>NORM_PRIORITY：其值为5</li></ul><p>这些优先级需要操作系统的支持，因此应该尽量避免直接为线程指定优先级，而应该使用上述三个静态常量。</p><h1 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h1><h2 id="抢占式调度"><a href="#抢占式调度" class="headerlink" title="抢占式调度"></a>抢占式调度</h2><h2 id="协同式调度"><a href="#协同式调度" class="headerlink" title="协同式调度"></a>协同式调度</h2><h2 id="Java的线程调度方式：抢占式"><a href="#Java的线程调度方式：抢占式" class="headerlink" title="Java的线程调度方式：抢占式"></a>Java的线程调度方式：抢占式</h2><h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><p>线程安全的经典问题：银行取钱问题。下面使用两个线程模拟两个人从一个银行账户中取钱。接下来定义一个账户类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String accountNo;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> balance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Account</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(String accountNo, <span class="keyword">double</span> balance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.accountNo = accountNo;</span><br><span class="line">        <span class="keyword">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略getter、setter</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBalance</span><span class="params">(<span class="keyword">double</span> balance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Account account = (Account) o;</span><br><span class="line">        <span class="keyword">return</span> account.accountNo.equals(accountNo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accountNo.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后是取钱线程类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DrawThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="comment">//账户</span></span><br><span class="line">    <span class="keyword">private</span> Account account;</span><br><span class="line">    <span class="comment">//取得钱数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> drawAmount;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DrawThread</span><span class="params">(String name, Account account, <span class="keyword">double</span> drawAmount)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.account = account;</span><br><span class="line">        <span class="keyword">this</span>.drawAmount = drawAmount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(account.getBalance() &gt;= drawAmount) &#123;</span><br><span class="line">            System.out.println(getName() + <span class="string">&quot;取钱成功，吐出钞票：&quot;</span> + drawAmount);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            account.setBalance(account.getBalance() - drawAmount);</span><br><span class="line">            System.out.println(<span class="string">&quot;余额为：&quot;</span>+ account.getBalance());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(getName() + <span class="string">&quot;取钱失败，余额不足&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是主程序</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DrawTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个账户</span></span><br><span class="line">        Account account = <span class="keyword">new</span> Account(<span class="string">&quot;0001&quot;</span>, <span class="number">1000</span>);</span><br><span class="line">        <span class="comment">//模拟两个线程取钱</span></span><br><span class="line">        <span class="keyword">new</span> DrawThread(<span class="string">&quot;甲&quot;</span>, account, <span class="number">800</span>).start();</span><br><span class="line">        <span class="keyword">new</span> DrawThread(<span class="string">&quot;乙&quot;</span>, account, <span class="number">800</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果<strong>可能</strong>为如下：</p><p><img src="image-20210710000053047.png" alt="线程同步 运行结果"></p><p>这就涉及了线程同步问题。</p><h2 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h2><p>之所以出现上述结果，是因为run方法的方法体不具有线程安全性，程序有两个并发线程在修改Account对象。</p><p>为了解决这样的问题，Java的多线程支持引入了同步监视器来解决这个问题，使用让同步监视器的通用方法就是同步代码块，语法格式如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(obj) &#123;</span><br><span class="line">    <span class="comment">//此处的代码就是同步代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：</p><ol><li>上述obj就是同步监视器，上面代码的含义是线程开始执行同步代码块之前必须先获得对同步监视器的锁定。</li><li>任何时刻只能有一个线程可以获得对同步监视器的锁定，当同步代码块执行完成后，该线程会释放对同步监视器的锁定。</li><li>通常推荐使用可能被并发访问的共享资源充当同步监视器。</li></ol><blockquote><p>synchronized属于独占式的悲观锁，同时属于可重入锁。</p><p>Synchronized的实现原理：详见《Offer来了 原理篇》P87</p></blockquote><p>根据上述修改代码考虑使用Account作为同步监视器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DrawThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="comment">//账户</span></span><br><span class="line">    <span class="keyword">private</span> Account account;</span><br><span class="line">    <span class="comment">//取得钱数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> drawAmount;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DrawThread</span><span class="params">(String name, Account account, <span class="keyword">double</span> drawAmount)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.account = account;</span><br><span class="line">        <span class="keyword">this</span>.drawAmount = drawAmount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//同步代码块：使用account作为同步监视器，任何线程进入下面同步代码块之前，必须先获得对account账户的锁定，其他线程无法获得锁也就无法修改它，这种做法符合“加锁，修改，释放锁”的逻辑</span></span><br><span class="line">        <span class="keyword">synchronized</span> (account) &#123;</span><br><span class="line">            <span class="keyword">if</span>(account.getBalance() &gt;= drawAmount) &#123;</span><br><span class="line">                System.out.println(getName() + <span class="string">&quot;取钱成功，吐出钞票：&quot;</span> + drawAmount);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                account.setBalance(account.getBalance() - drawAmount);</span><br><span class="line">                System.out.println(<span class="string">&quot;余额为：&quot;</span>+ account.getBalance());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(getName() + <span class="string">&quot;取钱失败，余额不足&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这种方式就可以保证并发线程在任一时刻只有一个线程可以进入修改共享资源的代码区（也被称为临界区），所以同一时刻只有一个线程处于临界区内，从而保证了线程安全性。</p><h2 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h2><p>同步方法就是使用synchronized关键字来修饰某个方法，则该方法称为同步方法，对于synchronized修饰的实例方法（而非静态方法），无需显式指定同步监视器，同步方法的同步监视器是this，也就是调用该方法的对象。</p><p>下面将Account的balance的访问设置成线程安全的，那么只要把修改balance的方法编程同步方法即可。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String accountNo;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> balance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Account</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(String accountNo, <span class="keyword">double</span> balance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.accountNo = accountNo;</span><br><span class="line">        <span class="keyword">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//getter、setter</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAccountNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accountNo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    public void setBalance(double balance) &#123;</span></span><br><span class="line"><span class="comment">//        this.balance = balance;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//账户余额不允许修改，所以只为balance提供getter方法，</span></span><br><span class="line">    <span class="comment">//提供一线程安全的draw方法来完成取钱操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">double</span> drawAmount)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(balance &gt;= drawAmount) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;取钱成功！吐出钞票：&quot;</span>+drawAmount);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            balance -= drawAmount;</span><br><span class="line">            System.out.println(<span class="string">&quot;余额为：&quot;</span>+ balance);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;取钱失败，余额不足&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略equals和hashCode方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>因为Account提供了draw方法，而且取消了setBalance方法，DrawThread的run方法需要改写。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    account.draw(drawAmount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：</p><ol><li>synchronized关键字可以修饰方法，代码块但是布恩那个修饰构造器、成员变量等。</li><li>经过上述修改，DrawThread类无需自己实现取钱操作，而是直接调用account的draw方法。由于draw方法使用了synchronized修饰，同步方法的监视器是this。在上面的示例种，this是account，因此多个线程并发访问同一份account之前必须先对account加锁。这就保证了线程安全。</li><li>在Account里定义draw方法，而不是直接在run方法种实现取钱逻辑，这种做法更符合面向对象的规则。在面向对象里有一种流行的设计：Domain Driven Design（<strong>领域驱动设计</strong>，DDD），这种方式认为每个类都应该是完备的领域对象，例如账户类应该提供账户的相关方法。</li><li>为了减少线程安全带来的降低程序运行效率的影响应该：不要对线程安全类的所有方法进行同步，只对那些改变京城资源的方法进行同；如果可变类有两种运行环境：单线程运行环境和多线程运行环境，则应该为可变类提供两种版本。</li></ol><h2 id="释放同步监视器的锁定"><a href="#释放同步监视器的锁定" class="headerlink" title="释放同步监视器的锁定"></a>释放同步监视器的锁定</h2><p>程序无法显式释放对同步监视器的锁定，线程会在如下几种情况下释放对同步监视器的锁定。</p><ul><li>当前线程的同步方法、同步代码块执行结束。</li><li>当前线程在同步代码块，同步方法中遇到了break、return终止了该代码块、该方法的继续执行。</li><li>当前线程在同步代码块，同步方法中遇到了未处理的Error或Exception</li><li>程序执行了同步监视器对象的wait方法，则当前线程暂停，并释放同步监视器。</li></ul><p>在如下情况下，线程不会释放同步监视器。</p><ul><li>程序调用了Thread.sleep、Thread.yield方法来暂停当前线程的执行，</li><li>其他线程调用了该线程的suspend方法将线程挂起。</li></ul><h2 id="同步锁"><a href="#同步锁" class="headerlink" title="同步锁"></a>同步锁</h2><p>Lock提供了比synchronized方法和synchronized代码块更广泛更灵活的操作。</p><p>Lock是控制多个线程对共享资源进行访问的工具，通常，锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。</p><p>Lock接口的主要方法：</p><ul><li><code>void lock();</code> 加锁</li><li><code>void lockInterruptibly()</code> 当前线程未被中断则获取该锁。</li><li><code>boolean tryLock();</code>试图加锁，但不会阻塞</li><li><code>boolean tryLock(long time, TimeUnit unit)</code> 创建定时锁</li><li><code>void unlock();</code> 释放锁</li><li><code>Condition newCondition();</code> 创建条件对象，获取等待通知组件。</li></ul><p>Lock、ReadWriteLock是J5提供的两个根接口，并为Lock提供了ReentrantLock（可重入锁）【常用】实现类，为ReadWriteLock提供了ReentrantReadWriteLock实现类。</p><p>J8新增了StampedLock类，在大多数场景下可以替代传统的ReentrantReadWriteLock。ReentrantReadWriteLock为读写操作提供了三种锁模式：Writing、ReadingOptimistic、Reading</p><p>通常使用ReentrantLock的代码格式如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">//定义需要保证线程安全的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//需要保证线程安全的代码</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ReentrantLock是一个可重入的独占锁。通过AQS来实现锁的获取和释放。</p><p>ReentrantLock不但提供了Synchronized对锁的操作功能。还提供了诸如可响应中断锁、可轮询锁请求，定时锁等避免多线程死锁的方法。</p></blockquote><p>根据Lock的使用修改Account的代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String accountNo;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> balance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Account</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(String accountNo, <span class="keyword">double</span> balance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.accountNo = accountNo;</span><br><span class="line">        <span class="keyword">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//getter、setter</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAccountNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accountNo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    public void setBalance(double balance) &#123;</span></span><br><span class="line"><span class="comment">//        this.balance = balance;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//账户余额不允许修改，所以只为balance提供getter方法，</span></span><br><span class="line">    <span class="comment">//提供一线程安全的draw方法来完成取钱操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">double</span> drawAmount)</span></span>&#123;</span><br><span class="line">        lock.lock(); <span class="comment">//加锁</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(balance &gt;= drawAmount) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;取钱成功！吐出钞票：&quot;</span>+drawAmount);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                balance -= drawAmount;</span><br><span class="line">                System.out.println(<span class="string">&quot;余额为：&quot;</span>+ balance);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;取钱失败，余额不足&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">//释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//省略hashCode、equals</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用Lock与使用同步方法有点相似，只是使用Lock时显式使用Lock对象作为同步锁，而使用同步方法时系统隐式使用当前对象作为同步监视器。</p><p>同步方法或同步代码块使用竞争资源相关的、隐式的同步监视器，并且强制要求加锁和释放锁要出现在一个块结构中。并且获取了多个锁时，他们必须以相反的顺序释放。所以同步方法或同步代码块的范围机制使得多线程安全编程非常方便，可以避免很多锁的常见编程错误。</p><p>Lock提供了同步方法或同步代码块所没有的其他功能，包括tryLock方法，以及试图获取可中断锁的lockInterruptibly方法，还可以获取超时失效锁的tryLock(long, TimeUnit)方法</p><p>ReentrantLock锁具有可重入性，也就是说，一个线程可以对已加锁的ReentrantLock锁再次加锁，ReentrantLock对象会维持一个计数器来追踪lock方法的嵌套调用，线程在每次调用lock加锁后，必须显式调用unlock来释放锁，所以一段被所保护的代码可以调用另一个被相同锁保护的方法。</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>编写程序时应尽量避免死锁。</p><ul><li>避免多次锁定：尽量避免同一个线程对多个同步监视器进行锁定</li><li>具有相同的加锁顺序：如果多个线程需要对多个同步监视器进行锁定，则应该保证他们以相同的顺序请求加锁。</li><li>使用定时锁：设置锁的超时时间。</li><li>依靠算法进行死锁检测。</li></ul><h1 id="Java锁详解"><a href="#Java锁详解" class="headerlink" title="Java锁详解"></a>Java锁详解</h1><p>Java中的锁主要保障多并发线程情况下的数据一致性。</p><p>锁从乐观和悲观的角度可分为乐观锁和悲观锁，从获取资源的公平性角度可分为公平锁和非公平锁，从是否共享资源的角度可分为共享锁和独占锁，从锁的状态可分为偏向锁，轻量级锁和重量级锁。此外JVM还设计了自旋锁来更快的使用CPU。</p><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>乐观锁，在每次读取数据时都认为别人不会修改数据，所以不会上锁，但在更新时会判断在此期间别人有没有更新该数据，通常在写时先读出当前版本号然后加锁的方法。具体过程是，比较当前版本号和上一版本号，如果版本号一致，则更新，否则重复进行读、比较、写操作。</p><p>Java中的乐观锁大部分是通过CAS算法实现的。</p><h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p>悲观锁，在每次读取数据时都认为别人会修改数据，所以每次在读写数据都会上锁，这样别人像读写这个数据就会阻塞、等待直到拿到锁。</p><p>Java中的悲观锁大部分是通过AQS架构实现的。许多同步类的实现都依赖于它，例如Synchronized、ReentrantLock、Semaphore、CountDownLatch。该框架下的锁先尝试以乐观锁去获取锁，如果获取不到，则会转为悲观锁。</p><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>自旋锁认为，如果持有锁的线程能够在很短时间内释放锁，那么等待竞争的锁线程不需要阻塞、挂起状态切换，只需要等一等（内旋），在持有锁的线程释放锁之后即可立即获得锁，这样减少了时间损耗。</p><p>线程自选时会占用CPU，所以需要设置一个自选等待的最大时间。</p><p>自旋锁的优缺点：</p><ul><li>优点：减少了CPU上下文的切换，对于占用锁的时间非常短或锁竞争不激烈的代码块来说，性能大幅提升。</li><li>缺点：线程如果在自旋过程中长时间获取不到锁资源，将会引起CPU的浪费。</li></ul><h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><p>可重入锁是指该锁支持一个线程对同一个资源多次加锁。Synchronized、ReentrantLock都是可重入锁。</p><h2 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h2><p>允许多个线程同时获取该锁，并发访问共享资源。ReentrantReadWriteLock中的读锁为共享锁的实现。</p><p>共享锁采用了乐观的加锁策略，允许多个执行读操作的线程同时访问共享资源。</p><h2 id="独占锁"><a href="#独占锁" class="headerlink" title="独占锁"></a>独占锁</h2><p>也叫互斥锁。每次只允许一个线程持有该锁。ReentrantLock为独占锁的实现。</p><p>独占锁是一种悲观的加锁策略。同一时刻只允许一个读线程读取锁资源，限制了读操作的并发性。</p><h2 id="重量级锁、轻量级锁和偏向锁"><a href="#重量级锁、轻量级锁和偏向锁" class="headerlink" title="重量级锁、轻量级锁和偏向锁"></a>重量级锁、轻量级锁和偏向锁</h2><p>以后再说。</p><h2 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h2><ul><li>公平锁指再分配锁之前检查是否有线程在排队等待获取锁，优先将锁分配给排队时间最长的线程。</li><li>非公平锁指在分配锁时不考虑线程排队的情况，直接尝试获取锁，在获取不到锁时在排到队尾等待。</li></ul><p>公平锁需要在多核的情况下维护一个锁线程等待队列，基于该队列进行锁的分配，因此效率比非公平锁低很多。</p><p>Java中的Synchronized、ReentrantLock默认lock方法都是非公平锁。</p><h2 id="读写锁：ReadWriteLock"><a href="#读写锁：ReadWriteLock" class="headerlink" title="读写锁：ReadWriteLock"></a>读写锁：ReadWriteLock</h2><p>Lock接口及对象加的锁是普通锁，这种锁不区分读写。为了提高性能，Java提供了读写锁。</p><p>读写锁分为读锁和写锁。多个读锁不互斥，读锁和写锁互斥。在没有写锁的情况下，读是无阻塞的。</p><p>一般做法是分别定义一个读锁和写锁。在Java中使用ReentrantReadWriteLock来完成对读写锁的定义和使用。</p><h2 id="分段锁"><a href="#分段锁" class="headerlink" title="分段锁"></a>分段锁</h2><p>分段锁是一种思想。用于将数据分段并在每个分段上都单独加锁，把锁进一步细粒度化，以提高并发效率。例如：ConcurrentHashMap</p><h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><ul><li>减少锁的持有时间</li><li>减少锁粒度</li><li>锁分离</li><li>锁粗化</li><li>锁消除</li></ul><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>不再赘述。</p><h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h2><p>不再赘述。</p><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>以后再说</p><h2 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h2><p>以后再说</p><h1 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h1><p>通过一个案例，来学习线程通信部分的知识。</p><p>假设系统有一个特殊的需求：系统要求存款者和取款者不断重复地存款取款，而且要求每当存款者将钱存入账户，取款者就立刻去除这笔钱，不允许连续两次存钱，也不允许连续两次取钱。</p><h2 id="传统的线程通信"><a href="#传统的线程通信" class="headerlink" title="传统的线程通信"></a>传统的线程通信</h2><p>为了实现上述功能，可以借助Object类提供的wait、notify、notifyAll方法。这三个方法不属于Thread，但是这三个方法必须由同步监视器对象来调用。</p><ul><li>对于synchronized修饰的同步方法，this就是同步监视器对象，所以可以直接在同步方法中直接调用这三个方法。</li><li>对于synchronized修饰的同步代码块，同步监视器是synchronized后括号里的对象，必须使用该对象调用这三个方法。</li></ul><p>下面介绍这三个方法：</p><ul><li>wait：导致当前线程等待，直到其他线程调用该同步监视器的notify或notifyAll来唤醒该线程。无参数的wait方法会一直等待，带时间参数的wait方法线程会在指定时间后自动苏醒。</li><li>notify：唤醒在此同步监视器上等待的单个线程。唤醒是任意的。只有当前线程放弃对该同步监视器的锁定后，才可以执行被唤醒的线程。</li><li>notifyAll：唤醒在此同步监视器上等待的所有线程。</li></ul><p>本程序为Account类提供了draw方法和deposit方法，分别对应账户的取钱和存钱操作。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String accountNo;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> balance; <span class="comment">//账户余额</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>; <span class="comment">//是否已有存款</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Account</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(String accountNo, <span class="keyword">double</span> balance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.accountNo = accountNo;</span><br><span class="line">        <span class="keyword">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//getter、setter</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAccountNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accountNo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    public void setBalance(double balance) &#123;</span></span><br><span class="line"><span class="comment">//        this.balance = balance;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//账户余额不允许修改，所以只为balance提供getter方法，</span></span><br><span class="line">    <span class="comment">//提供一线程安全的draw方法来完成取钱操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">double</span> drawAmount)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!flag) &#123; <span class="comment">//无存款，则取钱线程阻塞</span></span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;取钱：&quot;</span> + drawAmount);</span><br><span class="line">                balance -= drawAmount;</span><br><span class="line">                System.out.println(<span class="string">&quot;账户余额：&quot;</span>+ balance);</span><br><span class="line">                flag = <span class="keyword">false</span>; <span class="comment">//存款标志设置为false</span></span><br><span class="line">                notifyAll(); <span class="comment">//唤醒其他线程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">deposit</span><span class="params">(<span class="keyword">double</span> depositAmount)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag) &#123; <span class="comment">//有存款，则存款线程阻塞</span></span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;存款：&quot;</span> + depositAmount);</span><br><span class="line">                balance += depositAmount;</span><br><span class="line">                System.out.println(<span class="string">&quot;账户余额：&quot;</span>+ balance);</span><br><span class="line">                flag = <span class="keyword">true</span>; <span class="comment">//存款标志设置为false</span></span><br><span class="line">                notifyAll(); <span class="comment">//唤醒其他线程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略hashCode、equals</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来是取款者和存款者线程</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取款线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DrawThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="comment">//账户</span></span><br><span class="line">    <span class="keyword">private</span> Account account;</span><br><span class="line">    <span class="comment">//取得钱数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> drawAmount;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DrawThread</span><span class="params">(String name, Account account, <span class="keyword">double</span> drawAmount)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.account = account;</span><br><span class="line">        <span class="keyword">this</span>.drawAmount = drawAmount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            account.draw(drawAmount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//存款线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DepositThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="comment">//账户</span></span><br><span class="line">    <span class="keyword">private</span> Account account;</span><br><span class="line">    <span class="comment">//取得钱数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> depositAmount;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DepositThread</span><span class="params">(String name, Account account, <span class="keyword">double</span> depositAmount)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.account = account;</span><br><span class="line">        <span class="keyword">this</span>.depositAmount = depositAmount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            account.deposit(depositAmount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后是主程序：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个账户</span></span><br><span class="line">    Account account = <span class="keyword">new</span> Account(<span class="string">&quot;0001&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//一个取款线程，两个存款线程</span></span><br><span class="line">    <span class="keyword">new</span> DrawThread(<span class="string">&quot;取款者&quot;</span>, account, <span class="number">800</span>).start();</span><br><span class="line">    <span class="keyword">new</span> DepositThread(<span class="string">&quot;存款者1&quot;</span>, account, <span class="number">800</span>).start();</span><br><span class="line">    <span class="keyword">new</span> DepositThread(<span class="string">&quot;存款者2&quot;</span>, account, <span class="number">800</span>).start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主程序设置了一个取款者和两个存款者，最后线程会阻塞这是因为两个存款者会有200次存款操作，而一个取款者只有100次取款操作。运行程序可以发现，存取款线程交替执行。</p><h2 id="使用Condition控制线程通信"><a href="#使用Condition控制线程通信" class="headerlink" title="使用Condition控制线程通信"></a>使用Condition控制线程通信</h2><p>如果程序不使用synchronized关键字来保证同步，而是使用Lock对象来保证同步，则系统中不存在隐式的同步监视器，也就不能使用wait、notify、notifyAll方法进行通信了。</p><p>当使用Lock对象来保证同步时，Java提供了一个Condition类来保持协调，使用Condition可以让那些已经得到Lock对象却无法继续执行的线程释放Lock对象，Condition对象也可以唤醒其他处于等待的线程。</p><p>Condition实例被绑定在一个Lock对象上。要获得Lock实例的Condition实例，需要调用Lock都西昂的newCondition方法。Condition提供了如下三个方法</p><ul><li>await：类似于wait方法，导致线程等待，直到其他线程调用该Condition的signal、signalAll方法来唤醒该线程。</li><li>signal：唤醒此Lock对象上等待的单个线程。只有当前线程放弃对该Lock对象的锁定后，才可以执行被唤醒的进程。</li><li>signalAll：唤醒此Lock对象上等待的所有线程。</li></ul><p>根据上面改写Account类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock(); <span class="comment">//定义Lock对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition condition = lock.newCondition();<span class="comment">//获得指定的Condition</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String accountNo;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> balance; <span class="comment">//账户余额</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>; <span class="comment">//是否已有存款</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Account</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(String accountNo, <span class="keyword">double</span> balance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.accountNo = accountNo;</span><br><span class="line">        <span class="keyword">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//getter、setter</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAccountNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accountNo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    public void setBalance(double balance) &#123;</span></span><br><span class="line"><span class="comment">//        this.balance = balance;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//账户余额不允许修改，所以只为balance提供getter方法，</span></span><br><span class="line">    <span class="comment">//提供一线程安全的draw方法来完成取钱操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">double</span> drawAmount)</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!flag) &#123; <span class="comment">//无存款，则取钱线程阻塞</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;取钱：&quot;</span> + drawAmount);</span><br><span class="line">                balance -= drawAmount;</span><br><span class="line">                System.out.println(<span class="string">&quot;账户余额：&quot;</span>+ balance);</span><br><span class="line">                flag = <span class="keyword">false</span>; <span class="comment">//存款标志设置为false</span></span><br><span class="line">                condition.signalAll(); <span class="comment">//唤醒其他线程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">deposit</span><span class="params">(<span class="keyword">double</span> depositAmount)</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag) &#123; <span class="comment">//有存款，则存款线程阻塞</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;存款：&quot;</span> + depositAmount);</span><br><span class="line">                balance += depositAmount;</span><br><span class="line">                System.out.println(<span class="string">&quot;账户余额：&quot;</span>+ balance);</span><br><span class="line">                flag = <span class="keyword">true</span>; <span class="comment">//存款标志设置为false</span></span><br><span class="line">                condition.signalAll(); <span class="comment">//唤醒其他线程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//忽略hashCode、equals</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用阻塞队列控制线程通信"><a href="#使用阻塞队列控制线程通信" class="headerlink" title="使用阻塞队列控制线程通信"></a>使用阻塞队列控制线程通信</h2><p>Java5提供了一个BlockingQueue接口，它主要用作线程同步工具，而非容器。</p><p>BlockingQueue有一个特征：当生产者线程试图向BlockingQueue中放入元素时，如果该队列已满，则该线程被阻塞。当消费者线程试图从BlockingQueue取出元素时，如果该队列已空，则该线程被阻塞。</p><p>程序的两个线程通过交替向BlockingQueue放入取出元素，即可很好的控制线程的通信。</p><p>BlockingQueue包含的方法对应关系如图：</p><div class="table-container"><table><thead><tr><th></th><th>抛出异常</th><th>返回boolean</th><th>阻塞线程</th><th>指定超时市场</th></tr></thead><tbody><tr><td>队尾插入元素</td><td>add(e)</td><td>offer(e)</td><td>put(e)</td><td>offer(e, time, unit)</td></tr><tr><td>队头删除元素</td><td>remove()</td><td>poll()</td><td>take()</td><td>poll(time, unit)</td></tr><tr><td>获取、不删除元素</td><td>element()</td><td>peek()</td><td>无</td><td>无</td></tr></tbody></table></div><p>BlockingQueue与实现类之间类图如下：</p><p><img src="image-20210710181645057.png" alt="BlockingQueue 类图"></p><p>可以看到BlockingQueue的五个实现类</p><p>下面使用BlockingQueue来实现生产者消费者的线程通信。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingQueueTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> Producer(<span class="string">&quot;产品A&quot;</span>, queue).start();</span><br><span class="line">        <span class="keyword">new</span> Producer(<span class="string">&quot;产品B&quot;</span>, queue).start();</span><br><span class="line">        <span class="keyword">new</span> Consumer(queue).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;String&gt; queue;</span><br><span class="line">    <span class="keyword">private</span> String productName ;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(String productName, BlockingQueue&lt;String&gt; queue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.productName = productName;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(productName + i); <span class="comment">//尝试放入元素，如果队列满，则阻塞</span></span><br><span class="line">                System.out.println(getName() + <span class="string">&quot;生产完成：&quot;</span> + queue);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;String&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(BlockingQueue&lt;String&gt; queue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(getName() + <span class="string">&quot;消费元素：&quot;</span> + queue.take());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>该程序不符合预期，原因不明。</strong></p><p><img src="image-20210710190620858.png" alt="阻塞队列 运行结果"></p><h1 id="多线程共享数据"><a href="#多线程共享数据" class="headerlink" title="多线程共享数据"></a>多线程共享数据</h1><h2 id="将数据抽象成一个类，并将这个数据的操作封装到这个类中"><a href="#将数据抽象成一个类，并将这个数据的操作封装到这个类中" class="headerlink" title="将数据抽象成一个类，并将这个数据的操作封装到这个类中"></a>将数据抽象成一个类，并将这个数据的操作封装到这个类中</h2><h2 id="将Runnable对象作为一个类的内部类，将共享数据作为这个类的成员变量"><a href="#将Runnable对象作为一个类的内部类，将共享数据作为这个类的成员变量" class="headerlink" title="将Runnable对象作为一个类的内部类，将共享数据作为这个类的成员变量"></a>将Runnable对象作为一个类的内部类，将共享数据作为这个类的成员变量</h2><h1 id="线程组和未处理的异常"><a href="#线程组和未处理的异常" class="headerlink" title="线程组和未处理的异常"></a>线程组和未处理的异常</h1><h2 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h2><p>Java使用ThreadGroup来表示线程组，Java允许程序对线程组进行控制。用户创建的所有线程都属于指定线程组。如果程序没有显式指定线程属于哪个线程组，则该线程属于默认线程组。默认情况下， 子线程和创建它的父线程处于同一个线程组。</p><p>线程运行中途不能改变它所属的线程组。</p><p>下面是Thread类提供的构造器来设置线程属于哪个线程组：</p><ul><li>Thread(ThreadGroup group, Runnable target)：以target的run方法作为线程执行体创建新线程，属于group线程组。</li><li>Thread(ThreadGroup group, Runnable target, String name)</li><li>Thread(ThreadGroup group, String name)</li></ul><p>Thread提供了一个getThreadGroup方法来返回线程所属的线程组。</p><p>ThreadGroup提供了两个构造器来创建实例。</p><ul><li>ThreadGroup(String name)</li><li>ThreadGroup(ThreadGroup parent, String name)：以指定名字、指定父线程组创建一个新线程组。</li></ul><p>其中name参数是指定线程组的名字，线程组的名字可以通过getName方法得到，但是不能修改。</p><p>ThreadGroup的常用方法：</p><ul><li>int activeCount()</li><li>void isDaemon()</li><li>void interrupt()</li><li>void setDaemon(boolean daemon)</li><li>void setMaxPriority(int pri)</li></ul><p>ThreadGroup内定义了一个很有用的方法：<code>void uncaughtException(Thread t, Throwable e)</code>，该方法可以处理该线程组内的任意线程所抛出的未处理异常。</p><h2 id="线程异常"><a href="#线程异常" class="headerlink" title="线程异常"></a>线程异常</h2><p>Java5之后，如果线程执行过程中抛出了一个未处理的异常，JVM在结束之前会自动查找是否有对应的Thread.UncaughtExceptionHandler对象，如果有，则会调用该对象的<code>uncaughtException(Thread t, Throwable e)</code>来处理异常。</p><p>Thread类提供了两个方法来设置异常处理器：</p><ul><li>setUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh)：为指定线程实例设置默认的异常处理器</li><li>static setDefaultUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh)：为该线程类的所有实例设置默认的异常处理器。</li></ul><p>ThreadGroup类实现了Thread.UncaughtExceptionHandler接口。</p><p>所以线程处理异常的流程如下：</p><ol><li>如果线程设置了异常处理器，则调用该异常处理器处理异常</li><li>查找线程是否属于线程组：<ol><li>如果所属线程组有父线程组，则调用父线程组的uncaughtException方法</li><li>如果该线程组有异常处理器，则使用该异常处理器处理异常。</li></ol></li></ol><p>注意：当使用catch捕获异常时，异常不会向上传播给上一级调用者；但使用异常处理器对异常进行处理后，异常依然会传播给上一级调用者。</p><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>当程序需要创建大量生存期很短暂的线程时，更应该考虑使用线程池。</p><p>线程池在系统启动时即创建大量空闲线程，程序将一个Runnable/Callable对象传给线程池，线程池就会启动一个空闲线程来执行run/call方法，方法执行完毕后，线程不会死亡而是返回线程池成为空闲状态。</p><p>线程池的主要作用是线程复用，线程资源管理，控制操作系统的最大并发数，以保证系统高效（通过线程资源复用实现）且安全（通过控制最大线程并发数实现）的运行。</p><h2 id="线程池的核心组件和核心类"><a href="#线程池的核心组件和核心类" class="headerlink" title="线程池的核心组件和核心类"></a>线程池的核心组件和核心类</h2><p>Java线程池主要由4个核心组件组成。</p><ul><li>线程池管理器：用于创建并管理线程</li><li>工作线程：线程池中执行具体任务的线程。</li><li>任务接口：用于定义工作线程的调度和执行策略，只有线程实现了该接口，线程中的任务才能够被线程池调度。</li><li>任务队列：存放待处理的任务，新的任务将会不断被加入队列中，执行完成的任务将被从队列中移除。</li></ul><p>Java线程池用到了Executor、Executors、ExecutorService、ThreadPoolExecutor、Callable、Future、FutureTask这几个核心类，具体继承关系如下：</p><p><img src="image-20210803000256474.png" alt="线程池核心类 类图"></p><p>ThreadPoolExecutor是构建线程池的核心实现。</p><h2 id="使用Executors管理线程"><a href="#使用Executors管理线程" class="headerlink" title="使用Executors管理线程"></a>使用Executors管理线程</h2><p>Java5以前，开发者必须实现自己的线程池，从Java5开始，新增了一个Executors工厂类来产生线程池。它包含如下静态工厂方法：</p><ul><li>ExecutorService newCachedThreadPool()：创建一个具有缓存功能的线程池</li><li>ExecutorService newFixedThreadPool(int nThreads)：创建一个可重用的、具有固定线程数的线程池</li><li>ExecutorService newSingleThreadExecutor()：创建一个只有单线程的线程池，相当于newFixedThreadPool(1)</li><li>ScheduledExecutorService newScheduledThreadPool(int corePoolSize)：创建具有指定线程数的线程池。参数指出池中所保存的线程数。</li><li>ScheduledExecutorService newSingleThreadScheduledExecutor()：创建只有一个现成的线程池</li><li>ExecutorService newWorkStealingPool(int parallelism)：创建持有足够的线程的线程池来支持给定的并行级别</li><li>ExecutorService newWorkStealingPool()：相当于前一个方法的简化版本，假设当前机器有4个CPU，则相当于前一个方法传入4</li></ul><p>前面介绍的方法中返回值类型中ExecutorService代表线程池，它可以执行Runnable/Callable所代表的线程；ScheduledExecutorService 是ExecutorService的子类，它可以在指定延迟后执行线程任务。</p><p>最后两个方法是J8新增，他们成分利用了多CPU的并行能力，这两个方法创建的相当于后台线程池。</p><p>ExecutorService代表尽快执行线程的线程池：</p><ul><li><code>Future&lt;?&gt; submit(Runnable task)</code>：将一个Runnable对象提交给线程池，线程池将在有空闲线程时执行Runnable对象代表的任务。其中Future对象代表Runnable的返回值，但是run方法没有返回值，所以Future对象将在run方法执行结束后返回null</li><li><code>&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result)</code>：同上一个方法类似，但本方法将在run方法结束后返回result</li><li><code>&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)</code></li></ul><p>ScheduledExecutorService 代表在指定延迟后或周期性的执行线程任务，它提供了四个主要方法：</p><ul><li><code>&lt;V&gt; ScheduledFuture&lt;V&gt; schedule(Callable&lt;V&gt; callable, long delay, TimeUnit unit)</code>：</li><li><code>ScheduledFuture&lt;?&gt; schedule(Runnable command, long delay, TimeUnit unit)</code></li><li><code>ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)</code>：可设定频率重复执行线程任务</li><li><code>ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)</code>：每一次执行终止和下一次执行开始之间都存在一个给定的延迟。</li></ul><p>当用完一个线程池后，应该调用该线程池的shutdown方法，调用shutdown方法后，线程池不再接受新的任务，但会将以前所有已提交任务执行完成。</p><p>使用线程池执行线程任务的步骤如下：</p><ol><li>调用Executors类的静态工厂方法创建一个线程池</li><li>创建Runnable/Callable实例</li><li>调用submit方法提交Runnable/Callable实例</li><li>调用线程池的shutdown方法关闭线程池。</li></ol><p>举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个固定线程处的线程池</span></span><br><span class="line">        ExecutorService pool = Executors.newFixedThreadPool(<span class="number">6</span>);</span><br><span class="line">        Runnable target = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;的i值为：&quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//向线程池提交两个线程</span></span><br><span class="line">        pool.submit(target);</span><br><span class="line">        pool.submit(target);</span><br><span class="line"></span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用ForkJoinPool利用多CPU"><a href="#使用ForkJoinPool利用多CPU" class="headerlink" title="使用ForkJoinPool利用多CPU"></a>使用ForkJoinPool利用多CPU</h2><p>Java7提供了ForkJoinPool来支持多CPU计算。ForkJoinPool是ExecutorService的实现类，因此是一个特殊的线程池。</p><p>ForkJoinPool有两个构造器：</p><ul><li>ForkJoinPool(int parallelism)：创建一个包含parallelism个并行线程的ForkJoinPool</li><li>ForkJoinPool()：以Runtime.availableProcessors方法的返回值作为parallelism参数创建ForkJoinPool</li></ul><p>J8进一步扩展了ForkJoinPool的功能。J8通过提供如下两个静态方法为ForkJoinPool增加了通用池功能。</p><ul><li>ForkJoinPool commonPool()：该方法返回一个通用池，通用池不会受到shutdown或shutdownNow方法的影响。</li><li>int getCommonPoolParallelism：该方法返回通用池的并行级别。</li></ul><p>在创建ForkJoinPool实例之后就可以调用它的submit(ForkJoinTask<T> task)方法来执行指定任务。ForkJoinTask是一个抽象类，他代表一个可并行、合并的任务。他有两个抽象子类。RecursiveAction和RecursiveTask。RecursiveAction代表无返回值的任务，RecursiveTask代表有返回值的任务。</p><p>举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinPoolTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">        Random rand = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = rand.nextInt(<span class="number">20</span>);</span><br><span class="line">            total += (arr[i] = tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;单线程累加的结果为：&quot;</span> + total);</span><br><span class="line"></span><br><span class="line">        Future&lt;Integer&gt; future = pool.submit(<span class="keyword">new</span> CalTask(arr, <span class="number">0</span>, arr.length));</span><br><span class="line">        System.out.println(<span class="string">&quot;并行CPU累加的结果为：&quot;</span> + future.get());</span><br><span class="line"></span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CalTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD = <span class="number">20</span>; <span class="comment">//每个小人物最多累加20个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CalTask</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.arr = arr;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(end - start &lt; THRESHOLD) &#123; <span class="comment">//当数组数量小于THRESHOLD时开始累加</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">                sum += arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//分解成子任务</span></span><br><span class="line">            CalTask left = <span class="keyword">new</span> CalTask(arr, start, mid);</span><br><span class="line">            CalTask right = <span class="keyword">new</span> CalTask(arr, mid, end);</span><br><span class="line">            left.fork();<span class="comment">//执行任务</span></span><br><span class="line">            right.fork();</span><br><span class="line">            <span class="keyword">return</span> left.join() + right.join(); <span class="comment">//返回结果</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="*ThreadPoolExecutor"></a>*ThreadPoolExecutor</h2><p>Java提供了Excutors工具类，适用于小项目，对于一些大型程序还是需要自己创建ThreadPoolExecutor类。这样做的好处有：</p><ul><li>使用ThreadPoolExecutor更加明确线程池的运行规则，规避资源耗尽的风险。</li><li>Excutors的newFixedThreadPool和newSingleThreadExecutor的主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至OOM；Excutors的newCachedThreadPool和newScheduledThreadPool主要问题是线程最大数为Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至OOM。</li></ul><p>ThreadPoolExecutor是构建线程池的核心实现，定义如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="params"><span class="function">                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="params"><span class="function">                              RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体参数如表格：</p><div class="table-container"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>corePoolSize</td><td>线程池中核心线程的数量</td></tr><tr><td>maximumPoolSize</td><td>线程池中最大线程数量</td></tr><tr><td>keepAliveTime</td><td>当前线程数量超过corePoolSize时，空闲线程的存活时间</td></tr><tr><td>unit</td><td>keepAliveTime的时间单位</td></tr><tr><td>workQueue</td><td>任务队列，被提交但尚未被执行的任务存放的地方</td></tr><tr><td>threadFactory</td><td>线程工厂，用于创建线程，可使用默认的线程工厂或自定义</td></tr><tr><td>handler</td><td>由于任务过多或其他原因导致线程池无法处理时的任务拒绝策略</td></tr></tbody></table></div><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>通过调用ThreadPoolExecutor的构造方法来创建一个线程池。线程池刚被创建时，只是向系统申请一个用于执行线程队列和管理线程池的线程资源。在添加一个任务时，当前现有线程数（设为n）：</p><ol><li>n&lt;corePoolSize，线程池就会立刻创建线程并执行该线程任务。</li><li>n&gt;=corePoolSize，该任务就会进入阻塞队列。</li><li>如果队列已满，且n&lt;maximumPoolSize时，线程池会创建非核心线程立刻执行该线程任务。</li><li>如果队列已满，且n&gt;=maximumPoolSize时，线程池将拒绝执行该线程任务并抛出RejectExecutionException异常。</li><li>线程任务执行完毕，该任务将从线程池队列中移除，线程池将从队列中取出下一个线程任务继续执行。</li><li>在线程处于空闲状态的实践超过keepAliveTime时，正在运行的线程数量超过corePoolSize，该线程将被认定为空闲线程并停止。因此，在线程池中所有线程任务都执行完毕，线程池会收缩到corePoolSize大小。</li></ol><h3 id="入队策略"><a href="#入队策略" class="headerlink" title="入队策略"></a>入队策略</h3><ol><li>直接传递：SynchronousQueue（待补充）</li><li>无界队列：使用无界队列（LinkedBlockingQueue）作为等待队列，当所有核心线程都在处理任务时，新提交的任务都会进入等待队列。此时maximumPoolSize将失去作用。</li><li>有界队列：有界队列（ArrayBlockingQueue）可以防止资源耗尽，但是难以调整和控制。队列大小和线程池大小可以相互作用，使用大队列和小线程数可以减少CPU使用率、系统资源和上下文切换的开销，但是会导致吞吐量变低，如果任务频繁阻塞，系统就能为更多的线程调度执行时间。使用小队列通常需要更多的线程数，这样可以最大化CPU使用率。但可能会需要更大的调度开销，从而降低吞吐量。</li></ol><h3 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h3><p>JDK内置的拒绝策略有AbortPolicy、CallerRunsPolicy、DiscardOldestPolicy、DiscardPolicy这四种。</p><ul><li>AbortPolicy：默认策略，抛出RejectExecutionException异常</li><li>CallerRunsPolicy：在execute方法的调用线程中运行被拒绝的任务，如果线程已关闭，任务将被丢弃。</li><li>DiscardOldestPolicy：丢弃队列中等待时间最长的任务并执行当前提交的任务。</li><li>DiscardPolicy：直接丢弃任务。</li><li>自定义拒绝策略需要实现RejectedExecutionHandler接口，实现<code>rejectedExecution(Runnable r, ThreadPoolExecutor executor)</code>方法。</li></ul><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> corePoolSize = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> maximumPoolSize = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">long</span> keepAliveTime = <span class="number">2</span>;</span><br><span class="line">    TimeUnit unit = TimeUnit.SECONDS;</span><br><span class="line">    BlockingQueue&lt;Runnable&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">    ThreadPoolExecutor pool = <span class="keyword">null</span>;</span><br><span class="line">    pool = <span class="keyword">new</span> ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, unit, queue);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> index = i+<span class="number">1</span>;</span><br><span class="line">        pool.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我是线程&quot;</span> + index);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//每个任务提交后休眠500ms在执行下一个任务，用于保证提交顺序。</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pool.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是运行结果。</p><p><img src="image-20210730173914926.png" alt="拒绝策略 运行截图"></p><p>对该运行结果进行分析：</p><ol><li>由于corePoolSize设置的为3，所以任务1、2、3正常提交且开始执行。</li><li>提交任务4，5时，任务123还在运行，所以任务4，5进入到阻塞队列。</li><li>提交任务6，7，8时，正在运行的任务等于corePoolSize且小于maximumPoolSize，阻塞队列满，所以会立即创建非核心线程执行任务678</li><li>当任务1执行完毕后，取出队列中的任务4开始执行。</li><li>当任务2执行完毕后，取出队列中的任务5开始执行。</li></ol><p>为了演示默认的拒绝策略，将上述案例增加一个线程。结果如图</p><p><img src="image-20210730174640219.png" alt="拒绝策略 截图"></p><h1 id="线程相关类"><a href="#线程相关类" class="headerlink" title="线程相关类"></a>线程相关类</h1><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>ThreadLocal是Therad的局部变量的维护类，在Java中是作为一个特殊的变量存储在。当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。</p><p>因为每个Thread内有自己的实例副本，且该副本只能由当前Thread使用，也就不存在多线程间共享的问题。</p><p>总的来说，ThreadLocal适用于每个线程需要自己独立的实例且该实例需要在多个方法中被使用，也即变量在线程间隔离而在方法或类间共享的场景。</p><p>比如，有一个变量count，在多线程并发时操作count++会出现线程安全问题。但是通过ThreadLocal就可以为每个线程创建只属于当前线程的count副本，各自操作各自的副本，不会影响到其他线程。</p><p>使用示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; HOLDER = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ThreadLocalTest().execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HOLDER.set(<span class="string">&quot;main&quot;</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程ThreadLocal中的值：&quot;</span> + HOLDER.get());</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程ThreadLocal中的值：&quot;</span> + HOLDER.get());</span><br><span class="line">            HOLDER.set(<span class="string">&quot;thread&quot;</span>); <span class="comment">//设置当前线程的值</span></span><br><span class="line">            System.out.println(<span class="string">&quot;重新设置后，&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;线程ThreadLocal中的值：&quot;</span> + HOLDER.get());</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程执行结束&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程ThreadLocal中的值：&quot;</span> + HOLDER.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行程序，打印结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main线程ThreadLocal中的值：程序新视界</span><br><span class="line">Thread-0线程ThreadLocal中的值：null</span><br><span class="line">重新设置之后，Thread-0线程ThreadLocal中的值：《程序新视界》</span><br><span class="line">Thread-0线程执行结束</span><br><span class="line">main线程ThreadLocal中的值：程序新视界</span><br></pre></td></tr></table></figure><p>对照程序和输出结果，你会发现，主线程和Thread-0各自独享自己的变量存储。主线程并没有因为Thread-0调用了HOLDER的set方法而被改变。</p><p>之所以能达到这个效果，正是因为在ThreadLocal中，每个线程Thread拥有一份自己的副本变量，多个线程互不干扰。</p><p>ThreadLocal和其他同步机制一样，都是为了解决多线程对同一变量的访问冲突。在普通的同步机制中，试图用过对对象枷锁来实现多个线程对同一变量的安全访问的。ThreadLocal从另一个角度来解决多线程并发访问，ThreadLocal将需要并发访问的资源复制多分，每个线程拥有一份资源，从而就没有必要再对该变量进行同步了。在编写多线程代码时，可以把不安全的整个变量封装进ThreadLocal，或者把该对象与线程相关的状态使用ThreadLocal保存。</p><p>ThreadLocal不能代替同步机制，两者面向的领域不同。同步机制是为了同步多个线程对相同资源的并发访问，是多个线程之间通信的有效方式；而ThreadLocal是为了隔离多个线程的数据共享，从根本上避免了多个线程对共享资源的竞争。</p><p><em>参考资料：<a href="https://zhuanlan.zhihu.com/p/368293603">https://zhuanlan.zhihu.com/p/368293603</a></em></p><h2 id="包装线程不安全集合"><a href="#包装线程不安全集合" class="headerlink" title="包装线程不安全集合"></a>包装线程不安全集合</h2><p>在Java集合中所讲的ArrayList、LinkedList、HashSet、TreeSet、HashMap、TreeMap都是线程不安全的。Collections提供的类方法可以把这些集合包装成线程安全的集合。</p><ul><li>static <T> Collection<T> synchronizedCollection(Collection<T> c)</li><li>static <T> List<T> synchronizedList(List<T> list)</li><li>static <K,V> Map<K,V> synchronizedMap(Map<K,V> m)</li><li>static <T> Set<T> synchronizedSet(Set<T> s)</li><li>static <K,V> SortedMap<K,V> synchronizedSortedMap(SortedMap<K,V> m)</li><li>static <T> SortedSet<T> synchronizedSortedSet(SortedSet<T> s)</li></ul><p>例如需要使用线程安全的HashMap对象，则采用下面的代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;&gt;()); <span class="comment">//在创建后立即包装</span></span><br></pre></td></tr></table></figure><h2 id="线程安全集合类"><a href="#线程安全集合类" class="headerlink" title="线程安全集合类"></a>线程安全集合类</h2><p><img src="image-20210711190905713.png" alt="线程安全的集合类"></p><p>线程安全的集合类可以分为两种：</p><ul><li>以Concurrent开头的集合类：代表了支持并发访问的集合，对这种集合的写入操作都是线程安全的，但读取操作不必锁定。</li><li>以CopyOnWrite开头的集合类：采用了更复杂的算法（复制底层数组的方式实现写操作）来保证永远不会锁住集合，因此并发写入时有较好的性能。</li></ul><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><ul><li>默认支持16个线程并发写入，可以通过设置构造参数来支持更多的并发。</li><li>J8扩展了ConcurrentHashMap的功能，新增的方法分为如下三类<ul><li>forEach</li><li>search</li><li>reduce</li></ul></li></ul><h2 id="J9新增的发布-订阅框架"><a href="#J9新增的发布-订阅框架" class="headerlink" title="J9新增的发布-订阅框架"></a>J9新增的发布-订阅框架</h2><p>略</p><h1 id="Java并发关键字"><a href="#Java并发关键字" class="headerlink" title="Java并发关键字"></a>Java并发关键字</h1><h2 id="CountDownLacth"><a href="#CountDownLacth" class="headerlink" title="CountDownLacth"></a>CountDownLacth</h2><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><h2 id="Semaphore-1"><a href="#Semaphore-1" class="headerlink" title="Semaphore"></a>Semaphore</h2><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><h1 id="补充：进程调度算法"><a href="#补充：进程调度算法" class="headerlink" title="补充：进程调度算法"></a>补充：进程调度算法</h1><h2 id="优先调度算法"><a href="#优先调度算法" class="headerlink" title="优先调度算法"></a>优先调度算法</h2><h2 id="高优先权优先调度算法"><a href="#高优先权优先调度算法" class="headerlink" title="高优先权优先调度算法"></a>高优先权优先调度算法</h2><h2 id="时间片的轮转调度算法"><a href="#时间片的轮转调度算法" class="headerlink" title="时间片的轮转调度算法"></a>时间片的轮转调度算法</h2><h1 id="补充：CAS、ABA、AQS"><a href="#补充：CAS、ABA、AQS" class="headerlink" title="补充：CAS、ABA、AQS"></a>补充：CAS、ABA、AQS</h1><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>《疯狂Java讲义》 多线程篇</li><li><a href="https://mp.weixin.qq.com/s/F8PbZ5PnwGNI4jRiylCRpQ">为什么阿里不允许用Executors创建线程池，而是通过ThreadPoolExecutor的方式？</a></li><li>《Offer 来了 Java面试核心知识点讲解 原理篇》 多线程</li><li><a href="https://zhuanlan.zhihu.com/p/368293603">ThreadLocal全攻略：使用实战，源码分析，内存泄露分析</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>_Python实现一个简单的多线程程序</title>
      <link href="/2022/01/20/Python%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%A8%8B%E5%BA%8F/"/>
      <url>/2022/01/20/Python%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文是一个知识碎片，以后再做详细整理。</p></blockquote><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>我尝试使用多线程批量下载图片。代码框架如下，</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing.pool <span class="keyword">import</span> ThreadPool</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">下载输入的url保存为图片</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_urls</span>(<span class="params">url</span>):</span></span><br><span class="line">    r = requests.request(<span class="string">&#x27;GET&#x27;</span>, url, headers=&#123;&#125;)</span><br><span class="line">    <span class="keyword">if</span> r.status_code == <span class="number">200</span>:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;save_path&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(r.content)</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># urls</span></span><br><span class="line">url_list = [<span class="string">&#x27;...&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 单线程</span></span><br><span class="line"><span class="comment">#  for url in url_list:</span></span><br><span class="line"><span class="comment">#      download_urls(url)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 多线程</span></span><br><span class="line"><span class="comment"># 设置线程池线程数</span></span><br><span class="line">pool = ThreadPool(<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 传入下载函数和下载list</span></span><br><span class="line">pool.imap_unordered(download_urls, url_list)</span><br><span class="line"></span><br><span class="line">pool.close()</span><br><span class="line">pool.join()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>目前我不明白的是，</p><ul><li><strong>不能使用main函数将代码包含进去，否则起不来多线程，为什么？</strong></li><li>Python多线程的基本知识；</li><li>Python GIL等。</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://blog.csdn.net/weixin_36896856/article/details/108016558">Python下载文件的11种方式</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《动手学深度学习》读书笔记（二）从全连接层到卷积层</title>
      <link href="/2022/01/20/%E3%80%8A%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E4%BB%8E%E5%85%A8%E8%BF%9E%E6%8E%A5%E5%B1%82%E5%88%B0%E5%8D%B7%E7%A7%AF%E5%B1%82/"/>
      <url>/2022/01/20/%E3%80%8A%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E4%BB%8E%E5%85%A8%E8%BF%9E%E6%8E%A5%E5%B1%82%E5%88%B0%E5%8D%B7%E7%A7%AF%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文FROM《动手学深度学习》第六章 卷积神经网络 6.1和6.2小节</p></blockquote><h1 id="从全连接层到卷积"><a href="#从全连接层到卷积" class="headerlink" title="从全连接层到卷积"></a>从全连接层到卷积</h1><p>假设我们使用之前的全连接层来训练图片数据集。一张普通图像都是百万像素，如果把图像的每一个像素作为一个特征传入MLP，那么网络的每次输入都是百万维度，这是不可接受的；其次，之前我们处理二维图像时，把二维图像的所有像素作为一个一维向量输入MLP，丢失了图像的结构特征。</p><p><strong>卷积神经网络</strong>（convolutional neural networks，CNN）应运而生，它是机器学习利用自然图像中一些已知结构的创造性方法。</p><h2 id="自然图像的两个性质"><a href="#自然图像的两个性质" class="headerlink" title="自然图像的两个性质"></a>自然图像的两个性质</h2><p>我们根据自然图像的两个性质，来设计适合于计算机视觉的神经网络架构：</p><ol><li><em>平移不变性</em>（translation invariance）：不管检测对象出现在图像中的哪个位置，神经网络的前面几层应该对相同的图像区域具有相似的反应，即为“平移不变性”。</li><li><em>局部性</em>（locality）：神经网络的前面几层应该只探索输入图像中的局部区域，而不过度在意图像中相隔较远区域的关系，这就是“局部性”原则。最终，可以聚合这些局部特征，以在整个图像级别进行预测。</li></ol><h2 id="MLP的限制"><a href="#MLP的限制" class="headerlink" title="MLP的限制"></a>MLP的限制</h2><p>首先，多层感知机的输入是二维图像$\mathbf{X}$，其隐藏表示 $\mathbf{H}$ 在数学上是一个矩阵，在代码中表示为二维张量。其中 $\mathbf{X}$ 和 $\mathbf{H}$ 具有相同的形状。</p><p>为了方便理解，我们可以认为，无论是输入还是隐藏表示都拥有空间结构。</p><blockquote><p>所谓隐藏表示是指输入经过MLP的一层后得到的输出。</p></blockquote><p>使用  $[\mathbf{X}]<em>{i, j}$ 和 $[\mathbf{H}]</em>{i, j}$ 分别表示输入图像和隐藏表示中位置($i$, $j$)处的像素。</p><p>为了使每个隐藏神经元都能接收到每个输入像素的信息，我们将参数从权重矩阵（如同我们先前在多层感知机中所做的那样）替换为四阶权重张量 $\mathsf{W}$。假设 $\mathbf{U}$ 包含偏置参数，我们可以将全连接层形式化地表示为</p><blockquote><p>在之前输入输出都是一维张量时，权重为二维张量。现在输入输出都是二维张量，则权重为四维张量。</p></blockquote><script type="math/tex; mode=display">\begin{aligned} \left[\mathbf{H}\right]_{i, j} &= [\mathbf{U}]_{i, j} + \sum_k \sum_l[\mathsf{W}]_{i, j, k, l}  [\mathbf{X}]_{k, l}\\ &=  [\mathbf{U}]_{i, j} +\sum_a \sum_b [\mathsf{V}]_{i, j, a, b}  [\mathbf{X}]_{i+a, j+b}.\end{aligned}</script><blockquote><p>这里 $\mathsf{W}$ 和 $\mathsf{V}$ 的转换仅仅是重新进行了索引。我们只需重新索引下标 $(k, l)$，使 $k = i+a$、$l = j+b$， 由此可得 $[\mathsf{V}]<em>{i, j, a, b} = [\mathsf{W}]</em>{i, j, i+a, j+b}$。</p><p>索引 $a$ 和 $b$ 通过在正偏移和负偏移之间移动覆盖了整个图像。对于隐藏表示中任意给定位置（$i$, $j$）处的像素值$[\mathbf{H}]<em>{i, j}$，可以通过在 $x$ 中以 $(i, j)$ 为中心对像素进行加权求和得到，加权使用的权重为 $[\mathsf{V}]</em>{i, j, a, b}$ 。</p></blockquote><h3 id="平移不变性"><a href="#平移不变性" class="headerlink" title="平移不变性"></a>平移不变性</h3><p>现在引用上述的第一个原则：平移不变性。这意味着检测对象在输入 $\mathbf{X}$ 中的平移，应该仅仅导致隐藏表示 $\mathbf{H}$ 中的平移。也就是说， $\mathsf{V}$ 和 $\mathbf{U}$ 实际上不依赖于 $(i, j)$ 的值，即 $[\mathsf{V}]<em>{i, j, a, b} = [\mathbf{V}]</em>{a, b}$。并且  $\mathbf{U}$ 是一个常数，比如 $u$。因此，我们可以简化 $\mathbf{H}$ 定义为：</p><script type="math/tex; mode=display">[\mathbf{H}]_{i, j} = u + \sum_a\sum_b [\mathbf{V}]_{a, b} [\mathbf{X}]_{i+a, j+b}.</script><p>这就是 <em>卷积</em> （convolution）。我们是在使用系数 $[\mathbf{V}]<em>{a, b}$ 对位置 $(i, j)$ 附近的像素 $(i+a, j+b)$ 进行加权得到$[\mathbf{H}]</em>{i, j}$。</p><p>注意，$[\mathbf{V}]<em>{a, b}$ 的系数比 $[\mathsf{V}]</em>{i, j, a, b}$ 少很多，因为前者不再依赖于图像中的位置。这就是显著的进步！</p><h3 id="局部性"><a href="#局部性" class="headerlink" title="局部性"></a>局部性</h3><p>现在引用上述的第二个原则：局部性。如上所述，为了收集用来训练参数 $[\mathbf{H}]<em>{i, j}$ 的相关信息，我们不应偏离到距 $(i, j)$ 很远的地方。这意味着在 $|a|&gt; \Delta$ 或 $|b| &gt; \Delta$ 的范围之外，我们可以设置 $[\mathbf{V}]</em>{a, b} = 0$。因此，我们可以将 $[\mathbf{H}]_{i, j}$ 重写为</p><script type="math/tex; mode=display">[\mathbf{H}]_{i, j} = u + \sum_{a = -\Delta}^{\Delta} \sum_{b = -\Delta}^{\Delta} [\mathbf{V}]_{a, b}  [\mathbf{X}]_{i+a, j+b}. \tag{$1$}</script><p>简而言之， 公式（1）代表的是一个 <em>卷积层</em> （convolutional layer），而卷积神经网络是包含卷积层的一类特殊的神经网络。</p><p>在深度学习研究社区中， $\mathbf{V}$ 被称为 <em>卷积核</em> （convolution kernel） 或者  <em>滤波器</em> （filter），它仅仅是可学习的一个层的权重。</p><p>当图像处理的局部区域很小时，卷积神经网络与多层感知机的训练差异可能是巨大的：以前，多层感知机可能需要数十亿个参数来表示网络中的一层，而现在卷积神经网络通常只需要几百个参数，而且不需要改变输入或隐藏表示的维数。</p><p>参数大幅减少的代价是，我们的特征现在是平移不变的，并且当确定每个隐藏激活的值时，每一层只能包含局部的信息。</p><p>以上所有的权重学习都将依赖于归纳偏置。当这种偏置与现实相符时，我们就能得到样本有效的模型，并且这些模型能很好地泛化到未知数据中。</p><p>但如果这偏置与现实不符时，比如当图像不满足平移不变时，我们的模型可能难以拟合我们的训练数据。</p><h2 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h2><p>在进一步讨论之前，我们先简要回顾一下为什么上面的操作被称为卷积。在数学中，两个函数（比如 $f, g: \mathbb{R}^d \to \mathbb{R}$）之间的“卷积”被定义为</p><script type="math/tex; mode=display">(f * g)(\mathbf{x}) = \int f(\mathbf{z}) g(\mathbf{x}-\mathbf{z}) d\mathbf{z}.</script><p>也就是说，卷积是测量 $f$ 和 $g$ 之间（把其中一个函数“翻转”并移位 $\mathbf{x}$ 时）的重叠。</p><p>当我们有离散对象时，积分就变成求和。例如：对于由索引为$\mathbb{Z}$的、平方可和的、无限维向量集合中抽取的向量，我们得到以下定义：</p><script type="math/tex; mode=display">(f * g)(i) = \sum_a f(a) g(i-a).</script><p>对于二维张量，则为 $f$ 的索引 $(a, b)$ 和 $g$ 的索引 $(i-a, j-b)$ 上的对应和：</p><script type="math/tex; mode=display">(f * g)(i, j) = \sum_a\sum_b f(a, b) g(i-a, j-b).  \tag{$2$}</script><p>这看起来类似于公式（1），但有一个主要区别：这里不是使用 $(i+a, j+b)$ ，而是使用差值。然而，这种区别主要是装饰性的，因为我们总是可以匹配公式（1）和公式（2）之间的符号。我们在公式（1）中的原始定义更正确地描述了<em>互相关</em>（cross-correlation）。</p><h2 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h2><p>然而（上述）这种方法有一个问题：我们忽略了图像一般包含三个通道/三种原色（红色、绿色和蓝色）。实际上，图像不是二维张量，而是一个由高度、宽度和颜色组成的三维张量，比如包含 $1024 \times 1024 \times 3$ 个像素。前两个轴与像素的空间位置有关，而第三个轴可以看作是每个像素的多维表示。因此，我们将 $\mathsf{X}$ 索引为 $[\mathsf{X}]<em>{i, j, k}$ 。由此卷积相应地调整为 $[\mathsf{V}]</em>{a,b,c}$ ，而不是 $[\mathbf{V}]_{a,b}$ 。</p><p>此外，由于输入图像是三维的，我们的隐藏表示 $\mathsf{H}$ 也最好采用三维张量。换句话说，对于每一个空间位置，我们想要采用一组而不是一个隐藏表示。这样一组隐藏表示可以想象成一些互相堆叠的二维网格。因此，我们可以把隐藏表示想象为一系列具有二维张量的 <em>通道</em> （channel）。这些通道有时也被称为 <em>特征映射</em> （feature maps），因为每个通道都向后续层提供一组空间化的学习特征。直观上你可以想象在靠近输入的底层，一些通道专门识别边，而其他通道专门识别纹理。</p><p>为了支持输入 $\mathsf{X}$ 和隐藏表示 $\mathsf{H}$ 中的多个通道，我们可以在 $\mathsf{V}$ 中添加第四个坐标，即 $[\mathsf{V}]_{a, b, c, d}$ 。综上所述，</p><script type="math/tex; mode=display">[\mathsf{H}]_{i,j,d} = \sum_{a = -\Delta}^{\Delta} \sum_{b = -\Delta}^{\Delta} \sum_c [\mathsf{V}]_{a, b, c, d} [\mathsf{X}]_{i+a, j+b, c}, \tag{$3$}</script><p>其中隐藏表示 $\mathsf{H}$ 中的 $d$ 索引表示输出通道，而随后的输出将继续以三维张量 $\mathsf{H}$ 作为输入进入下一个卷积层。所以，公式（3）可以定义具有多个通道的卷积层，而其中 $\mathsf{V}$ 是该卷积层的权重。</p><h1 id="图像卷积"><a href="#图像卷积" class="headerlink" title="图像卷积"></a>图像卷积</h1><h2 id="互相关运算"><a href="#互相关运算" class="headerlink" title="互相关运算"></a>互相关运算</h2><p>严格来说，卷积层是个错误的叫法，因为它所表达的运算其实是 <em>互相关运算</em> (cross-correlation)，而不是卷积运算。为了与深度学习文献中的标准术语保持一致，我们将继续把“互相关运算”称为卷积运算，尽管严格地说，它们略有不同.此外，对于卷积核张量上的权重，我们称其为<em>元素</em>。</p><p>根据上一节的描述，在卷积层中，输入张量和核张量通过(<strong>互相关运算</strong>)产生输出张量。</p><p>首先，我们暂时忽略通道（第三维）这一情况，看看如何处理二维图像数据和隐藏表示。在下图中，输入是高度为 $3$、宽度为 $3$ 的二维张量（即形状为 $3 \times 3$ ）。卷积核的高度和宽度都是 $2$。</p><p><img src="correlation.svg" alt="图1: 二维互相关运算。阴影部分是第一个输出元素，以及用于计算这个输出的输入和核张量元素：$0\times0+1\times1+3\times2+4\times3=19$."></p><p>在二维互相关运算中，卷积窗口从输入张量的左上角开始，从左到右、从上到下滑动。当卷积窗口滑动到新一个位置时，包含在该窗口中的部分张量与卷积核张量进行按元素相乘，得到的张量再求和得到一个单一的标量值，由此我们得出了这一位置的输出张量值。</p><p>在如上例子中，输出张量的四个元素由二维互相关运算得到，这个输出高度为 $2$ 、宽度为 $2$ ，如下所示：</p><script type="math/tex; mode=display">0\times0+1\times1+3\times2+4\times3=19,\\1\times0+2\times1+4\times2+5\times3=25,\\3\times0+4\times1+6\times2+7\times3=37,\\4\times0+5\times1+7\times2+8\times3=43.</script><p>注意，输出大小略小于输入大小。这是因为卷积核的宽度和高度大于1，而卷积核只与图像中每个大小完全适合的位置进行互相关运算。所以，输出大小等于输入大小 $n_h \times n_w$ 减去卷积核大小 $k_h \times k_w$，即：</p><script type="math/tex; mode=display">(n_h-k_h+1) \times (n_w-k_w+1).</script><p>这是因为我们需要足够的空间在图像上“移动”卷积核。稍后，我们将看到如何通过在图像边界周围填充零来保证有足够的空间移动内核，从而保持输出大小不变。接下来，我们在 <code>corr2d</code> 函数中实现如上过程，该函数接受输入张量 <code>X</code> 和卷积核张量  <code>K</code> ，并返回输出张量 <code>Y</code> 。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br><span class="line"><span class="comment"># 输入张量X和卷积核张量K</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">corr2d</span>(<span class="params">X, K</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算二维互相关运算&quot;&quot;&quot;</span></span><br><span class="line">    h, w = K.shape</span><br><span class="line">    <span class="comment"># 根据X和K得到输出Y的形状</span></span><br><span class="line">    Y = torch.zeros((X.shape[<span class="number">0</span>] - h + <span class="number">1</span>, X.shape[<span class="number">1</span>] - w + <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(Y.shape[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(Y.shape[<span class="number">1</span>]):</span><br><span class="line">            Y[i, j] = (X[i:i + h, j:j + w] * K).<span class="built_in">sum</span>()</span><br><span class="line">    <span class="keyword">return</span> Y</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对上述函数进行验证</span></span><br><span class="line">X = torch.tensor([[<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>], [<span class="number">3.0</span>, <span class="number">4.0</span>, <span class="number">5.0</span>], [<span class="number">6.0</span>, <span class="number">7.0</span>, <span class="number">8.0</span>]])</span><br><span class="line">K = torch.tensor([[<span class="number">0.0</span>, <span class="number">1.0</span>], [<span class="number">2.0</span>, <span class="number">3.0</span>]])</span><br><span class="line">corr2d(X, K)</span><br></pre></td></tr></table></figure><pre><code>tensor([[19., 25.],        [37., 43.]])</code></pre><h2 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h2><p>卷积层对输入和卷积核权重进行互相关运算，并在添加标量偏置之后产生输出。所以，卷积层中的两个被训练的参数是<strong>卷积核权重</strong>和<strong>标量偏置</strong>。就像我们之前随机初始化全连接层一样，在训练基于卷积层的模型时，我们也随机初始化卷积核权重。</p><p>基于上面定义的 <code>corr2d</code> 函数[<strong>实现二维卷积层</strong>]。在 <code>__init__</code> 构造函数中，将 <code>weight</code> 和 <code>bias</code> 声明为两个模型参数。前向传播函数调用 <code>corr2d</code> 函数并添加偏置。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Conv2D</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, kernel_size</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.weight = nn.Parameter(torch.rand(kernel_size))</span><br><span class="line">        self.bias = nn.Parameter(torch.zeros(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="keyword">return</span> corr2d(x, self.weight) + self.bias</span><br></pre></td></tr></table></figure><p>高度和宽度分别为 $h$ 和 $w$的卷积核可以被称为 $h \times w$ 卷积或 $h \times w$ 卷积核。我们也将带有 $h \times w$ 卷积核的卷积层称为 $h \times w$ 卷积层。</p><h2 id="图像中目标的边缘检测"><a href="#图像中目标的边缘检测" class="headerlink" title="图像中目标的边缘检测"></a>图像中目标的边缘检测</h2><p>如下是<strong>卷积层的一个简单应用：</strong>通过找到像素变化的位置，来<strong>检测图像中不同颜色的边缘</strong>。<br>首先，我们构造一个 $6\times 8$ 像素的黑白图像。中间四列为黑色（$0$），其余像素为白色（$1$）。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = torch.ones((<span class="number">6</span>, <span class="number">8</span>))</span><br><span class="line">X[:, <span class="number">2</span>:<span class="number">6</span>] = <span class="number">0</span></span><br><span class="line">X</span><br></pre></td></tr></table></figure><pre><code>tensor([[1., 1., 0., 0., 0., 0., 1., 1.],        [1., 1., 0., 0., 0., 0., 1., 1.],        [1., 1., 0., 0., 0., 0., 1., 1.],        [1., 1., 0., 0., 0., 0., 1., 1.],        [1., 1., 0., 0., 0., 0., 1., 1.],        [1., 1., 0., 0., 0., 0., 1., 1.]])</code></pre><p>接下来，我们构造一个高度为 $1$ 、宽度为 $2$ 的卷积核 <code>K</code> 。当进行互相关运算时，如果水平相邻的两元素相同，则输出为零，否则输出为非零。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">K = torch.tensor([[<span class="number">1.0</span>, -<span class="number">1.0</span>]])</span><br></pre></td></tr></table></figure><p>现在，我们对参数 <code>X</code> （输入）和 <code>K</code> （卷积核）执行互相关运算。如下所示，<strong>输出<code>Y</code>中的1代表从白色到黑色的边缘，-1代表从黑色到白色的边缘</strong>，其他情况的输出为 $0$。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Y = corr2d(X, K)</span><br><span class="line">Y</span><br></pre></td></tr></table></figure><pre><code>tensor([[ 0.,  1.,  0.,  0.,  0., -1.,  0.],        [ 0.,  1.,  0.,  0.,  0., -1.,  0.],        [ 0.,  1.,  0.,  0.,  0., -1.,  0.],        [ 0.,  1.,  0.,  0.,  0., -1.,  0.],        [ 0.,  1.,  0.,  0.,  0., -1.,  0.],        [ 0.,  1.,  0.,  0.,  0., -1.,  0.]])</code></pre><p>现在我们将输入的二维图像转置，再进行如上的互相关运算。其输出如下，之前检测到的垂直边缘消失了。不出所料，这个<strong>卷积核<code>K</code>只可以检测垂直边缘</strong>，无法检测水平边缘。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">corr2d(X.t(), K)</span><br></pre></td></tr></table></figure><pre><code>tensor([[0., 0., 0., 0., 0.],        [0., 0., 0., 0., 0.],        [0., 0., 0., 0., 0.],        [0., 0., 0., 0., 0.],        [0., 0., 0., 0., 0.],        [0., 0., 0., 0., 0.],        [0., 0., 0., 0., 0.],        [0., 0., 0., 0., 0.]])</code></pre><h2 id="学习卷积核"><a href="#学习卷积核" class="headerlink" title="学习卷积核"></a>学习卷积核</h2><p>在卷积神经网络中，卷积核是需要学习的参数。</p><p>现在让我们看看是否可以通过仅查看“输入-输出”对来学习由 <code>X</code> 生成 <code>Y</code> 的卷积核。我们先构造一个卷积层，并将其卷积核初始化为随机张量。接下来，在每次迭代中，我们比较  <code>Y</code> 与卷积层输出的平方误差，然后计算梯度来更新卷积核。为了简单起见，我们在此使用内置的二维卷积层，并忽略偏置。</p><blockquote><p><strong>这一段有几个问题</strong>：</p><ol><li>conv2d是什么，是nn.Conv2d函数本身，还是nn.Conv2d的返回值</li><li>为什么要将XY转换为四维。</li><li>l（loss）和conv2d之间是怎么建立起联系的？</li></ol></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 构造一个二维卷积层，它具有1个输出通道和形状为（1，2）的卷积核</span></span><br><span class="line"><span class="comment"># 第一二个参数指明了输入、输出的通道数</span></span><br><span class="line">conv2d = nn.Conv2d(<span class="number">1</span>,<span class="number">1</span>, kernel_size=(<span class="number">1</span>, <span class="number">2</span>), bias=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个二维卷积层使用四维输入和输出格式（批量大小、通道、高度、宽度），</span></span><br><span class="line"><span class="comment"># 其中批量大小和通道数都为1</span></span><br><span class="line">X = X.reshape((<span class="number">1</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">8</span>))</span><br><span class="line">Y = Y.reshape((<span class="number">1</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">7</span>))</span><br><span class="line">lr = <span class="number">3e-2</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">    Y_hat = conv2d(X)</span><br><span class="line">    l = (Y_hat - Y) ** <span class="number">2</span></span><br><span class="line">    conv2d.zero_grad()</span><br><span class="line">    l.<span class="built_in">sum</span>().backward()</span><br><span class="line">    <span class="comment"># 根据梯度迭代卷积核</span></span><br><span class="line">    conv2d.weight.data[:] -= lr * conv2d.weight.grad</span><br><span class="line">    <span class="keyword">if</span> (i + <span class="number">1</span>) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;epoch <span class="subst">&#123;i+<span class="number">1</span>&#125;</span>, loss <span class="subst">&#123;l.<span class="built_in">sum</span>():<span class="number">.3</span>f&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>epoch 2, loss 7.561epoch 4, loss 2.024epoch 6, loss 0.649epoch 8, loss 0.236epoch 10, loss 0.091epoch 12, loss 0.037epoch 14, loss 0.015epoch 16, loss 0.006epoch 18, loss 0.002epoch 20, loss 0.001</code></pre><p>查看我们所学到的卷积核权重张量，可以发现我们学习到的卷积核权重非常接近我们之前定义的卷积核K。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">conv2d.weight.data.reshape((<span class="number">1</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure><pre><code>tensor([[ 0.9966, -1.0032]])</code></pre><h2 id="特征映射和感受野"><a href="#特征映射和感受野" class="headerlink" title="特征映射和感受野"></a>特征映射和感受野</h2><p>输出的卷积层有时被称为 <em>特征映射</em> （Feature Map），因为它可以被视为一个输入映射到下一层的空间维度的转换器。在CNN中，对于某一层的任意元素 $x$ ，其 <em>感受野</em> （Receptive Field）是指在前向传播期间可能影响 $x$ 计算的所有元素（来自所有先前层）。</p><p>注意，感受野的覆盖率可能大于某层输入的实际区域大小。让我们用<em>图1</em>为例来解释感受野：给定 $2 \times 2$ 卷积核，阴影输出元素值 $19$ 的接收域是输入阴影部分的四个元素。假设之前输出为 $\mathbf{Y}$ ，其大小为 $2 \times 2$ ，现在我们在其后附加一个卷积层，该卷积层以 $\mathbf{Y}$ 为输入，输出单个元素 $z$。在这种情况下， $\mathbf{Y}$ 上的 $z$ 的接收字段包括 $\mathbf{Y}$ 的所有四个元素，而输入的感受野包括最初所有九个输入元素。因此，当一个特征图中的任意元素需要检测更广区域的输入特征时，我们可以构建一个更深的网络。</p><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p><a href="https://github.com/guoyujian/blog-resource/blob/main/d2l-notebooks/conv-layer.ipynb">https://github.com/guoyujian/blog-resource/blob/main/d2l-notebooks/conv-layer.ipynb</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="http://zh-v2.d2l.ai/chapter_convolutional-neural-networks/why-conv.html">《动手学深度学习》6.1. 从全连接层到卷积</a></li><li><a href="http://zh-v2.d2l.ai/chapter_convolutional-neural-networks/conv-layer.html">《动手学深度学习》6.2. 图像卷积</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
          <category> 动手学深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Win10系统下配置深度学习环境</title>
      <link href="/2022/01/16/Win10%E7%B3%BB%E7%BB%9F%E4%B8%8B%E9%85%8D%E7%BD%AE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83/"/>
      <url>/2022/01/16/Win10%E7%B3%BB%E7%BB%9F%E4%B8%8B%E9%85%8D%E7%BD%AE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<blockquote><p>之前在本机配置深度学习环境时候踩了很多坑，这里稍作记录备忘。</p></blockquote><h1 id="Anaconda"><a href="#Anaconda" class="headerlink" title="Anaconda"></a>Anaconda</h1><h2 id="安装Anaconda"><a href="#安装Anaconda" class="headerlink" title="安装Anaconda"></a>安装Anaconda</h2><p>在anaconda官网下载安装。</p><p>安装完成后，1. 配置环境变量；2. 修改anaconda的安装源</p><p>验证conda：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda -V</span><br><span class="line">conda env list</span><br></pre></td></tr></table></figure><h2 id="创建conda环境"><a href="#创建conda环境" class="headerlink" title="创建conda环境"></a>创建conda环境</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建一个名称为common的虚拟环境并指定python版本为3.6.8</span><br><span class="line">conda create -n common python=3.6.8</span><br><span class="line"># 激活虚拟环境</span><br><span class="line">activate common</span><br><span class="line"># 列出所有的虚拟环境</span><br><span class="line">conda env list</span><br><span class="line"># 退出虚拟环境</span><br><span class="line">conda deactivate</span><br><span class="line"># 删除虚拟环境</span><br><span class="line">conda remove -n common --all</span><br></pre></td></tr></table></figure><h1 id="安装NVIDIA显卡驱动"><a href="#安装NVIDIA显卡驱动" class="headerlink" title="安装NVIDIA显卡驱动"></a>安装NVIDIA显卡驱动</h1><p>官网选择电脑相应的显卡版本进行下载：<a href="https://www.nvidia.cn/geforce/drivers/">https://www.nvidia.cn/geforce/drivers/</a></p><h1 id="安装CUDA"><a href="#安装CUDA" class="headerlink" title="安装CUDA"></a>安装CUDA</h1><p>nvidia官网下载对应版本：</p><p><a href="https://developer.nvidia.cn/cuda-toolkit-archive">https://developer.nvidia.cn/cuda-toolkit-archive</a></p><p>安装完毕后，1. 添加环境变量（如果安装时自动添加则跳过这一步）2. 检查CUDA是否安装成功</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nvcc -V</span><br></pre></td></tr></table></figure><h1 id="安装CUDNN"><a href="#安装CUDNN" class="headerlink" title="安装CUDNN"></a>安装CUDNN</h1><p>NVIDIA cuDNN是用于深度神经网络的GPU加速库。</p><p>官网地址：<a href="https://developer.nvidia.com/rdp/cudnn-archive">https://developer.nvidia.com/rdp/cudnn-archive</a></p><p>选择和CUDA版本相对应的进行下载。</p><p>下载万恒后，把解压得到的文件夹内的bin、include、lib目录下的dll文件与h文件分别复制到相应的CUDA的安装目录下。</p><p>通过NVIDIA提供的 <code>deviceQuery.exe</code> 和 <code>bandwidthTest.exe</code> 来查看GPU的状态，两者均在安装目录的 <code>extras\demo_suite</code>文件夹中</p><h1 id="安装Pytorch"><a href="#安装Pytorch" class="headerlink" title="安装Pytorch"></a>安装Pytorch</h1><p>在<a href="https://pytorch.org/get-started/previous-versions/">https://pytorch.org/get-started/previous-versions/</a> 中选择与CUDA版本对应的Pytorch版本，执行给出的命令进行安装。</p><blockquote><p>这里推荐pip安装，在尝试的时候发现使用conda命令固然可以安装，但是安装之后<code>torch.cuda.is_available()</code>为False</p><p>后来选择pip安装，报错，后选择Pytorch低一点的版本，成功<code>torch.cuda.is_available()==True</code>。</p></blockquote><p>安装完成后，进入Python命令行，执行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import torch</span><br><span class="line">print(torch.cuda.is_available())</span><br></pre></td></tr></table></figure><p>结果为True则torch-GPU可用。</p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ol><li><strong>从显卡型号到显卡驱动，到CUDA，到CUDNN，到Pytorch，到torchvision，到cudatoolkit这些版本一定要对应好。</strong></li><li>安装pytorch选择命令时，选择pip手动下载whl文件安装较保险。</li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://mp.weixin.qq.com/s/-oNZfkYdOb_UiWPPZCk1Nw">给win11装个深度学习环境</a></li><li><a href="https://www.zhihu.com/question/370243934">为何torch.version.cuda返回None？</a></li><li><a href="https://blog.csdn.net/yinxian9019/article/details/106763892">pytorch gpu不可用 原因核查</a></li><li><a href="https://www.zhihu.com/question/59184480">显卡、显卡驱动、cuda 之间的关系是什么？</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
          <category> 环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库之分析函数</title>
      <link href="/2022/01/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8B%E5%88%86%E6%9E%90%E5%87%BD%E6%95%B0/"/>
      <url>/2022/01/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8B%E5%88%86%E6%9E%90%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文主要还是参考了Oracle相关资料，所以文中的语法细节和某些函数在其他DB不会生效。</p><p>我并不希望过多关注语法细节和具体函数（这些都可以自行百度），而更希望对分析函数这块的知识进行抽象。</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>分析函数，也称为窗口函数。</p><p>使用分析函数的查询，基于数据行的分组来计算总量值。尽管与一般的聚合函数提供的分组统计类似，但其主要不同点是，分析函数为每个分组返回多行数据。不同于每个分组只得到一行数据，分析函数可以同时得到所有行的详细数据。区分分析函数和聚合函数的一种方法就是，在体积分析函数中使用的一组数据时，使用数据：<strong>窗口</strong>。</p><p>“窗口”（windows）是通过分析子句定义的。每一行限定在一个滑动窗口中，这些滑动窗口确定了用来计算当前行的数据行范围。</p><p>可以把窗口理解为一个集合，一个窗口就是一个集合，在统计分析中有需要不同的「窗口」，比如一个部门分成不同组，在统计时会按组进行平均、排名等操作。再比如，在一些像时间这种有顺序的数据，我们可能5天分一组、一月分一组再进行排序、求中位数等计算。</p><p><strong>分析函数在SQL执行的顺序</strong>：除了ORDER BY子句，分析函数在查询中是最后执行的运算。</p><h2 id="示例数据"><a href="#示例数据" class="headerlink" title="示例数据"></a>示例数据</h2><p>为了方便讲解和更加直观，我建立了一张数据表，该表名为scores，存放了各班级各学生的数学成绩。建表语句如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table math_scores(</span><br><span class="line">student_id string,</span><br><span class="line">class_num int,</span><br><span class="line">score float);</span><br><span class="line">insert into math_scores(student_id, class_num, score) values(</span><br><span class="line">(&#x27;1&#x27;,1,84),</span><br><span class="line">(&#x27;2&#x27;,1,76),</span><br><span class="line">(&#x27;3&#x27;,1,85),</span><br><span class="line">(&#x27;4&#x27;,1,92),</span><br><span class="line">(&#x27;5&#x27;,2,89),</span><br><span class="line">(&#x27;6&#x27;,2,91),</span><br><span class="line">(&#x27;7&#x27;,2,63),</span><br><span class="line">(&#x27;8&#x27;,3,83),</span><br><span class="line">(&#x27;9&#x27;,3,63),</span><br><span class="line">(&#x27;10&#x27;,3,84)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h1 id="剖析"><a href="#剖析" class="headerlink" title="剖析"></a>剖析</h1><h2 id="与聚合的不同"><a href="#与聚合的不同" class="headerlink" title="与聚合的不同"></a>与聚合的不同</h2><p>窗口函数会按当前所在的分组进行聚合计算，并将聚合计算结果追加在当前行对应的新列，它表达的是当前行与这所在分组的关系。</p><p><img src="sql-windows-functions-01.png" alt="聚合函数与窗口函数"></p><p>窗口函数和 Group By 聚合函数区别在于：窗口函数仅仅只会将结果附加到当前的结果上，它不会对已有的行或列做任何修改。而 Group By 的做法完全不同：对于各个 Group 它仅仅会保留一行聚合结果。</p><p><img src="window-functions-partitioning.jpg" alt="窗口函数计算过程"></p><h2 id="与-group-by-的区别"><a href="#与-group-by-的区别" class="headerlink" title="与 group by 的区别"></a>与 group by 的区别</h2><ul><li>结果数据形式<ul><li>窗口函数可以在保留原表中的全部数据</li><li>group by 只能保留与分组字段聚合的结果</li></ul></li><li>排序范围不同<ul><li>窗口函数中的 order by 只是决定着窗口里的数据的排序方式</li><li>普通的 order by 决定查询出的数据以什么样的方式整体排序</li></ul></li><li>SQL 顺序<ul><li>group by 先进行计算</li><li>窗口函数在 group by 后进行计算</li></ul></li></ul><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>分析函数有三个基本组成部分：分区子句、排序子句以及开窗子句。分析函数的基本语法是：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">function1(argument1, argument2,...argumentN) <span class="keyword">over</span>([<span class="keyword">partition</span><span class="operator">-</span><span class="keyword">by</span><span class="operator">-</span>clause] [<span class="keyword">order</span><span class="operator">-</span><span class="keyword">by</span><span class="operator">-</span>clause] [windowing<span class="operator">-</span>clause])</span><br></pre></td></tr></table></figure><h3 id="function1"><a href="#function1" class="headerlink" title="function1"></a>function1</h3><p>function1是所调用的接收0个或多个参数的分析函数。下表列举了常用的分析函数。（不需要纠结每个函数具体怎么用，大致了解功能，用的时候再细看。）</p><div class="table-container"><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>lag</td><td>访问一个分区或结果集中之前的一行</td></tr><tr><td>lead</td><td>访问一个分区或结果集中之后的一行</td></tr><tr><td>first_value</td><td>访问一个分区或结果集中第一行</td></tr><tr><td>last_value</td><td>访问一个分区或结果集中最后一行</td></tr><tr><td>nth_value</td><td>访问一个分区或结果集中任意一行</td></tr><tr><td>rank</td><td>将数据行值按照排序后的顺序进行排名，在有并列的情况下排名值将被跳过</td></tr><tr><td>dense_rank</td><td>将数据行值按照排序后的顺序进行排名，在有并列的情况下也不跳过排名值</td></tr><tr><td>row_number</td><td>对行进行排序并为每一行增加唯一编号。这是一个非确定函数</td></tr><tr><td>ratio_to_report</td><td>计算报告中值得比例</td></tr><tr><td>percent_rank</td><td>将计算得到的排名值标准化为0-1之间的值</td></tr><tr><td>percentile_cont</td><td>取出与指定的排名百分比相匹配的值。是percent_rank的反函数</td></tr><tr><td>percentile_dist</td><td>取出与指定的排名百分比相匹配的值。采用谨慎分布模型</td></tr><tr><td>ntile</td><td>将数据行分组为单元</td></tr><tr><td>listagg</td><td>将来自不同行的列值转化为列表格式</td></tr></tbody></table></div><p><strong>除了上述分析函数，function1还可以是min/max/avg/count等聚合函数</strong>。</p><h3 id="分区子句"><a href="#分区子句" class="headerlink" title="分区子句"></a>分区子句</h3><p>分区子句按照分区列的值对数据行进行分组。所有分区列的值相同的数据行被组合为一个数据分区。例如<code>partition by class_num</code>就是按班级进行分区。</p><h3 id="排序子句"><a href="#排序子句" class="headerlink" title="排序子句"></a>排序子句</h3><p>排序子句对数据分区中的行进行排序。排序可以按照升序或者降序，使用<code>NULLS FIRST</code>或<code>NULLS LAST</code>子句可以将空值放到数据分区的最上面或最下面。</p><h3 id="开窗子句"><a href="#开窗子句" class="headerlink" title="开窗子句"></a>开窗子句</h3><p>之前的窗口是固定的数据分组窗口，但有时候我们需要根据数据的前后再分配窗口，比如在股票、气温等数据场景下，数据的前后会有影响，就适用于移动窗口计算。</p><p>开窗子句指定了分析函数进行运算的数据子集。这个窗口可以是动态的，他有一个很恰当的名字——<strong>滑动窗口</strong>。使用窗口说明子句来指定滑动窗口的上下边界条件。窗口子句的语法如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">ROWS</span> <span class="operator">|</span> <span class="keyword">RANGE</span>] <span class="keyword">BETWEEN</span> <span class="operator">&lt;</span><span class="keyword">start</span> expr<span class="operator">&gt;</span> <span class="keyword">AND</span> <span class="operator">&lt;</span><span class="keyword">end</span> expr<span class="operator">&gt;</span></span><br><span class="line">Whereas</span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">start</span> expr<span class="operator">&gt;</span> <span class="keyword">is</span> [UNBOUNDED PRECEDING <span class="operator">|</span> <span class="keyword">CURRENT</span> <span class="type">ROW</span> <span class="operator">|</span> n PRECEDING <span class="operator">|</span> n FOLLOWING]</span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">end</span> expr<span class="operator">&gt;</span> <span class="keyword">is</span> [UNBOUNDED PRECEDING <span class="operator">|</span> <span class="keyword">CURRENT</span> <span class="type">ROW</span> <span class="operator">|</span> n PRECEDING <span class="operator">|</span> n FOLLOWING]</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>移动范围设定<ul><li>rows: 物理窗口，rows 后的 n 是指相对当前行偏移n位（当前行也参与计算），可以与 between 搭配使用表达范围</li><li>range: 逻辑窗口，是指定当前行对应值的范围取值。</li><li>rows和range的区别见<em>参考资料3</em></li></ul></li><li>偏移方向<ul><li>precending: 向当前行之前</li><li>following: 向当前行之后</li></ul></li></ul><p>同时，preceding 与 following 可以相结合，例1：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">rows</span> <span class="keyword">between</span> <span class="number">1</span> precending <span class="keyword">and</span> <span class="number">2</span> following</span><br></pre></td></tr></table></figure><p>表示当前行的前一行和后两行，共 4 行（包括当前行）作为汇总的依据。</p><p>例2：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">rows</span> <span class="keyword">between</span> unbounded preceding <span class="keyword">and</span> <span class="keyword">current</span> <span class="type">row</span></span><br></pre></td></tr></table></figure><p>表示窗口最上一行是当前分区中的第一行而窗口最下一行是当前的数据行。</p><blockquote><p>并不是所有的分析函数都支持开窗子句；</p><p>分析函数不能嵌套。</p><p>窗口子句不能单独存在，必须有order by子句时才能出现。</p><p><strong>默认窗口</strong>分两种情况：</p><ul><li>有order by时，无窗口子句，则默认的窗口是<code>unbounded preceding and current row</code>，即当前组的第一行到当前行</li><li>无order by时，无窗口子句，则默认的窗口是<code>unbounded preceding and unbounded following</code>，即整个组</li></ul></blockquote><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><ul><li>下面sql指出了每位学生所在班级的平均数学成绩</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> student_id, class_num, <span class="built_in">AVG</span>(score) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> class_num) <span class="keyword">AS</span> math_avg</span><br><span class="line"><span class="keyword">FROM</span> math_scores</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">student_idclass_numscorealg_avg</span><br><span class="line">118484.25</span><br><span class="line">217684.25</span><br><span class="line">318584.25</span><br><span class="line">419284.25</span><br><span class="line">528981</span><br><span class="line">629181</span><br><span class="line">726381</span><br><span class="line">838376.67</span><br><span class="line">936376.67</span><br><span class="line">1038476.67</span><br></pre></td></tr></table></figure><ul><li>计算每位同学数学成绩的班级排名</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> student_id, class_num, score, <span class="built_in">RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> class_num <span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">DESC</span>) <span class="keyword">AS</span> rankk</span><br><span class="line"><span class="keyword">FROM</span> math_scores</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">student_idclass_numscorerankk</span><br><span class="line">41921</span><br><span class="line">31852</span><br><span class="line">11843</span><br><span class="line">21764</span><br><span class="line">62911</span><br><span class="line">52892</span><br><span class="line">72633</span><br><span class="line">103841</span><br><span class="line">83832</span><br><span class="line">93633</span><br></pre></td></tr></table></figure><h1 id="lead和lag"><a href="#lead和lag" class="headerlink" title="lead和lag"></a>lead和lag</h1><p>lead函数支持访问结果集中后面的行，lag能够访问结果集中前面的行。</p><p>lead和lag的语法如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">lag</span>(expr [, <span class="keyword">offset</span>] [, <span class="keyword">default</span>]) <span class="keyword">OVER</span> ([partition_by_clause] order_by_clause)</span><br><span class="line"><span class="built_in">lead</span>(expr [, <span class="keyword">offset</span>] [, <span class="keyword">default</span>]) <span class="keyword">OVER</span>([partition_by_clause] order_by_clause)</span><br></pre></td></tr></table></figure><p>lead和lag<strong>不支持开窗子句</strong>。这两个函数仅支持partition_by子句和order_by子句。</p><p>下面的sql给出当前数据行前一行的数学成绩（成绩从大到小排序）</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> student_id, class_num, score, <span class="built_in">lag</span>(score, <span class="number">1</span>) <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">DESC</span>) <span class="keyword">AS</span> last_score</span><br><span class="line"><span class="keyword">FROM</span> math_scores</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">student_idclass_numscorelast_score</span><br><span class="line">4192NULL</span><br><span class="line">629192</span><br><span class="line">528991</span><br><span class="line">318589</span><br><span class="line">1038485</span><br><span class="line">118484</span><br><span class="line">838384</span><br><span class="line">217683</span><br><span class="line">936376</span><br><span class="line">726363</span><br></pre></td></tr></table></figure><p>由于第一行没有前一行，所以第一行last_score为NULL，如果不想让它为NULL ，可以使用lag/lead的第三个参数指定默认值。</p><blockquote><p>理解offset是行偏移，而不是数据值偏移</p></blockquote><h1 id="first-value和last-value"><a href="#first-value和last-value" class="headerlink" title="first_value和last_value"></a>first_value和last_value</h1><p>first_value和last_value分别从数据行窗口返回第一行的列值和最后一行的列值。其语法如下</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">first_value</span>(expr) <span class="keyword">over</span>([<span class="keyword">partition</span><span class="operator">-</span><span class="keyword">by</span><span class="operator">-</span>clause] [<span class="keyword">order</span><span class="operator">-</span><span class="keyword">by</span><span class="operator">-</span>clause] [windowing<span class="operator">-</span>clause])</span><br><span class="line"><span class="built_in">last_value</span>(expr) <span class="keyword">over</span>([<span class="keyword">partition</span><span class="operator">-</span><span class="keyword">by</span><span class="operator">-</span>clause] [<span class="keyword">order</span><span class="operator">-</span><span class="keyword">by</span><span class="operator">-</span>clause] [windowing<span class="operator">-</span>clause])</span><br></pre></td></tr></table></figure><p>例如，使用first_value可以实现计算<em>每个班级的数学成绩最高分</em>。（自行思考）</p><p>使用开窗语句，可以为这些函数运算定义动态滑动窗口，例如计算到<em>目前为止的最大销售额</em></p><h2 id="处理空值"><a href="#处理空值" class="headerlink" title="处理空值"></a>处理空值</h2><p>空值通过[RESPECT NULLS | IGNORE NULLS]处理。RESPECT NULLS子句是默认值。默认情况下，如果第一行的列值为空，first_value函数就会返回空值。如果指定了IGNORE NULLS子句，则first_value函数将会返回在窗口中第一个列值不为空的行的值。</p><h1 id="rank-dense-rank-row-number"><a href="#rank-dense-rank-row-number" class="headerlink" title="rank/dense_rank/row_number"></a>rank/dense_rank/row_number</h1><p>这三个函数都是返回排名，不同之处在于他们对排名相同行的处理。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rank</span>() <span class="keyword">OVER</span>([partition_by_clause] order_by_clause); <span class="comment">-- 间断，相同值同序号，如 1、1、3、4、5</span></span><br><span class="line"><span class="built_in">row_number</span>() <span class="keyword">OVER</span>([partition_by_clause] order_by_clause); <span class="comment">-- 不间断，序号不重复，如 1、2、3、4、5</span></span><br><span class="line"><span class="built_in">dense_rank</span>() <span class="keyword">OVER</span>([partition_by_clause] order_by_clause) <span class="comment">-- 不间断，相同值同序号，如 1、1、2、3、3</span></span><br></pre></td></tr></table></figure><p>row_number是一个非确定函数，如果数据分区中的两行具有同样的值，row_number的值是不确定的。</p><p>这三个函数都不能使用开窗子句</p><h1 id="其他分析函数"><a href="#其他分析函数" class="headerlink" title="其他分析函数"></a>其他分析函数</h1><h2 id="nth-value"><a href="#nth-value" class="headerlink" title="nth_value"></a>nth_value</h2><p>first_value和last_value函数能够获取排序过的结果集中第一行或最后一行的数据。使用nth_value函数，可以获取排过序的结果集中的任意一行。</p><p>语法如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">nth_value</span>(measure, n) [<span class="keyword">FROM</span> <span class="keyword">FIRST</span> <span class="operator">|</span> <span class="keyword">FROM</span> <span class="keyword">LAST</span> ] [RESPECT NULLS <span class="operator">|</span> IGNORE NULLS] <span class="keyword">OVER</span>(...)</span><br></pre></td></tr></table></figure><p>其中第一个参数是列名，第二个参数为窗口位移量。</p><h2 id="ratio-to-report"><a href="#ratio-to-report" class="headerlink" title="ratio_to_report"></a>ratio_to_report</h2><p>ratio_to_report计算数据分区中某个值与和值的比率。</p><h2 id="listagg-Oracle"><a href="#listagg-Oracle" class="headerlink" title="listagg(Oracle)"></a>listagg(Oracle)</h2><p>这是Oracle 11gR2中引入的分析函数。这个分析函数能够将来自多个行的列值转化为列表格式。</p><p>listagg语法如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">listagg</span>(string, separator) <span class="keyword">within</span> <span class="keyword">group</span> (<span class="keyword">order</span><span class="operator">-</span><span class="keyword">by</span><span class="operator">-</span>clause) <span class="keyword">over</span>(<span class="keyword">partition</span><span class="operator">-</span><span class="keyword">by</span><span class="operator">-</span>clause)</span><br></pre></td></tr></table></figure><blockquote><p>在HIVE中可以使用<code>collect_list</code>或<code>collect_set</code>以及数组转字符串函数<code>concat_ws(&#39;,&#39;, COLLECT_LIST(&lt;cloumn&gt;))</code>来实现相同的效果。</p><p>listagg函数的一个<strong>局限</strong>就是，他的结果强制为VARCHAR2数据类型的最大长度。</p></blockquote><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>《精通Oracle SQL》 第八章</li><li><a href="https://www.gairuo.com/p/hive-sql-tutorial">HIVE SQL教程</a> 窗口计算 </li><li><a href="http://blog.itpub.net/21251711/viewspace-1068855/">分析函数用法及窗口子句 range/rows差别</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> 分析函数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> 分析函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP协议的幂等性</title>
      <link href="/2022/01/15/HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7/"/>
      <url>/2022/01/15/HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>基于HTTP协议的Web API是时下最为流行的一种分布式服务提供方式。无论是在大型互联网应用还是企业级架构中，我们都见到了越来越多的SOA或RESTful的Web API。为什么Web API如此流行呢？我认为很大程度上应归功于简单有效的HTTP协议。</p><p>HTTP协议是一种分布式的面向资源的网络<strong>应用层协议</strong>，无论是服务器端提供Web服务，还是客户端消费Web服务都非常简单。再加上浏览器、Javascript、AJAX、JSON以及HTML5等技术和工具的发展，互联网应用架构设计表现出了从传统的PHP、JSP、ASP.NET等服务器端动态网页向Web API + RIA（富互联网应用）过渡的趋势。Web API专注于提供业务服务，RIA专注于用户界面和交互设计，从此两个领域的分工更加明晰。在这种趋势下，Web API设计将成为服务器端程序员的必修课。然而，正如简单的Java语言并不意味着高质量的Java程序，简单的HTTP协议也不意味着高质量的Web API。要想设计出高质量的Web API，还需要深入理解分布式系统及HTTP协议的特性。</p><h1 id="幂等性定义"><a href="#幂等性定义" class="headerlink" title="幂等性定义"></a>幂等性定义</h1><p>本文所要探讨的正是HTTP协议涉及到的一种重要性质：幂等性(Idempotence)。在HTTP/1.1规范中幂等性的定义是：</p><blockquote><p>Methods can also have the property of “idempotence” in that (aside from error or expiration issues) the side-effects of N &gt; 0 identical requests is the same as for a single request.</p></blockquote><p>从定义上看，<strong>HTTP方法的幂等性是指一次和多次请求某一个资源应该具有同样的副作用。</strong>幂等性属于语义范畴，正如编译器只能帮助检查语法错误一样，HTTP规范也没有办法通过消息格式等语法手段来定义它，这可能是它不太受到重视的原因之一。但实际上，幂等性是分布式系统设计中十分重要的概念，而HTTP的分布式本质也决定了它在HTTP中具有重要地位。</p><h1 id="分布式事务-vs-幂等设计"><a href="#分布式事务-vs-幂等设计" class="headerlink" title="分布式事务 vs 幂等设计"></a>分布式事务 vs 幂等设计</h1><p>为什么需要幂等性呢？我们先从一个例子说起，假设有一个从账户取钱的远程API（可以是HTTP的，也可以不是），我们暂时用类函数的方式记为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool withdraw(account_id, amount)</span><br></pre></td></tr></table></figure><p>withdraw的语义是从account_id对应的账户中扣除amount数额的钱；如果扣除成功则返回true，账户余额减少amount；如果扣除失败则返回false，账户余额不变。值得注意的是：和本地环境相比，我们不能轻易假设分布式环境的可靠性。一种典型的情况是withdraw请求已经被服务器端正确处理，但服务器端的返回结果由于网络等原因被掉丢了，导致客户端无法得知处理结果。如果是在网页上，一些不恰当的设计可能会使用户认为上一次操作失败了，然后刷新页面，这就导致了withdraw被调用两次，账户也被多扣了一次钱。如图1所示：</p><p><img src="20110810171503575.png" alt="图1"></p><p>这个问题的<strong>解决方案一</strong>是采用分布式事务，通过引入支持分布式事务的中间件来保证withdraw功能的事务性。分布式事务的优点是对于调用者很简单，复杂性都交给了中间件来管理。缺点则是一方面架构太重量级，容易被绑在特定的中间件上，不利于异构系统的集成；另一方面分布式事务虽然能保证事务的ACID性质，而但却无法提供性能和可用性的保证。</p><p>另一种更<strong>轻量级的解决方案</strong>是幂等设计。我们可以通过一些技巧把withdraw变成幂等的，比如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int create_ticket() </span><br><span class="line">bool idempotent_withdraw(ticket_id, account_id, amount)</span><br></pre></td></tr></table></figure><p>create_ticket的语义是获取一个服务器端生成的唯一的处理号ticket_id，它将用于标识后续的操作。idempotent_withdraw和withdraw的区别在于关联了一个ticket_id，<strong>一个ticket_id表示的操作至多只会被处理一次</strong>，每次调用都将返回第一次调用时的处理结果。这样，idempotent_withdraw就符合幂等性了，客户端就可以放心地多次调用。</p><p>基于幂等性的解决方案中一个完整的取钱流程被分解成了两个步骤：1.调用create_ticket()获取ticket_id；2.调用idempotent_withdraw(ticket_id, account_id, amount)。虽然create_ticket不是幂等的，但在这种设计下，它对系统状态的影响可以忽略，加上idempotent_withdraw是幂等的，所以任何一步由于网络等原因失败或超时，客户端都可以重试，直到获得结果。如图2所示：</p><p><img src="201106042051069339.png" alt="图2"></p><p>和分布式事务相比，幂等设计的优势在于它的轻量级，容易适应异构环境，以及性能和可用性方面。在某些性能要求比较高的应用，幂等设计往往是唯一的选择。</p><h1 id="HTTP的幂等性"><a href="#HTTP的幂等性" class="headerlink" title="HTTP的幂等性"></a>HTTP的幂等性</h1><p>HTTP协议本身是一种面向资源的应用层协议，但对HTTP协议的使用实际上存在着两种不同的方式：<strong>一种是RESTful的，它把HTTP当成应用层协议，比较忠实地遵守了HTTP协议的各种规定；另一种是SOA的，它并没有完全把HTTP当成应用层协议，而是把HTTP协议作为了传输层协议，</strong>然后在HTTP之上建立了自己的应用层协议。本文所讨论的HTTP幂等性主要针对RESTful风格的，不过正如上一节所看到的那样，幂等性并不属于特定的协议，它是分布式系统的一种特性；所以，不论是SOA还是RESTful的Web API设计都应该考虑幂等性。下面将介绍HTTP GET、DELETE、PUT、POST四种主要方法的语义和幂等性。</p><p><strong>HTTP GET方法用于获取资源，不应有副作用，所以是幂等的。</strong>比如：GET <a href="http://www.bank.com/account/123456，不会改变资源的状态，不论调用一次还是N次都没有副作用。请注意，这里强调的是一次和N次具有相同的副作用，而不是每次GET的结果相同。GET">http://www.bank.com/account/123456，不会改变资源的状态，不论调用一次还是N次都没有副作用。请注意，这里强调的是一次和N次具有相同的副作用，而不是每次GET的结果相同。GET</a> <a href="http://www.news.com/latest-news这个HTTP请求可能会每次得到不同的结果，但它本身并没有产生任何副作用，因而是满足幂等性的。">http://www.news.com/latest-news这个HTTP请求可能会每次得到不同的结果，但它本身并没有产生任何副作用，因而是满足幂等性的。</a></p><p><strong>HTTP DELETE方法用于删除资源，有副作用，但它应该满足幂等性。</strong>比如：DELETE <a href="http://www.forum.com/article/4231，调用一次和N次对系统产生的副作用是相同的，即删掉id为4231的帖子；因此，调用者可以多次调用或刷新页面而不必担心引起错误。">http://www.forum.com/article/4231，调用一次和N次对系统产生的副作用是相同的，即删掉id为4231的帖子；因此，调用者可以多次调用或刷新页面而不必担心引起错误。</a></p><p>比较容易混淆的是HTTP POST和PUT。POST和PUT的区别容易被简单地误认为“POST表示创建资源，PUT表示更新资源”；而实际上，二者均可用于创建资源，更为本质的差别是在幂等性方面。在HTTP规范中对POST和PUT是这样定义的：</p><blockquote><p>The POST method is used to request that the origin server accept the entity enclosed in the request as a new subordinate of the resource identified by the Request-URI in the Request-Line …… If a resource has been created on the origin server, the response SHOULD be 201 (Created) and contain an entity which describes the status of the request and refers to the new resource, and a Location header.</p><p>The PUT method requests that the enclosed entity be stored under the supplied Request-URI. If the Request-URI refers to an already existing resource, the enclosed entity SHOULD be considered as a modified version of the one residing on the origin server. If the Request-URI does not point to an existing resource, and that URI is capable of being defined as a new resource by the requesting user agent, the origin server can create the resource with that URI.</p></blockquote><p><strong>POST所对应的URI并非创建的资源本身，而是资源的接收者。</strong>比如：POST <a href="http://www.forum.com/articles的语义是在http://www.forum.com/articles下创建一篇帖子，HTTP响应中应包含帖子的创建状态以及帖子的URI。两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI；所以，**POST方法不具备幂等性**。而PUT所对应的URI是要创建或更新的资源本身。比如：PUT">http://www.forum.com/articles的语义是在http://www.forum.com/articles下创建一篇帖子，HTTP响应中应包含帖子的创建状态以及帖子的URI。两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI；所以，**POST方法不具备幂等性**。而PUT所对应的URI是要创建或更新的资源本身。比如：PUT</a> <a href="http://www.forum/articles/4231的语义是创建或更新ID为4231的帖子。对同一URI进行多次PUT的副作用和一次PUT是相同的；因此，**PUT方法具有幂等性。**">http://www.forum/articles/4231的语义是创建或更新ID为4231的帖子。对同一URI进行多次PUT的副作用和一次PUT是相同的；因此，**PUT方法具有幂等性。**</a></p><p><strong>在介绍了几种操作的语义和幂等性之后，我们来看看如何通过Web API的形式实现前面所提到的取款功能。很简单，用POST /tickets来实现create_ticket；用PUT /accounts/account_id/ticket_id?amount=xxx来实现idempotent_withdraw。值得注意的是严格来讲amount参数不应该作为URI的一部分，真正的URI应该是/accounts/account_id/ticket_id，而amount应该放在请求的body中。这种模式可以应用于很多场合，比如：论坛网站中防止意外的重复发帖。</strong></p><h2 id="如何防范-POST-重复提交"><a href="#如何防范-POST-重复提交" class="headerlink" title="如何防范 POST 重复提交"></a>如何防范 POST 重复提交</h2><p>HTTP POST 操作既不是安全的，也不是幂等的（至少在 HTTP 规范里没有保证）。当我们因为反复刷新浏览器导致多次提交表单，多次发出同样的 POST 请求，导致远端服务器重复创建出了资源。</p><p>为了避免这种情形，有以下几种解决方法：</p><ol><li>上述所说的幂等性设计；</li><li>PRG(Post/Redirect/Get模式)：服务器端收到 POST 请求，在操作成功后必须 302 跳转到另外一个页面，这样即使用户刷新页面，也不会重复提交表单。</li><li>用JavaScript的方式在客户端处理：表单提交之后，将提交按钮设置为不可用；</li><li>后端 WebService 一定要做到幂等性：<ol><li>使用Session设置令牌。客户端请求页面时，服务器为每次产生的Form表单分配唯一的随机标识号，并且在orm的一个隐藏字段中设置这个标识号，同时在当前用户的Session中保存这个标识号。当提交表单时，服务器比较hidden和session中的标识号是否相同，相同则继续，处理完后清空Session，否则服务器忽略请求。注意：恶意用户可利用这一性质，不断重复访问页面，以致Session中保存的标识号不断增多，最终严重消耗服务器内存。可以采用在Session中记录用户发帖的时间，然后通过一个时间间隔来限制用户连续发帖的数量来解决这一问题。</li><li>在数据库添加唯一字段。在数据库建表的时候在ID字段添加主键约束，账号，名称的信息添加唯一性约束。确保数据库只可以添加一条数据。</li></ol></li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://www.cnblogs.com/weidagang2046/archive/2011/06/04/idempotence.html">理解HTTP幂等性</a></li><li><a href="https://blog.csdn.net/qq_33945246/article/details/104613726">HTTP协议的补充（POST、GET请求方法、幂等性）</a></li><li><a href="https://juejin.cn/post/6968747879682801672">防止表单重复提交的解决方案整理</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> HTTP协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> HTTP协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>神经网络训练初体验: 房价预测比赛</title>
      <link href="/2022/01/12/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E8%AE%AD%E7%BB%83%E5%88%9D%E4%BD%93%E9%AA%8C-%E6%88%BF%E4%BB%B7%E9%A2%84%E6%B5%8B%E6%AF%94%E8%B5%9B/"/>
      <url>/2022/01/12/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E8%AE%AD%E7%BB%83%E5%88%9D%E4%BD%93%E9%AA%8C-%E6%88%BF%E4%BB%B7%E9%A2%84%E6%B5%8B%E6%AF%94%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文FROM《动手学深度学习》第四章第十节，链接详见<em>参考资料1</em></p></blockquote><h1 id="工作环境"><a href="#工作环境" class="headerlink" title="工作环境"></a>工作环境</h1><div class="table-container"><table><thead><tr><th>软件名称</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td>anaconda</td><td>Python环境和开源模块管理工具</td><td>默认</td></tr><tr><td>Python</td><td>开发语言</td><td>3.8</td></tr><tr><td>torch、torchvision</td><td>深度学习框架</td><td>默认</td></tr><tr><td>d2l</td><td>动手学深度学习官方模块</td><td>默认</td></tr><tr><td>VS Code</td><td>开发IDE</td><td>默认</td></tr></tbody></table></div><h1 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h1><p>创建项目文件夹<code>kaggle-house-prices</code>（自定义命名）以及<code>code</code>子文件夹，<code>code/</code>下创建Jupyter notebook，所有代码写在这里面。</p><p>生成的项目结构如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kaggle-house-prices/</span><br><span class="line">code/</span><br><span class="line">kaggle-house-prices.ipynb</span><br></pre></td></tr></table></figure><h1 id="下载数据集"><a href="#下载数据集" class="headerlink" title="下载数据集"></a>下载数据集</h1><p>数据集来自于Kaggle上的一个竞赛。网址：<a href="https://www.kaggle.com/c/house-prices-advanced-regression-techniques/data">https://www.kaggle.com/c/house-prices-advanced-regression-techniques/data</a></p><p>你可以直接从上面下载数据集；（包含训练集、测试集、数据描述和提交样例）</p><p>或者你可以使用书中的方式下载代码，这里我把完整的代码贴一下。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> tarfile</span><br><span class="line"><span class="keyword">import</span> zipfile</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个二元组包含数据集的url和验证文件完整性的sha-1密钥</span></span><br><span class="line">DATA_HUB = <span class="built_in">dict</span>()</span><br><span class="line">DATA_URL = <span class="string">&#x27;http://d2l-data.s3-accelerate.amazonaws.com/&#x27;</span></span><br><span class="line">DATA_HUB[<span class="string">&#x27;kaggle_house_train&#x27;</span>] = (</span><br><span class="line">    DATA_URL + <span class="string">&#x27;kaggle_house_pred_train.csv&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;585e9cc93e70b39160e7921475f9bcd7d31219ce&#x27;</span>)</span><br><span class="line"></span><br><span class="line">DATA_HUB[<span class="string">&#x27;kaggle_house_test&#x27;</span>] = (</span><br><span class="line">    DATA_URL + <span class="string">&#x27;kaggle_house_pred_test.csv&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;fa19780a7b011d9b009e8bff8e99922a8ee2eb90&#x27;</span>)</span><br><span class="line"></span><br><span class="line">DATA_URL = <span class="string">&#x27;http://d2l-data.s3-accelerate.amazonaws.com/&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">定义了一堆下载、解压的函数</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download</span>(<span class="params">name, cache_dir=os.path.join(<span class="params"><span class="string">&#x27;..&#x27;</span>, <span class="string">&#x27;data&#x27;</span></span>)</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;下载一个DATA_HUB中的文件，返回本地文件名&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">assert</span> name <span class="keyword">in</span> DATA_HUB, <span class="string">f&quot;<span class="subst">&#123;name&#125;</span> 不存在于 <span class="subst">&#123;DATA_HUB&#125;</span>&quot;</span></span><br><span class="line">    url, sha1_hash = DATA_HUB[name]</span><br><span class="line">    os.makedirs(cache_dir, exist_ok=<span class="literal">True</span>)</span><br><span class="line">    fname = os.path.join(cache_dir, url.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">if</span> os.path.exists(fname):</span><br><span class="line">        sha1 = hashlib.sha1()</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(fname, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                data = f.read(<span class="number">1048576</span>)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                sha1.update(data)</span><br><span class="line">        <span class="keyword">if</span> sha1.hexdigest() == sha1_hash:</span><br><span class="line">            <span class="keyword">return</span> fname  <span class="comment"># 命中缓存</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;正在从<span class="subst">&#123;url&#125;</span>下载<span class="subst">&#123;fname&#125;</span>...&#x27;</span>)</span><br><span class="line">    r = requests.get(url, stream=<span class="literal">True</span>, verify=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(fname, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(r.content)</span><br><span class="line">    <span class="keyword">return</span> fname</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_extract</span>(<span class="params">name, folder=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;下载并解压zip/tar文件&quot;&quot;&quot;</span></span><br><span class="line">    fname = download(name)</span><br><span class="line">    base_dir = os.path.dirname(fname)</span><br><span class="line">    data_dir, ext = os.path.splitext(fname)</span><br><span class="line">    <span class="keyword">if</span> ext == <span class="string">&#x27;.zip&#x27;</span>:</span><br><span class="line">        fp = zipfile.ZipFile(fname, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> ext <span class="keyword">in</span> (<span class="string">&#x27;.tar&#x27;</span>, <span class="string">&#x27;.gz&#x27;</span>):</span><br><span class="line">        fp = tarfile.<span class="built_in">open</span>(fname, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">assert</span> <span class="literal">False</span>, <span class="string">&#x27;只有zip/tar文件可以被解压缩&#x27;</span></span><br><span class="line">    fp.extractall(base_dir)</span><br><span class="line">    <span class="keyword">return</span> os.path.join(base_dir, folder) <span class="keyword">if</span> folder <span class="keyword">else</span> data_dir</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_all</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;下载DATA_HUB中的所有文件&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> DATA_HUB:</span><br><span class="line">        download(name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载训练集和测试集</span></span><br><span class="line">download_all()</span><br></pre></td></tr></table></figure><pre><code>正在从http://d2l-data.s3-accelerate.amazonaws.com/kaggle_house_pred_train.csv下载..\data\kaggle_house_pred_train.csv...正在从http://d2l-data.s3-accelerate.amazonaws.com/kaggle_house_pred_test.csv下载..\data\kaggle_house_pred_test.csv...</code></pre><p>使用书中的代码下载的数据集存放在<code>../data/</code>中。结构目录如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kaggle-house-prices/</span><br><span class="line">code/</span><br><span class="line">kaggle-house-prices.ipynb</span><br><span class="line">    data/</span><br><span class="line">    kaggle_house_pred_train.csv</span><br><span class="line">    kaggle_house_pred_test.csv</span><br></pre></td></tr></table></figure><p>下面进行数据读取和预处理。</p><h1 id="读取数据集"><a href="#读取数据集" class="headerlink" title="读取数据集"></a>读取数据集</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果pandas没有被安装，请取消下一句的注释。</span></span><br><span class="line"><span class="comment"># !pip install pandas</span></span><br><span class="line"></span><br><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train_data = pd.read_csv(<span class="string">&quot;../data/kaggle_house_pred_train.csv&quot;</span>)</span><br><span class="line">test_data = pd.read_csv(<span class="string">&quot;../data/kaggle_house_pred_train.csv&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打印他们的行列数，这里test_data的列比train_data少1，少的是标签一列</span></span><br><span class="line"><span class="built_in">print</span>(train_data.shape)</span><br><span class="line"><span class="built_in">print</span>(test_data.shape)</span><br></pre></td></tr></table></figure><pre><code>(1460, 81)(1460, 81)</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># print train_data 两个参数分别指出打印的行（样本）和列（特征）</span></span><br><span class="line"><span class="built_in">print</span>(train_data.iloc[<span class="number">0</span>:<span class="number">4</span>, [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, -<span class="number">3</span>, -<span class="number">2</span>, -<span class="number">1</span>]])</span><br></pre></td></tr></table></figure><pre><code>   Id  MSSubClass MSZoning  LotFrontage SaleType SaleCondition  SalePrice0   1          60       RL         65.0       WD        Normal     2085001   2          20       RL         80.0       WD        Normal     1815002   3          60       RL         68.0       WD        Normal     2235003   4          70       RL         60.0       WD       Abnorml     140000</code></pre><p>将train_data和test_data去掉第一个特征（第一个特征是ID，对训练无意义）的所有特征都放到all_features中：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">all_features = pd.concat((train_data.iloc[:, <span class="number">1</span>:-<span class="number">1</span>], test_data.iloc[:, <span class="number">1</span>:]))</span><br></pre></td></tr></table></figure><h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><p>在开始建模之前，我们需要对数据进行预处理。</p><p>对于数字特征，首先，<strong>将所有缺失的值替换为相应特征的平均值；</strong></p><p>然后，为了将所有特征放在一个共同的尺度上，我们<strong>通过将特征重新缩放到零均值和单位方差来标准化数据</strong>：</p><script type="math/tex; mode=display">x \leftarrow \frac{x - \mu}{\sigma}.</script><p>此时，特征即具有零均值和单位方差，即 $E[\frac{x-\mu}{\sigma}] = \frac{\mu - \mu}{\sigma} = 0$和$E[(x-\mu)^2] = (\sigma^2 + \mu^2) - 2\mu^2+\mu^2 = \sigma^2$。</p><p>标准化数据有两个原因：</p><ul><li>方便优化；</li><li>我们不知道哪些特征是相关的，所以我们不想让惩罚分配给一个特征的系数比分配给其他任何特征的系数更大；</li><li>取消由于量纲不同、自身变异或者数值相差较大所引起的误差。</li></ul><p>更多关于标准化的知识请见<em>参考资料2</em></p><p>这里可以看到，书中提到的是先处理缺失值，再标准化；而实际代码是先标准化，再处理缺失值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 若无法获得测试数据，则可根据训练数据计算均值和标准差</span></span><br><span class="line"><span class="comment"># 取出数字类型的特征索引</span></span><br><span class="line">numeric_features = all_features.dtypes[all_features.dtypes != <span class="string">&#x27;object&#x27;</span>].index</span><br><span class="line"><span class="comment"># 将数字类型的特征标准化</span></span><br><span class="line">all_features[numeric_features] = all_features[numeric_features].apply(</span><br><span class="line">    <span class="keyword">lambda</span> x: (x - x.mean()) / (x.std()))</span><br><span class="line"><span class="comment"># 在标准化数据之后，所有均值消失，因此我们可以将缺失值设置为0</span></span><br><span class="line">all_features[numeric_features] = all_features[numeric_features].fillna(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>对于离散值，我们使用one-hot编码，就是特征的离散值转换为向量。例如，特征“type”的值包括cat，dog，rat，那么经过one-hot编码后会生成三个特征“type_cat”，“type_dog”，“type_rat”。如果原来“type”=cat，则“type_cat”=1，“type_dog”=0，“type_rat”=0。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># “Dummy_na=True”将“na”（缺失值）视为有效的特征值，并为其创建指示符特征</span></span><br><span class="line">all_features = pd.get_dummies(all_features, dummy_na=<span class="literal">True</span>)</span><br><span class="line">all_features.shape</span><br></pre></td></tr></table></figure><pre><code>(2920, 332)</code></pre><p>可以看到，此转换会将特征的总数量从79个增加到331个。 最后，通过values属性，我们可以 从pandas格式中提取NumPy格式，并将其转换为张量表示用于训练。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n_train = train_data.shape[<span class="number">0</span>]  <span class="comment"># 取得train_data的行数</span></span><br><span class="line"><span class="comment"># 取出all_features的train_data转换成tensor</span></span><br><span class="line">train_features = torch.tensor(all_features[:n_train].values, dtype=torch.float32)</span><br><span class="line"><span class="comment"># 取出all_features的test_data转换成tensor</span></span><br><span class="line">test_features = torch.tensor(all_features[n_train:].values, dtype=torch.float32)</span><br><span class="line"><span class="comment"># train_labels.shape[0] == n_train</span></span><br><span class="line"><span class="comment"># reshape(-1, 1)相当于把labels一行转为一列和train_features一一对应</span></span><br><span class="line">train_labels = torch.tensor(</span><br><span class="line">    train_data.SalePrice.values.reshape(-<span class="number">1</span>, <span class="number">1</span>), dtype=torch.float32)</span><br></pre></td></tr></table></figure><h1 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h1><p>首先，我们训练一个带有损失平方的线性模型。如果一切顺利，线性模型将作为基线（baseline）模型， 让我们直观地知道最好的模型有超出简单的模型多少。</p><p>损失函数：MSE Loss</p><p>基线模型：（个人理解）最先想到的、最简单的、结果比较差、一般在此基础上进行优化的模型。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">loss = nn.MSELoss()</span><br><span class="line">in_features = train_features.shape[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_net</span>():</span></span><br><span class="line">    net = nn.Sequential(nn.Linear(in_features,<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> net</span><br></pre></td></tr></table></figure><p>对于房价，就像股票价格一样，我们关心的是相对数量，而不是绝对数量。因此，[<strong>我们更关心相对误差$\frac{y - \hat{y}}{y}$，</strong>]而不是绝对误差$y - \hat{y}$。例如，如果我们在俄亥俄州农村地区估计一栋房子的价格时，我们的预测偏差了10万美元，在那里一栋典型的房子的价值是12.5万美元，那么我们可能做得很糟糕。另一方面，如果我们在加州豪宅区的预测出现了这个数字的偏差，这可能是一个惊人的准确预测（在那里，房价均值超过400万美元）。</p><p>(<strong>解决这个问题的一种方法是用价格预测的对数来衡量差异</strong>)。事实上，这也是比赛中官方用来评价提交质量的误差指标。即将 $\delta$ for $|\log y - \log \hat{y}| \leq \delta$转换为$e^{-\delta} \leq \frac{\hat{y}}{y} \leq e^\delta$。这使得预测价格的对数与真实标签价格的对数之间出现以下均方根误差：</p><script type="math/tex; mode=display">\sqrt{\frac{1}{n}\sum_{i=1}^n\left(\log y_i -\log \hat{y}_i\right)^2}.</script><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log_rmse</span>(<span class="params">net, features, labels</span>):</span></span><br><span class="line">    <span class="comment"># 为了在取对数时进一步稳定该值，将小于1的值设置为1</span></span><br><span class="line">    <span class="comment"># clamp方法说明详见 参考资料5</span></span><br><span class="line">    clipped_preds = torch.clamp(net(features), <span class="number">1</span>, <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>))</span><br><span class="line">    rmse = torch.sqrt(loss(torch.log(clipped_preds),</span><br><span class="line">                           torch.log(labels)))</span><br><span class="line">    <span class="keyword">return</span> rmse.item()</span><br></pre></td></tr></table></figure><blockquote><p>在这里，我一开始对损失函数（loss）和评价指标（metrics）没有理解，所以我对loss和log_rmse纠结了很久。</p><p>这里我的理解是，</p><p>loss是需要丢到网络里的，是网络优化的目标函数；因为需要通过梯度下降来反向传播，所以必须是可导的；</p><p>metrics是评价网络的一种指标，不参与优化；不需要可导。</p><p>更多关于损失函数和评价指标请参见<em>参考资料3</em>，<em>参考资料4</em></p></blockquote><hr><p>我们的训练函数将借助Adam优化器。</p><p>Adam优化器的主要吸引力在于它对初始学习率不那么敏感。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span>(<span class="params">net, train_features, train_labels, test_features, test_labels,</span></span></span><br><span class="line"><span class="params"><span class="function">          num_epochs, learning_rate, weight_decay, batch_size</span>):</span></span><br><span class="line">    train_ls, test_ls = [], []</span><br><span class="line">    train_iter = d2l.load_array((train_features, train_labels), batch_size)</span><br><span class="line">    <span class="comment"># 这里使用的是Adam优化算法</span></span><br><span class="line">    optimizer = torch.optim.Adam(net.parameters(),</span><br><span class="line">                                 lr = learning_rate,</span><br><span class="line">                                 weight_decay = weight_decay)</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">        <span class="keyword">for</span> X, y <span class="keyword">in</span> train_iter:</span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            l = loss(net(X), y)</span><br><span class="line">            l.backward()</span><br><span class="line">            optimizer.step()</span><br><span class="line">        train_ls.append(log_rmse(net, train_features, train_labels))</span><br><span class="line">        <span class="keyword">if</span> test_labels <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            test_ls.append(log_rmse(net, test_features, test_labels))</span><br><span class="line">    <span class="keyword">return</span> train_ls, test_ls</span><br></pre></td></tr></table></figure><h1 id="K-折交叉验证"><a href="#K-折交叉验证" class="headerlink" title="K-折交叉验证"></a>K-折交叉验证</h1><p>所谓K-折交叉验证就是把train data分为K份，每次1/K份作为验证集，把另外的1 - 1/K份作为训练集。事实上，<code>get_k_fold_data</code>就是在做这件事。</p><p>K-折交叉验证有助于模型选择和超参数调整。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_k_fold_data</span>(<span class="params">k, i, X, y</span>):</span></span><br><span class="line">    <span class="keyword">assert</span> k &gt; <span class="number">1</span></span><br><span class="line">    fold_size = X.shape[<span class="number">0</span>] // k</span><br><span class="line">    X_train, y_train = <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">        <span class="comment"># slice方法说明详见参考资料6</span></span><br><span class="line">        idx = <span class="built_in">slice</span>(j * fold_size, (j + <span class="number">1</span>) * fold_size)</span><br><span class="line">        X_part, y_part = X[idx, :], y[idx]</span><br><span class="line">        <span class="keyword">if</span> j == i:</span><br><span class="line">            X_valid, y_valid = X_part, y_part</span><br><span class="line">        <span class="keyword">elif</span> X_train <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            X_train, y_train = X_part, y_part</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            X_train = torch.cat([X_train, X_part], <span class="number">0</span>) <span class="comment"># 将已有的X_train和X_part连接起来</span></span><br><span class="line">            y_train = torch.cat([y_train, y_part], <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> X_train, y_train, X_valid, y_valid</span><br></pre></td></tr></table></figure><p><code>k_fold</code>中先求每一折得到的trian-loss, valid-loss，注意train_ls和valid_ls是一个list，存放了每次迭代后loss值，我们取train_ls[-1]，也就是最终的那个loss</p><p>最后把所有K-折得到的train-loss的平均和valid-loss的平均</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">k_fold</span>(<span class="params">k, X_train, y_train, num_epochs, learning_rate, weight_decay,</span></span></span><br><span class="line"><span class="params"><span class="function">           batch_size</span>):</span></span><br><span class="line">    train_l_sum, valid_l_sum = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">        <span class="comment"># 这里data实际是一个元组(X_train, y_train, X_valid, y_valid)</span></span><br><span class="line">        data = get_k_fold_data(k, i, X_train, y_train)</span><br><span class="line">        net = get_net()</span><br><span class="line">        <span class="comment"># 把data这个元组传入，对应train中的train_features, train_labels, test_features, test_labels四个参数</span></span><br><span class="line">        train_ls, valid_ls = train(net, *data, num_epochs, learning_rate,</span><br><span class="line">                                   weight_decay, batch_size)</span><br><span class="line">        train_l_sum += train_ls[-<span class="number">1</span>]</span><br><span class="line">        valid_l_sum += valid_ls[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">            d2l.plot(<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, num_epochs + <span class="number">1</span>)), [train_ls, valid_ls],</span><br><span class="line">                     xlabel=<span class="string">&#x27;epoch&#x27;</span>, ylabel=<span class="string">&#x27;rmse&#x27;</span>, xlim=[<span class="number">1</span>, num_epochs],</span><br><span class="line">                     legend=[<span class="string">&#x27;train&#x27;</span>, <span class="string">&#x27;valid&#x27;</span>], yscale=<span class="string">&#x27;log&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;折<span class="subst">&#123;i + <span class="number">1</span>&#125;</span>，训练log rmse<span class="subst">&#123;<span class="built_in">float</span>(train_ls[-<span class="number">1</span>]):f&#125;</span>, &#x27;</span></span><br><span class="line">              <span class="string">f&#x27;验证log rmse<span class="subst">&#123;<span class="built_in">float</span>(valid_ls[-<span class="number">1</span>]):f&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> train_l_sum / k, valid_l_sum / k</span><br></pre></td></tr></table></figure><h1 id="模型选择"><a href="#模型选择" class="headerlink" title="模型选择"></a>模型选择</h1><p>下面是一组超参数，后面我们可以对此进行调优（改改数， run run code）</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">k, num_epochs, lr, weight_decay, batch_size = <span class="number">5</span>, <span class="number">100</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">64</span></span><br><span class="line">train_l, valid_l = k_fold(k, train_features, train_labels, num_epochs, lr,</span><br><span class="line">                          weight_decay, batch_size)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;k&#125;</span>-折验证: 平均训练log rmse: <span class="subst">&#123;<span class="built_in">float</span>(train_l):f&#125;</span>, &#x27;</span></span><br><span class="line">      <span class="string">f&#x27;平均验证log rmse: <span class="subst">&#123;<span class="built_in">float</span>(valid_l):f&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>折1，训练log rmse0.168934, 验证log rmse0.158768折2，训练log rmse0.162051, 验证log rmse0.186553折3，训练log rmse0.163633, 验证log rmse0.167966折4，训练log rmse0.167716, 验证log rmse0.154111折5，训练log rmse0.161381, 验证log rmse0.1841885-折验证: 平均训练log rmse: 0.164743, 平均验证log rmse: 0.170317</code></pre><p><img src="kaggle-house-prices_31_1.svg" alt="svg"></p><p>请注意，有时一组超参数的训练误差可能非常低，但 K 折交叉验证的误差要高得多， 这表明模型过拟合了。 在整个训练过程中，你将希望监控训练误差和验证误差这两个数字。 较少的过拟合可能表明现有数据可以支撑一个更强大的模型， 较大的过拟合可能意味着我们可以通过正则化技术来获益。</p><h1 id="提交Kaggle预测"><a href="#提交Kaggle预测" class="headerlink" title="提交Kaggle预测"></a>提交Kaggle预测</h1><p>当我们用上面的K-折交叉验证确定参数后，我们将超参数固定住，把所有的train data拿来train。</p><p>如果测试集上的预测与 K 倍交叉验证过程中的预测相似， 那就是时候把它们上传到Kaggle了。 下面的代码将生成一个名为submission.csv的文件。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_and_pred</span>(<span class="params">train_features, test_feature, train_labels, test_data,</span></span></span><br><span class="line"><span class="params"><span class="function">                   num_epochs, lr, weight_decay, batch_size</span>):</span></span><br><span class="line">    net = get_net()</span><br><span class="line">    train_ls, _ = train(net, train_features, train_labels, <span class="literal">None</span>, <span class="literal">None</span>,</span><br><span class="line">                        num_epochs, lr, weight_decay, batch_size)</span><br><span class="line">    d2l.plot(np.arange(<span class="number">1</span>, num_epochs + <span class="number">1</span>), [train_ls], xlabel=<span class="string">&#x27;epoch&#x27;</span>,</span><br><span class="line">             ylabel=<span class="string">&#x27;log rmse&#x27;</span>, xlim=[<span class="number">1</span>, num_epochs], yscale=<span class="string">&#x27;log&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;训练log rmse：<span class="subst">&#123;<span class="built_in">float</span>(train_ls[-<span class="number">1</span>]):f&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="comment"># 将网络应用于测试集。</span></span><br><span class="line">    preds = net(test_features).detach().numpy()</span><br><span class="line">    <span class="comment"># 将其重新格式化以导出到Kaggle</span></span><br><span class="line">    test_data[<span class="string">&#x27;SalePrice&#x27;</span>] = pd.Series(preds.reshape(<span class="number">1</span>, -<span class="number">1</span>)[<span class="number">0</span>])</span><br><span class="line">    submission = pd.concat([test_data[<span class="string">&#x27;Id&#x27;</span>], test_data[<span class="string">&#x27;SalePrice&#x27;</span>]], axis=<span class="number">1</span>)</span><br><span class="line">    submission.to_csv(<span class="string">&#x27;submission.csv&#x27;</span>, index=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">train_and_pred(train_features, test_features, train_labels, test_data,</span><br><span class="line">               num_epochs, lr, weight_decay, batch_size)</span><br></pre></td></tr></table></figure><pre><code>训练log rmse：0.162150</code></pre><p><img src="kaggle-house-prices_34_1.svg" alt="svg"></p><p>接下来我们将生成的<code>submission.csv</code>文件提交到Kaggle：</p><ul><li>访问<a href="https://www.kaggle.com/c/house-prices-advanced-regression-techniques/data">https://www.kaggle.com/c/house-prices-advanced-regression-techniques/data</a></li><li>点击“Submit Predictions”</li><li>选择你要上传的预测文件<code>submission.csv</code></li><li>点击页面底部的“Make Submission”按钮，即可查看结果。</li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul><li>真实数据通常混合了不同的数据类型，需要进行预处理。</li><li>常用的预处理方法：将实值数据重新缩放为零均值和单位方法；用均值替换缺失值。</li><li>将类别特征转化为指标特征，可以使我们把这个特征当作一个独热向量来对待。</li><li>我们可以使用 K 折交叉验证来选择模型并调整超参数。</li><li>对数对于相对误差很有用。</li></ul><h1 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h1><p>这里是书中给出的一些思考问题，我没做，但是依然列出来供参考：</p><ol><li>将试图预测价格改为试图预测价格的对数，会发生什么？</li><li>用平均值替换缺失值总是好主意吗？提示：你能构造一个不随机丢失值的情况吗？</li><li>通过 K 折交叉验证调整超参数，从而提高Kaggle的得分。</li><li>通过改进模型（例如，层、权重衰减和dropout）来提高分数。</li><li>如果我们没有像本节所做的那样标准化连续的数值特征，会发生什么？</li></ol><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>我仔细阅读原文，捋了一边代码。</p><p>基础比较差，有些地方认识不太清晰，全凭自己理解，如有错误，请多包涵，或直接邮箱联系我。</p><p>我原以为会有训练模型错误率不断降低的成就感。。但实际上全是复制粘贴run code。</p><p>好像学到了又好像没学到。🤦‍</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="http://zh-v2.d2l.ai/chapter_multilayer-perceptrons/kaggle-house-price.html#id6">《动手学深度学习》 4.10. 实战Kaggle比赛：预测房价</a></li><li><a href="https://www.cnblogs.com/wangqiang9/p/9285594.html">数据预处理之中心化（零均值化）与标准化（归一化）</a></li><li><a href="https://zhuanlan.zhihu.com/p/373032887">机器学习——损失函数(loss)与评价指标(metric)的区别？</a></li><li><a href="https://codeantenna.com/a/7p6uOqnNhx">keras中compile方法的 loss 和 metrics 区别</a></li><li><a href="https://pytorch.org/docs/stable/generated/torch.clamp.html">torch.clamp方法说明</a></li><li><a href="https://www.runoob.com/python/python-func-slice.html">Python slice方法说明</a></li><li><a href="https://blog.csdn.net/m0_37871195/article/details/79829488">深度学习中iteration、epoch、batchsize的定义</a></li><li><a href="https://pytorch.org/docs/1.9.1/generated/torch.Tensor.detach.html">torch.detach方法说明</a></li><li><a href="https://pytorch.org/docs/stable/generated/torch.cat.html#torch.cat">torch.cat方法说明</a></li><li><a href="https://csbwang.github.io/dl_ch2">机器学习基础</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
          <category> 动手学深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《动手学深度学习》读书笔记（一） 前言</title>
      <link href="/2022/01/10/%E3%80%8A%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89-%E5%89%8D%E8%A8%80/"/>
      <url>/2022/01/10/%E3%80%8A%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89-%E5%89%8D%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<p><em>本博客记录阅读《动手学深度学习》的读书笔记。</em></p><blockquote><p>原文地址：<a href="http://zh-v2.d2l.ai/chapter_introduction/index.html">http://zh-v2.d2l.ai/chapter_introduction/index.html</a></p></blockquote><h1 id="日常生活中的机器学习"><a href="#日常生活中的机器学习" class="headerlink" title="日常生活中的机器学习"></a>日常生活中的机器学习</h1><p>我们可以把<strong>参数</strong>看作旋钮，我们可以转动旋钮来调整程序的行为。</p><p>任一调整参数后的程序，我们称为<strong>模型</strong>（model）。</p><p>通过操作参数而生成的所有不同程序（输入-输出映射）的集合称为“<strong>模型族</strong>”。</p><p>使用数据集来选择参数的元程序被称为<strong>学习算法</strong>（learning algorithm）。</p><p>在我们开始用机器学习算法解决问题之前，我们必须精确地定义问题，确定<strong>输入（input）和输出（output）</strong>的性质，并选择合适的模型族。</p><p>在机器学习中，<strong>学习</strong>（learning）是一个训练模型的过程。 通过这个过程，我们可以发现正确的参数集，从而使模型强制执行所需的行为。 换句话说，我们用数据<strong>训练</strong>（train）我们的模型。 </p><p>训练过程通常包含如下步骤：</p><ol><li>从一个随机初始化参数的模型开始，这个模型基本毫不“智能”。</li><li>获取一些数据样本（例如，音频片段以及对应的{是,否}标签）。</li><li>调整参数，使模型在这些样本中表现得更好。</li><li>重复第2步和第3步，直到模型在任务中的表现令你满意。</li></ol><p><img src="ml-loop.png" alt="典型的训练过程"></p><h1 id="关键组件"><a href="#关键组件" class="headerlink" title="关键组件"></a>关键组件</h1><p>无论我们遇到什么类型的机器学习问题，这些组件都将伴随我们左右：</p><ol><li>我们可以学习的<strong>数据</strong>（data）。</li><li>如何转换数据的<strong>模型</strong>（model）。</li><li>一个<strong>目标函数</strong>（objective function），用来量化模型的有效性。</li><li>调整模型参数以优化目标函数的<strong>算法</strong>（algorithm）。</li></ol><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p>每个数据集由一个个<strong>样本</strong>（example, sample）组成，大多时候，它们遵循独立同分布(independently and identically distributed, i.i.d.)。 样本有时也叫做<strong>数据点</strong>（data point）或者<strong>数据实例</strong>（data instance），通常每个样本由一组称为<strong>特征</strong>（features，或<strong>协变量</strong>（covariates））的属性组成。 机器学习模型会根据这些属性进行预测。 </p><p><strong>标签</strong>：预测的一个特殊属性，例如是/否，猫/狗等。</p><p>当每个样本的特征类别数量都是相同的时候，其特征向量是固定长度的，这个长度被称为数据的维数（dimensionality）。 固定长度的特征向量是一个方便的属性，它有助于我们量化学习大量样本。</p><p>然而，并不是所有的数据都可以用“固定长度”的向量表示。例如不同的图片大小，文本长度。与传统机器学习方法相比，深度学习的一个主要优势是可以处理不同长度的数据。</p><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><h2 id="目标函数"><a href="#目标函数" class="headerlink" title="目标函数"></a>目标函数</h2><p>在机器学习中，我们需要定义模型的优劣程度的度量，这个度量在大多数情况是“可优化”的，我们称之为<strong>目标函数</strong>（objective function）。 我们通常定义一个目标函数，并希望优化它到最低点。 因为越低越好，所以这些函数有时被称为<strong>损失函数</strong>（loss function，或cost function）。</p><p>当任务在试图预测数值时，最常见的损失函数是<strong>平方误差</strong>（squared error），即预测值与实际值之差的平方。 当试图解决分类问题时，最常见的目标函数是最小化错误率，即预测与实际情况不符的样本比例。 有些目标函数（如平方误差）很容易被优化，有些目标（如错误率）由于不可微性或其他复杂性难以直接优化。 在这些情况下，通常会优化替代目标。</p><p> 在一个数据集上，我们通过最小化总损失来学习模型参数的最佳值。 该数据集由一些为训练而收集的样本组成，称为<strong>训练数据集</strong>（training dataset，或称为训练集（training set））。 然而，在训练数据上表现良好的模型，并不一定在“新数据集”上有同样的效能，这里的“新数据集”通常称为测试数据集（test dataset，或称为<strong>测试集</strong>（test set））。</p><p>综上所述，我们通常将可用数据集分成两部分：<strong>训练数据集用于拟合模型参数，测试数据集用于评估拟合的模型。</strong> 然后我们观察模型在这两部分数据集的效能。 你可以把“一个模型在训练数据集上的效能”想象成“一个学生在模拟考试中的分数”。 这个分数用来为一些真正的期末考试做参考，即使成绩令人鼓舞，也不能保证期末考试成功。 换言之，测试性能可能会显著偏离训练性能。 当一个模型在训练集上表现良好，但不能推广到测试集时，我们说这个模型是“<strong>过拟合</strong>”（overfitting）的。</p><h2 id="优化算法"><a href="#优化算法" class="headerlink" title="优化算法"></a>优化算法</h2><p>一旦我们获得了一些数据源及其表示、一个模型和一个合适的损失函数，我们接下来就需要一种算法，它能够搜索出最佳参数，以最小化损失函数。 深度学习中，大多流行的优化算法通常基于一种基本方法–<strong>梯度下降</strong>（gradient descent）。 简而言之，在每个步骤中，梯度下降法都会检查每个参数，看看如果你仅对该参数进行少量变动，训练集损失会朝哪个方向移动。 然后，它在可以减少损失的方向上优化参数。</p><h1 id="各种机器学习问题"><a href="#各种机器学习问题" class="headerlink" title="各种机器学习问题"></a>各种机器学习问题</h1><h2 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h2><p>监督学习（supervised learning）擅长在“<strong>给定输入特征</strong>”的情况下预测标签。</p><p>监督学习举例：根据计算机断层扫描（CT）肿瘤图像，预测是否为癌症；根据本月的财务报告数据，预测下个月股票的价格。</p><p>在工业中，大部分机器学习的成功应用都是监督学习。 这是因为在一定程度上，许多重要的任务可以清晰地描述为：在给定一组特定的可用数据的情况下，估计未知事物的概率。</p><p><img src="supervised-learning.png" alt="监督学习"></p><h3 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h3><p>回归（regression）是最简单的监督学习任务之一。</p><p>当标签取任意数值时，我们称之为回归问题。 我们的目标是生成一个模型，它的预测非常接近实际标签值。</p><p>回归问题举例：预测房价；预测用户对一部电影的评分。</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>二分类，多分类。</p><p>分类可能变得比二元分类、多元分类复杂得多。 例如，有一些分类任务的变体可以用于寻找层次结构，层次结构假定在许多类之间存在某种关系。因此，并不是所有的错误都是均等的。 我们宁愿错误地分入一个相关的类别，也不愿错误地分入一个遥远的类别，这通常被称为<strong>层次分类</strong>(hierarchical classification)。</p><h3 id="标记问题"><a href="#标记问题" class="headerlink" title="标记问题"></a>标记问题</h3><p>学习预测不相互排斥的类别的问题称为<strong>多标签分类</strong>（multi-label classification）。</p><p> 举个例子，人们在技术博客上贴的标签，比如“机器学习”、“技术”、“小工具”、“编程语言”、“Linux”、“云计算”。 一篇典型的文章可能会用5-10个标签，因为这些概念是相互关联的。</p><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>在信息检索领域，我们希望对一组项目进行排序。 以网络搜索为例，我们的目标不是简单的“查询（query）-网页（page）”分类，而是在海量搜索结果中找到用户最需要的那部分。</p><h3 id="推荐系统"><a href="#推荐系统" class="headerlink" title="推荐系统"></a>推荐系统</h3><h3 id="序列学习"><a href="#序列学习" class="headerlink" title="序列学习"></a>序列学习</h3><p>有些时候，输入是连续的。我们的模型可能就需要拥有“记忆”功能。</p><p>比如文字序列，图像序列（视频）</p><p>以下是序列学习的特殊情况：</p><ul><li><strong>标记和解析</strong></li><li><strong>语音识别</strong></li><li><strong>文本到语音</strong></li><li><strong>机器翻译</strong></li></ul><h2 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h2><p> 比如，你的老板可能会给你一大堆数据，然后让你用它做一些数据科学研究，却没有对结果有要求。 我们称这类数据中不含有“目标”的机器学习问题为<strong>无监督学习</strong>（unsupervised learning）</p><p>以下列举了集中无监督学习：</p><ul><li><strong>聚类</strong>（clustering）问题：没有标签的情况下，我们是否能给数据分类</li><li><strong>主成分分析</strong>（principal component analysis）问题：我们能否找到少量的参数来准确地捕捉数据的线性相关属性？比如，一个球的运动轨迹可以用球的速度、直径和质量来描述。</li><li><strong>因果关系</strong>（causality）和概率图模型（probabilistic graphical models）问题：我们能否描述观察到的许多数据的根本原因？</li><li><strong>生成对抗性网络</strong>（generative adversarial networks）：为我们提供一种合成数据的方法，甚至像图像和音频这样复杂的结构化数据。</li></ul><h3 id="与环境互动"><a href="#与环境互动" class="headerlink" title="与环境互动"></a>与环境互动</h3><p>到目前为止，不管是监督学习还是无监督学习，我们都会预先获取大量数据，然后启动模型，不再与环境交互。 这里所有学习都是在算法与环境断开后进行的，被称为<strong>离线学习</strong>（offline learning）。</p><p>这种简单的离线学习有它的魅力。 好的一面是，我们可以孤立地进行模式识别，而不必分心于其他问题。 但缺点是，解决的问题相当有限。 与预测不同，“与真实环境互动”实际上会影响环境。 这里的人工智能是“智能代理”，而不仅是“预测模型”。 因此，我们必须考虑到它的行为可能会影响未来的观察结果。</p><p>考虑“与真实环境互动”将打开一整套新的建模问题。以下只是几个例子：</p><ul><li>环境还记得我们以前做过什么吗？</li><li>环境是否有助于我们建模？例如，用户将文本读入语音识别器。</li><li>环境是否想要打败模型？例如，一个对抗性的设置，如垃圾邮件过滤或玩游戏？</li><li>环境是否重要？</li><li>环境是否变化？例如，未来的数据是否总是与过去相似，还是随着时间的推移会发生变化？是自然变化还是响应我们的自动化工具而发生变化？</li></ul><p>当训练和测试数据不同时，最后一个问题提出了<strong>分布偏移</strong>（distribution shift）的问题。 接下来，我们将简要描述强化学习问题，这是一类明确考虑与环境交互的问题。</p><h3 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h3><p><em>不是太懂</em></p><p>在强化学习问题中，agent在一系列的时间步骤上与环境交互。 在每个特定时间点，agent从环境接收一些观察（observation），并且必须选择一个动作（action），然后通过某种机制（有时称为执行器）将其传输回环境，最后agent从环境中获得奖励（reward）。 此后新一轮循环开始，agent接收后续观察，并选择后续操作，依此类推。</p><p><img src="rl-environment.png" alt="强化学习"></p><p>强化学习框架的通用性十分强大。 例如，我们可以将任何监督学习问题转化为强化学习问题。</p><p>当然，强化学习还可以解决许多监督学习无法解决的问题。 例如，在监督学习中，我们总是希望<strong>输入与正确的标签相关联</strong>。 但在强化学习中，我们<strong>并不假设环境告诉agent每个观测的最优动作</strong>。 一般来说，agent只是得到一些奖励。 此外，环境甚至可能不会告诉我们是哪些行为导致了奖励。</p><p>强化学习可能还必须处理部分可观测性问题。 也就是说，当前的观察结果可能无法阐述有关当前状态的所有信息。 比方说，一个清洁机器人发现自己被困在一个许多相同的壁橱的房子里。 推断机器人的精确位置（从而推断其状态），需要在进入壁橱之前考虑它之前的观察结果。</p><p>最后，在任何时间点上，强化学习agent可能知道一个好的策略，但可能有许多更好的策略从未尝试过的。 强化学习agent必须不断地做出选择：是应该利用当前最好的策略，还是探索新的策略空间（放弃一些短期回报来换取知识）。</p><p>一般的强化学习问题是一个非常普遍的问题。 agent的动作会影响后续的观察，而奖励只与所选的动作相对应。 环境可以是完整观察到的，也可以是部分观察到的，解释所有这些复杂性可能会对研究人员要求太高。 此外，并不是每个实际问题都表现出所有这些复杂性。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
          <category> 动手学深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Scrapy的网络爬虫案例</title>
      <link href="/2022/01/09/%E5%9F%BA%E4%BA%8EScrapy%E7%9A%84%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E6%A1%88%E4%BE%8B/"/>
      <url>/2022/01/09/%E5%9F%BA%E4%BA%8EScrapy%E7%9A%84%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这是在公司实习时，领导给出的一个数据爬取需求。（所以涉及法律问题请找公司的麻烦，不要联系我😂）</p><p>虽然我之前也干过网络爬虫，但都是在比较完整的框架下进行实现：以前只需要实现URL解析和网页源码抽取接口，其他像网络爬虫配置，数据存储，数据抽取，数据导出，任务启动和停止等模块只需要鼠标click一下或者根本就是“黑盒”的，不需要我操心。。</p><p>这一次，我基本是从“0”开始。所以在完成任务的过程中学到了很多。（当然也还不够多）</p><p>由于爬取的网站是一个经典的“列表-详情”结构，且爬取难度不难（网站没有设置反爬），作为爬虫初学者很合适，所以我把该任务的实现过程记录下来，方便自己学习。</p><p>本篇博客将记录我在实现该任务时，学到的知识、遇到的困难、对应的解决方案。</p><p>通过阅读本篇博客你将获得</p><ul><li>使用Scrapy进行简单的网页数据爬取</li><li>使用BeautifulSoup解析HTML</li><li>使用Pandas做简单的数据读取、去重、分析操作</li></ul><p>不能获得：</p><ul><li>Scrapy高级使用、框架结构、底层原理</li><li>破解数据采集时遇到的反爬</li></ul><p>废话比较多。先来看一下阅读本文需要的前置知识。</p><h1 id="阅读本文需要的前置知识"><a href="#阅读本文需要的前置知识" class="headerlink" title="阅读本文需要的前置知识"></a>阅读本文需要的前置知识</h1><p>阅读本篇博客需要一定的前置知识。我将列举一些，可能不全。</p><ul><li>网络爬虫：什么是网络爬虫</li><li>//Conda：什么是Conda，Conda安装、环境创建等</li><li>Python 基础：基础数据结构及操作、文件I/O操作</li><li>PyCharm使用：如何配置开发环境，连接远程环境进行开发等</li><li>//Linux 服务器基本命令</li><li>HTML基础、CSS选择器等前端基础知识。</li><li>XPath数据定位、正则表达式匹配等知识。</li></ul><p>如果你有以上基础，那么阅读本篇博客基本没有障碍。</p><p>下面介绍我的工作环境。</p><h1 id="工作环境"><a href="#工作环境" class="headerlink" title="工作环境"></a>工作环境</h1><div class="table-container"><table><thead><tr><th>软件名称</th><th>备注</th><th>版本</th></tr></thead><tbody><tr><td>Windows</td><td>操作系统</td><td>10</td></tr><tr><td>PyCharm</td><td>开发IDE</td><td>2019.3.5</td></tr><tr><td>Ananconda</td><td>Python环境管理和包管理工具</td><td>懒得写了</td></tr><tr><td>Scrapy</td><td>Python开源模块，爬虫框架</td><td>懒得写了</td></tr><tr><td>BeautifulSoup</td><td>Python开源模块，解析HTML</td><td>懒得写了</td></tr><tr><td>Pandas</td><td>Python开源模块，这里用它做简单的数据提取</td><td>懒得写了</td></tr></tbody></table></div><p>下面介绍具体需求。</p><h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>爬取网站 <a href="https://www.yunyubaike.com/">孕育百科</a> 各分类下的孕育问答。结果以CSV格式给出。</p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>打开 <a href="https://www.yunyubaike.com/">孕育百科</a> 可以看到有很多孕育百科的分类，选择一个分类，比如，这里我们选择【准备怀孕】。</p><p><img src="image-20220107161453957.png" alt="分类"></p><p>新打开的网页为<a href="https://www.yunyubaike.com/beiyun/">https://www.yunyubaike.com/beiyun/</a></p><p>可以看到这里有一些子分类：</p><p><img src="image-20220107162138428.png" alt="分类和子分类"></p><p>这些分类和子分类下有很多孕育百科问答，我们点击一个问题的超链接，在弹出的详情页中给出问题的答案，如图：</p><p><img src="image-20220107162808046.png" alt="孕育百科-详情页"></p><p>把这些问题和答案“抽取”到到CSV文件中，作为最终结果。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先我们需要分析该网站，例如网站数据量大小，网站网页结构，网站跳转方式，数据传输方式，数据是否加密，网站反爬严不严重等等。</p><p>可以抓包、写网页下载代码测试一下。</p><p>据此指定网站采集策略，是使用本地IP就可以采集还是需要设置一批代理IP，数据文件是存放到本地还是需要存放到Hadoop，是否需要可视化（Selenium）采集等等。</p><h2 id="采集策略"><a href="#采集策略" class="headerlink" title="采集策略"></a>采集策略</h2><ol><li>先采集分类（首页）URL；</li><li>根据分类（首页）URL不断循环生成分页（列表页）；</li><li>爬取每个列表页中的详情URL；</li><li>下载详情URL的HTML文件，保存到本地；</li><li>解析本地HTML，生成CSV文件。</li></ol><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="采集分类"><a href="#采集分类" class="headerlink" title="采集分类"></a>采集分类</h2><p>仔细分析网站可以发现，在采集分类存在两个坑。</p><ul><li>不是所有分类都是孕育百科：对于不是分类的URL可以直接丢弃。</li><li>子分类下和分类存在重复：去重。</li></ul><p>由于子分类和分类不是很多，这里使用的手工采集。</p><p>虽说手工采集，但还是需要一点小小的技巧。这里不是挨个复制网页源码中的分类连接，而是通过Chrome的一个插件<a href="https://chrome.google.com/webstore/detail/xpath-helper/hgimnogjllphhhkhlmebbmlgjoejdpjl?utm_source=chrome-ntp-icon">XPath Helper</a>。</p><p>该插件支持通过写XPath的方式批量获得信息。</p><p>例如我们要获取上图【分类和子分类】中的子分类。先查看这部分的网页源码</p><p><img src="image-20220107165203546.png" alt="子分类网页源码"></p><p>打开XPath Helper，写入XPath获得结果。</p><p><img src="image-20220107165324295.png" alt="XPath Helper截图"></p><p>最终获得大小分类共72个。</p><h2 id="列表页翻页采集详情页URL"><a href="#列表页翻页采集详情页URL" class="headerlink" title="列表页翻页采集详情页URL"></a>列表页翻页采集详情页URL</h2><p>每个分类下有很多翻页，通过不断的翻页采集所有的详情URL。</p><p><img src="image-20220107165646544.png" alt="翻页"></p><p>这里我一开始偷懒，用的“八爪鱼采集器”。后来发现这软件虽然不需要写代码，但是对于大于1W的数据需要收费，就放弃了。</p><p>后续我基于Scrapy爬虫框架完成采集。</p><h3 id="新建Scrapy项目"><a href="#新建Scrapy项目" class="headerlink" title="新建Scrapy项目"></a>新建Scrapy项目</h3><p>首先我们需要新建一个Scrapy项目（前提是已经安装了Scrapy）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scrapy startproject yybkSpider</span><br></pre></td></tr></table></figure><p>其中， yybkSpider为项目名称，可以看到将会创建一个yybkSpider文件夹，目录结构大致如下：</p><p>下面来简单介绍一下各个主要文件的作用：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yybkSpider/</span><br><span class="line">    scrapy.cfg</span><br><span class="line">    yybkSpider/</span><br><span class="line">        __init__.py</span><br><span class="line">        items.py</span><br><span class="line">        pipelines.py</span><br><span class="line">        settings.py</span><br><span class="line">        spiders/</span><br><span class="line">            __init__.py</span><br></pre></td></tr></table></figure><p>这里介绍我认为比较重要的文件：</p><ul><li>settings.py: 项目的配置文件，默认下载的网页是Unicode，需要在这里配置为UTF-8编码。</li><li>yybkSpider/: 项目的Python模块，将会从这里引用代码。</li><li>yybkSpider/items.py: 保存数据的实体，有点像Java Bean。</li><li>yybkSpider/yybkSpider/: 存储爬虫代码目录。</li></ul><h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><p>这里默认下载的网页为UTF-8，所以需要在<code>settings.py</code>中增加配置<code>FEED_EXPORT_ENCODING = &#39;utf-8&#39;</code></p><p>还可以修改下载的线程数。但是我查阅了网上的相关资料，好像作用并不大。由于对Python和Scrapy不是很了解，这里直接给出连接：</p><ul><li><a href="https://www.zhihu.com/question/23474039">为什么有人说 Python 的多线程是鸡肋呢？</a></li><li><a href="https://www.zhihu.com/question/26062225">scrapy在爬网页的时候是自动采用多线程的吗？</a></li></ul><h3 id="制作爬虫"><a href="#制作爬虫" class="headerlink" title="制作爬虫"></a>制作爬虫</h3><p>紧接着，制作一个爬虫：</p><ul><li>Input：所有分类首页</li><li>Output：<ul><li>所有列表页</li><li>每个列表页的详情URL和其他信息。</li></ul></li></ul><p>进入<code>yybkSpider/</code>目录下，输入命令创建爬虫：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scrapy genspider yybk_list &quot;yunyubaike.com&quot;</span><br></pre></td></tr></table></figure><ul><li><code>yybk_list</code>是爬虫的名称</li><li><code>&quot;yunyubaike.com&quot;</code>指出该爬虫爬取的域名，超出域名的不会爬取。</li></ul><p>之后可以看到在<code>yybkSpider/yybkSpider/</code>生成了一个文件<code>yybk_list.py</code>，它默认增加了下列代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YybkListSpider</span>(<span class="params">scrapy.Spider</span>):</span></span><br><span class="line">    name = <span class="string">&#x27;yybk_list&#x27;</span></span><br><span class="line">    allowed_domains = [<span class="string">&#x27;yunyubaike.com&#x27;</span>]</span><br><span class="line">    start_urls = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span>(<span class="params">self, response</span>):</span></span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>name = “” ：这个爬虫的识别名称，必须是唯一的，在不同的爬虫必须定义不同的名字。</p><p>allow_domains = [] 是搜索的域名范围，也就是爬虫的约束区域，规定爬虫只爬取这个域名下的网页，不存在的URL会被忽略。</p><p>start_urls = [] ：爬取的URL列表。爬虫从这里开始抓取数据，所以，第一次下载的数据将会从这些urls开始。其他子URL将会从这些起始URL中继承性生成。</p><p>parse(self, response) ：解析的方法，每个初始URL完成下载后将被调用，调用的时候传入从每一个URL传回的Response对象来作为唯一参数，主要作用如下：</p><ul><li>负责解析返回的网页数据(response.body)，提取结构化数据(生成item)</li><li>生成需要下一页的URL请求。</li></ul><p>接下来我们完成该爬虫。首先start_urls不是一个而是72个分类首页URL。再者我们要在parse方法中完成两件事：</p><ol><li>不断生成下一页</li><li>对于每个列表页解析其中的数据。</li></ol><p>下面是完整代码，这部分参考了官方文档：<a href="https://docs.scrapy.org/en/latest/intro/overview.html。">https://docs.scrapy.org/en/latest/intro/overview.html。</a></p><p>这里有几个地方值得注意：</p><ol><li>通过<code>response.url</code>获得当前采集的URL</li><li><code>response.xpath(&#39;&#39;)</code>返回的是一组元素</li><li>我把<code>response.xpath(&#39;&#39;)[0].get()</code>都改写了，原因是如果<code>response.xpath(&#39;&#39;)</code>为空在执行<code>[0]</code>操作就会报错，导致爬取失败</li><li>使用<code>get()</code>而不是<code>exract()</code>。原因如下： </li></ol><blockquote><p>get() 、getall() 是新版本的方法，extract() 、extract_first()是旧版本的方法。</p><p>前者更好用，取不到就返回None，后者取不到就raise一个错误。</p></blockquote><ol><li>想要在当前元素下继续通过XPath选取元素，需要在XPath开头加一个<code>.</code></li><li>注意<code>yield</code>的使用</li><li>这里采集了很多“多余”的字段，例如页码，总数，当前url。这是为了后续验证采集的数据是否完整正确而增加的冗余字段。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YybkListSpider</span>(<span class="params">scrapy.Spider</span>):</span></span><br><span class="line">    name = <span class="string">&#x27;yybk_list&#x27;</span></span><br><span class="line">    allowed_domains = [<span class="string">&#x27;yunyubaike.com&#x27;</span>]</span><br><span class="line">    <span class="comment"># 一共是72个URL，这里没有列全</span></span><br><span class="line">    start_urls = [<span class="string">&#x27;https://www.yunyubaike.com/yunqi/&#x27;</span>,</span><br><span class="line">                  <span class="string">&#x27;https://www.yunyubaike.com/yichuanyousheng/&#x27;</span>,</span><br><span class="line">                  <span class="string">&#x27;https://www.yunyubaike.com/beiyun/&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span>(<span class="params">self, response</span>):</span></span><br><span class="line">        domain_url = <span class="string">&quot;https://www.yunyubaike.com&quot;</span></span><br><span class="line">        <span class="comment"># items = []</span></span><br><span class="line">        this_url = response.url</span><br><span class="line">        page_nums = response.xpath(<span class="string">&quot;//div[@class=&#x27;pagebar&#x27;]/b/text()&quot;</span>)</span><br><span class="line">        page_num = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> page_nums:</span><br><span class="line">            page_num = page_nums[<span class="number">0</span>].get()</span><br><span class="line">        <span class="comment"># page_num = response.xpath(&quot;//div[@class=&#x27;pagebar&#x27;]/b/text()&quot;)[0].get()</span></span><br><span class="line">        counts = response.xpath(<span class="string">&quot;//div[@class=&#x27;pagebar&#x27;]/a[@title]/b/text()&quot;</span>)</span><br><span class="line">        count=<span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> counts:</span><br><span class="line">            count = counts[<span class="number">0</span>].get()</span><br><span class="line">        <span class="comment"># count = response.xpath(&quot;//div[@class=&#x27;pagebar&#x27;]/a[@title]/b/text()&quot;)[0].get()</span></span><br><span class="line">        <span class="keyword">for</span> li <span class="keyword">in</span> response.xpath(<span class="string">&quot;//div[@class=&#x27;list&#x27;]/ul/li&quot;</span>):</span><br><span class="line">            titles = li.xpath(<span class="string">&#x27;.//h2/a/text()&#x27;</span>)</span><br><span class="line">            title = <span class="string">&#x27;&#x27;</span></span><br><span class="line">            <span class="keyword">if</span> titles:</span><br><span class="line">                title = titles[<span class="number">0</span>].get()</span><br><span class="line">            detail_urls = li.xpath(<span class="string">&#x27;.//h2/a/@href&#x27;</span>)</span><br><span class="line">            detail_url = <span class="string">&#x27;&#x27;</span></span><br><span class="line">            <span class="keyword">if</span> detail_urls:</span><br><span class="line">                detail_url = detail_urls[<span class="number">0</span>].get()</span><br><span class="line">            <span class="comment"># detail_url = li.xpath(&#x27;.//h2/a/@href&#x27;)[0].get()</span></span><br><span class="line">            <span class="keyword">yield</span> &#123;</span><br><span class="line">                <span class="string">&#x27;this_url&#x27;</span>: this_url,  <span class="comment"># 当前采集的URL</span></span><br><span class="line">                <span class="string">&#x27;page_num&#x27;</span>: page_num,  <span class="comment"># 第几页</span></span><br><span class="line">                <span class="string">&#x27;count&#x27;</span>: count,  <span class="comment"># 该分类下的问答总数</span></span><br><span class="line">                <span class="string">&#x27;title&#x27;</span>: title,  <span class="comment"># 问答标题</span></span><br><span class="line">                <span class="string">&#x27;detail_url&#x27;</span>: domain_url + detail_url  <span class="comment"># 详情URL</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment"># 生成下一页</span></span><br><span class="line">        next_pages = response.xpath(<span class="string">&quot;//a[text()=&#x27;下一页&#x27;]/@href&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> next_pages:</span><br><span class="line">            next_page = next_pages[<span class="number">0</span>].get()</span><br><span class="line">            <span class="comment"># next_page = response.xpath(&quot;//a[text()=&#x27;下一页&#x27;]/@href&quot;)[0].get()</span></span><br><span class="line">            <span class="keyword">if</span> next_page <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">yield</span> response.follow(domain_url + next_page, self.parse)  <span class="comment"># 将下一页的连接传递给爬虫继续解析。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h3 id="启动爬虫"><a href="#启动爬虫" class="headerlink" title="启动爬虫"></a>启动爬虫</h3><p>最后启动爬虫，保存数据。在项目根目录下运行</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scrapy crawl yybk_list -o urls.json</span><br></pre></td></tr></table></figure><p>可以发现，在项目根目录多出了urls.json文件，里面是我们保存的所有列表数据。</p><p>我们也可以保存为其他格式。这里不再赘述。</p><p>这样我们就得到了大约27W的详情连接。下面我们把这些连接对应的HTML保存到本地。</p><h2 id="下载详情网页源码"><a href="#下载详情网页源码" class="headerlink" title="下载详情网页源码"></a>下载详情网页源码</h2><h3 id="制作爬虫-1"><a href="#制作爬虫-1" class="headerlink" title="制作爬虫"></a>制作爬虫</h3><p>进入<code>yybkSpider/</code>目录下，输入命令创建爬虫：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scrapy genspider yybk_detail_down &quot;yunyubaike.com&quot;</span><br></pre></td></tr></table></figure><p>和上面类似，在<code>yybkSpider/yybkSpider/yybk_detail_down.py</code>写入代码：</p><p>这里需要注意：</p><ol><li>start_urls是需要从文件中读取的</li><li>为了读数据、取数据方便，我使用了pands</li><li>获得网页源码，使用<code>response.text</code></li><li>这里没有对网页源码直接解析，而是先保存，再在后续解析。提高容错。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YybkDetailDownSpider</span>(<span class="params">scrapy.Spider</span>):</span></span><br><span class="line">    name = <span class="string">&#x27;yybk_detail_down&#x27;</span></span><br><span class="line">    allowed_domains = [<span class="string">&#x27;yunyubaike.com&#x27;</span>]</span><br><span class="line">    df = pd.read_json(<span class="string">&quot;yybkSpider/urls.json&quot;</span>)</span><br><span class="line">    <span class="comment"># 273179条数据</span></span><br><span class="line">    <span class="comment"># 取detail_url列，去重，转换成list</span></span><br><span class="line">    start_urls = df[<span class="string">&#x27;detail_url&#x27;</span>].drop_duplicates().tolist()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span>(<span class="params">self, response</span>):</span></span><br><span class="line">        url = response.url</span><br><span class="line">        <span class="comment"># 获得网页源码</span></span><br><span class="line">        content = response.text</span><br><span class="line"></span><br><span class="line">        file_name = url.replace(<span class="string">&quot;https://www.yunyubaike.com/&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        file_name = <span class="string">&#x27;html/&#x27;</span> + file_name.replace(<span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;_&#x27;</span>)   <span class="comment"># html/huaiyun_wiki_270163.html</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;保存文件：&quot;</span> + file_name)</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(file_name, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(content)</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>此外，我担心detail_url格式是否一致，所以在Python Shell中执行了如下代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df = pd.read_json(<span class="string">&quot;yybkSpider/urls.json&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df[df[<span class="string">&#x27;detail_url&#x27;</span>].<span class="built_in">str</span>.match(<span class="string">r&#x27;https://www.yunyubaike.com/\w+/\d+\.html&#x27;</span>) == <span class="literal">False</span>]</span><br></pre></td></tr></table></figure><p>执行结果为空，这证明detail_url格式一致。</p><h3 id="启动爬虫-1"><a href="#启动爬虫-1" class="headerlink" title="启动爬虫"></a>启动爬虫</h3><p>紧接着启动爬虫，和上面类似：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scrapy crawl yybk_detail_down</span><br></pre></td></tr></table></figure><p>由于这里不需要生成文件，所以没有<code>-o</code></p><p>等待代码执行完毕后，可以发现在项目根目录产生了一个<code>html/</code>文件夹，下面保存了所有详情页的网页源码。</p><h2 id="解析详情页"><a href="#解析详情页" class="headerlink" title="解析详情页"></a>解析详情页</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>打开一个详情页：</p><p><img src="image-20220109124722467.png" alt="详情页"></p><p>可以定位到：在<code>&lt;div class=&#39;article_content&#39; /&gt;</code>标签下，所有的带文字的p标签是我们需要的。每个p标签是一个段落，在保存的时候，段落信息是不能丢失的。也就是说换行符是需要的。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>这一步是脱离于Scrapy框架的。</p><p>自定义一个Python脚本：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">input_dir = <span class="string">&#x27;html/&#x27;</span>  <span class="comment"># 上一步保存源码的文件夹路径</span></span><br><span class="line">output_file_base_name = <span class="string">&#x27;yybkSpider/output/yybk_&#123;&#125;.csv&#x27;</span>  <span class="comment"># 生成的CSV文件的保存路径</span></span><br><span class="line">MAX_ROWS = <span class="number">50000</span>    <span class="comment"># 单个csv文件写入的最大行数</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">解析方法，传入文件名</span></span><br><span class="line"><span class="string">返回需要的字段</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse</span>(<span class="params">file_name</span>):</span></span><br><span class="line">    soup = BeautifulSoup(<span class="built_in">open</span>(file_name, encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    <span class="comment"># title解析</span></span><br><span class="line">    title = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    h1 = soup.find_all(<span class="string">&quot;h1&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> h1:</span><br><span class="line">        title = h1[<span class="number">0</span>].get_text()</span><br><span class="line">    <span class="comment"># content解析</span></span><br><span class="line">    p_list = soup.select(<span class="string">&quot;div.article_content &gt; p&quot;</span>)</span><br><span class="line">    content = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> p_list:</span><br><span class="line">        p_text = p.get_text()</span><br><span class="line">        <span class="keyword">if</span> p_text != <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">            <span class="comment"># 为了避免csv解析失败</span></span><br><span class="line">            p_text = p_text.replace(<span class="string">&quot;,&quot;</span>, <span class="string">&quot;，&quot;</span>).replace(<span class="string">&#x27;&quot;&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            content += p_text + <span class="string">&quot;\n&quot;</span></span><br><span class="line">    content = content.rstrip().lstrip()</span><br><span class="line">    <span class="keyword">return</span> title, content</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    htmls = os.listdir(input_dir)</span><br><span class="line">    <span class="comment"># 计算最终生成的文件个数</span></span><br><span class="line">    file_num = (<span class="built_in">len</span>(htmls) + MAX_ROWS - <span class="number">1</span>) // MAX_ROWS</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(file_num):</span><br><span class="line">        <span class="comment"># i从0开始</span></span><br><span class="line">        <span class="comment"># 第i个文件保存 i*MAX_ROWS[下标] 到 (i+1)*MAX_ROWS - 1</span></span><br><span class="line">        start_index = i*MAX_ROWS</span><br><span class="line">        end_index = (i+<span class="number">1</span>)*MAX_ROWS - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> end_index &gt; <span class="built_in">len</span>(htmls):</span><br><span class="line">            end_index = <span class="built_in">len</span>(htmls)</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(output_file_base_name.<span class="built_in">format</span>(i), <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;parsing :start_index:&#123;&#125;, end_index:&#123;&#125;; saving as &#123;&#125;&quot;</span></span><br><span class="line">                  .<span class="built_in">format</span>(start_index, end_index, output_file_base_name.<span class="built_in">format</span>(i)))</span><br><span class="line">            f.write(<span class="string">&quot;article_id,content,title\n&quot;</span>)</span><br><span class="line">            <span class="keyword">for</span> html_name <span class="keyword">in</span> htmls[start_index: end_index]:</span><br><span class="line">                title, content = parse(os.path.join(input_dir, html_name))</span><br><span class="line">                f.write(html_name + <span class="string">&#x27;,&quot;&#x27;</span> + content + <span class="string">&#x27;&quot;,&#x27;</span> + title + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在<code>parse</code>方法中需要注意以下几点：</p><ol><li><code>soup.select(&quot;div.article_content &gt; p&quot;)</code>这里使用了CSS选择器，制定了div下的直接子标签；</li><li><code>p.get_text()</code>获得p标签下的所有文字；</li><li>为了避免CSV解析失败，这里把英文逗号换成中文逗号，把英文的引号全部去掉。（CSV文件用英文逗号做字段分割；当我们需要把多行数据保存在一个字段中时，需要把多行数据用英文引号包起来）；</li><li>使用BeautifulSoup解析HTML。</li></ol><p>在<code>main</code>方法中需要注意：</p><ol><li>27W行保存到一个CSV文件中，我担心不好把控，所以我将27W行数据每5W行保存为一个CSV</li><li>当需要对除法结果四舍五入时，这样做比较简单：<code>(被除数+除数-1)/除数</code></li></ol><h3 id="运行脚本"><a href="#运行脚本" class="headerlink" title="运行脚本"></a>运行脚本</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python xxx.py</span><br></pre></td></tr></table></figure><p>最终导出6个CSV文件。任务完成。</p><h1 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h1><p><a href="https://github.com/guoyujian/blog-resource/tree/main/yybkSpider">https://github.com/guoyujian/blog-resource/tree/main/yybkSpider</a></p><h1 id="此外…"><a href="#此外…" class="headerlink" title="此外…"></a>此外…</h1><h2 id="Scrapy-Shell快速测试"><a href="#Scrapy-Shell快速测试" class="headerlink" title="Scrapy Shell快速测试"></a>Scrapy Shell快速测试</h2><p>在使用Scrapy的过程中，我想先传入一条URL测试返回的resonpse。经过查阅使用如下命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scrapy shell &lt;url&gt;</span><br></pre></td></tr></table></figure><p>执行后，进入Python Console，内置的response对象即是\<url\>的response</p><h2 id="在服务器运行"><a href="#在服务器运行" class="headerlink" title="在服务器运行"></a>在服务器运行</h2><p>如果在本机执行爬虫代码，会占用较多的资源，也不方便。此时可以把爬虫代码同步到服务器运行。我使用PyChram连接远程服务器，在本机编写爬虫代码，然后同步到服务器中执行。（具体请自行百度）</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://docs.scrapy.org/en/latest/intro/overview.html">Scrapy at a glance</a></li><li><a href="https://www.runoob.com/w3cnote/scrapy-detail.html">Scrapy 入门教程</a></li><li><a href="https://www.runoob.com/cssref/css-selectors.html">CSS选择器</a></li><li><a href="https://scrapy-chs.readthedocs.io/zh_CN/1.0/topics/shell.html">Scrapy shell</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 网络爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络爬虫 </tag>
            
            <tag> Scrapy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解HTTP协议</title>
      <link href="/2022/01/05/%E8%AF%A6%E8%A7%A3HTTP%E5%8D%8F%E8%AE%AE/"/>
      <url>/2022/01/05/%E8%AF%A6%E8%A7%A3HTTP%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p><strong>超文本传输协议</strong>（HTTP，HyperText Transfer Protocol）是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。1960年美国人Ted Nelson构思了一种通过计算机处理文本信息的方法，并称之为超文本（hypertext）,这成为了HTTP超文本传输协议标准架构的发展根基。Ted Nelson组织协调万维网协会（World Wide Web Consortium）和互联网工程工作小组（Internet Engineering Task Force ）共同合作研究，最终发布了一系列的RFC，其中著名的RFC 2616定义了HTTP 1.1。</p><h1 id="HTTP协议的作用及特点"><a href="#HTTP协议的作用及特点" class="headerlink" title="HTTP协议的作用及特点"></a>HTTP协议的作用及特点</h1><p>HTTP是一个客户端和服务器端请求和应答的标准（TCP）。客户端是终端用户，服务器端是网站。</p><p>通过使用Web浏览器、网络爬虫或者其它的工具，客户端发起一个到服务器上指定端口（<strong>默认端口为80</strong>）的HTTP请求。（我们称这个客户端）叫<strong>用户代理（user agent）</strong>。应答的服务器上存储着（一些）资源，比如HTML文件和图像。（我们称）这个应答服务器为源服务器（origin server）。在用户代理和源服务器中间可能存在多个中间层，比如代理，网关，或者隧道（tunnels）。尽管TCP/IP协议是互联网上最流行的应用，HTTP协议并没有规定必须使用它和（基于）它支持的层。 事实上，HTTP可以在任何其他互联网协议上，或者在其他网络上实现。HTTP只假定（其下层协议提供）可靠的传输，任何能够提供这种保证的协议都可以被其使用。</p><p>通常，由HTTP客户端发起一个请求，建立一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端发送过来的请求。一旦收到请求，服务器（向客户端）发回一个状态行，比如”HTTP/1.1 200 OK”，和（响应的）消息，消息的消息体可能是请求的文件、错误消息、或者其它一些信息。<strong>HTTP使用TCP而不是UDP的原因在于（打开）一个网页必须传送很多数据，而TCP协议提供传输控制，按顺序组织数据，和错误纠正。</strong></p><p>通过HTTP或者HTTPS协议请求的资源由<strong>统一资源标示符</strong>（Uniform Resource Identifiers）（或者，更准确一些，URLs）来标识。</p><ol><li>基于请求/响应模型的协议。请求和响应必须成对，先有请求后有响应</li><li>HTTP协议默认端口:80</li><li>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST等。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</li><li>灵活：<strong>HTTP允许传输任意类型的数据对象。</strong>正在传输的类型由Content-Type加以标记。</li><li><strong>无连接</strong>：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li><li><strong>无状态</strong>：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</li></ol><h1 id="协议功能"><a href="#协议功能" class="headerlink" title="协议功能"></a>协议功能</h1><p>HTTP协议是用于从WWW服务器传输超文本到本地浏览器的传输协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。</p><p>HTTP是客户端浏览器或其他程序与Web服务器之间的<strong>应用层通信协议</strong>。在Internet上的Web服务器上存放的都是超文本信息，客户机需要通过HTTP协议传输所要访问的超文本信息。HTTP包含命令和传输信息，不仅可用于Web访问，也可以用于其他因特网/内联网应用系统之间的通信，从而实现各类应用资源超媒体访问的集成。</p><p>我们在浏览器的地址栏里输入的网站地址叫做URL (Uniform Resource Locator，统一资源定位符)。就像每家每户都有一个门牌地址一样，每个网页也都有一个Internet地址。当你在浏览器的地址框中输入一个URL或是单击一个超级链接时，URL就确定了要浏览的地址。浏览器通过超文本传输协议(HTTP)，将Web服务器上站点的网页代码提取出来，并翻译成漂亮的网页。</p><h1 id="HTTP协议的版本"><a href="#HTTP协议的版本" class="headerlink" title="HTTP协议的版本"></a>HTTP协议的版本</h1><p>HTTP/1.0，发送请求，创建一次连接，获得<strong>一个</strong>web资源，连接断开</p><p>HTTP/1.1，发送请求，创建一次连接，获得<strong>多个</strong>web资源，连接断开</p><p>HTTP/2.0</p><h1 id="HTTP协议的组成"><a href="#HTTP协议的组成" class="headerlink" title="HTTP协议的组成"></a>HTTP协议的组成</h1><p>HTTP协议由<strong>HTTP请求</strong>和<strong>HTTP响应</strong>组成，当在浏览器中输入网址访问某个网站时， 你的浏览器会将你的请求封装成一个HTTP请求发送给服务器站点，服务器接收到请  求后会组织响应数据封装成一个HTTP响应返回给浏览器。即没有请求就没有响应。</p><p><strong>HTTP请求包括：请求行、请求头、请求体</strong></p><p><strong>HTTP响应包括：响应行、响应头、响应体</strong></p><h1 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h1><p>HTTP请求报文由3部分组成（请求行+请求头+请求体）：</p><p><img src="HTTP请求报文.png" alt="HTTP请求报文"></p><h2 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h2><p>例如：<code>POST /chapter17/user.html HTTP/1.1</code></p><p>格式：<code>请求方式 资源路径 协议/版本</code></p><p>请求行必须在HTTP请求格式的第一行。</p><blockquote><p>GET请求</p></blockquote><ul><li>将请求参数追加在URL后面，不安全</li><li>URL长度限制GET请求方式数据的大小</li><li>没有请求体</li><li>一般的HTTP请求大多都是GET。</li><li>常见GET请求：地址栏直接访问、\<a href=""\>、\<img src=""\>等</li></ul><blockquote><p>POST请求</p></blockquote><p>请求参数在请求体处，较安全。</p><p>请求数据大小没有限制</p><p>只有表单设置为method=“post”才是POST请求，其他都是GET请求</p><blockquote><p>HEAD请求</p></blockquote><p>HEAD跟GET相似，不过服务端接收到HEAD请求时<strong>只返回响应头</strong>，不发送响应内容。所以，如果只需要查看某个页面的状态时，用HEAD更高效，因为省去了传输页面内容的时间。</p><blockquote><p>DELETE请求</p></blockquote><p>删除某一个资源。</p><blockquote><p>OPTIONS请求</p></blockquote><p>用于获取当前URL所支持的方法。若请求成功，会在HTTP头中包含一个名为“Allow”的头，值是所支持的方法，如”GET, POST”。</p><blockquote><p>PUT请求</p></blockquote><p>把一个资源存放在指定的位置上。</p><p>本质上来讲， PUT和POST极为相似，都是向服务器发送数据，但它们之间有一个重要区别，PUT通常指定了资源的存放位置，而POST则没有，POST的数据存放位置由服务器自己决定。</p><blockquote><p>TRACE请求</p></blockquote><p>回显服务器收到的请求，主要用于测试或诊断。</p><blockquote><p>CONNECT请求</p></blockquote><p>CONNECT方法是HTTP/1.1协议预留的，能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接与非加密的HTTP代理服务器的通信。</p><p><strong>在 REST 架构风格中，有严格规定对于不同的请求类型要设置合适的请求方法。</strong></p><p>也是避免出现因为乱用导致混乱的问题。这里提到了REST架构，现在很多同学都在写REST，有没有人能够明白为什么要定义REST这个架构风格？（使用REST）</p><ol><li>随着服务化架构的普及，HTTP协议的使用频率越来越高</li><li>很多人在错误的使用HTTP协议定义接口，比如各种各样的命名，什么 getUserInfoById， deleteById 之类的、<strong>有状态和无状态请求混用。</strong></li><li>对于 http 协议本身提供的规则并没有很好的利用</li></ol><p>所以，为了更好的解决这些问题，干脆就定义一套规则，这套规则并没有引入新的东西，无非就是对 http 协议本身的使用做了一些约束，比如说</p><ol><li><strong>REST是面向资源</strong>，每一个 URI 代表一个资源</li><li>强调<strong>无状态化</strong>，服务器端不能存储来自某个客户的某个请求中的信息，并在该客户的其他 请求中使用</li><li>强调 URL 暴露资源时，<strong>不要在 URI 中出现动词</strong></li><li>合理的利用 http 状态码、请求方法。</li></ol><p>因此大家在参照这种标准去使用 REST 风格时，要明白你遵循的是什么以及要解决什么问题。</p><h2 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h2><p>例如：Host: 39.108.107.149:8080</p><p>请求头从第二行开始，到第一个空格结束。请求头和请求体之间存在一个空格(如下)</p><p>例如：Host: 39.108.107.149:8080</p><p>请求头从第二行开始，到第一个空格结束。请求头和请求体之间存在一个空格(如下)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST http://39.108.107.149:8080/vk/app/rest/ddp/iModelServiceImpl/findModelByType HTTP/1.1</span><br><span class="line">User-Agent: Fiddler</span><br><span class="line">Host: 39.108.107.149:8080</span><br><span class="line">Content-Length: 11</span><br><span class="line"> </span><br><span class="line">name=城市</span><br></pre></td></tr></table></figure><p>请求头通常以键值对{key:value}方式传递数据。</p><p>key为规范的固定值</p><p>value为key对应的取值，通常是一个值，可能是一组。</p><h3 id="常见的请求头属性"><a href="#常见的请求头属性" class="headerlink" title="常见的请求头属性"></a>常见的请求头属性</h3><p><strong>Referer:</strong> 表示这个请求是从哪个url跳过来的，通过百度来搜索淘宝网,那么在进入淘宝网的请求报文中，Referer的值就是:www.baidu.com。 如果是直接访问就不会有这个头。</p><p>常用于：防盗链。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Referer: no-referrer-when-downgrade</span><br></pre></td></tr></table></figure><p><strong>Accept:</strong> 告诉服务端，该请求所能支持的响应数据类型，专业术语称为MIME 类型(文件类型的一种描述方式)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8</span><br></pre></td></tr></table></figure><p>MIME格式：大类型/小类型[;参数]</p><p>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,<em>/</em>;q=0.8</p><p>例如:</p><p>text/html,html文件</p><p>text/css,css文件</p><p>text/javascript,js文件</p><p>image/*，所有图片文件</p><p><strong>Cookie:</strong> 客户端的Cookie就是通过这个报文头属性传给服务端的哦！</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cookie: JSESSIONID=15982C27F7507C7FDAF0F97161F634B5</span><br></pre></td></tr></table></figure><p>这里就出了一个问题,网站A怎么保证自己请求体中保存的cookie就是网站A的cookie而不是网站B的cookie呢,这就和cookie里面的jsessionid有关系了，关于cookie,session,sessionid,jsessionid的区别联系，可以参考这个博文:</p><p><a href="http://www.cnblogs.com/fnng/archive/2012/08/14/2637279.html">http://www.cnblogs.com/fnng/archive/2012/08/14/2637279.html</a></p><p><strong>User-Agent:</strong> 浏览器通知服务器，客户端浏览器与操作系统相关信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36</span><br></pre></td></tr></table></figure><p><strong>Connection:</strong> 表示客户端与服务连接类型；Keep-Alive表示持久连接，close已关闭</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure><p><strong>Host:</strong> 请求的服务器主机名</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host: sczpkj.f3322.net:3000</span><br></pre></td></tr></table></figure><p><strong>Content-Length:</strong> 请求体的长度</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST http://39.108.107.149:8080/vk/app/rest/ddp/iModelServiceImpl/findModelByType HTTP/1.1</span><br><span class="line">User-Agent: Fiddler</span><br><span class="line">Host: 39.108.107.149:8080</span><br><span class="line">Content-Length: 11</span><br><span class="line"> </span><br><span class="line">name=城市</span><br></pre></td></tr></table></figure><p><strong>Content-Type:</strong> 请求的与实体对应的MIME信息。如果是POST请求,会有这个头,默认值为application/x-www-form-urlencoded，表示请求体内容使用url编码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Content-Type: application/x-www-form-urlencoded</span><br></pre></td></tr></table></figure><blockquote><h4 id="Content-Type详解"><a href="#Content-Type详解" class="headerlink" title="Content-Type详解"></a>Content-Type详解</h4><p>常见的Content-Type：</p><div class="table-container"><table><thead><tr><th>Content-Type</th><th>解释</th></tr></thead><tbody><tr><td>text/html</td><td>html格式</td></tr><tr><td>text/plain</td><td>纯文本格式</td></tr><tr><td>text/css</td><td>CSS格式</td></tr><tr><td>text/javascript</td><td>js格式</td></tr><tr><td>image/gif</td><td>gif图片格式</td></tr><tr><td>image/jpeg</td><td>jpg图片格式</td></tr><tr><td>image/png</td><td>png图片格式</td></tr><tr><td>application/x-www-form-urlencoded</td><td>POST专用：普通的表单提交默认是通过这种方式。form表单数据被编码为key/value格式发送到服务器。</td></tr><tr><td>application/json</td><td>POST专用：用来告诉服务端消息主体是序列化后的 JSON 字符串</td></tr><tr><td>text/xml</td><td>POST专用：发送xml数据</td></tr><tr><td>multipart/form-data</td><td>POST专用：下面讲解</td></tr></tbody></table></div><p><strong>application/x-www-form-urlencoded</strong> </p><p>最常见的post提交数据的方式。浏览器原生的form表单，如果不设置<strong>enctype属性</strong>，那么最终就会以application/x-www-form-urlencoded 方式提交数据</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST http://39.108.107.149:8080/vk/app/rest/ddp/iModelServiceImpl/findModelByType HTTP/1.1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">cache-control: no-cache</span><br><span class="line">Postman-Token: 8e602802-b4f5-4d05-96d7-e1c7a1951719</span><br><span class="line">User-Agent: PostmanRuntime/7.1.1</span><br><span class="line">Accept: */*</span><br><span class="line">Host: 39.108.107.149:8080</span><br><span class="line">cookie: JSESSIONID=6CD80B7028062D9190717CEE001C3194</span><br><span class="line">accept-encoding: gzip, deflate</span><br><span class="line">content-length: 32</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line">name=%E5%9F%8E%E5%B8%82&amp;status=1</span><br></pre></td></tr></table></figure><p>首先，Content-Type 被指定为 application/x-www-form-urlencoded；其次，提交的数据按照 key1=val1&amp;key2=val2 的方式进行编码，key 和 val 都进行了 URL 转码。大部分服务端语言都对这种方式有很好的支持。</p><p>很多时候，我们用 Ajax 提交数据时，也是使用这种方式。例如 JQuery 和 QWrap 的 Ajax，Content-Type 默认「application/x-www-form-urlencoded;charset=utf-8」。 </p><p><strong>multipart/form-data</strong> </p><p>这又是一个常见的 POST 数据提交的方式。我们<strong>使用表单上传文件</strong>时，必须让 form 的 enctyped 等于这个值。</p><p>此时（当使用表单上传文件时），HTTP请求报文格式如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST http://39.108.107.149:8080/vk/app/rest/ddp/iDataSourcesBaseService/file HTTP/1.1</span><br><span class="line">Content-Type: multipart/form-data; boundary=--------------------------629236571647111133881449</span><br><span class="line">cache-control: no-cache</span><br><span class="line">Postman-Token: 2146b4b3-2d30-469c-bbcd-fbc4693934d9</span><br><span class="line">User-Agent: PostmanRuntime/7.1.1</span><br><span class="line">Accept: */*</span><br><span class="line">Host: 39.108.107.149:8080</span><br><span class="line">cookie: JSESSIONID=6CD80B7028062D9190717CEE001C3194</span><br><span class="line">accept-encoding: gzip, deflate</span><br><span class="line">content-length: 435</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line">----------------------------629236571647111133881449</span><br><span class="line">Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;test.txt&quot;</span><br><span class="line">Content-Type: text/plain</span><br><span class="line"></span><br><span class="line">test upload</span><br><span class="line">----------------------------629236571647111133881449</span><br><span class="line">Content-Disposition: form-data; name=&quot;extCode&quot;</span><br><span class="line"></span><br><span class="line">test</span><br><span class="line">----------------------------629236571647111133881449</span><br><span class="line">Content-Disposition: form-data; name=&quot;extId&quot;</span><br><span class="line"></span><br><span class="line">3306</span><br><span class="line">----------------------------629236571647111133881449--  //结束标识</span><br></pre></td></tr></table></figure><p>首先生成了一个 boundary 用于分割不同的字段，为了避免与正文内容重复，boundary 很长很复杂。然后 Content-Type 里指明了数据是以 mutipart/form-data 来编码，本次请求的 boundary 是什么内容。</p><p>消息主体里按照字段个数又分为多个结构类似的部分，每部分都是<strong>以—boundary开始</strong>，紧接着内容描述信息，然后是回车，最后是最后是字段具体内容（文本或二进制），如果传输的是文件，还要包含文件名和文件类型信息。消息主体最后<strong>以—boundary—标示结束</strong>。</p><p>上面提到的这两种 POST 数据的方式，都是浏览器原生支持的，而且现阶段原生 form 表单也只支持这两种方式。但是随着越来越多的 Web 站点，尤其是 WebApp，全部使用 Ajax 进行数据交互之后，我们完全可以定义新的数据提交方式，给开发带来更多便利。 </p><p><strong>application/json</strong></p><p>application/json 这个 Content-Type 作为响应头大家肯定不陌生。实际上，现在越来越多的人把它作为请求头，用来告诉服务端消息主体是序列化后的 JSON 字符串。由于 JSON 规范的流行，除了低版本 IE 之外的各大浏览器都原生支持 JSON.stringify，服务端语言也都有处理 JSON 的函数，使用 JSON 不会遇上什么麻烦。 <strong>JSON 格式支持比键值对复杂得多的结构化数据，这一点也很有用。</strong></p><p>当<code>Content-Type: application/json</code>时请求报文如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST http://39.108.107.149:8080/vk/app/rest/ddp/vkIndexsService/queryVkIndxs HTTP/1.1</span><br><span class="line">Content-Type: application/json</span><br><span class="line">cache-control: no-cache</span><br><span class="line">Postman-Token: 5014bc39-0777-49d5-bb8a-73db9a981e49</span><br><span class="line">User-Agent: PostmanRuntime/7.1.1</span><br><span class="line">Accept: */*</span><br><span class="line">Host: 39.108.107.149:8080</span><br><span class="line">cookie: JSESSIONID=6CD80B7028062D9190717CEE001C3194</span><br><span class="line">accept-encoding: gzip, deflate</span><br><span class="line">content-length: 132</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"> &quot;name&quot;:&quot;828验证继承&quot;,</span><br><span class="line"> &quot;getresultType&quot;:&quot;2&quot;,</span><br><span class="line"> &quot;createTime&quot;:&quot;Tue Sep 11 2018 00:00:00 GMT+0800 (中国标准时间)&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方案，可以方便的提交复杂的结构化数据，特别适合 RESTful 的接口。各大抓包工具如 Chrome 自带的开发者工具、Firebug、Fiddler，都会以树形结构展示 JSON 数据，非常友好。</p></blockquote><p><strong>Accept-Encoding:</strong> 浏览器通知服务器，浏览器支持的数据压缩格式。如GZIP压缩</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Accept-Encoding: gzip, deflate</span><br></pre></td></tr></table></figure><p><strong>Accept-Language:</strong> 浏览器通知服务器，浏览器支持的语言。各国语言(国际化i18n)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br></pre></td></tr></table></figure><p><strong>Cache-Control:</strong> 指定请求和响应遵循的缓存机制</p><p>对缓存进行控制，如一个请求希望响应返回的内容在客户端要被缓存一年，或不希望被缓存就可以通过这个报文头达到目的。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cache-Control: no-cache</span><br></pre></td></tr></table></figure><p>更多请求头属性可以参考这篇文章:<a href = "http://tools.jb51.net/table/http_header">HTTP响应头和请求头信息对照表</a></p><h2 id="请求体"><a href="#请求体" class="headerlink" title="请求体"></a>请求体</h2><p>当请求方式是post的时，请求体会有请求的参数，格式如下：</p><p>username=zhangsan&amp;password=123</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST http://39.108.107.149:8080/vk/app/rest/ddp/iModelServiceImpl/findModelByType HTTP/1.1</span><br><span class="line">User-Agent: Fiddler</span><br><span class="line">Host: 39.108.107.149:8080</span><br><span class="line">Content-Length: 20</span><br><span class="line"> </span><br><span class="line">name=城市&amp;status=1</span><br></pre></td></tr></table></figure><h1 id="HTTP响应报文"><a href="#HTTP响应报文" class="headerlink" title="HTTP响应报文"></a>HTTP响应报文</h1><p>HTTP的响应报文也由三部分组成（响应行+响应头+响应体）</p><p><img src="HTTP响应报文.png" alt="HTTP响应报文"></p><h2 id="响应行"><a href="#响应行" class="headerlink" title="响应行"></a>响应行</h2><p>例如：<code>HTTP/1.1 200 OK</code></p><p>格式：<code>报文协议及版本 状态码及状态描述</code></p><h3 id="常见的状态码"><a href="#常见的状态码" class="headerlink" title="常见的状态码"></a>常见的状态码</h3><p>状态码：由3位数字组成，第一个数字定义了响应的类别</p><p>1xx：指示信息，表示请求已接收，继续处理</p><p>2xx：成功，表示请求已被成功接受，处理。</p><ul><li>200 OK：客户端请求成功</li><li>204 No Content：无内容。服务器成功处理，但未返回内容。一般用在只是客户端向服务器发送信息，而服务器不用向客户端返回什么信息的情况。不会刷新页面。</li><li>206 Partial Content：服务器已经完成了部分GET请求（客户端进行了范围请求）。响应报文中包含Content-Range指定范围的实体内容</li></ul><p>3xx：重定向</p><ul><li>301 Moved Permanently：永久重定向，表示请求的资源已经永久的搬到了其他位置。</li><li>302 Found：临时重定向，表示请求的资源临时搬到了其他位置</li><li>303 See Other：临时重定向，应使用GET定向获取请求资源。303功能与302一样，区别只是303明确客户端应该使用GET访问</li><li>307 Temporary Redirect：临时重定向，和302有着相同含义。POST不会变成GET</li><li>304 Not Modified：表示客户端发送附带条件的请求（GET方法请求报文中的IF…）时，条件不满足。返回304时，不包含任何响应主体。虽然304被划分在3XX，但和重定向一毛钱关系都没有</li></ul><p>4xx：客户端错误</p><ul><li>400 Bad Request：客户端请求有语法错误，服务器无法理解。</li><li>401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用。</li><li>403 Forbidden：服务器收到请求，但是拒绝提供服务</li><li>404 Not Found：请求资源不存在。比如，输入了错误的url</li><li>415 Unsupported media type：不支持的媒体类型</li></ul><p>5xx：服务器端错误，服务器未能实现合法的请求。</p><ul><li>500 Internal Server Error：服务器发生不可预期的错误。</li><li>503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常，</li></ul><h2 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h2><p>响应报文头，也是由多个属性组成；</p><p>响应头也是用键值对；</p><p>服务器通过响应头来控制浏览器的行为，不同的头浏览器操作不同</p><div class="table-container"><table><thead><tr><th>常见请求头</th><th>描述</th></tr></thead><tbody><tr><td>Location</td><td>指定响应的路径，需要与状态码302配合使用，完成跳转。</td></tr><tr><td>Content-Type</td><td>响应正文的类型（MIME类型）；取值：text/html;charset=UTF-8</td></tr><tr><td>Content-Disposition</td><td>通过浏览器以下载方式解析正文；  取值：attachment;filename=xx.zip</td></tr><tr><td>Set-Cookie</td><td>与会话相关技术。服务器向浏览器写入Cookie</td></tr><tr><td>Content-Encoding</td><td>服务器使用的压缩格式；取值：gzip</td></tr><tr><td>Content-length</td><td>响应正文的长度</td></tr><tr><td>Refresh</td><td>定时刷新，格式：秒数;url=路径。url可省略，默认值为当前页。取值：3;url=www.itcast.cn    //三秒刷新页面到www.itcast.cn</td></tr><tr><td>Server</td><td>指的是服务器名称，默认值：Apache-Coyote/1.1。可以通过conf/server.xml配置进行修改。<Connector port="8080" ... server="itcast"/></td></tr><tr><td>Last-Modified</td><td>服务器通知浏览器，文件的最后修改时间。与If-Modified-Since一起使用。</td></tr><tr><td>Cache-Control</td><td>响应输出到客户端后，服务端通过该报文头属告诉客户端如何控制响应内容的缓存。常见的取值有常见的取值有private、public、no-cache、max-age，no-store，默认为private。缓存时间为31536000秒（365天）</td></tr></tbody></table></div><p>更多请求头属性可以参考这篇文章：<a href="http://tools.jb51.net/table/http_header">HTTP响应头和请求头信息对照表</a></p><h2 id="响应体"><a href="#响应体" class="headerlink" title="响应体"></a>响应体</h2><p>响应报文体，服务器发送给浏览器的正文，即我们真正要的“干货” ；</p><p>响应体，响应体是服务器回写给客户端的页面正文，浏览器将正文加载到内存，然后解析渲染，显示页面内容。</p><h1 id="HTTP协议扩展"><a href="#HTTP协议扩展" class="headerlink" title="HTTP协议扩展"></a>HTTP协议扩展</h1><blockquote><p><strong>如果传输的文件过大怎么办</strong></p></blockquote><p>服务器上返回的资源文件比较大，比如有些 js 文件大小可能就有几兆。文件过大就会影响传 输的效率，同时也会带来带宽的消耗。怎么办呢？</p><ol><li>常见的手段是，对文件进行<strong>压缩</strong>，减少文件大小。那压缩和解压缩的流程怎么实现呢？ 首先服务端需要能支持文件的压缩功能，其次浏览器能够针对被压缩的文件进行解压缩。浏览器可以指定 Accept-Encoding 来高速服务器我当前支持的编码类型 Accept-Encoding:gzip,deflate 那服务端会根据支持的编码类型，选择合适的类型进行压缩。常见的编码方式有：gzip/deflate</li><li><strong>分割</strong>传输 在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面。这种把实体主体分块的功能称为分块传输编码（Chunked Transfer Coding）。</li></ol><blockquote><p><strong>每次请求都要建立连接吗？</strong></p></blockquote><p>在最早的 HTTP 协议中，每进行一次 HTTP 通信，就需要做一次 TCP 的连接。而一次连接需要进行 3 次握手，这种通信方式会增加通信量的开销。</p><p><img src="HTTP一次通信.png" alt="HTTP一次通信"></p><p>所以在 <strong>HTTP/1.1 中改用了持久连接</strong>，就是在一次连接建立之后，只要客户端或者服务端没有 明确提出断开连接，那么这个 tcp 连接会一直保持连接状态 持久连接的一个最大的好处是：大大减少了连接的建立以及关闭时延。 HTTP1.1 中有一个 Transport 段。会携带一个 <strong>Connection:Keep-Alive</strong>，表示希望将此条连接 作为持久连接。</p><p>HTTP/1.1 持久连接在默认情况下是激活的，除非特别指明，否则 HTTP/1.1 假定所有的连接都 是持久的，要在事务处理结束之后将连接关闭，HTTP/1.1 应用程序必须向报文中显示地添加 一个 Connection：close 首部。</p><p>HTTP1.1 客户端加载在收到响应后，除非响应中包含了 Connection：close 首部，不然 HTTP/1.1 连接就仍然维持在打开状态。但是，客户端和服务器仍然可以随时关闭空闲的连接。不发送 Connection：close 并不意味这服务器承诺永远将连接保持在打开状态。</p><p><strong>管道化连接</strong>：http/1.1 允许在持久连接上使用请求管道。以前发送请求后需等待并收到响应， 才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。这样就 能够做到同时并行发送多个请求，而不需要一个接一个地等待响应了。</p><p><img src="管道化连接.png" alt="管道化连接"></p><blockquote><p><strong>HTTP协议如何解决无状态问题</strong></p></blockquote><p>HTTP 协议是无状态的，什么是无状态呢？就是说 HTTP 协议本身不会对请求和响应之间的 通信状态做保存。 但是现在的应用都是有状态的，如果是无状态，那这些应用基本没人用，你想想，访问一个电商网站，先登录，然后去选购商品，当点击一个商品加入购物车以后又提示你登录。这种用户体验根本不会有人去使用。那我们是如何实现带状态的协议呢？</p><ol><li><strong>客户端支持的 cookie</strong></li></ol><p>HTTP 协议中引入了 Cookie 技术，用来解决HTTP协议无状态的问题。通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态；Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。</p><ol><li><strong>服务端支持的 session</strong></li></ol><p>服务端是通过什么方式来保存状态的呢？ 在基于 tomcat 这类的 jsp/servlet 容器中，会提供 session 这样的机制来保存服务端的对象状态，服务器使用一种类似于散列表的结构来保存信息，当程序需要为某个客户端的请求创建一个 session 的时候，服务器首先检查这个客户端 的请求是否包含了一个 session 标识- session id； 如果已包含一个 session id 则说明以前已经为客户端创建过 session，服务器就按照 session id 把这个 session 检索出来使用（如果检索不到，会新建一个）； 如果客户端请求不包含 sessionid，则为此客户端创建一个 session 并且生成一个与此 session 相关联的 session id， session id 的值是一个既不会重复，又不容易被找到规律的仿造字符 串，这个 session id 将会返回给客户端保存</p><p><img src="Session实现原理.png" alt="Session实现原理"></p><h1 id="更多…"><a href="#更多…" class="headerlink" title="更多…"></a>更多…</h1><ul><li>[ ] HTTP1.0/HTTP1.1/HTTP2.0的异同</li><li>[ ] HTTP与HTTPS的不同；HTTPS的原理</li><li>[ ] HTTP长连接与短连接</li><li>[ ] GET/POST区别详解</li><li>[ ] Cookie、Session详解</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://blog.csdn.net/weixin_38087538/article/details/82838762">Http协议详解(深入理解)</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> HTTP协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> HTTP协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从堆排序到优先级队列</title>
      <link href="/2021/12/29/%E4%BB%8E%E5%A0%86%E6%8E%92%E5%BA%8F%E5%88%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/"/>
      <url>/2021/12/29/%E4%BB%8E%E5%A0%86%E6%8E%92%E5%BA%8F%E5%88%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文包含以下几部分内容</p><ul><li>[x] 二叉堆</li><li>[x] 堆排序</li><li>[x] 二叉堆应用：优先级队列</li><li>[x] Java PriorityQueue</li></ul><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h2><p>二叉堆是堆排序实现的底层逻辑结构。二叉堆是一种特殊的二叉树（完全二叉树），一般存储在数组中。</p><p>对于链表二叉树，一般是操作节点指针，而对于二叉堆，我们使用数组索引作为指针。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父节点的索引</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">parent</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> root / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 左孩子的索引</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> root * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 右孩子的索引</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">right</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> root * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是二叉堆物理存储结构示意图，注意这里索引0空着不用。</p><p><img src="1.png" alt="二叉堆示意图"></p><p>二叉堆设计的巧妙之处就在于，对于一个节点，只需要通过简单的运算就可以得到其父、左右孩子节点。</p><p>二叉堆分为大顶堆和小顶堆。大顶堆的性质是<strong>每个节点都大于等于他的两个子节点</strong>，小顶堆的性质相反。</p><p>本文以大顶堆为例。此外，为了更加直观，下面会画的图都是二叉树结构。由于大顶堆的性质，堆顶元素arr[1]一定是所有元素中最大的元素。</p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆排序就是利用堆这种数据结构设计的一种排序算法。</p><blockquote><p><strong>堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了</strong></p></blockquote><p>堆排序是一种<strong>选择排序，</strong>它的最坏，最好，平均时间复杂度均为<strong>O(nlogn)</strong>，它是<a href="https://baike.baidu.com/item/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%A8%B3%E5%AE%9A%E6%80%A7/9763250"><strong>不稳定排序</strong></a>。</p><p>下面通过一个例子来了解堆排序的过程。</p><p>序列：4，6，8，5，9。</p><p><strong>步骤一</strong>： 构造初始堆。</p><p><img src="2.png" alt="初始堆"></p><p><strong>步骤二</strong>：由<strong>下向上，由右向左</strong>不断调整，使其满足大顶堆的要求。</p><p><img src="3.png" alt="构造大顶堆的过程示意"></p><ol><li>先看【6，5，9】，9为这棵树的最大值节点，因此将9和根节点6互换；</li><li>再看【4，9，8】，9为这棵树的最大值节点，因此将9和根节点4互换；</li><li>由于刚才的交换，【4，5，6】不再满足大顶堆的性质，6为这棵树的最大值节点，因此将4和根节点6互换。</li><li>此时整棵树都满足了大顶堆的性质。</li></ol><p><strong>步骤三</strong>：将堆顶元素与末尾元素进行交换，使末尾元素最大。弹出末尾最大元素。重复<strong>步骤二</strong>使其满足大顶堆。如此反复进行交换、重建、交换……直到堆空，元素弹出堆的顺序即为排序后的顺序。</p><p><img src="4.png" alt="步骤三示意"></p><p>总结堆排序算法步骤：</p><ol><li>将无需序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆；</li><li>由下向上，由右向左不断调整，使初始堆满足大顶堆的要求。</li><li>将堆顶元素与末尾元素进行交换，使末尾元素最大。弹出末尾最大元素。重复<strong>步骤二</strong>使其满足大顶堆。如此反复进行交换、重建、交换……直到堆空。元素弹出堆的顺序即为排序后的顺序。</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>//TODO</p><h2 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h2><p>优先级队列的性质是，出队元素总是优先级最高的元素。优先级队列的底层就是使用二叉堆和堆排序实现了这一性质。当元素插入/删除时，优先级队列的元素会自动排序。</p><h3 id="代码框架"><a href="#代码框架" class="headerlink" title="代码框架"></a>代码框架</h3><p>优先级队列有两个主要 API，分别是<code>insert</code>插入一个元素和<code>delMax</code>删除最大元素。</p><p>下面给出优先级队列的代码框架。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxPQ</span> &lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt;&gt; </span>&#123; <span class="comment">//Key是可比较大小的泛型</span></span><br><span class="line">    <span class="comment">//二叉堆，大顶堆</span></span><br><span class="line">    <span class="keyword">private</span> Key[] pq;</span><br><span class="line">    <span class="comment">//当前priority queue中元素个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MaxPQ</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//索引0不用，所以多一个分配空间</span></span><br><span class="line">        pq = (Key[]) <span class="keyword">new</span> Comparable[cap + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回当前队列中的最大元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">max</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pq[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//插入元素e</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span> <span class="params">(Key e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除并返回当前队列中的最大元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">delMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//上浮第k个元素，以维护最大堆的性质</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="comment">//TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//下沉第k个元素，以维护最大堆的性质</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="comment">//TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交换数组的两个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        Key tmp = pq[i];</span><br><span class="line">        pq[i] = pq[j];</span><br><span class="line">        pq[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//pq[i]是否比pq[j]小</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pq[i].compareTo(pq[j]) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现swim和sink"><a href="#实现swim和sink" class="headerlink" title="实现swim和sink"></a>实现swim和sink</h3><p>元素的swim（上浮）和sink（下沉）都是为了维护堆的性质。</p><p>我们要讲的是最大堆，每个节点都比它的两个子节点大，但是在插入元素和删除元素时，难免破坏堆的性质，这就需要通过这两个操作来恢复堆的性质了。</p><p>对于最大堆，会破坏堆性质的有有两种情况：</p><ol><li>如果某个节点 A 比它的子节点（中的一个）小，那么 A 就不配做父节点，应该下去，下面那个更大的节点上来做父节点，这就是对 A 进行<strong>下沉</strong>。</li><li>如果某个节点 A 比它的父节点大，那么 A 不应该做子节点，应该把父节点换下来，自己去做父节点，这就是对 A 的<strong>上浮</strong>。</li></ol><p>swim代码实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果浮到了堆顶，就不需要再上浮了</span></span><br><span class="line">    <span class="keyword">while</span>(k &gt; <span class="number">1</span> &amp;&amp; less(parent(k), k)) &#123;</span><br><span class="line">        <span class="comment">//如果第k个元素比上层大，就将k换上去</span></span><br><span class="line">        exch(parent(k), k);</span><br><span class="line">        k = parent(k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sink代码实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下沉第k个元素，以维护最大堆性质</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果沉到堆底，就沉不下去了</span></span><br><span class="line">    <span class="keyword">while</span>(left(k) &lt;= N) &#123;</span><br><span class="line">        <span class="comment">//假设左边节点比较大</span></span><br><span class="line">        <span class="keyword">int</span> older = left(k);</span><br><span class="line">        <span class="comment">//如果右边节点存在，则左右节点比一下大小</span></span><br><span class="line">        <span class="keyword">if</span>(right(k) &lt;= N &amp;&amp; less(older, right(k))) &#123;</span><br><span class="line">            older = right(k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//节点k比左右孩子都大，就不必下沉了</span></span><br><span class="line">        <span class="keyword">if</span>(less(older, k))  <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//否则，不符合大顶堆性质，下沉k节点</span></span><br><span class="line">        exch(k, older);</span><br><span class="line">        k = older;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现delMax和insert"><a href="#实现delMax和insert" class="headerlink" title="实现delMax和insert"></a>实现delMax和insert</h3><p>delMax和insert就是建立在swim和sink基础上。</p><p><code>insert</code>方法先把要插入的元素添加到堆底的最后，然后让其上浮到正确位置。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Key e)</span> </span>&#123;</span><br><span class="line">    N++;</span><br><span class="line">    <span class="comment">// 先把新元素加到最后</span></span><br><span class="line">    pq[N] = e;</span><br><span class="line">    <span class="comment">// 然后让它上浮到正确的位置</span></span><br><span class="line">    swim(N);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>delMax</code>方法先把堆顶元素 A 和堆底最后的元素 B 对调，然后删除 A，最后让 B 下沉到正确位置。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Key <span class="title">delMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 最大堆的堆顶就是最大元素</span></span><br><span class="line">    Key max = pq[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 把这个最大元素换到最后，删除之</span></span><br><span class="line">    exch(<span class="number">1</span>, N);</span><br><span class="line">    pq[N] = <span class="keyword">null</span>;</span><br><span class="line">    N--;</span><br><span class="line">    <span class="comment">// 让 pq[1] 下沉到正确位置</span></span><br><span class="line">    sink(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，一个优先级队列就实现了，插入和删除元素的时间复杂度为 <em>O(logK)</em>，K为当前二叉堆（优先级队列）中的元素总数。因为我们时间复杂度主要花费在<code>sink</code>或者<code>swim</code>上，而不管上浮还是下沉，最多也就树（堆）的高度，也就是 log 级别。</p><h2 id="Java-PriorityQueue"><a href="#Java-PriorityQueue" class="headerlink" title="Java PriorityQueue"></a>Java PriorityQueue</h2><p>Java PriorityQueue的介绍请看我的另一篇博客<a href="https://gmet233.gitee.io/2021/12/19/PriorityQueue-%E6%A6%82%E8%BF%B0/#%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8">PriorityQueue 概述</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://mp.weixin.qq.com/s/o7tdyLiYm668dpUWd-x7Lg">labuladong: 图文详解二叉堆，实现优先级队列</a></li><li>《算法（第4版）》</li><li><a href="https://www.cnblogs.com/chengxiao/p/6129630.html">图解排序算法(三)之堆排序</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 排序 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>统计文件夹下各种后缀名的文件个数</title>
      <link href="/2021/12/29/%E7%BB%9F%E8%AE%A1%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E5%90%84%E7%A7%8D%E5%90%8E%E7%BC%80%E5%90%8D%E7%9A%84%E6%96%87%E4%BB%B6%E4%B8%AA%E6%95%B0/"/>
      <url>/2021/12/29/%E7%BB%9F%E8%AE%A1%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E5%90%84%E7%A7%8D%E5%90%8E%E7%BC%80%E5%90%8D%E7%9A%84%E6%96%87%E4%BB%B6%E4%B8%AA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>test文件夹组织结构如下：</p><blockquote><p>test/<br>   -1.jpg<br>   -dd/<br>       -2.jpg<br>       -e/<br>           -3.jpg<br>           -4.jpg<br>           -5.txt<br>   -ll.dir/<br>       -5.rar</p></blockquote><p>现在想统计test目录下不同<strong>文件</strong>后缀名的个数。</p><p>下面通过两种方案解决。</p><h1 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h1><p>shell一行命令搞定，<strong>但对于带点号的目录，这种方法会出Bug</strong>。应该可以对此改进，但后面找到了Python的方式。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find -type f -name &quot;*.*&quot; | cut -f3 -d&#x27;.&#x27; | sort | uniq -c -i  (递归查找当前文件夹下的所有子文件夹)</span><br></pre></td></tr></table></figure><p>下面对该命令进行分解解释。</p><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>find命令参数说明</p><blockquote><p>  -type c<br>        File is of type c:<br>            d      directory<br>            f      regular file<br>  -name pattern<br>        Base of file name (the path with the leading directories  removed)  matches  shell  pattern  pattern.  </p></blockquote><ul><li>只查找文件，而不需要关心文件夹，所以使用-type f参数(注意，在linux上会有链接文件、块文件等其它格式的文件类型，而且Window系统上的快捷方式其格式也是一般文件)</li><li>只过滤出有后缀名的文件，所以使用-name “<em>.</em>“参数(注意，使用-name “<em>.</em>“参数也会过滤出.name和name.这样的文件，因此要严格过滤出<em>.</em>且”.”前后都有字符的文件，可以使用-regex “./.+..+”参数，具体作用请百度“find正则表达式”)</li></ul><h2 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h2><p>cut命令参数说明</p><blockquote><p>   -f, —fields=LIST<br>          select  only  these fields;  also print any line that contains no delimiter character, unless the -s option is specified<br>   -d, —delimiter=DELIM<br>          use DELIM instead of TAB for field delimiter</p></blockquote><ul><li>-f3表示截取第三部分</li></ul><h2 id="sort和uniq"><a href="#sort和uniq" class="headerlink" title="sort和uniq"></a>sort和uniq</h2><p>sort命令很好理解，就是对前面的输出进行一下排序，以便与uniq命令操作。</p><p>uniq命令说明</p><blockquote><p>uniq - report or omit repeated lines</p><p>-c, —count<br>   prefix lines by the number of occurrences<br>-i, —ignore-case<br>   ignore differences in case when comparing</p></blockquote><ul><li>uniq的作用就是找到<strong>连续重复的行</strong></li><li>-c 统计次数</li><li>-i 忽略大小写</li></ul><h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">&quot;count suffix from dir&quot;</span>)</span><br><span class="line"><span class="comment"># 设置脚本传参，传入需要统计后缀名的文件夹</span></span><br><span class="line">parser.add_argument(<span class="string">&#x27;-d&#x27;</span>, <span class="string">&#x27;--directory&#x27;</span>, required=<span class="literal">True</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, <span class="built_in">help</span>=<span class="string">&#x27;need a full path&#x27;</span>)</span><br><span class="line">args = parser.parse_args()</span><br><span class="line">directory = args.directory</span><br><span class="line"><span class="comment"># 结果dict</span></span><br><span class="line">res = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;suffix : count&quot;</span>)</span><br><span class="line"><span class="comment"># print(directory)</span></span><br><span class="line"><span class="comment"># 如果目录不存在则退出</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(directory):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;dir does not exist&quot;</span>)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 如果传递的不是目录则退出</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.isdir(directory):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;need a dir not a file&quot;</span>)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">os.walk得到的三元组列表：分别指出了目录，目录下目录列表，目录下的文件列表</span></span><br><span class="line"><span class="string">(&#x27;.&#x27;, [&#x27;dd&#x27;, &#x27;ll.dir&#x27;], [&#x27;1.jpg&#x27;])</span></span><br><span class="line"><span class="string">(&#x27;./dd&#x27;, [&#x27;e&#x27;], [&#x27;2.jpg&#x27;])</span></span><br><span class="line"><span class="string">(&#x27;./dd/e&#x27;, [], [&#x27;3.jpg&#x27;, &#x27;4.jpg&#x27;, &#x27;5.txt&#x27;])</span></span><br><span class="line"><span class="string">(&#x27;./ll.dir&#x27;, [], [&#x27;5.rar&#x27;])</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> path, dirs, files <span class="keyword">in</span> os.walk(directory):</span><br><span class="line">    <span class="comment"># print(str(files))</span></span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">        file = file.lower()  <span class="comment"># 都统一转换成小写</span></span><br><span class="line">        <span class="comment"># 如果没有后缀名则不纳入统计范围</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> re.match(<span class="string">r&#x27;[\s\S]*\.[\s\S]*&#x27;</span>, file):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="comment"># 得到后缀字符串</span></span><br><span class="line">        suffix = file.split(<span class="string">&quot;.&quot;</span>)[-<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># 从字典中取出后缀对应的count，如果没有则默认为0</span></span><br><span class="line">        count = res.setdefault(suffix, <span class="number">0</span>)</span><br><span class="line">        <span class="comment"># count ++</span></span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 将更新的count放回字典</span></span><br><span class="line">        res[suffix] = count</span><br><span class="line"></span><br><span class="line"><span class="comment"># print</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> res.keys():</span><br><span class="line">    <span class="built_in">print</span>(key + <span class="string">&quot; : &quot;</span> + <span class="built_in">str</span>(res[key]))</span><br></pre></td></tr></table></figure><p>将上述代码保存为<code>.py</code>文件，然后命令行执行<code>python xxx.py -d &lt;目录&gt;</code></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文涉及到的知识点：</p><ul><li>Shell<ul><li>find命令，查询目录/文件</li><li>cut命令，分割字符串</li><li>sort命令，排序</li><li>uniq命令，找到连续重复的行</li></ul></li><li>Python<ul><li>dict 基本操作</li><li>argparse库，脚本传参</li><li>os库，读目录/文件</li><li>re库，正则匹配</li></ul></li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://blog.csdn.net/nfer_zhuang/article/details/42582425">一句话脚本系列之统计文件夹下各种后缀名的文件个数</a></li><li><a href="https://www.runoob.com/python/os-walk.html">Python os.walk() 方法</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Scripts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python dict 笔记</title>
      <link href="/2021/12/28/Python-dict-%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/12/28/Python-dict-%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>字典（dict）是Python内置提供的一种常用数据结构，他用于存放具有映射（mapping）关系的数据。</p><p>可变对象。</p><h1 id="dict-常用操作"><a href="#dict-常用操作" class="headerlink" title="dict 常用操作"></a>dict 常用操作</h1><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>两种方式，使用dict()函数创建字典；使用花括号语法创建字典。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;&#125;</span><br><span class="line">dict2 = <span class="built_in">dict</span>()  <span class="comment"># 创建了一个空字典</span></span><br></pre></td></tr></table></figure><blockquote><p>dict的key必须为不可变类型，所以字符串、元组等类型可以作为dict的key，但像列表这种可变类型，不能作为dict的key</p></blockquote><p>在使用 dict() 函数创建字典时，可以传入多个列表或元组参数作为 key-value 对，每个列表或元组将被当成一个 key-value 对，因此这些列表或元组都只能包含两个元素。例如如下代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>person = [(<span class="string">&#x27;age&#x27;</span>, <span class="number">18</span>), (<span class="string">&#x27;sex&#x27;</span>, <span class="string">&#x27;male&#x27;</span>), (<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;gyj&#x27;</span>)]  <span class="comment"># 这里换成person = [[&#x27;age&#x27;, 18], [&#x27;sex&#x27;, &#x27;male&#x27;], [&#x27;name&#x27;, &#x27;gyj&#x27;]]也是可以的</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict3 = <span class="built_in">dict</span>(person)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict3</span><br><span class="line">&#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;male&#x27;</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;gyj&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="通过key访问value"><a href="#通过key访问value" class="headerlink" title="通过key访问value"></a>通过key访问value</h2><p>三种方式：</p><ul><li>通过方括号语法访问</li><li>使用get方法</li><li>使用setdefault()方法</li></ul><p>这三者不同的地方在于：</p><ul><li>使用方括号语法访问并不存在的key时，字典会引发KeyError错误</li><li>但如果使用get()方法访问不存在的key，该方法会简单地返回None，不会导致错误</li><li>使用setdefault()，当程序要获取的 key 在字典中不存在时，该方法会先为这个不存在的 key 设置一个默认的 value，然后再返回该 key 对应的 value。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">scores = &#123;<span class="string">&#x27;语文&#x27;</span>: <span class="number">89</span>&#125;</span><br><span class="line"><span class="comment"># 通过key访问value</span></span><br><span class="line">scores.get(<span class="string">&#x27;语文&#x27;</span>) <span class="comment"># 89</span></span><br><span class="line">scores.get(<span class="string">&#x27;数学&#x27;</span>) <span class="comment"># None</span></span><br><span class="line">scores[<span class="string">&#x27;数学&#x27;</span>] <span class="comment"># KeyError</span></span><br><span class="line">scores.setdefault(<span class="string">&#x27;数学&#x27;</span>, <span class="number">0</span>)  <span class="comment"># 0</span></span><br><span class="line">scores.setdefault(<span class="string">&#x27;语文&#x27;</span>, <span class="number">0</span>)  <span class="comment"># 89</span></span><br></pre></td></tr></table></figure><h2 id="通过key添加k-v对"><a href="#通过key添加k-v对" class="headerlink" title="通过key添加k-v对"></a>通过key添加k-v对</h2><p>例如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">scores[<span class="string">&#x27;数学&#x27;</span>] = <span class="number">93</span></span><br></pre></td></tr></table></figure><h2 id="通过key删除k-v对"><a href="#通过key删除k-v对" class="headerlink" title="通过key删除k-v对"></a>通过key删除k-v对</h2><p>使用del语句删除k-v对</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">del</span> scores[<span class="string">&#x27;语文&#x27;</span>]</span><br></pre></td></tr></table></figure><h2 id="通过key修改k-v对"><a href="#通过key修改k-v对" class="headerlink" title="通过key修改k-v对"></a>通过key修改k-v对</h2><p>两种方式：对存在的key-value对赋值，改变key-value对；使用update方法</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">scores[<span class="string">&#x27;数学&#x27;</span>] = <span class="number">95</span></span><br><span class="line">scores.update(&#123;<span class="string">&#x27;数学&#x27;</span>:<span class="number">100</span>&#125;)  <span class="comment"># 如果update的key不存在，那么会增加一个新的k-v对</span></span><br></pre></td></tr></table></figure><h2 id="判断指定key是否存在"><a href="#判断指定key是否存在" class="headerlink" title="判断指定key是否存在"></a>判断指定key是否存在</h2><p>使用in或not in 运算符判断key是否存在</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;数学&#x27;</span> <span class="keyword">in</span> scores  <span class="comment"># True</span></span><br><span class="line"><span class="string">&#x27;数学&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> scores    <span class="comment"># False</span></span><br></pre></td></tr></table></figure><h2 id="清空字典中所有的k-v对"><a href="#清空字典中所有的k-v对" class="headerlink" title="清空字典中所有的k-v对"></a>清空字典中所有的k-v对</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">scores.clear()</span><br></pre></td></tr></table></figure><h2 id="获取dict所有k-v对，所有key，所有value"><a href="#获取dict所有k-v对，所有key，所有value" class="headerlink" title="获取dict所有k-v对，所有key，所有value"></a>获取dict所有k-v对，所有key，所有value</h2><p>items()：获取字典中的所有 key-value 对</p><p>keys()：获取字典中的所有 key</p><p>values()：获取字典中的所有 value</p><p>这三个方法依次返回 dict_items、dict_keys 和 dict_values 对象，Python 不希望用户直接操作这几个方法，但可通过 list() 函数把它们转换成列表。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>scores = &#123;<span class="string">&#x27;数学&#x27;</span>: <span class="number">96</span>, <span class="string">&#x27;英语&#x27;</span>: <span class="number">88</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>scores.items()</span><br><span class="line">dict_items([(<span class="string">&#x27;数学&#x27;</span>, <span class="number">96</span>), (<span class="string">&#x27;英语&#x27;</span>, <span class="number">88</span>)])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(scores.items())</span><br><span class="line">[(<span class="string">&#x27;数学&#x27;</span>, <span class="number">96</span>), (<span class="string">&#x27;英语&#x27;</span>, <span class="number">88</span>)]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="弹出指定key的k-v对"><a href="#弹出指定key的k-v对" class="headerlink" title="弹出指定key的k-v对"></a>弹出指定key的k-v对</h2><p>pop() 方法用于获取指定 key 对应的 value，并删除这个 key-value 对。例如</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">math_score = scores.pop(<span class="string">&#x27;数学&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="随机弹出k-v对"><a href="#随机弹出k-v对" class="headerlink" title="随机弹出k-v对"></a>随机弹出k-v对</h2><p>popitem() 方法用于随机弹出字典中的一个 key-value 对。</p><blockquote><p>此处的随机其实是假的，正如列表的 pop() 方法总是弹出列表中最后一个元素，实际上字典的 popitem() 其实也是弹出字典中最后一个 key-value 对。由于字典存储 key-value 对的顺序是不可知的，因此开发者感觉字典的 popitem() 方法是“随机”弹出的，但实际上字典的 popitem() 方法总是弹出底层存储的最后一个 key-value 对。</p></blockquote><h2 id="根据给定的多个key创建字典"><a href="#根据给定的多个key创建字典" class="headerlink" title="根据给定的多个key创建字典"></a>根据给定的多个key创建字典</h2><p>fromkeys() 方法使用给定的多个 key 创建字典，参数可以是list也可以是tuple，这些 key 对应的 value 默认都是 None；也可以额外传入一个参数作为默认的 value。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用列表创建包含2个key的字典</span></span><br><span class="line">a_dict = <span class="built_in">dict</span>.fromkeys([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(a_dict) <span class="comment"># &#123;&#x27;a&#x27;: None, &#x27;b&#x27;: None&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用元组创建包含2个key的字典，指定默认的value</span></span><br><span class="line">c_dict = <span class="built_in">dict</span>.fromkeys((<span class="number">13</span>, <span class="number">17</span>), <span class="string">&#x27;good&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(c_dict) <span class="comment"># &#123;13: &#x27;good&#x27;, 17: &#x27;good&#x27;&#125;</span></span><br></pre></td></tr></table></figure><h2 id="使用字典格式化字符串"><a href="#使用字典格式化字符串" class="headerlink" title="使用字典格式化字符串"></a>使用字典格式化字符串</h2><p>举例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 字符串模板中使用key</span></span><br><span class="line">temp = <span class="string">&#x27;教程是:%(name)s, 价格是:%(price)010.2f, 出版社是:%(publish)s&#x27;</span></span><br><span class="line">book = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;Python基础教程&#x27;</span>, <span class="string">&#x27;price&#x27;</span>: <span class="number">99</span>, <span class="string">&#x27;publish&#x27;</span>: <span class="string">&#x27;C语言中文网&#x27;</span>&#125;</span><br><span class="line"><span class="comment"># 使用字典为字符串模板中的key传入值</span></span><br><span class="line"><span class="built_in">print</span>(temp % book)</span><br><span class="line">book = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;C语言小白变怪兽&#x27;</span>, <span class="string">&#x27;price&#x27;</span>:<span class="number">159</span>, <span class="string">&#x27;publish&#x27;</span>: <span class="string">&#x27;C语言中文网&#x27;</span>&#125;</span><br><span class="line"><span class="comment"># 使用字典为字符串模板中的key传入值</span></span><br><span class="line"><span class="built_in">print</span>(temp % book)</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="http://c.biancheng.net/view/2212.html">Python字典及基本操作（超级详细）</a></li><li>《Python 学习手册（第四版）》</li></ol>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LRU: 缓存淘汰算法</title>
      <link href="/2021/12/26/LRU-%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95/"/>
      <url>/2021/12/26/LRU-%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在使用缓存时，由于缓存容量有限，当缓存容量到达上限，就需要删除部分数据挪出空间。但是缓存数据不能随机删除，一般情况下需要根据某种算法删除缓存数据。</p><p>常用的淘汰算法有LRU, LFU, FIFO，本篇介绍LRU算法并重点讲述LRU的实现。完整代码也是<a href="https://leetcode-cn.com/problems/lru-cache/">LeetCode 146. LRU缓存</a>的答案。</p><h1 id="LRU-简介"><a href="#LRU-简介" class="headerlink" title="LRU 简介"></a>LRU 简介</h1><p>LRU是Least recently used的缩写，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。当缓存容量满的时候，优先淘汰最近最少被使用的数据。</p><p>根据以上策略，给出使用LRU淘汰算法时的示例。</p><p><img src="LRU淘汰算法示例.jpg" alt="LRU淘汰算法示例"></p><p>通过上图可以看到LRU算法的具体步骤是：</p><ol><li>新数据直接插入到列表头部</li><li>缓存数据被命中，将数据移动到链表头部</li><li>缓存已满，移除列表尾部数据。</li></ol><h1 id="LRU-算法实现"><a href="#LRU-算法实现" class="headerlink" title="LRU 算法实现"></a>LRU 算法实现</h1><p>上面看到LRU算法需要添加头节点，删除尾节点。而链表添加/删除节点的时间复杂度为O(1)，但这里不能使用普通的单向链表，原因在于：</p><ul><li>虽然单向链表添加/删除/移动元素比较方便，但是再查询元素时的时间复杂度为O(N)</li><li>移动中间节点到头节点需要知道前一个节点和后一个节点的信息，单向链表就不得不再次遍历获取信息。</li></ul><p>针对以上问题的解决方案是：</p><ul><li>使用散列表存储节点，获取节点的复杂度将为O(1)，</li><li>使用双向链表用来获得前驱节点的信息。</li></ul><p><img src="LRU数据结构.png" alt="LRU数据结构"></p><p>在这里，增加了两个【哨兵】节点，不用来存储任何数据，目的是再增加、删除结点的时候不用考虑节点不存在的情况。简化编程难度。</p><p>在算法实现的过程中，我发现LeetCode 146是类似的题目，故把该题直接拿来使用。</p><p>该题的算法签名是</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(key);</span></span><br><span class="line"><span class="comment"> * obj.put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>通过调用put\get方法实现存取缓存的目的。下面是对代码的逐步分析。</p><h2 id="双向链表数据结构"><a href="#双向链表数据结构" class="headerlink" title="双向链表数据结构"></a>双向链表数据结构</h2><p>这里使用一个内部类作为双向链表的数据结构。比较简单，直接给出代码。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">//定义一个内部类，作为缓存列表</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span></span>&#123;</span><br><span class="line">       <span class="keyword">public</span> Entry pre; <span class="comment">//指向前驱的指针</span></span><br><span class="line">       <span class="keyword">public</span> Entry next; <span class="comment">//指向后继的指针</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">int</span> key; <span class="comment">//缓存的key</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">int</span> value; <span class="comment">//缓存的value</span></span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">Entry</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.key = key;</span><br><span class="line">           <span class="keyword">this</span>.value = value;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">Entry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="定义成员变量和构造函数"><a href="#定义成员变量和构造函数" class="headerlink" title="定义成员变量和构造函数"></a>定义成员变量和构造函数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Entry head, tail; <span class="comment">//头尾两个哨兵节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> capacity; <span class="comment">// 容量</span></span><br><span class="line"><span class="keyword">int</span> size; <span class="comment">//当前缓存大小</span></span><br><span class="line">Map&lt;Integer, Entry&gt; cache; <span class="comment">//缓存散列表</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    <span class="comment">//初始化操作</span></span><br><span class="line">    initLinkedList();</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    cache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化操作函数<code>initLinkedList()</code>的实现是将head和tail通过指针连接起来。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       head = <span class="keyword">new</span> Entry();</span><br><span class="line">       tail = <span class="keyword">new</span> Entry();</span><br><span class="line"></span><br><span class="line">       head.next = tail;</span><br><span class="line">       tail.pre = head;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="put操作"><a href="#put操作" class="headerlink" title="put操作"></a>put操作</h2><p>put操作可以分三种情况：</p><ol><li>如果key已经存在与缓存中，则将key对应的节点移动到链表头部，并重设value</li><li>如果key在缓存中不存在，那么检查缓存是否已满<ol><li>如果未满，就直接将新节点加入到链表头部</li><li>如果已满，就先删除尾节点，再将新节点加入到链表头部</li></ol></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    Entry node = cache.get(key);</span><br><span class="line">    <span class="comment">//如果key在缓存中已经存在，则移动到头部</span></span><br><span class="line">    <span class="keyword">if</span>(node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.value = value;</span><br><span class="line">        move2Head(node);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//容量已满先删除尾节点</span></span><br><span class="line">    <span class="keyword">if</span>(size == capacity) &#123;</span><br><span class="line">        Entry lastNode = tail.pre;</span><br><span class="line">        deleteNode(lastNode);</span><br><span class="line">        cache.remove(lastNode.key);</span><br><span class="line">        size --;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//add new Node</span></span><br><span class="line">    Entry newNode = <span class="keyword">new</span> Entry();</span><br><span class="line">    newNode.key = key;</span><br><span class="line">    newNode.value = value;</span><br><span class="line">    addNode(newNode);</span><br><span class="line">    cache.put(key, newNode);</span><br><span class="line">    size ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于<code>move2Head</code>操作，无非是先删除原来的节点关系<code>deleteNode</code>，再添加到队列头部<code>addNode</code></p><p>而<code>deleteNode</code>和<code>addNode</code>是比较基础的双向链表操作，这里就不再做过多解释。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addNode</span><span class="params">(Entry node)</span> </span>&#123;</span><br><span class="line">    head.next.pre = node;</span><br><span class="line">    node.next = head.next;</span><br><span class="line"></span><br><span class="line">    node.pre = head;</span><br><span class="line">    head.next = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(Entry node)</span> </span>&#123;</span><br><span class="line">    node.pre.next = node.next;</span><br><span class="line">    node.next.pre = node.pre;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">move2Head</span><span class="params">(Entry node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//删除原来的节点关系</span></span><br><span class="line">    deleteNode(node);</span><br><span class="line">    addNode(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="get-操作"><a href="#get-操作" class="headerlink" title="get 操作"></a>get 操作</h2><p>当key不在缓存中，返回-1，当key存在于缓存时，就将该元素移动到链表头部，并返回对应的value。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">       Entry node = cache.get(key);</span><br><span class="line">       <span class="keyword">if</span>(node == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       move2Head(node);</span><br><span class="line">       <span class="keyword">return</span> node.value;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Entry head, tail;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity; <span class="comment">// 容量</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    Map&lt;Integer, Entry&gt; cache;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        <span class="comment">//初始化操作</span></span><br><span class="line">        initLinkedList();</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        cache = <span class="keyword">new</span> HashMap&lt;&gt;(capacity + <span class="number">2</span>); <span class="comment">//这里为什么要+2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        head = <span class="keyword">new</span> Entry();</span><br><span class="line">        tail = <span class="keyword">new</span> Entry();</span><br><span class="line"></span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.pre = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        Entry node = cache.get(key);</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        move2Head(node);</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将节点插入到头节点，如果容量已满，则会删除尾节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        Entry node = cache.get(key);</span><br><span class="line">        <span class="comment">//如果key在缓存中已经存在，则移动到头部</span></span><br><span class="line">        <span class="keyword">if</span>(node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.value = value;</span><br><span class="line">            move2Head(node);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//容量已满先删除尾节点</span></span><br><span class="line">        <span class="keyword">if</span>(size == capacity) &#123;</span><br><span class="line">            Entry lastNode = tail.pre;</span><br><span class="line">            deleteNode(lastNode);</span><br><span class="line">            cache.remove(lastNode.key);</span><br><span class="line">            size --;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//add new Node</span></span><br><span class="line">        Entry newNode = <span class="keyword">new</span> Entry();</span><br><span class="line">        newNode.key = key;</span><br><span class="line">        newNode.value = value;</span><br><span class="line">        addNode(newNode);</span><br><span class="line">        cache.put(key, newNode);</span><br><span class="line">        size ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addNode</span><span class="params">(Entry node)</span> </span>&#123;</span><br><span class="line">        head.next.pre = node;</span><br><span class="line">        node.next = head.next;</span><br><span class="line"></span><br><span class="line">        node.pre = head;</span><br><span class="line">        head.next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(Entry node)</span> </span>&#123;</span><br><span class="line">        node.pre.next = node.next;</span><br><span class="line">        node.next.pre = node.pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">move2Head</span><span class="params">(Entry node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//删除原来的节点关系</span></span><br><span class="line">        deleteNode(node);</span><br><span class="line">        addNode(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个内部类，作为缓存链表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> Entry pre; <span class="comment">//指向前驱的指针</span></span><br><span class="line">        <span class="keyword">public</span> Entry next; <span class="comment">//指向后继的指针</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> key; <span class="comment">//缓存的key</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value; <span class="comment">//缓存的value</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Entry</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Entry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://www.bilibili.com/video/BV1Va411677h">手写LRU算法 - IT老哥</a></li><li><a href="https://zhuanlan.zhihu.com/p/34133067">LRU原理和Redis实现——一个今日头条的面试题</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tmux 简介</title>
      <link href="/2021/12/26/Tmux-%E7%AE%80%E4%BB%8B/"/>
      <url>/2021/12/26/Tmux-%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是Tmux"><a href="#什么是Tmux" class="headerlink" title="什么是Tmux"></a>什么是Tmux</h1><p>打开一个终端窗口（terminal window，以下简称”窗口”），在里面输入命令。</p><p>用户与计算机的这种临时的交互，称为一次”会话”（session） 。</p><p>会话的一个重要特点是，窗口与其中启动的进程是<a href="https://www.ruanyifeng.com/blog/2016/02/linux-daemon.html">连在一起</a>的。打开窗口，会话开始；关闭窗口，会话结束。</p><p>一个典型的例子，打开一个远程窗口执行命令，这时关闭窗口，那么会话也就终止，里面的进程也随之终止。</p><p>为了解决这个问题，会话与窗口可以”解绑”：窗口关闭时，会话并不终止，而是继续运行，等到以后需要的时候，再让会话”绑定”其他窗口。</p><p><strong>Tmux 就是会话与窗口的”解绑”工具</strong>。</p><h1 id="使用Tmux"><a href="#使用Tmux" class="headerlink" title="使用Tmux"></a>使用Tmux</h1><h2 id="安装Tmux"><a href="#安装Tmux" class="headerlink" title="安装Tmux"></a>安装Tmux</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Ubuntu 或 Debian</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install tmux</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> CentOS 或 Fedora</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo yum install tmux</span></span><br></pre></td></tr></table></figure><h2 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h2><p>直接给出最常用的操作流程如下：</p><ul><li>新建会话<code>tmux new -s &lt;session_name&gt;</code>。（第一个启动的 Tmux 窗口，编号是0，第二个窗口的编号是1，以此类推。）</li><li>在 Tmux 窗口运行所需的程序。</li><li>按下快捷键<code>Ctrl+b d</code>将会话分离。</li><li>下次使用时，重新连接到会话<code>tmux a -t &lt;session_name&gt;</code>。</li></ul><h2 id="其他Tricks"><a href="#其他Tricks" class="headerlink" title="其他Tricks"></a>其他Tricks</h2><ul><li><code>Ctrl+b s</code>：列出所有会话。</li><li><code>tmux rename-session -t 0 &lt;new-name&gt;</code>：重命名会话。</li><li><code>tmux kill-session -t &lt;session-name&gt;</code>：杀死会话。</li><li><code>Ctrl+b [</code>：进入会话后，使用该快捷命令查看控制台历史消息，可通过键盘上的上下左右键来滚动历史输出信息。如果要退出查看模式，按下q即可。</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://www.ruanyifeng.com/blog/2019/10/tmux.html">Tmux 使用教程</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 开发工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>火车站台数量问题</title>
      <link href="/2021/12/25/%E7%81%AB%E8%BD%A6%E7%AB%99%E5%8F%B0%E6%95%B0%E9%87%8F%E9%97%AE%E9%A2%98/"/>
      <url>/2021/12/25/%E7%81%AB%E8%BD%A6%E7%AB%99%E5%8F%B0%E6%95%B0%E9%87%8F%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="题干"><a href="#题干" class="headerlink" title="题干"></a>题干</h1><p>假设已知某个火车站的所有过往列车的到达arrival和离开departure时间（同一天），如果要求所有列车都不等待直接进站，问至少需要多少个站台。无需考虑晚点等特殊情况。</p><p>例如，<br> Input：<br> 到达时间：  arr[]  = {9:00,  9:40, 9:50,  11:00, 15:00, 18:00}<br> 离开时间：  dep[]  = {9:10, 12:00, 11:20, 11:30, 19:00, 20:00}</p><p><em>注：方便起见，输入为int，例如：9:00的输入是900</em></p><p>Output：<br> 3  （最多有3辆列车同时进站（在11:00到11:20之间））</p><h1 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h1><p>暴力解法。逐个检查每个车辆的<strong>停发时间段</strong>，然后看有多少个时间段区间与其有重合，记录最多的重合区间数目，即为待求解的答案。易知，此方法的时间复杂度为O(n^2)。</p><p>下面给出代码，<em>代码只经过简单测试，如有误请通过邮箱联系我</em></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"><span class="keyword">from</span> traitlets <span class="keyword">import</span> Int</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxPlatform</span>(<span class="params">self, arr: <span class="type">List</span>[Int], dep: <span class="type">List</span>[Int]</span>) -&gt; Int:</span></span><br><span class="line">        n = <span class="built_in">len</span>(arr)</span><br><span class="line">        max_platform = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            now_platform = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> dep[i] &gt; arr[j]:</span><br><span class="line">                    now_platform += <span class="number">1</span></span><br><span class="line">                max_platform = <span class="built_in">max</span>(max_platform, now_platform)</span><br><span class="line">        <span class="keyword">return</span> max_platform</span><br></pre></td></tr></table></figure><h1 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h1><p>将所有的<strong>事件</strong> (到达或离开)按时间顺序排序，然后只记录当前还在车站（未离开的）列车。所有时间点中最多数量列车即待求解的答案。该解法的时间复杂度为O(n·logn)</p><p>例如上述出发到达时间排序得到下表：</p><div class="table-container"><table><thead><tr><th>时间</th><th>事件</th><th>站台数</th></tr></thead><tbody><tr><td>9:00</td><td>Arrival</td><td>1</td></tr><tr><td>9:10</td><td>Departure</td><td>0</td></tr><tr><td>9:40</td><td>Arrival</td><td>1</td></tr><tr><td>9:50</td><td>Arrival</td><td>2</td></tr><tr><td>11:00</td><td>Arrival</td><td><strong>3</strong></td></tr><tr><td>11:20</td><td>Departure</td><td>2</td></tr><tr><td>11:30</td><td>Departure</td><td>1</td></tr><tr><td>12:00</td><td>Departure</td><td>0</td></tr><tr><td>15:00</td><td>Arrival</td><td>1</td></tr><tr><td>18:00</td><td>Arrival</td><td>2</td></tr><tr><td>19:00</td><td>Departure</td><td>1</td></tr><tr><td>20:00</td><td>Departure</td><td>0</td></tr></tbody></table></div><p>最多需要3站台。</p><p>在算法实现时，只需要对arr、dep数组单独排序，然后在进行有序数组的归并排序。下面给出代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPlatform</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span>[] dep)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        Arrays.sort(dep); <span class="comment">//分别对到达和离开排序</span></span><br><span class="line">        <span class="keyword">int</span> numPlatform = <span class="number">0</span>, maxPlatform = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; <span class="comment">//两个指针</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; n || j &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; n &amp;&amp; j &lt; n) &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i] &lt; dep[j]) &#123;</span><br><span class="line">                    numPlatform++;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(arr[i] &gt; dep[j])&#123;</span><br><span class="line">                    numPlatform--;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(j&gt;=n) &#123; <span class="comment">// 此时还将继续有火车进站</span></span><br><span class="line">                numPlatform++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 此时只有火车出站</span></span><br><span class="line">                numPlatform--;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            maxPlatform = Math.max(maxPlatform, numPlatform);</span><br><span class="line"><span class="comment">//            System.out.println(numPlatform);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxPlatform;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这是之前遇到的一道面试题，挺巧妙的。当时没做出来，故做一个小结。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://www.jianshu.com/p/3948fda91d3d">火车站台数量问题</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-初识注解</title>
      <link href="/2021/12/23/Java-%E5%88%9D%E8%AF%86%E6%B3%A8%E8%A7%A3/"/>
      <url>/2021/12/23/Java-%E5%88%9D%E8%AF%86%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="初识注解"><a href="#初识注解" class="headerlink" title="初识注解"></a>初识注解</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>Annotation提供了一种为恒旭元素设置元数据的方法。</li><li>类似于修饰符，可用于修饰包、类、构造器、方法、成员变量、参数、局部变量的声明。</li><li>Annotation是一个接口，程序可以通过反射来获取指定程序元素的Annotation对象。</li><li>Annotation不影响程序代码的运行。</li><li>如果希望Annotation在程序运行时起作用，只有通过某种配套工具对Annotation的信息进行访问和处理。访问和处理Annotation的工具统称为APT。</li></ul><h2 id="内置注解"><a href="#内置注解" class="headerlink" title="内置注解"></a>内置注解</h2><p>Java定义了一套注解如下。</p><ul><li>以下注解在java.lang中：<ul><li><strong>@Override</strong> - 检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。</li><li><strong>@Deprecated</strong> - 标记过时方法。如果使用该方法，会报编译警告。</li><li><strong>@SuppressWarnings</strong> - 指示编译器去忽略注解中声明的警告。</li><li>@SafeVarargs - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。</li><li><strong>@FunctionalInterface</strong> - Java 8 开始支持，标识一个匿名函数或函数式接口。</li></ul></li><li>以下注解在java.lang.annotation中，他们作用在其他注解中，也成为<strong>元注解</strong>：<ul><li><strong>@Retention</strong> - 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。</li><li>@Documented - 标记这些注解是否包含在用户文档中。</li><li><strong>@Target</strong> - 标记这个注解应该是哪种 Java 成员。</li><li><strong>@Inherited</strong> - 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类)<ul><li>详解：假设，我们定义了某个 Annotaion，它的名称是 MyAnnotation，并且 MyAnnotation 被标注为 @Inherited。现在，某个类 Base 使用了MyAnnotation，则 Base “具有了注解 MyAnnotation”；现在，Sub 继承了 Base，由于 MyAnnotation 是 @Inherited的(具有继承性)，所以，Sub 也 “具有了注解 MyAnnotation”。</li></ul></li><li>@Repeatable - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。</li></ul></li></ul><h2 id="Annotation架构"><a href="#Annotation架构" class="headerlink" title="Annotation架构"></a>Annotation架构</h2><p><img src="1.jpg" alt="Annotation架构"></p><p>从中可以看出：</p><ol><li>1个Annotation对象，都会有唯一的RetentionPolicy属性。</li><li>1 个 Annotation 对象，可以有若干个 ElementType 属性。</li><li>Annotation 有许多实现类，包括：Deprecated, Documented, Inherited, Override 等等。</li></ol><p>下面介绍，在java Annotation的组成中，有三个重要的主干类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Annotation.java</span></span><br><span class="line"><span class="keyword">package</span> java.lang.annotation;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Annotation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends Annotation&gt; annotationType();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ElementType.java</span></span><br><span class="line"><span class="keyword">package</span> java.lang.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">ElementType</span> </span>&#123;</span><br><span class="line">    TYPE,               <span class="comment">/* 类、接口（包括注释类型）或枚举声明  */</span></span><br><span class="line"></span><br><span class="line">    FIELD,              <span class="comment">/* 字段声明（包括枚举常量）  */</span></span><br><span class="line"></span><br><span class="line">    METHOD,             <span class="comment">/* 方法声明  */</span></span><br><span class="line"></span><br><span class="line">    PARAMETER,          <span class="comment">/* 参数声明  */</span></span><br><span class="line"></span><br><span class="line">    CONSTRUCTOR,        <span class="comment">/* 构造方法声明  */</span></span><br><span class="line"></span><br><span class="line">    LOCAL_VARIABLE,     <span class="comment">/* 局部变量声明  */</span></span><br><span class="line"></span><br><span class="line">    ANNOTATION_TYPE,    <span class="comment">/* 注释类型声明  */</span></span><br><span class="line"></span><br><span class="line">    PACKAGE             <span class="comment">/* 包声明  */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//RetentionPolicy.java</span></span><br><span class="line"><span class="keyword">package</span> java.lang.annotation;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">RetentionPolicy</span> </span>&#123;</span><br><span class="line">    SOURCE,            <span class="comment">/* Annotation信息仅存在于编译器处理期间，编译器处理完之后就没有该Annotation信息了  */</span></span><br><span class="line"></span><br><span class="line">    CLASS,             <span class="comment">/* 编译器将Annotation存储于类对应的.class文件中。默认行为  */</span></span><br><span class="line"></span><br><span class="line">    RUNTIME            <span class="comment">/* 编译器将Annotation存储于class文件中，并且可由JVM读入 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ol><li>Annotation是一个接口，继承这个接口的就是注解。</li><li><strong>ElementType 是 Enum 枚举类型，它用来指定 Annotation 的类型。</strong><ol><li>例如，若一个 Annotation 对象是 METHOD 类型，则该 Annotation 只能用来修饰方法。</li></ol></li><li><strong>RetentionPolicy 是 Enum 枚举类型，它用来指定 Annotation 的策略。通俗点说，就是不同 RetentionPolicy 类型的 Annotation 的作用域不同。</strong><ol><li>若 Annotation 的类型为 SOURCE，则意味着：Annotation 仅存在于编译器处理期间，编译器处理完之后，该 Annotation 就没用了。 例如，” @Override” 标志就是一个 Annotation。当它修饰一个方法的时候，就意味着该方法覆盖父类的方法；并且在编译期间会进行语法检查！编译器处理完后，”@Override” 就没有任何作用了。</li><li>若 Annotation 的类型为 CLASS，则意味着：编译器将 Annotation 存储于类对应的 .class 文件中，它是 Annotation 的默认行为。</li><li>若 Annotation 的类型为 RUNTIME，则意味着：编译器将 Annotation 存储于 class 文件中，并且可由JVM读入。</li></ol></li></ol><h2 id="注解通用定义"><a href="#注解通用定义" class="headerlink" title="注解通用定义"></a>注解通用定义</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation1 &#123;</span><br><span class="line">    <span class="comment">//属性列表</span></span><br><span class="line">    <span class="comment">//Annotation的成员变量在Annotation定义中以无形参方法形式来声明，其方法名和返回值定义了该成员变量的名字和类型。</span></span><br><span class="line">    <span class="comment">//注解元素的类型可以为：基本类型，String，Class，枚举类型，注解类型，以及前面所述类型组成的数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：上面的作用是定义了一个注解，名为MyAnnotation1。定义了MyAnnotation1之后，我们可以在代码中通过@MyAnnotation1使用它。其他的，@Documented, @Target, @Retention, @interface都是来修饰MyAnnotation1的。</p><ul><li><p><strong>@interface</strong>：使用 @interface <strong>关键字</strong>定义注解时，意味着它实现了java.lang.annotation.Annotation 接口，即该注解就是一个Annotation。</p></li><li><p><strong>@Documented</strong>：类和方法的 Annotation 在缺省情况下是不出现在 javadoc 中的。如果使用 @Documented 修饰该 Annotation，则表示它可以出现在 javadoc 中。定义 Annotation 时，@Documented 可有可无；若没有定义，则 Annotation 不会出现在 javadoc 中。</p></li><li><p><strong>@Target(ElementType.TYPE)</strong>：ElementType 是 Annotation 的类型属性。而 @Target 的作用，就是来指定 Annotation 的类型属性。</p><p>@Target(ElementType.TYPE) 的意思就是指定该 Annotation 的类型是 ElementType.TYPE。这就意味着，MyAnnotation1 是来修饰”类、接口（包括注释类型）或枚举声明”的注解。</p><p>定义 Annotation 时，@Target 可有可无。若有 @Target，则该 Annotation 只能用于它所指定的地方；若没有 @Target，则该 Annotation 可以用于任何地方。</p></li><li><p><strong>@Retention(RetentionPolicy.RUNTIME)</strong>：前面我们说过，RetentionPolicy 是 Annotation 的策略属性，而 @Retention 的作用，就是指定 Annotation 的策略属性。</p><p>@Retention(RetentionPolicy.RUNTIME) 的意思就是指定该 Annotation 的策略是 RetentionPolicy.RUNTIME。这就意味着，编译器会将该 Annotation 信息保留在 .class 文件中，并且能被虚拟机读取。</p><p>定义 Annotation 时，@Retention 可有可无。若没有 @Retention，则默认是 RetentionPolicy.CLASS。</p></li></ul><p>根据注解是否包含成员变量，可以把注解分为</p><ul><li>标记注解：没有成员变量的注解，这种注解仅利用自身是否存在来提供信息。</li><li>元数据注解：包含成员变量的注解，因为它可以接受更多的元数据，所以也被称为元数据注解。</li></ul><h2 id="Annotation作用"><a href="#Annotation作用" class="headerlink" title="Annotation作用"></a>Annotation作用</h2><h3 id="编译检查"><a href="#编译检查" class="headerlink" title="编译检查"></a>编译检查</h3><p>Annotation 具有”让编译器进行编译检查的作用”。@SuppressWarnings, @Deprecated 和 @Override 都具有编译检查作用。</p><h3 id="☆在反射中解析并使用-Annotation"><a href="#☆在反射中解析并使用-Annotation" class="headerlink" title="☆在反射中解析并使用 Annotation"></a>☆在反射中解析并使用 Annotation</h3><p>程序通过反射机制可以解析被修饰的方法中的注解数据，当程序获取特殊标记后，可以做出相应的处理。这在Spring等框架中经常使用。详见下面代码。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AnnotationTest.java</span></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Annotation;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Inherited;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Annotation在反射函数中的使用示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 说明：在这里，我们不能把value()看成一个方法，而是一个同名的变量</span></span><br><span class="line"><span class="comment">     * 在使用的时候可以通过@MyAnnotation(value=&#123;&quot;a&quot;,&quot;b&quot;&#125;来赋值</span></span><br><span class="line"><span class="comment">     * default 给value制定了默认值</span></span><br><span class="line"><span class="comment">     * 如果注解的属性只有一个，且叫value，那么使用该注解时，可以不用指定属性名，因为默认就是给value赋值：</span></span><br><span class="line"><span class="comment">     * @MyAnnotation(&#123;&quot;a&quot;,&quot;b&quot;&#125;) //这样也是可以的</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">    String[] value() default &quot;unknown&quot;;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Person类。它会使用MyAnnotation注解。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * empty()方法同时被 &quot;<span class="doctag">@Deprecated</span>&quot; 和 &quot;<span class="doctag">@MyAnnotation</span>(value=&#123;&quot;a&quot;,&quot;b&quot;&#125;)&quot;所标注</span></span><br><span class="line"><span class="comment">     * (01) <span class="doctag">@Deprecated</span>，意味着empty()方法，不再被建议使用</span></span><br><span class="line"><span class="comment">     * (02) <span class="doctag">@MyAnnotation</span>, 意味着empty() 方法对应的MyAnnotation的value值是默认值&quot;unknown&quot;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@MyAnnotation</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">empty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;\nempty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * sombody() 被 <span class="doctag">@MyAnnotation</span>(value=&#123;&quot;girl&quot;,&quot;boy&quot;&#125;) 所标注，</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@MyAnnotation</span>(value=&#123;&quot;girl&quot;,&quot;boy&quot;&#125;), 意味着MyAnnotation的value值是&#123;&quot;girl&quot;,&quot;boy&quot;&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@MyAnnotation(value=&#123;&quot;girl&quot;,&quot;boy&quot;&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">somebody</span><span class="params">(String name, <span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;\nsomebody: &quot;</span>+name+<span class="string">&quot;, &quot;</span>+age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 新建Person</span></span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        <span class="comment">// 获取Person的Class实例</span></span><br><span class="line">        Class&lt;Person&gt; c = Person.class;</span><br><span class="line">        <span class="comment">// 获取 somebody() 方法的Method实例</span></span><br><span class="line">        Method mSomebody = c.getMethod(<span class="string">&quot;somebody&quot;</span>, <span class="keyword">new</span> Class[]&#123;String.class, <span class="keyword">int</span>.class&#125;);</span><br><span class="line">        <span class="comment">// 执行该方法</span></span><br><span class="line">        mSomebody.invoke(person, <span class="keyword">new</span> Object[]&#123;<span class="string">&quot;lily&quot;</span>, <span class="number">18</span>&#125;);</span><br><span class="line">        iteratorAnnotations(mSomebody);</span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 somebody() 方法的Method实例</span></span><br><span class="line">        Method mEmpty = c.getMethod(<span class="string">&quot;empty&quot;</span>, <span class="keyword">new</span> Class[]&#123;&#125;);</span><br><span class="line">        <span class="comment">// 执行该方法</span></span><br><span class="line">        mEmpty.invoke(person, <span class="keyword">new</span> Object[]&#123;&#125;);        </span><br><span class="line">        iteratorAnnotations(mEmpty);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iteratorAnnotations</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断 somebody() 方法是否包含MyAnnotation注解</span></span><br><span class="line">        <span class="keyword">if</span>(method.isAnnotationPresent(MyAnnotation.class))&#123;</span><br><span class="line">            <span class="comment">// 获取该方法的MyAnnotation注解实例</span></span><br><span class="line">            MyAnnotation myAnnotation = method.getAnnotation(MyAnnotation.class);</span><br><span class="line">            <span class="comment">// 获取 myAnnotation的值，并打印出来</span></span><br><span class="line">            String[] values = myAnnotation.value();</span><br><span class="line">            <span class="keyword">for</span> (String str:values)</span><br><span class="line">                System.out.printf(str+<span class="string">&quot;, &quot;</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 获取方法上的所有注解，并打印出来</span></span><br><span class="line">        Annotation[] annotations = method.getAnnotations();</span><br><span class="line">        <span class="keyword">for</span>(Annotation annotation : annotations)&#123;</span><br><span class="line">            System.out.println(annotation);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">somebody: lily, 18</span><br><span class="line">girl, boy, </span><br><span class="line">@com.skywang.annotation.MyAnnotation(value=[girl, boy])</span><br><span class="line"></span><br><span class="line">empty</span><br><span class="line">unknown, </span><br><span class="line">@com.skywang.annotation.MyAnnotation(value=[unknown])</span><br><span class="line">@java.lang.Deprecated()</span><br></pre></td></tr></table></figure><h3 id="根据Annotation生成帮助文档"><a href="#根据Annotation生成帮助文档" class="headerlink" title="根据Annotation生成帮助文档"></a>根据Annotation生成帮助文档</h3><p>@Documented</p><h3 id="帮忙查看代码"><a href="#帮忙查看代码" class="headerlink" title="帮忙查看代码"></a>帮忙查看代码</h3><p>通过 @Override, @Deprecated 等，我们能很方便的了解程序的大致结构。</p><h3 id="附属文件的自动生成"><a href="#附属文件的自动生成" class="headerlink" title="附属文件的自动生成"></a>附属文件的自动生成</h3><p>例如部署描述符或者bean信息类。</p><h3 id="测试、日志等代码的自动生成"><a href="#测试、日志等代码的自动生成" class="headerlink" title="测试、日志等代码的自动生成"></a>测试、日志等代码的自动生成</h3><p>//TODO</p><h2 id="框架中常用的注解"><a href="#框架中常用的注解" class="headerlink" title="框架中常用的注解"></a>框架中常用的注解</h2><h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><p>//TODO</p><h3 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h3><p>//TODO</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li><p>注解就像标签，是程序判断执行的依据。比如，程序读到@Test就知道这个方法是待测试方法，而@Before的方法要在测试方法之前执行</p></li><li><p>注解需要三要素：定义、使用、<strong>读取并执行</strong></p></li><li>注解分为自定义注解、JDK内置注解和第三方注解（框架）。自定义注解一般要我们自己定义、使用、并写程序读取，而JDK内置注解和第三方注解我们只要使用，定义和读取都交给它们</li><li>大多数情况下，三角关系中我们只负责使用注解，无需定义和执行，框架会将注解类和读取注解的程序隐藏起来，除非阅读源码，否则根本看不到。平时见不到定义和读取的过程，光顾着使用注解，久而久之很多人就忘了注解如何起作用了！</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://www.zhihu.com/question/47449512/answer/658228092">怎样理解 Java 注解和运用注解编程？</a></li><li><a href="https://www.runoob.com/w3cnote/java-annotation.html">菜鸟教程-Java 注解（Annotation）</a></li><li>《Java疯狂讲义 第十四章 注解》</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编写脚本读取文件并执行命令</title>
      <link href="/2021/12/21/%E7%BC%96%E5%86%99%E8%84%9A%E6%9C%AC%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E5%B9%B6%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/12/21/%E7%BC%96%E5%86%99%E8%84%9A%E6%9C%AC%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E5%B9%B6%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>最近遇到如下需求：</p><blockquote><p>有一个文件，文件格式大概是这样</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;filename1&gt;\t&lt;download_url1&gt;</span><br><span class="line"></span><br><span class="line">&lt;filename2&gt;\t&lt;download_url2&gt;</span><br></pre></td></tr></table></figure><p>编写一个脚本循环读取该文件的每一行，使用<code>axel</code>命令将<code>download_url</code>下载下来，保存为本地文件<code>filename</code></p></blockquote><h1 id="Bash"><a href="#Bash" class="headerlink" title="Bash"></a>Bash</h1><p>先给出Code：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ./download.sh &lt;filename&gt;</span></span><br><span class="line"></span><br><span class="line">cat <span class="variable">$1</span> | <span class="keyword">while</span> <span class="built_in">read</span> line</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="comment"># echo $&#123;line&#125;</span></span><br><span class="line">    array=(<span class="variable">$&#123;line// / &#125;</span>) <span class="comment"># array=($&#123;line//\t/ &#125;) 不生效</span></span><br><span class="line">    <span class="comment"># echo $&#123;array[0]&#125; + &quot;;&quot; + $&#123;array[1]&#125; </span></span><br><span class="line">    cmd=<span class="string">&#x27;axel -o &#x27;</span><span class="variable">$&#123;array[0]&#125;</span><span class="string">&#x27; &quot;&#x27;</span><span class="variable">$&#123;array[1]&#125;</span><span class="string">&#x27;&quot;&#x27;</span></span><br><span class="line">    <span class="built_in">eval</span> <span class="variable">$cmd</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>下面对code逐一解释</p><h2 id="bin-bash"><a href="#bin-bash" class="headerlink" title="#! /bin/bash"></a>#! /bin/bash</h2><p><strong>#!/bin/bash</strong>是指此脚本使用<strong>/bin/bash</strong>来解释执行，Bash脚本首行固定写法。</p><h2 id="Bash注释"><a href="#Bash注释" class="headerlink" title="Bash注释"></a>Bash注释</h2><p>Bash中使用<code>#</code>进行单行注释，见如上代码第三行</p><h2 id="Bash-接收外部参数"><a href="#Bash-接收外部参数" class="headerlink" title="Bash 接收外部参数"></a>Bash 接收外部参数</h2><p>我们可以在执行 Shell 脚本时，向脚本传递参数，脚本内获取参数的格式为：<strong>$n</strong>。<strong>n</strong> 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推……</p><p>特殊的 ，<strong>$0</strong> 表示脚本名称（含路径）。</p><p>另外，<strong>$#</strong> 表示传递参数的个数。</p><p>上面代码中<code>cat $1 |</code>就是将第一个参数作为文件名，读取文件中的内容，通过管道命令<code>|</code>将文件内容传给while循环</p><h2 id="Bash-循环读取每一行"><a href="#Bash-循环读取每一行" class="headerlink" title="Bash 循环读取每一行"></a>Bash 循环读取每一行</h2><p>最简单的</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> line</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$line</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>还可以使用for循环等，详细可参见参考资料1。</p><h2 id="Bash按指定字符分割字符串"><a href="#Bash按指定字符分割字符串" class="headerlink" title="Bash按指定字符分割字符串"></a>Bash按指定字符分割字符串</h2><p>接上文，line是待处理的字符串，则指定分隔符<code>\t</code>将line分割后的字符串数组存放到array，</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">array=(<span class="variable">$&#123;line// / &#125;</span>)</span><br></pre></td></tr></table></figure><p>注意这里<code>//</code>和<code>/</code>之间是一个制表符，而不是空格。</p><p>我也曾使用<code>array=($&#123;line//\t/ &#125;)</code>来进行分割，但是测试后发现它会按照字符<code>t</code>对字符串进行分割。</p><p><em>还没弄明白语法规则</em></p><h2 id="Bash字符串拼接"><a href="#Bash字符串拼接" class="headerlink" title="Bash字符串拼接"></a>Bash字符串拼接</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmd=<span class="string">&#x27;axel -o &#x27;</span><span class="variable">$&#123;array[0]&#125;</span><span class="string">&#x27; &quot;&#x27;</span><span class="variable">$&#123;array[1]&#125;</span><span class="string">&#x27;&quot;&#x27;</span></span><br></pre></td></tr></table></figure><p>这一行就是取array中的值进行字符串拼接，注意取值的语法<code>$&#123;&#125;</code></p><ul><li><p>Bash中对字符串拼接不需要使用<code>+</code>进行连接</p></li><li><p>这里使用单引号是为了避免对双引号转义</p></li></ul><h2 id="Bash执行cmd"><a href="#Bash执行cmd" class="headerlink" title="Bash执行cmd"></a>Bash执行cmd</h2><p><code>eval $cmd</code>是读取变量cmd的值当作一条Shell命令进行执行</p><h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><p>上面的代码先读取每一行，在对行按照制表符进行分割。其实可以更简洁：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> filenameurl</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="comment">#echo $filename</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>同样的需要注意<code>filename</code>，<code>url</code>之间是一个制表符而不是空格。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>当url过长时，该脚本并不能完整的读取url。例如，当文件如下时</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">covid19-image-dataset-collection-volumes-folder.ziphttps://storage.googleapis.com/kaggle-data-sets/862993/1470970/bundle/archive.zip?X-Goog-Algorithm=GOOG4-RSA-SHA256&amp;X-Goog-Credential=gcp-kaggle-com%40kaggle-161607.iam.gserviceaccount.com%2F20211221%2Fauto%2Fstorage%2Fgoog4_request&amp;X-Goog-Date=20211221T052609Z&amp;X-Goog-Expires=259199&amp;X-Goog-SignedHeaders=host&amp;X-Goog-Signature=6549111df89ca0440058e7061ba9a13d72ea22ed7bcfdbcfc56ddadaf7a54ec4d3285487b269808d60cf0568264db1803899989475d8ca0aeec0777891f54df612a6a8f7ba808c8df3899feda1a94ca0507a580e407c0e42371d97e3ce1c75d598bed1f693bf841f7d4660294488e99fc944d6e1498c5ec38b431b969e5f13eda5f2d8029e855ea368c57eab60897a32f7556df116a96bfd321dd4d214dfe847d4c8ca11fdb7c3472ebac9f7a9eb20b44a148df51ecb2f93acdc5459800a894cdc2d62a0cc2c2e42e6711e568827f44b82d6faaa02aa1357c8d93140eb2c72bde9b8c1716e565800ac3ff812df304ce7a54c2a83896696ac5fa935329afa66ef</span><br></pre></td></tr></table></figure><p>读取并拼接后的命令字符串如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">axel -o covid19-image-dataset-collection-volumes-folder.zip &quot;https://storage.googleapis.com/kaggle-data-sets/862993/1470970/bundle/archive.zip?X-Goog-Algorithm=GOOG4-RSA-SHA256&amp;X-Goog-Credential=gcp-kaggle-com%40kaggle-161607.iam.gserviceaccount.com%2F20211221%2Fauto%2Fstorage%2Fgoog4_request&amp;X-Goog-Date=20211221T052609Z&amp;X-Goog-Expires=259199&amp;X-Goog-SignedHeaders=host&amp;X-Goog-Signature=6549111df89ca0440058e7061ba9a13d72ea22ed7bcfdbcfc56ddadaf7a54ec4d3285487b269808d60cf0568264db1803899989475d8ca0aeec0777891f54df612a6a8f7ba808c8df3899feda1a94ca0507a580e407c0e42371d97e3ce1c75d598bed1f693bf841f7d4660294488e99fc944d6e1498c5ec38b431b969e5f13eda5f2d8029e855ea368c57eab60897a32f7556df116a96bfd321dd4d214dfe847d4c8ca11fdb7c3472ebac9f7a9eb20b44a148df51ecb2f93acdc5459800a894cdc2d62a0cc2c2e42e6711e568827f44b82d6faaa02aa1357c8d93140eb2c72bde9b8c1716e565800ac3ff812df304ce7a54c2a83896696ac5fa9353&quot;9afa66ef</span><br></pre></td></tr></table></figure><p>注意引号外面还有数据，这是不符合预期的。</p><p><em>目前还没有解决该问题</em></p><h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><p>由于本人对Bash不是很熟悉，所以改用Python来完成这一需求。</p><p>下面给出完整代码</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#python download.py -f list</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    parser = argparse.ArgumentParser(description=<span class="string">&quot;download kaggle dataset according to file&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;-f&#x27;</span>, <span class="string">&#x27;--filename&#x27;</span>, required=<span class="literal">True</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, <span class="built_in">help</span>=<span class="string">&#x27;filename&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">    filename = args.filename</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        lines = f.readlines()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        arr = line.split(<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">        save_name = arr[<span class="number">0</span>]</span><br><span class="line">        url = arr[<span class="number">1</span>].replace(<span class="string">&quot;\n&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        cmd = <span class="string">&#x27;axel -o &#x27;</span> + save_name + <span class="string">&#x27; &quot;&#x27;</span> + url + <span class="string">&#x27;&quot;&#x27;</span></span><br><span class="line">        <span class="comment"># print(cmd)</span></span><br><span class="line">        res_f = os.popen(cmd)  <span class="comment"># 返回的是一个文件对象</span></span><br><span class="line">        <span class="built_in">print</span>(res_f.read())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="Python-main函数"><a href="#Python-main函数" class="headerlink" title="Python main函数"></a>Python main函数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>这是Python的main函数，Python脚本总会从该“函数“进入。</p><h2 id="Python-接收外部参数"><a href="#Python-接收外部参数" class="headerlink" title="Python 接收外部参数"></a>Python 接收外部参数</h2><p>使用类库<code>argparse</code>来读取外部参数。上述代码给出了一个简单的示例</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">parser = argparse.ArgumentParser(description=<span class="string">&quot;download kaggle dataset according to file&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">第一、二个参数是指定参数名，第一个是简写形式</span></span><br><span class="line"><span class="string">在调用命令的时候，可以使用python script.py -f &lt;param&gt;或者python script.py --filename &lt;param&gt;</span></span><br><span class="line"><span class="string">required=True 表示该参数必填</span></span><br><span class="line"><span class="string">type=str 指定参数类型</span></span><br><span class="line"><span class="string">help=&#x27;filename&#x27; 指定提示语</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">parser.add_argument(<span class="string">&#x27;-f&#x27;</span>, <span class="string">&#x27;--filename&#x27;</span>, required=<span class="literal">True</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, <span class="built_in">help</span>=<span class="string">&#x27;filename&#x27;</span> 指定提示语)</span><br><span class="line"></span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">filename = args.filename  <span class="comment"># filename存放了外部参数的值</span></span><br></pre></td></tr></table></figure><p>详细请参见<code>参考资料2</code></p><h2 id="Python文件、字符串操作"><a href="#Python文件、字符串操作" class="headerlink" title="Python文件、字符串操作"></a>Python文件、字符串操作</h2><p>略</p><h2 id="在Python中执行Shell命令"><a href="#在Python中执行Shell命令" class="headerlink" title="在Python中执行Shell命令"></a>在Python中执行Shell命令</h2><p>有两种方式。使用<code>os.system(&quot;command&quot;)</code>执行无返回值的Shell命令；使用<code>f = os.popen(&quot;command&quot;)</code>执行有输出的Shell命令，其返回值<code>f</code>是一个文件对象，通过<code>f.read()</code>来读取命令输出内容。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="http://c.biancheng.net/shell/">Shell 脚本学习指南</a></li><li><a href="https://docs.python.org/zh-cn/3/howto/argparse.html">Python Argparse 教程</a></li><li><a href="https://blog.csdn.net/qq_27825451/article/details/102909772">python执行shell脚本的几种方法</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Scripts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Linux Bash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>田忌赛马与贪心法则</title>
      <link href="/2021/12/20/%E7%94%B0%E5%BF%8C%E8%B5%9B%E9%A9%AC%E4%B8%8E%E8%B4%AA%E5%BF%83%E6%B3%95%E5%88%99/"/>
      <url>/2021/12/20/%E7%94%B0%E5%BF%8C%E8%B5%9B%E9%A9%AC%E4%B8%8E%E8%B4%AA%E5%BF%83%E6%B3%95%E5%88%99/</url>
      
        <content type="html"><![CDATA[<p>本文涉及<em><a href="https://leetcode-cn.com/problems/advantage-shuffle/">LeetCode 870. 优势洗牌</a></em></p><blockquote><p>给定两个大小相等的数组 A 和 B，A 相对于 B 的优势可以用满足 A[i] &gt; B[i] 的索引 i 的数目来描述。返回 A 的任意排列，使其相对于 B 的优势最大化。</p><p>示例 1：</p><p>输入：A = [2,7,11,15], B = [1,10,4,11]<br>输出：[2,11,7,15]<br>示例 2：</p><p>输入：A = [12,24,8,32], B = [13,25,32,11]<br>输出：[24,32,8,12]</p></blockquote><p>这就像⽥忌赛⻢的情景，nums1 就是⽥忌的⻢，nums2 就是⻬王的⻢，数组中的元素就是⻢的战⽃⼒：</p><p>算法策略是：<strong>将⻬王和⽥忌的⻢按照战⽃⼒排序，然后按照排名⼀⼀对⽐。如果⽥忌的⻢能赢，那就⽐赛，如果赢不了，那就换个垫底的来送⼈头，保存实⼒。</strong></p><p>这里要注意一个问题：是否需要保存实力，即如果⽥忌的⼆号选⼿也能⼲得过⻬王的⼀号选⼿，此时让⼆号选⼿去对决⻬王的⼀号选⼿，不是更节约？</p><p>这种节约的策略是没问题的，但是<strong>没有必要</strong>。</p><p>我们暂且把⽥忌的⼀号选⼿称为 T1，⼆号选⼿称为 T2，⻬王的⼀号选⼿称为 Q1。如果 T2 能赢 Q1，你试图保存⼰⽅实⼒，让 T2 去战 Q1，把 T1 留着是为了对付谁？显然，你担⼼⻬王还有战⼒⼤于 T2 的⻢，可以让 T1 去对付。但是你仔细想想，现在 T2 已经是可以战胜 Q1 的，Q1 可是⻬王的最快的⻢，⻬王剩下的那些⻢⾥，怎么可能还有⽐ T2 更强的⻢？</p><p>所以没必要节约。</p><p>根据上述思路得到的代码逻辑如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对两个数组nums1和nums2排序</span><br><span class="line">对两个数组的元素挨个比较，如果nums1[i]&gt;nums2[i]那就比，否则就换上nums1最小的元素进行比较。</span><br></pre></td></tr></table></figure><p>由于需要对两个数组排序，但是返回结果依赖nums2的顺序，所以不能直接对nums2进行排序，而是利用优先级队列。（将(index, nums2[index]放入优先级队列，出队优先级按照nums2[index]大小，index记录索引值）</p><p>此外，解法还是用到双指针技巧。完整代码如下。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] advantageCount(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums1.length;</span><br><span class="line">    <span class="comment">// 给 nums2 降序排序</span></span><br><span class="line">    PriorityQueue&lt;<span class="keyword">int</span>[]&gt; maxpq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(</span><br><span class="line">        (<span class="keyword">int</span>[] pair1, <span class="keyword">int</span>[] pair2) -&gt; &#123; </span><br><span class="line">            <span class="keyword">return</span> pair2[<span class="number">1</span>] - pair1[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        maxpq.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, nums2[i]&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 给 nums1 升序排序</span></span><br><span class="line">    Arrays.sort(nums1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// nums1[left] 是最小值，nums1[right] 是最大值</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!maxpq.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] pair = maxpq.poll();</span><br><span class="line">        <span class="comment">// maxval 是 nums2 中的最大值，i 是对应索引</span></span><br><span class="line">        <span class="keyword">int</span> i = pair[<span class="number">0</span>], maxval = pair[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (maxval &lt; nums1[right]) &#123;</span><br><span class="line">            <span class="comment">// 如果 nums1[right] 能胜过 maxval，那就自己上</span></span><br><span class="line">            res[i] = nums1[right];</span><br><span class="line">            right--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则用最小值去换nums2的最大值</span></span><br><span class="line">            res[i] = nums1[left];</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&amp;mid=2247491139&amp;idx=1&amp;sn=10cb35e0056ac8f8c540fccd0156f333&amp;scene=21&amp;ascene=7&amp;devicetype=iOS15.2&amp;version=1800103a&amp;nettype=WIFI&amp;abtest_cookie=AAACAA%3D%3D&amp;lang=zh_CN&amp;fontScale=100&amp;exportkey=A2t5E2fVKmwEJxWEKsScbfU%3D&amp;pass_ticket=n3zshxiiR8IMf1IfoZgzB%2BPSm6RatluaPa8vtuS3bDtR2ttHhdhxmZkQCXMUyC9L&amp;wx_header=1">labuladong: 算法大师——孙膑</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 数组/链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PriorityQueue 概述</title>
      <link href="/2021/12/19/PriorityQueue-%E6%A6%82%E8%BF%B0/"/>
      <url>/2021/12/19/PriorityQueue-%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><p><code>Queue</code>是一个严格的先进先出（FIFO）的队列。</p><p>但有时候这并不能满足我们的需求。当我们需要对队列中的元素重排，按照重排后的元素顺序出队时，这时候就需要<code>PriorityQueue</code>。</p><p><code>PriorityQueue</code>和<code>Queue</code>的区别在于，它的出队顺序与元素的优先级有关，对<code>PriorityQueue</code>调用<code>remove()</code>或<code>poll()</code>方法，返回的总是优先级最高的元素。</p><p>要使用<code>PriorityQueue</code>，我们就必须给每个元素定义“优先级”。请看下面的例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPriorityQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Queue&lt;User&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(</span><br><span class="line">                (User user1, User user2) -&gt; &#123;</span><br><span class="line">                    <span class="keyword">return</span> user2.getLevel() - user1.getLevel();</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">        queue.offer(<span class="keyword">new</span> User(<span class="string">&quot;sb_1&quot;</span>, <span class="number">1</span>)); <span class="comment">//优先级低</span></span><br><span class="line">        queue.offer(<span class="keyword">new</span> User(<span class="string">&quot;vip_1&quot;</span>, <span class="number">2</span>)); <span class="comment">//优先级高</span></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            User user = queue.poll();</span><br><span class="line">            System.out.println(user.getName());</span><br><span class="line">        &#125; <span class="comment">//出队的顺序是vip_1, sb_1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> level;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.level = level;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//getter、setter</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的例子使用lambda表达式实现了排序。你也可以自定义排序器（实现Comparable接口），然后将排序器对象传递给<code>PriorityQueue</code>构造器。构造函数签名如下：</p><p><code>public PriorityQueue(Comparator&lt;? super E&gt; comparator)</code></p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>通过堆实现，具体说是通过完全二叉树（<em>complete binary tree</em>）实现的<strong>小顶堆</strong>（任意一个非叶子节点的权值，都不大于其左右子节点的权值）。</p><p>具体请参考<strong>堆排序</strong>。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1265120632401152">https://www.liaoxuefeng.com/wiki/1252599548343744/1265120632401152</a></li><li><a href="https://www.cnblogs.com/CarpenterLee/p/5488070.html">https://www.cnblogs.com/CarpenterLee/p/5488070.html</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 集合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例设计模式</title>
      <link href="/2021/12/16/%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2021/12/16/%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>单例模式确保一个类只有一个实例，并提供了一个全局访问点。</p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>线程池，数据库连接对象。</p><h1 id="经典单例模式"><a href="#经典单例模式" class="headerlink" title="经典单例模式"></a>经典单例模式</h1><p>一个经典的单例模式实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> This is not thread safe!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> uniqueInstance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该实现是线程不安全的。可以想象有两个线程同时进入了getInstance()方法。</p><h1 id="解决经典单例模式线程安全问题"><a href="#解决经典单例模式线程安全问题" class="headerlink" title="解决经典单例模式线程安全问题"></a>解决经典单例模式线程安全问题</h1><p>解决方案，给getInstance方法加上synchronized关键字，迫使每个线程进入该方法前都需要等待别的线程离开该方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> uniqueInstance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该解决方案得缺点就是只有第一次执行该方法才真正需要线程同步。</p><h1 id="更进一步…"><a href="#更进一步…" class="headerlink" title="更进一步…"></a>更进一步…</h1><p>这里给出三种改善方案：</p><ol><li>如果getInstance得性能对于应用程序不是很关键，就什么也别做。</li><li>使用“急切”创建实例，而不用延迟实例化的做法。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>使用<strong>双重检查加锁</strong>，在getInstance中减少使用同步。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>备注：</p><ul><li>首先检查实例是否存在，如果不存在再进入同步代码块。</li><li>进入区块后在检查一次，如果仍然是null则创建实例。</li><li>volatile关键字确保：当instance变量初始化后，多个线程正确的处理instance变量。</li></ul><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><blockquote><p>两个类加载器可能有机会创建自己的单例实例？</p></blockquote><p>是的。所以如果你的程序有多个类加载器又同时使用了单例模式，请小心。解决方法是自行指定类加载器，并指定同一个类加载器。</p><blockquote><p>类如果能做两件事，就违反了OO设计。单例模式是否违反了这样的观念呢？</p></blockquote><p>单例类不止负责管理自己的实例，还在应用程序中担任角色，所以可以视为是两个责任。但是由类管理自己的实例的做法并不少见，也可以让设计更简单。</p><blockquote><p>我想把单例类当成超类，设计出子类。究竟可不可以继承单例类。</p></blockquote><p>不能。继承单例类遇到的一个问题就是构造器是私有的。你不能用私有构造器来扩展类。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《Head First设计模式》(中文版)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
