<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="基于ResNet的树叶分类任务"><meta name="keywords" content="深度学习"><meta name="author" content="Met Guo"><meta name="copyright" content="Met Guo"><title>基于ResNet的树叶分类任务 | Gmet's Blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.8.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.8.2"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.2'
} </script><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Gmet's Blog" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">流程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%93%E6%9E%84"><span class="toc-number">3.</span> <span class="toc-text">结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#baseline"><span class="toc-number">4.</span> <span class="toc-text">baseline</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E5%8C%85"><span class="toc-number">4.1.</span> <span class="toc-text">导入包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86"><span class="toc-number">4.2.</span> <span class="toc-text">数据处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0Dataset"><span class="toc-number">4.3.</span> <span class="toc-text">实现Dataset</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0Dataloader"><span class="toc-number">4.4.</span> <span class="toc-text">实现Dataloader</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96GPU"><span class="toc-number">4.5.</span> <span class="toc-text">获取GPU</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.6.</span> <span class="toc-text">定义模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E8%B6%85%E5%8F%82%E6%95%B0"><span class="toc-number">4.7.</span> <span class="toc-text">定义超参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#train-amp-valid"><span class="toc-number">4.8.</span> <span class="toc-text">train&amp;valid</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%84%E6%B5%8B"><span class="toc-number">4.9.</span> <span class="toc-text">预测</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%94%B9%E8%BF%9B%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.</span> <span class="toc-text">改进模型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%8D%E6%80%9D"><span class="toc-number">6.</span> <span class="toc-text">反思</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">7.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Met Guo</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">38</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">31</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">32</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://images7.alphacoders.com/550/thumb-1920-550739.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Gmet's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/slides">Slides</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">基于ResNet的树叶分类任务</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-04-04</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">深度学习</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">动手学深度学习</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">2k</span><span class="post-meta__separator">|</span><span>阅读时长: 9 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>本文任务、数据集来源于《动手学深度学习》课程中的树叶分类竞赛。详见参考资料1</p>
<p>本文代码主要参考kaggle用户nekokiku给出的resnet baseline。详见参考资料2</p>
<p>通过本次竞赛和代码可以学习到：</p>
<ul>
<li>简单的PyTorch深度学习项目代码、结构是怎样的</li>
<li>如何继承PyTorch中的Dataset, DataLoader实现自己的Dataset, DataLoader类</li>
<li>如何使用PyTorch快速实现ResNet模型。</li>
</ul>
</blockquote>
<h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><p>分析baseline code，总结一下深度学习的代码流程。</p>
<ol>
<li>处理数据：包括元数据和图像数据。比如看看数据的样子，标签的分布，unique 标签的数量等。</li>
<li>实现自己的Dataset、DataLoader类</li>
<li>CPU OR GPU</li>
<li>定义模型</li>
<li>定义超参数：学习率等</li>
<li>train&amp;valid</li>
<li>使用训练好的模型进行预测。</li>
</ol>
<h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p>针对本次任务项目结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">leaves_classification_competition/</span><br><span class="line">└─data/</span><br><span class="line">    └─classify-leaves/</span><br><span class="line">        └─images/</span><br><span class="line">		└─train.csv</span><br><span class="line">		└─test.csv</span><br><span class="line">└─script.ipynb</span><br></pre></td></tr></table></figure>
<p><code>data/</code>目录下是本次任务用到的数据。将从kaggle上下载的数据压缩包解压到本文件夹。</p>
<p><code>script.ipynb</code>是代码脚本。</p>
<p>在更大的训练中，代码应该拆分为各种<code>.py</code>文件。</p>
<h1 id="baseline"><a href="#baseline" class="headerlink" title="baseline"></a>baseline</h1><h2 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 首先导入包</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset, DataLoader</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> torchvision.models <span class="keyword">as</span> models</span><br><span class="line"><span class="comment"># This is for the progress bar.</span></span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br></pre></td></tr></table></figure>
<h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><p>看一看train.csv长什么样</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DATA_BASE_PATH = <span class="string">&#x27;./data/classify-leaves/&#x27;</span></span><br><span class="line"><span class="comment"># label文件</span></span><br><span class="line">labels_df = pd.read_csv(os.path.join(DATA_BASE_PATH, <span class="string">&#x27;train.csv&#x27;</span>))</span><br><span class="line">labels_df.head()</span><br><span class="line"><span class="comment"># len(labels_df)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">labels_df.describe()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 把树叶的标签去重映射为数值</span></span><br><span class="line">leaves_labels = <span class="built_in">sorted</span>(<span class="built_in">list</span>(<span class="built_in">set</span>(labels_df[<span class="string">&#x27;label&#x27;</span>])))</span><br><span class="line">n_classes = <span class="built_in">len</span>(leaves_labels)</span><br><span class="line">class2num = <span class="built_in">dict</span>(<span class="built_in">zip</span>(leaves_labels, <span class="built_in">range</span>(n_classes)))</span><br><span class="line">class2num</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#x27;abies_concolor&#x27;: 0,</span><br><span class="line"> &#x27;abies_nordmanniana&#x27;: 1,</span><br><span class="line"> &#x27;acer_campestre&#x27;: 2,</span><br><span class="line">……</span><br><span class="line"> &#x27;zelkova_serrata&#x27;: 175&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 转换成key为数字，val为树叶类型，方便预测。</span></span><br><span class="line">num2class = &#123;v:k <span class="keyword">for</span> k, v <span class="keyword">in</span> class2num.items()&#125;</span><br><span class="line">num2class</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;0: &#x27;abies_concolor&#x27;,</span><br><span class="line"> 1: &#x27;abies_nordmanniana&#x27;,</span><br><span class="line"> 2: &#x27;acer_campestre&#x27;,</span><br><span class="line"> 3: &#x27;acer_ginnala&#x27;,</span><br><span class="line"> 4: &#x27;acer_griseum&#x27;,</span><br><span class="line">……</span><br><span class="line"> 175: &#x27;zelkova_serrata&#x27;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现Dataset"><a href="#实现Dataset" class="headerlink" title="实现Dataset"></a>实现Dataset</h2><p>继承Dataset类，实现自己的Dataset。继承之后，需要实现三个函数</p>
<ul>
<li><code>__init__</code>：传入必要的参数，初始化；</li>
<li><code>__getitem__</code>：返回item，如果是train或者valid则返回img和label，如果是test则返回img</li>
<li><code>__len__</code>：数据集长度</li>
<li>更多参见参考资料3</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 继承Dataset类。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LeaveDataSet</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, csv_path, img_path, mode=<span class="string">&#x27;train&#x27;</span>, valid_ratio = <span class="number">0.2</span>, resize_height = <span class="number">256</span>, resize_width = <span class="number">256</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">          csv_path: label文件路径</span></span><br><span class="line"><span class="string">          img_path: 图片存放路径</span></span><br><span class="line"><span class="string">          mode: 训练模式还是测试模式</span></span><br><span class="line"><span class="string">          valid_ratio: 验证集比例</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.img_path = img_path</span><br><span class="line">        self.mode = mode</span><br><span class="line">        self.data_info = pd.read_csv(csv_path)</span><br><span class="line">        self.data_len = <span class="built_in">len</span>(self.data_info)</span><br><span class="line">        self.train_len = <span class="built_in">int</span>(self.data_len * (<span class="number">1</span> - valid_ratio))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> mode == <span class="string">&#x27;train&#x27;</span>:</span><br><span class="line">            <span class="comment"># 为啥要转成nparray</span></span><br><span class="line">            self.train_image = np.asarray(self.data_info.iloc[:self.train_len, <span class="number">0</span>])</span><br><span class="line">            self.train_label = np.asarray(self.data_info.iloc[:self.train_len, <span class="number">1</span>])</span><br><span class="line">            <span class="comment"># 为了在不同模式下统一变量</span></span><br><span class="line">            self.image_arr = self.train_image</span><br><span class="line">            self.label_arr = self.train_label</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> mode == <span class="string">&#x27;valid&#x27;</span>:</span><br><span class="line">            self.valid_image = np.asarray(self.data_info.iloc[self.train_len:,<span class="number">0</span>])</span><br><span class="line">            self.valid_label = np.asarray(self.data_info.iloc[self.train_len:,<span class="number">1</span>])</span><br><span class="line">            self.image_arr = self.valid_image</span><br><span class="line">            self.label_arr = self.valid_label</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.test_image = np.asarray(self.data_info.iloc[:,<span class="number">0</span>])</span><br><span class="line">            self.image_arr = self.test_image</span><br><span class="line">            <span class="comment">#test 没有label</span></span><br><span class="line">        self.real_len = <span class="built_in">len</span>(self.image_arr)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Finished reading the &#123;&#125; set of Leaves Dataset. (&#123;&#125; samples found)&quot;</span>.<span class="built_in">format</span>(mode, self.real_len))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, index</span>):</span><br><span class="line"></span><br><span class="line">        single_image_name = self.image_arr[index]</span><br><span class="line">        img_as_img = Image.<span class="built_in">open</span>(os.path.join(self.img_path, single_image_name))</span><br><span class="line">        <span class="keyword">if</span> self.mode == <span class="string">&#x27;train&#x27;</span>:</span><br><span class="line">            transform = transforms.Compose([</span><br><span class="line">                transforms.Resize((<span class="number">224</span>, <span class="number">224</span>)),</span><br><span class="line">                transforms.RandomHorizontalFlip(p=<span class="number">0.5</span>),   <span class="comment">#随机水平翻转 选择一个概率</span></span><br><span class="line">                transforms.ToTensor()</span><br><span class="line">            ])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># valid和test不做数据增强</span></span><br><span class="line">            transform = transforms.Compose([</span><br><span class="line">                transforms.Resize((<span class="number">224</span>, <span class="number">224</span>)),</span><br><span class="line">                transforms.ToTensor()</span><br><span class="line">            ])</span><br><span class="line">        img_as_img = transform(img_as_img)</span><br><span class="line">        <span class="comment"># 先不做图像裁剪，增强和灰度处理</span></span><br><span class="line">        <span class="keyword">if</span> self.mode == <span class="string">&#x27;test&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> img_as_img</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            label = self.label_arr[index]</span><br><span class="line">            <span class="comment"># label转数字</span></span><br><span class="line">            number_label = class2num[label]</span><br><span class="line">            <span class="keyword">return</span> img_as_img, number_label</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.real_len</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">生成dataset对象</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">train_csv_path = <span class="string">&#x27;./data/classify-leaves/train.csv&#x27;</span></span><br><span class="line">test_csv_path = <span class="string">&#x27;./data/classify-leaves/test.csv&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># csv文件中已经images的路径了，因此这里只到上一级目录</span></span><br><span class="line"></span><br><span class="line">img_path = <span class="string">&#x27;./data/classify-leaves/&#x27;</span></span><br><span class="line"></span><br><span class="line">train_dataset = LeaveDataSet(train_csv_path, img_path, mode=<span class="string">&#x27;train&#x27;</span>)</span><br><span class="line">test_dataset = LeaveDataSet(train_csv_path, img_path, mode=<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line">valid_dataset = LeaveDataSet(train_csv_path, img_path, mode=<span class="string">&#x27;valid&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Finished reading the train set of Leaves Dataset (14681 samples found)</span><br><span class="line">Finished reading the test set of Leaves Dataset (18353 samples found)</span><br><span class="line">Finished reading the valid set of Leaves Dataset (3672 samples found)</span><br></pre></td></tr></table></figure>
<h2 id="实现Dataloader"><a href="#实现Dataloader" class="headerlink" title="实现Dataloader"></a>实现Dataloader</h2><p>定义train，valid，test的dataloader，参数详见参考资料4</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义 data loader</span></span><br><span class="line"><span class="comment"># dataloader 参数详解：https://blog.csdn.net/qq_36653505/article/details/84728855</span></span><br><span class="line"></span><br><span class="line">train_loader = DataLoader(</span><br><span class="line">    dataset=train_dataset,</span><br><span class="line">    batch_size=<span class="number">8</span>,</span><br><span class="line">    shuffle=<span class="literal">False</span>,</span><br><span class="line">    num_workers=<span class="number">5</span> <span class="comment"># 使用nums_workers个线程读数据</span></span><br><span class="line">)</span><br><span class="line">valid_loader = DataLoader(</span><br><span class="line">    dataset=valid_dataset,</span><br><span class="line">    batch_size=<span class="number">8</span>,</span><br><span class="line">    shuffle=<span class="literal">False</span>,</span><br><span class="line">    num_workers=<span class="number">5</span></span><br><span class="line">)</span><br><span class="line">test_loader = DataLoader(</span><br><span class="line">    dataset=test_dataset,</span><br><span class="line">    batch_size=<span class="number">8</span>,</span><br><span class="line">    shuffle=<span class="literal">False</span>,</span><br><span class="line">    num_workers=<span class="number">5</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h2 id="获取GPU"><a href="#获取GPU" class="headerlink" title="获取GPU"></a>获取GPU</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># CPU OR GPU</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_device</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;cuda&#x27;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&#x27;cpu&#x27;</span></span><br><span class="line"></span><br><span class="line">device = get_device()</span><br><span class="line"><span class="built_in">print</span>(device)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cuda</span><br></pre></td></tr></table></figure>
<h2 id="定义模型"><a href="#定义模型" class="headerlink" title="定义模型"></a>定义模型</h2><p>这里模型使用resnet34</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义resnet34</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">num_classes: 传入分类任务的类别数，由上面的数据可知，一共有176种树叶，所以一会调用该函数返回模型时，传入的num_classes参数为176</span></span><br><span class="line"><span class="string">use_pretrained: 是否使用预训练模型。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">res_model</span>(<span class="params">num_classes, feature_extract = <span class="literal">False</span>, use_pretrained = <span class="literal">False</span></span>):</span><br><span class="line">    model_ft = models.resnet34(pretrained=use_pretrained)</span><br><span class="line">    <span class="comment"># set_parameter_requires_grad(model_ft, feature_extract)</span></span><br><span class="line">    <span class="comment"># 这里是想要把原始模型的最后一层全连接层替换掉，替换成输出类别为num_classes的全连接层。</span></span><br><span class="line">    <span class="comment"># 为了做到这一点我们需要先知道原始模型的全连接层的输入feature维度。</span></span><br><span class="line">    num_ftrs = model_ft.fc.in_features</span><br><span class="line">    model_ft.fc = nn.Sequential(nn.Linear(num_ftrs, num_classes))</span><br><span class="line">    <span class="keyword">return</span> model_ft</span><br></pre></td></tr></table></figure>
<h2 id="定义超参数"><a href="#定义超参数" class="headerlink" title="定义超参数"></a>定义超参数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 超参数</span></span><br><span class="line">lr = <span class="number">3e-4</span> <span class="comment">#学习率</span></span><br><span class="line">weight_decay = <span class="number">1e-3</span></span><br><span class="line">num_epoch = <span class="number">50</span> <span class="comment">#迭代轮数</span></span><br><span class="line">model_path = <span class="string">&#x27;./pre_res_model.ckpt&#x27;</span> <span class="comment"># 模型保存位置</span></span><br></pre></td></tr></table></figure>
<h2 id="train-amp-valid"><a href="#train-amp-valid" class="headerlink" title="train&amp;valid"></a>train&amp;valid</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 模型初始化，并放到具体的设备中</span></span><br><span class="line">model = res_model(<span class="number">176</span>)</span><br><span class="line"><span class="comment"># 将模型放到device上。</span></span><br><span class="line">model = model.to(device)</span><br><span class="line">model.device = device <span class="comment"># 这行代码貌似没什么用</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分类任务使用交叉熵损失作为评估标准</span></span><br><span class="line">criterion = nn.CrossEntropyLoss()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Adam优化器</span></span><br><span class="line">optimizer = torch.optim.Adam(model.parameters(), lr = lr, weight_decay= weight_decay)</span><br><span class="line"></span><br><span class="line">n_epochs = num_epoch</span><br><span class="line"></span><br><span class="line">best_acc = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(n_epochs):</span><br><span class="line">    <span class="comment"># ------- train --------</span></span><br><span class="line">    <span class="comment"># 训练的时候，要调用该函数，使模型处于训练模式</span></span><br><span class="line">    model.train()</span><br><span class="line">    <span class="comment"># 记录每次使用一个batch训练后，模型的损失和精确率。</span></span><br><span class="line">    train_loss = []</span><br><span class="line">    train_accs = []</span><br><span class="line">    <span class="comment"># tqdm是一个显示进度条的工具包，不用管。</span></span><br><span class="line">    <span class="keyword">for</span> batch <span class="keyword">in</span> tqdm(train_loader):</span><br><span class="line">        <span class="comment"># A batch consists of image data and corresponding labels.</span></span><br><span class="line">        imgs, labels = batch</span><br><span class="line">        <span class="comment"># 把数据都放到同一个device上</span></span><br><span class="line">        imgs = imgs.to(device)</span><br><span class="line">        labels = labels.to(device)</span><br><span class="line"></span><br><span class="line">        logits = model(imgs)</span><br><span class="line">        <span class="comment"># 计算模型输出和真实label之间的损失，反向传播。。</span></span><br><span class="line">        loss = criterion(logits, labels)</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">        <span class="comment">#这行code不是很懂，大概就是统计预测正确标签的占比</span></span><br><span class="line">        <span class="comment"># 弄明白：https://csbwang.github.io/dl_ch2#2161</span></span><br><span class="line">        acc = (logits.argmax(dim = -<span class="number">1</span>) == labels).<span class="built_in">float</span>().mean()</span><br><span class="line">        </span><br><span class="line">        train_loss.append(loss.item())</span><br><span class="line">        train_accs.append(acc)</span><br><span class="line">    <span class="comment"># 计算本次epoch后的loss和acc</span></span><br><span class="line">    train_loss = <span class="built_in">sum</span>(train_loss) / <span class="built_in">len</span>(train_loss)</span><br><span class="line">    train_acc = <span class="built_in">sum</span>(train_accs) / <span class="built_in">len</span>(train_accs)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;[ Train | <span class="subst">&#123;epoch + <span class="number">1</span>:03d&#125;</span>/<span class="subst">&#123;n_epochs:03d&#125;</span> ] loss = <span class="subst">&#123;train_loss:<span class="number">.5</span>f&#125;</span>, acc = <span class="subst">&#123;train_acc:<span class="number">.5</span>f&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="comment"># ------- valid --------</span></span><br><span class="line">    <span class="comment"># 验证时，把模型调成评估模式</span></span><br><span class="line">    model.<span class="built_in">eval</span>()  <span class="comment"># eval具体是做什么?</span></span><br><span class="line"></span><br><span class="line">    valid_loss = []</span><br><span class="line">    valid_accs = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> batch <span class="keyword">in</span> tqdm(valid_loader):</span><br><span class="line">        imgs, labels = batch</span><br><span class="line">        <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">            logits = model(imgs.to(device))</span><br><span class="line">        loss = criterion(logits, labels.to(device))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># acc = (logits.argmax(dim = -1) == labels).float().mean()</span></span><br><span class="line">        acc = (logits.argmax(dim = -<span class="number">1</span>) == labels.to(device)).<span class="built_in">float</span>().mean()</span><br><span class="line"></span><br><span class="line">        valid_loss.append(loss.item())</span><br><span class="line">        valid_accs.append(acc)</span><br><span class="line">    </span><br><span class="line">    valid_loss = <span class="built_in">sum</span>(valid_loss) / <span class="built_in">len</span>(valid_loss)</span><br><span class="line">    valid_acc = <span class="built_in">sum</span>(valid_accs) / <span class="built_in">len</span>(valid_accs)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;[ Valid | <span class="subst">&#123;epoch + <span class="number">1</span>:03d&#125;</span>/<span class="subst">&#123;n_epochs:03d&#125;</span> ] loss = <span class="subst">&#123;valid_loss:<span class="number">.5</span>f&#125;</span>, acc = <span class="subst">&#123;valid_acc:<span class="number">.5</span>f&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果在验证集得到的acc大于已知最好的acc，则保存模型。</span></span><br><span class="line">    <span class="keyword">if</span> valid_acc &gt; best_acc:</span><br><span class="line">        best_acc = valid_acc</span><br><span class="line">        torch.save(model.state_dict(), model_path)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;saving model with acc &#123;:.3f&#125;&#x27;</span>.<span class="built_in">format</span>(best_acc))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>//控制台输出</p>
<h2 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h2><p>上面就是训练过程，下面用训练好的模型进行预测</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">################ </span></span><br><span class="line">saveFileName = <span class="string">&#x27;./data/classify-leaves/submission.csv&#x27;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## predict</span></span><br><span class="line">model = res_model(<span class="number">176</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># create model and load weights from checkpoint</span></span><br><span class="line">model = model.to(device)</span><br><span class="line">model.load_state_dict(torch.load(model_path))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Make sure the model is in eval mode.</span></span><br><span class="line"><span class="comment"># Some modules like Dropout or BatchNorm affect if the model is in training mode.</span></span><br><span class="line">model.<span class="built_in">eval</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Initialize a list to store the predictions.</span></span><br><span class="line">predictions = []</span><br><span class="line"><span class="comment"># Iterate the testing set by batches.</span></span><br><span class="line"><span class="keyword">for</span> batch <span class="keyword">in</span> tqdm(test_loader):</span><br><span class="line">    </span><br><span class="line">    imgs = batch</span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        logits = model(imgs.to(device))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Take the class with greatest logit as prediction and record it.</span></span><br><span class="line">    predictions.extend(logits.argmax(dim=-<span class="number">1</span>).cpu().numpy().tolist())</span><br><span class="line"></span><br><span class="line">preds = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> predictions:</span><br><span class="line">    preds.append(num2class[i])</span><br><span class="line"></span><br><span class="line">test_data = pd.read_csv(test_path)</span><br><span class="line">test_data[<span class="string">&#x27;label&#x27;</span>] = pd.Series(preds)</span><br><span class="line">submission = pd.concat([test_data[<span class="string">&#x27;image&#x27;</span>], test_data[<span class="string">&#x27;label&#x27;</span>]], axis=<span class="number">1</span>)</span><br><span class="line">submission.to_csv(saveFileName, index=<span class="literal">False</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Done!!!!!!!!!!!!!!!!!!!!!!!!!!!&quot;</span>)</span><br></pre></td></tr></table></figure>
<h1 id="改进模型"><a href="#改进模型" class="headerlink" title="改进模型"></a>改进模型</h1><p>//TODO</p>
<h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>初学深度学习，代码上犯了很多细节上的错误。其次，很多细节问题不明白，例如，优化器？各种计算公式等。以后要弄懂。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1z64y1o7iz">第二部分完结竞赛：图片分类【动手学深度学习v2】</a></li>
<li><a target="_blank" rel="noopener" href="https://www.kaggle.com/code/nekokiku/simple-resnet-baseline">nekokiku/simple-resnet-baseline</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/leviopku/article/details/99958182">Pytorch中的dataset类——创建适应任意模型的数据集接口</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36653505/article/details/84728855">Pytorch 中的数据类型 torch.utils.data.DataLoader 参数详解</a></li>
</ol>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Met Guo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://gmet233.gitee.io/2022/04/04/%E5%9F%BA%E4%BA%8EResNet%E7%9A%84%E6%A0%91%E5%8F%B6%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/">https://gmet233.gitee.io/2022/04/04/%E5%9F%BA%E4%BA%8EResNet%E7%9A%84%E6%A0%91%E5%8F%B6%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://gmet233.gitee.io">Gmet's Blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">深度学习</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2022/04/11/test-slides/"><i class="fa fa-chevron-left">  </i><span>test_slides</span></a></div><div class="next-post pull-right"><a href="/2022/03/29/%E5%A4%8D%E7%8E%B0ResNet50%EF%BC%88PyTorch%EF%BC%89/"><span>复现ResNet50（PyTorch）</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://images7.alphacoders.com/550/thumb-1920-550739.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2021 - 2022 By Met Guo</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.8.2"></script><script src="/js/fancybox.js?version=1.8.2"></script><script src="/js/sidebar.js?version=1.8.2"></script><script src="/js/copy.js?version=1.8.2"></script><script src="/js/fireworks.js?version=1.8.2"></script><script src="/js/transition.js?version=1.8.2"></script><script src="/js/scroll.js?version=1.8.2"></script><script src="/js/head.js?version=1.8.2"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>