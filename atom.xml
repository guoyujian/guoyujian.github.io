<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Gmet&#39;s Blog</title>
  
  <subtitle>Eureka!</subtitle>
  <link href="https://gmet233.gitee.io/atom.xml" rel="self"/>
  
  <link href="https://gmet233.gitee.io/"/>
  <updated>2021-12-26T14:28:34.124Z</updated>
  <id>https://gmet233.gitee.io/</id>
  
  <author>
    <name>Met Guo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LRU: 缓存淘汰算法</title>
    <link href="https://gmet233.gitee.io/2021/12/26/LRU-%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95/"/>
    <id>https://gmet233.gitee.io/2021/12/26/LRU-%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95/</id>
    <published>2021-12-26T11:54:01.000Z</published>
    <updated>2021-12-26T14:28:34.124Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在使用缓存时，由于缓存容量有限，当缓存容量到达上限，就需要删除部分数据挪出空间。但是缓存数据不能随机删除，一般情况下需要根据某种算法删除缓存数据。</p><p>常用的淘汰算法有LRU, LFU, FIFO，本篇介绍LRU算法并重点讲述LRU的实现。完整代码也是<a href="https://leetcode-cn.com/problems/lru-cache/">LeetCode 146. LRU缓存</a>的答案。</p><h1 id="LRU-简介"><a href="#LRU-简介" class="headerlink" title="LRU 简介"></a>LRU 简介</h1><p>LRU是Least recently used的缩写，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。当缓存容量满的时候，优先淘汰最近最少被使用的数据。</p><p>根据以上策略，给出使用LRU淘汰算法时的示例。</p><p><img src="/LRU-%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95/v2-584ed398c35ba76250cfb2f01b20ec0c_720w.jpg" alt="LRU淘汰算法示例"></p><p>通过上图可以看到LRU算法的具体步骤是：</p><ol><li>新数据直接插入到列表头部</li><li>缓存数据被命中，将数据移动到链表头部</li><li>缓存已满，移除列表尾部数据。</li></ol><h1 id="LRU-算法实现"><a href="#LRU-算法实现" class="headerlink" title="LRU 算法实现"></a>LRU 算法实现</h1><p>上面看到LRU算法需要添加头节点，删除尾节点。而链表添加/删除节点的时间复杂度为O(1)，但这里不能使用普通的单向链表，原因在于：</p><ul><li>虽然单向链表添加/删除/移动元素比较方便，但是再查询元素时的时间复杂度为O(N)</li><li>移动中间节点到头节点需要知道前一个节点和后一个节点的信息，单向链表就不得不再次遍历获取信息。</li></ul><p>针对以上问题的解决方案是：</p><ul><li>使用散列表存储节点，获取节点的复杂度将为O(1)，</li><li>使用双向链表用来获得前驱节点的信息。</li></ul><p><img src="/LRU-%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95/image-20211226215652530.png" alt="LRU数据结构"></p><p>在这里，增加了两个【哨兵】节点，不用来存储任何数据，目的是再增加、删除结点的时候不用考虑节点不存在的情况。简化编程难度。</p><p>在算法实现的过程中，我发现LeetCode 146是类似的题目，故把该题直接拿来使用。</p><p>该题的算法签名是</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(key);</span></span><br><span class="line"><span class="comment"> * obj.put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>通过调用put\get方法实现存取缓存的目的。下面是对代码的逐步分析。</p><h2 id="双向链表数据结构"><a href="#双向链表数据结构" class="headerlink" title="双向链表数据结构"></a>双向链表数据结构</h2><p>这里使用一个内部类作为双向链表的数据结构。比较简单，直接给出代码。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">//定义一个内部类，作为缓存列表</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span></span>&#123;</span><br><span class="line">       <span class="keyword">public</span> Entry pre; <span class="comment">//指向前驱的指针</span></span><br><span class="line">       <span class="keyword">public</span> Entry next; <span class="comment">//指向后继的指针</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">int</span> key; <span class="comment">//缓存的key</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">int</span> value; <span class="comment">//缓存的value</span></span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">Entry</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.key = key;</span><br><span class="line">           <span class="keyword">this</span>.value = value;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">Entry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="定义成员变量和构造函数"><a href="#定义成员变量和构造函数" class="headerlink" title="定义成员变量和构造函数"></a>定义成员变量和构造函数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Entry head, tail; <span class="comment">//头尾两个哨兵节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> capacity; <span class="comment">// 容量</span></span><br><span class="line"><span class="keyword">int</span> size; <span class="comment">//当前缓存大小</span></span><br><span class="line">Map&lt;Integer, Entry&gt; cache; <span class="comment">//缓存散列表</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    <span class="comment">//初始化操作</span></span><br><span class="line">    initLinkedList();</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    cache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化操作函数<code>initLinkedList()</code>的实现是将head和tail通过指针连接起来。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       head = <span class="keyword">new</span> Entry();</span><br><span class="line">       tail = <span class="keyword">new</span> Entry();</span><br><span class="line"></span><br><span class="line">       head.next = tail;</span><br><span class="line">       tail.pre = head;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="put操作"><a href="#put操作" class="headerlink" title="put操作"></a>put操作</h2><p>put操作可以分三种情况：</p><ol><li>如果key已经存在与缓存中，则将key对应的节点移动到链表头部，并重设value</li><li>如果key在缓存中不存在，那么检查缓存是否已满<ol><li>如果未满，就直接将新节点加入到链表头部</li><li>如果已满，就先删除尾节点，再将新节点加入到链表头部</li></ol></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    Entry node = cache.get(key);</span><br><span class="line">    <span class="comment">//如果key在缓存中已经存在，则移动到头部</span></span><br><span class="line">    <span class="keyword">if</span>(node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.value = value;</span><br><span class="line">        move2Head(node);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//容量已满先删除尾节点</span></span><br><span class="line">    <span class="keyword">if</span>(size == capacity) &#123;</span><br><span class="line">        Entry lastNode = tail.pre;</span><br><span class="line">        deleteNode(lastNode);</span><br><span class="line">        cache.remove(lastNode.key);</span><br><span class="line">        size --;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//add new Node</span></span><br><span class="line">    Entry newNode = <span class="keyword">new</span> Entry();</span><br><span class="line">    newNode.key = key;</span><br><span class="line">    newNode.value = value;</span><br><span class="line">    addNode(newNode);</span><br><span class="line">    cache.put(key, newNode);</span><br><span class="line">    size ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于<code>move2Head</code>操作，无非是先删除原来的节点关系<code>deleteNode</code>，再添加到队列头部<code>addNode</code></p><p>而<code>deleteNode</code>和<code>addNode</code>是比较基础的双向链表操作，这里就不再做过多解释。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addNode</span><span class="params">(Entry node)</span> </span>&#123;</span><br><span class="line">    head.next.pre = node;</span><br><span class="line">    node.next = head.next;</span><br><span class="line"></span><br><span class="line">    node.pre = head;</span><br><span class="line">    head.next = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(Entry node)</span> </span>&#123;</span><br><span class="line">    node.pre.next = node.next;</span><br><span class="line">    node.next.pre = node.pre;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">move2Head</span><span class="params">(Entry node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//删除原来的节点关系</span></span><br><span class="line">    deleteNode(node);</span><br><span class="line">    addNode(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="get-操作"><a href="#get-操作" class="headerlink" title="get 操作"></a>get 操作</h2><p>当key不在缓存中，返回-1，当key存在于缓存时，就将该元素移动到链表头部，并返回对应的value。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">       Entry node = cache.get(key);</span><br><span class="line">       <span class="keyword">if</span>(node == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       move2Head(node);</span><br><span class="line">       <span class="keyword">return</span> node.value;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Entry head, tail;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity; <span class="comment">// 容量</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    Map&lt;Integer, Entry&gt; cache;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        <span class="comment">//初始化操作</span></span><br><span class="line">        initLinkedList();</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        cache = <span class="keyword">new</span> HashMap&lt;&gt;(capacity + <span class="number">2</span>); <span class="comment">//这里为什么要+2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        head = <span class="keyword">new</span> Entry();</span><br><span class="line">        tail = <span class="keyword">new</span> Entry();</span><br><span class="line"></span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.pre = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        Entry node = cache.get(key);</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        move2Head(node);</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将节点插入到头节点，如果容量已满，则会删除尾节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        Entry node = cache.get(key);</span><br><span class="line">        <span class="comment">//如果key在缓存中已经存在，则移动到头部</span></span><br><span class="line">        <span class="keyword">if</span>(node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.value = value;</span><br><span class="line">            move2Head(node);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//容量已满先删除尾节点</span></span><br><span class="line">        <span class="keyword">if</span>(size == capacity) &#123;</span><br><span class="line">            Entry lastNode = tail.pre;</span><br><span class="line">            deleteNode(lastNode);</span><br><span class="line">            cache.remove(lastNode.key);</span><br><span class="line">            size --;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//add new Node</span></span><br><span class="line">        Entry newNode = <span class="keyword">new</span> Entry();</span><br><span class="line">        newNode.key = key;</span><br><span class="line">        newNode.value = value;</span><br><span class="line">        addNode(newNode);</span><br><span class="line">        cache.put(key, newNode);</span><br><span class="line">        size ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addNode</span><span class="params">(Entry node)</span> </span>&#123;</span><br><span class="line">        head.next.pre = node;</span><br><span class="line">        node.next = head.next;</span><br><span class="line"></span><br><span class="line">        node.pre = head;</span><br><span class="line">        head.next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(Entry node)</span> </span>&#123;</span><br><span class="line">        node.pre.next = node.next;</span><br><span class="line">        node.next.pre = node.pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">move2Head</span><span class="params">(Entry node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//删除原来的节点关系</span></span><br><span class="line">        deleteNode(node);</span><br><span class="line">        addNode(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个内部类，作为缓存链表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> Entry pre; <span class="comment">//指向前驱的指针</span></span><br><span class="line">        <span class="keyword">public</span> Entry next; <span class="comment">//指向后继的指针</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> key; <span class="comment">//缓存的key</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value; <span class="comment">//缓存的value</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Entry</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Entry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://www.bilibili.com/video/BV1Va411677h">手写LRU算法 - IT老哥</a></li><li><a href="https://zhuanlan.zhihu.com/p/34133067">LRU原理和Redis实现——一个今日头条的面试题</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在使用缓存时，由于缓存容量有限，当缓存容量到达上限，就需要删除部分数据挪出空间。但是缓存数据不能随机删除，一般情况下需要根据某种算法删除缓存</summary>
      
    
    
    
    <category term="操作系统" scheme="https://gmet233.gitee.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="数据结构与算法" scheme="https://gmet233.gitee.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="操作系统" scheme="https://gmet233.gitee.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Tmux 简介</title>
    <link href="https://gmet233.gitee.io/2021/12/26/Tmux-%E7%AE%80%E4%BB%8B/"/>
    <id>https://gmet233.gitee.io/2021/12/26/Tmux-%E7%AE%80%E4%BB%8B/</id>
    <published>2021-12-26T03:07:45.000Z</published>
    <updated>2021-12-26T03:09:25.529Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是Tmux"><a href="#什么是Tmux" class="headerlink" title="什么是Tmux"></a>什么是Tmux</h1><p>打开一个终端窗口（terminal window，以下简称”窗口”），在里面输入命令。</p><p>用户与计算机的这种临时的交互，称为一次”会话”（session） 。</p><p>会话的一个重要特点是，窗口与其中启动的进程是<a href="https://www.ruanyifeng.com/blog/2016/02/linux-daemon.html">连在一起</a>的。打开窗口，会话开始；关闭窗口，会话结束。</p><p>一个典型的例子，打开一个远程窗口执行命令，这时关闭窗口，那么会话也就终止，里面的进程也随之终止。</p><p>为了解决这个问题，会话与窗口可以”解绑”：窗口关闭时，会话并不终止，而是继续运行，等到以后需要的时候，再让会话”绑定”其他窗口。</p><p><strong>Tmux 就是会话与窗口的”解绑”工具</strong>。</p><h1 id="使用Tmux"><a href="#使用Tmux" class="headerlink" title="使用Tmux"></a>使用Tmux</h1><h2 id="安装Tmux"><a href="#安装Tmux" class="headerlink" title="安装Tmux"></a>安装Tmux</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Ubuntu 或 Debian</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install tmux</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> CentOS 或 Fedora</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo yum install tmux</span></span><br></pre></td></tr></table></figure><h2 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h2><p>直接给出最常用的操作流程如下：</p><ul><li>新建会话<code>tmux new -s &lt;session_name&gt;</code>。（第一个启动的 Tmux 窗口，编号是0，第二个窗口的编号是1，以此类推。）</li><li>在 Tmux 窗口运行所需的程序。</li><li>按下快捷键<code>Ctrl+b d</code>将会话分离。</li><li>下次使用时，重新连接到会话<code>tmux a -t &lt;session_name&gt;</code>。</li></ul><h2 id="其他Tricks"><a href="#其他Tricks" class="headerlink" title="其他Tricks"></a>其他Tricks</h2><ul><li><code>Ctrl+b s</code>：列出所有会话。</li><li><code>tmux rename-session -t 0 &lt;new-name&gt;</code>：重命名会话。</li><li><code>tmux kill-session -t &lt;session-name&gt;</code>：杀死会话。</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://www.ruanyifeng.com/blog/2019/10/tmux.html">Tmux 使用教程</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是Tmux&quot;&gt;&lt;a href=&quot;#什么是Tmux&quot; class=&quot;headerlink&quot; title=&quot;什么是Tmux&quot;&gt;&lt;/a&gt;什么是Tmux&lt;/h1&gt;&lt;p&gt;打开一个终端窗口（terminal window，以下简称”窗口”），在里面输入命令。&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="Linux" scheme="https://gmet233.gitee.io/categories/Linux/"/>
    
    <category term="开发工具" scheme="https://gmet233.gitee.io/categories/Linux/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="Linux" scheme="https://gmet233.gitee.io/tags/Linux/"/>
    
    <category term="开发工具" scheme="https://gmet233.gitee.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>火车站台数量问题</title>
    <link href="https://gmet233.gitee.io/2021/12/25/%E7%81%AB%E8%BD%A6%E7%AB%99%E5%8F%B0%E6%95%B0%E9%87%8F%E9%97%AE%E9%A2%98/"/>
    <id>https://gmet233.gitee.io/2021/12/25/%E7%81%AB%E8%BD%A6%E7%AB%99%E5%8F%B0%E6%95%B0%E9%87%8F%E9%97%AE%E9%A2%98/</id>
    <published>2021-12-25T13:34:56.000Z</published>
    <updated>2021-12-25T13:39:27.993Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题干"><a href="#题干" class="headerlink" title="题干"></a>题干</h1><p>假设已知某个火车站的所有过往列车的到达arrival和离开departure时间（同一天），如果要求所有列车都不等待直接进站，问至少需要多少个站台。无需考虑晚点等特殊情况。</p><p>例如，<br> Input：<br> 到达时间：  arr[]  = {9:00,  9:40, 9:50,  11:00, 15:00, 18:00}<br> 离开时间：  dep[]  = {9:10, 12:00, 11:20, 11:30, 19:00, 20:00}</p><p><em>注：方便起见，输入为int，例如：9:00的输入是900</em></p><p>Output：<br> 3  （最多有3辆列车同时进站（在11:00到11:20之间））</p><h1 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h1><p>暴力解法。逐个检查每个车辆的<strong>停发时间段</strong>，然后看有多少个时间段区间与其有重合，记录最多的重合区间数目，即为待求解的答案。易知，此方法的时间复杂度为O(n^2)。</p><p>下面给出代码，<em>代码只经过简单测试，如有误请通过邮箱联系我</em></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"><span class="keyword">from</span> traitlets <span class="keyword">import</span> Int</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxPlatform</span>(<span class="params">self, arr: <span class="type">List</span>[Int], dep: <span class="type">List</span>[Int]</span>) -&gt; Int:</span></span><br><span class="line">        n = <span class="built_in">len</span>(arr)</span><br><span class="line">        max_platform = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            now_platform = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> dep[i] &gt; arr[j]:</span><br><span class="line">                    now_platform += <span class="number">1</span></span><br><span class="line">                max_platform = <span class="built_in">max</span>(max_platform, now_platform)</span><br><span class="line">        <span class="keyword">return</span> max_platform</span><br></pre></td></tr></table></figure><h1 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h1><p>将所有的<strong>事件</strong> (到达或离开)按时间顺序排序，然后只记录当前还在车站（未离开的）列车。所有时间点中最多数量列车即待求解的答案。该解法的时间复杂度为O(n·logn)</p><p>例如上述出发到达时间排序得到下表：</p><table><thead><tr><th>时间</th><th>事件</th><th>站台数</th></tr></thead><tbody><tr><td>9:00</td><td>Arrival</td><td>1</td></tr><tr><td>9:10</td><td>Departure</td><td>0</td></tr><tr><td>9:40</td><td>Arrival</td><td>1</td></tr><tr><td>9:50</td><td>Arrival</td><td>2</td></tr><tr><td>11:00</td><td>Arrival</td><td><strong>3</strong></td></tr><tr><td>11:20</td><td>Departure</td><td>2</td></tr><tr><td>11:30</td><td>Departure</td><td>1</td></tr><tr><td>12:00</td><td>Departure</td><td>0</td></tr><tr><td>15:00</td><td>Arrival</td><td>1</td></tr><tr><td>18:00</td><td>Arrival</td><td>2</td></tr><tr><td>19:00</td><td>Departure</td><td>1</td></tr><tr><td>20:00</td><td>Departure</td><td>0</td></tr></tbody></table><p>最多需要3站台。</p><p>在算法实现时，只需要对arr、dep数组单独排序，然后在进行有序数组的归并排序。下面给出代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPlatform</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span>[] dep)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        Arrays.sort(dep); <span class="comment">//分别对到达和离开排序</span></span><br><span class="line">        <span class="keyword">int</span> numPlatform = <span class="number">0</span>, maxPlatform = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; <span class="comment">//两个指针</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; n || j &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; n &amp;&amp; j &lt; n) &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i] &lt; dep[j]) &#123;</span><br><span class="line">                    numPlatform++;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(arr[i] &gt; dep[j])&#123;</span><br><span class="line">                    numPlatform--;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(j&gt;=n) &#123; <span class="comment">// 此时还将继续有火车进站</span></span><br><span class="line">                numPlatform++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 此时只有火车出站</span></span><br><span class="line">                numPlatform--;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            maxPlatform = Math.max(maxPlatform, numPlatform);</span><br><span class="line"><span class="comment">//            System.out.println(numPlatform);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxPlatform;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这是之前遇到的一道面试题，挺巧妙的。当时没做出来，故做一个小结。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://www.jianshu.com/p/3948fda91d3d">火车站台数量问题</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题干&quot;&gt;&lt;a href=&quot;#题干&quot; class=&quot;headerlink&quot; title=&quot;题干&quot;&gt;&lt;/a&gt;题干&lt;/h1&gt;&lt;p&gt;假设已知某个火车站的所有过往列车的到达arrival和离开departure时间（同一天），如果要求所有列车都不等待直接进站，问至少需要多少</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://gmet233.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://gmet233.gitee.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Java-初识注解</title>
    <link href="https://gmet233.gitee.io/2021/12/23/Java-%E5%88%9D%E8%AF%86%E6%B3%A8%E8%A7%A3/"/>
    <id>https://gmet233.gitee.io/2021/12/23/Java-%E5%88%9D%E8%AF%86%E6%B3%A8%E8%A7%A3/</id>
    <published>2021-12-23T12:45:17.000Z</published>
    <updated>2021-12-26T14:28:23.961Z</updated>
    
    <content type="html"><![CDATA[<h1 id="初识注解"><a href="#初识注解" class="headerlink" title="初识注解"></a>初识注解</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>Annotation提供了一种为恒旭元素设置元数据的方法。</li><li>类似于修饰符，可用于修饰包、类、构造器、方法、成员变量、参数、局部变量的声明。</li><li>Annotation是一个接口，程序可以通过反射来获取指定程序元素的Annotation对象。</li><li>Annotation不影响程序代码的运行。</li><li>如果希望Annotation在程序运行时起作用，只有通过某种配套工具对Annotation的信息进行访问和处理。访问和处理Annotation的工具统称为APT。</li></ul><h2 id="内置注解"><a href="#内置注解" class="headerlink" title="内置注解"></a>内置注解</h2><p>Java定义了一套注解如下。</p><ul><li>以下注解在java.lang中：<ul><li><strong>@Override</strong> - 检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。</li><li><strong>@Deprecated</strong> - 标记过时方法。如果使用该方法，会报编译警告。</li><li><strong>@SuppressWarnings</strong> - 指示编译器去忽略注解中声明的警告。</li><li>@SafeVarargs - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。</li><li><strong>@FunctionalInterface</strong> - Java 8 开始支持，标识一个匿名函数或函数式接口。</li></ul></li><li>以下注解在java.lang.annotation中，他们作用在其他注解中，也成为<strong>元注解</strong>：<ul><li><strong>@Retention</strong> - 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。</li><li>@Documented - 标记这些注解是否包含在用户文档中。</li><li><strong>@Target</strong> - 标记这个注解应该是哪种 Java 成员。</li><li><strong>@Inherited</strong> - 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类)<ul><li>详解：假设，我们定义了某个 Annotaion，它的名称是 MyAnnotation，并且 MyAnnotation 被标注为 @Inherited。现在，某个类 Base 使用了MyAnnotation，则 Base “具有了注解 MyAnnotation”；现在，Sub 继承了 Base，由于 MyAnnotation 是 @Inherited的(具有继承性)，所以，Sub 也 “具有了注解 MyAnnotation”。</li></ul></li><li>@Repeatable - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。</li></ul></li></ul><h2 id="Annotation架构"><a href="#Annotation架构" class="headerlink" title="Annotation架构"></a>Annotation架构</h2><p><img src="/Java-%E5%88%9D%E8%AF%86%E6%B3%A8%E8%A7%A3/1.jpg" alt="Annotation架构"></p><p>从中可以看出：</p><ol><li>1个Annotation对象，都会有唯一的RetentionPolicy属性。</li><li>1 个 Annotation 对象，可以有若干个 ElementType 属性。</li><li>Annotation 有许多实现类，包括：Deprecated, Documented, Inherited, Override 等等。</li></ol><p>下面介绍，在java Annotation的组成中，有三个重要的主干类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Annotation.java</span></span><br><span class="line"><span class="keyword">package</span> java.lang.annotation;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Annotation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends Annotation&gt; annotationType();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ElementType.java</span></span><br><span class="line"><span class="keyword">package</span> java.lang.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">ElementType</span> </span>&#123;</span><br><span class="line">    TYPE,               <span class="comment">/* 类、接口（包括注释类型）或枚举声明  */</span></span><br><span class="line"></span><br><span class="line">    FIELD,              <span class="comment">/* 字段声明（包括枚举常量）  */</span></span><br><span class="line"></span><br><span class="line">    METHOD,             <span class="comment">/* 方法声明  */</span></span><br><span class="line"></span><br><span class="line">    PARAMETER,          <span class="comment">/* 参数声明  */</span></span><br><span class="line"></span><br><span class="line">    CONSTRUCTOR,        <span class="comment">/* 构造方法声明  */</span></span><br><span class="line"></span><br><span class="line">    LOCAL_VARIABLE,     <span class="comment">/* 局部变量声明  */</span></span><br><span class="line"></span><br><span class="line">    ANNOTATION_TYPE,    <span class="comment">/* 注释类型声明  */</span></span><br><span class="line"></span><br><span class="line">    PACKAGE             <span class="comment">/* 包声明  */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//RetentionPolicy.java</span></span><br><span class="line"><span class="keyword">package</span> java.lang.annotation;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">RetentionPolicy</span> </span>&#123;</span><br><span class="line">    SOURCE,            <span class="comment">/* Annotation信息仅存在于编译器处理期间，编译器处理完之后就没有该Annotation信息了  */</span></span><br><span class="line"></span><br><span class="line">    CLASS,             <span class="comment">/* 编译器将Annotation存储于类对应的.class文件中。默认行为  */</span></span><br><span class="line"></span><br><span class="line">    RUNTIME            <span class="comment">/* 编译器将Annotation存储于class文件中，并且可由JVM读入 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ol><li>Annotation是一个接口，继承这个接口的就是注解。</li><li><strong>ElementType 是 Enum 枚举类型，它用来指定 Annotation 的类型。</strong><ol><li>例如，若一个 Annotation 对象是 METHOD 类型，则该 Annotation 只能用来修饰方法。</li></ol></li><li><strong>RetentionPolicy 是 Enum 枚举类型，它用来指定 Annotation 的策略。通俗点说，就是不同 RetentionPolicy 类型的 Annotation 的作用域不同。</strong><ol><li>若 Annotation 的类型为 SOURCE，则意味着：Annotation 仅存在于编译器处理期间，编译器处理完之后，该 Annotation 就没用了。 例如，” @Override” 标志就是一个 Annotation。当它修饰一个方法的时候，就意味着该方法覆盖父类的方法；并且在编译期间会进行语法检查！编译器处理完后，”@Override” 就没有任何作用了。</li><li>若 Annotation 的类型为 CLASS，则意味着：编译器将 Annotation 存储于类对应的 .class 文件中，它是 Annotation 的默认行为。</li><li>若 Annotation 的类型为 RUNTIME，则意味着：编译器将 Annotation 存储于 class 文件中，并且可由JVM读入。</li></ol></li></ol><h2 id="注解通用定义"><a href="#注解通用定义" class="headerlink" title="注解通用定义"></a>注解通用定义</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation1 &#123;</span><br><span class="line">    <span class="comment">//属性列表</span></span><br><span class="line">    <span class="comment">//Annotation的成员变量在Annotation定义中以无形参方法形式来声明，其方法名和返回值定义了该成员变量的名字和类型。</span></span><br><span class="line">    <span class="comment">//注解元素的类型可以为：基本类型，String，Class，枚举类型，注解类型，以及前面所述类型组成的数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：上面的作用是定义了一个注解，名为MyAnnotation1。定义了MyAnnotation1之后，我们可以在代码中通过@MyAnnotation1使用它。其他的，@Documented, @Target, @Retention, @interface都是来修饰MyAnnotation1的。</p><ul><li><p><strong>@interface</strong>：使用 @interface <strong>关键字</strong>定义注解时，意味着它实现了java.lang.annotation.Annotation 接口，即该注解就是一个Annotation。</p></li><li><p><strong>@Documented</strong>：类和方法的 Annotation 在缺省情况下是不出现在 javadoc 中的。如果使用 @Documented 修饰该 Annotation，则表示它可以出现在 javadoc 中。定义 Annotation 时，@Documented 可有可无；若没有定义，则 Annotation 不会出现在 javadoc 中。</p></li><li><p>**@Target(ElementType.TYPE)**：ElementType 是 Annotation 的类型属性。而 @Target 的作用，就是来指定 Annotation 的类型属性。</p><p>@Target(ElementType.TYPE) 的意思就是指定该 Annotation 的类型是 ElementType.TYPE。这就意味着，MyAnnotation1 是来修饰”类、接口（包括注释类型）或枚举声明”的注解。</p><p>定义 Annotation 时，@Target 可有可无。若有 @Target，则该 Annotation 只能用于它所指定的地方；若没有 @Target，则该 Annotation 可以用于任何地方。</p></li><li><p>**@Retention(RetentionPolicy.RUNTIME)**：前面我们说过，RetentionPolicy 是 Annotation 的策略属性，而 @Retention 的作用，就是指定 Annotation 的策略属性。</p><p>@Retention(RetentionPolicy.RUNTIME) 的意思就是指定该 Annotation 的策略是 RetentionPolicy.RUNTIME。这就意味着，编译器会将该 Annotation 信息保留在 .class 文件中，并且能被虚拟机读取。</p><p>定义 Annotation 时，@Retention 可有可无。若没有 @Retention，则默认是 RetentionPolicy.CLASS。</p></li></ul><p>根据注解是否包含成员变量，可以把注解分为</p><ul><li>标记注解：没有成员变量的注解，这种注解仅利用自身是否存在来提供信息。</li><li>元数据注解：包含成员变量的注解，因为它可以接受更多的元数据，所以也被称为元数据注解。</li></ul><h2 id="Annotation作用"><a href="#Annotation作用" class="headerlink" title="Annotation作用"></a>Annotation作用</h2><h3 id="编译检查"><a href="#编译检查" class="headerlink" title="编译检查"></a>编译检查</h3><p>Annotation 具有”让编译器进行编译检查的作用”。@SuppressWarnings, @Deprecated 和 @Override 都具有编译检查作用。</p><h3 id="☆在反射中解析并使用-Annotation"><a href="#☆在反射中解析并使用-Annotation" class="headerlink" title="☆在反射中解析并使用 Annotation"></a>☆在反射中解析并使用 Annotation</h3><p>程序通过反射机制可以解析被修饰的方法中的注解数据，当程序获取特殊标记后，可以做出相应的处理。这在Spring等框架中经常使用。详见下面代码。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AnnotationTest.java</span></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Annotation;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Inherited;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Annotation在反射函数中的使用示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 说明：在这里，我们不能把value()看成一个方法，而是一个同名的变量</span></span><br><span class="line"><span class="comment">     * 在使用的时候可以通过@MyAnnotation(value=&#123;&quot;a&quot;,&quot;b&quot;&#125;来赋值</span></span><br><span class="line"><span class="comment">     * default 给value制定了默认值</span></span><br><span class="line"><span class="comment">     * 如果注解的属性只有一个，且叫value，那么使用该注解时，可以不用指定属性名，因为默认就是给value赋值：</span></span><br><span class="line"><span class="comment">     * @MyAnnotation(&#123;&quot;a&quot;,&quot;b&quot;&#125;) //这样也是可以的</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">    String[] value() default &quot;unknown&quot;;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Person类。它会使用MyAnnotation注解。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * empty()方法同时被 &quot;<span class="doctag">@Deprecated</span>&quot; 和 &quot;<span class="doctag">@MyAnnotation</span>(value=&#123;&quot;a&quot;,&quot;b&quot;&#125;)&quot;所标注</span></span><br><span class="line"><span class="comment">     * (01) <span class="doctag">@Deprecated</span>，意味着empty()方法，不再被建议使用</span></span><br><span class="line"><span class="comment">     * (02) <span class="doctag">@MyAnnotation</span>, 意味着empty() 方法对应的MyAnnotation的value值是默认值&quot;unknown&quot;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@MyAnnotation</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">empty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;\nempty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * sombody() 被 <span class="doctag">@MyAnnotation</span>(value=&#123;&quot;girl&quot;,&quot;boy&quot;&#125;) 所标注，</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@MyAnnotation</span>(value=&#123;&quot;girl&quot;,&quot;boy&quot;&#125;), 意味着MyAnnotation的value值是&#123;&quot;girl&quot;,&quot;boy&quot;&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@MyAnnotation(value=&#123;&quot;girl&quot;,&quot;boy&quot;&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">somebody</span><span class="params">(String name, <span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;\nsomebody: &quot;</span>+name+<span class="string">&quot;, &quot;</span>+age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 新建Person</span></span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        <span class="comment">// 获取Person的Class实例</span></span><br><span class="line">        Class&lt;Person&gt; c = Person.class;</span><br><span class="line">        <span class="comment">// 获取 somebody() 方法的Method实例</span></span><br><span class="line">        Method mSomebody = c.getMethod(<span class="string">&quot;somebody&quot;</span>, <span class="keyword">new</span> Class[]&#123;String.class, <span class="keyword">int</span>.class&#125;);</span><br><span class="line">        <span class="comment">// 执行该方法</span></span><br><span class="line">        mSomebody.invoke(person, <span class="keyword">new</span> Object[]&#123;<span class="string">&quot;lily&quot;</span>, <span class="number">18</span>&#125;);</span><br><span class="line">        iteratorAnnotations(mSomebody);</span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 somebody() 方法的Method实例</span></span><br><span class="line">        Method mEmpty = c.getMethod(<span class="string">&quot;empty&quot;</span>, <span class="keyword">new</span> Class[]&#123;&#125;);</span><br><span class="line">        <span class="comment">// 执行该方法</span></span><br><span class="line">        mEmpty.invoke(person, <span class="keyword">new</span> Object[]&#123;&#125;);        </span><br><span class="line">        iteratorAnnotations(mEmpty);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iteratorAnnotations</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断 somebody() 方法是否包含MyAnnotation注解</span></span><br><span class="line">        <span class="keyword">if</span>(method.isAnnotationPresent(MyAnnotation.class))&#123;</span><br><span class="line">            <span class="comment">// 获取该方法的MyAnnotation注解实例</span></span><br><span class="line">            MyAnnotation myAnnotation = method.getAnnotation(MyAnnotation.class);</span><br><span class="line">            <span class="comment">// 获取 myAnnotation的值，并打印出来</span></span><br><span class="line">            String[] values = myAnnotation.value();</span><br><span class="line">            <span class="keyword">for</span> (String str:values)</span><br><span class="line">                System.out.printf(str+<span class="string">&quot;, &quot;</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 获取方法上的所有注解，并打印出来</span></span><br><span class="line">        Annotation[] annotations = method.getAnnotations();</span><br><span class="line">        <span class="keyword">for</span>(Annotation annotation : annotations)&#123;</span><br><span class="line">            System.out.println(annotation);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">somebody: lily, 18</span><br><span class="line">girl, boy, </span><br><span class="line">@com.skywang.annotation.MyAnnotation(value=[girl, boy])</span><br><span class="line"></span><br><span class="line">empty</span><br><span class="line">unknown, </span><br><span class="line">@com.skywang.annotation.MyAnnotation(value=[unknown])</span><br><span class="line">@java.lang.Deprecated()</span><br></pre></td></tr></table></figure><h3 id="根据Annotation生成帮助文档"><a href="#根据Annotation生成帮助文档" class="headerlink" title="根据Annotation生成帮助文档"></a>根据Annotation生成帮助文档</h3><p>@Documented</p><h3 id="帮忙查看代码"><a href="#帮忙查看代码" class="headerlink" title="帮忙查看代码"></a>帮忙查看代码</h3><p>通过 @Override, @Deprecated 等，我们能很方便的了解程序的大致结构。</p><h3 id="附属文件的自动生成"><a href="#附属文件的自动生成" class="headerlink" title="附属文件的自动生成"></a>附属文件的自动生成</h3><p>例如部署描述符或者bean信息类。</p><h3 id="测试、日志等代码的自动生成"><a href="#测试、日志等代码的自动生成" class="headerlink" title="测试、日志等代码的自动生成"></a>测试、日志等代码的自动生成</h3><p>//TODO</p><h2 id="框架中常用的注解"><a href="#框架中常用的注解" class="headerlink" title="框架中常用的注解"></a>框架中常用的注解</h2><h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><p>//TODO</p><h3 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h3><p>//TODO</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li><p>注解就像标签，是程序判断执行的依据。比如，程序读到@Test就知道这个方法是待测试方法，而@Before的方法要在测试方法之前执行</p></li><li><p>注解需要三要素：定义、使用、<strong>读取并执行</strong></p></li><li><p>注解分为自定义注解、JDK内置注解和第三方注解（框架）。自定义注解一般要我们自己定义、使用、并写程序读取，而JDK内置注解和第三方注解我们只要使用，定义和读取都交给它们</p></li><li><p>大多数情况下，三角关系中我们只负责使用注解，无需定义和执行，框架会将注解类和读取注解的程序隐藏起来，除非阅读源码，否则根本看不到。平时见不到定义和读取的过程，光顾着使用注解，久而久之很多人就忘了注解如何起作用了！</p></li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://www.zhihu.com/question/47449512/answer/658228092">怎样理解 Java 注解和运用注解编程？</a></li><li><a href="https://www.runoob.com/w3cnote/java-annotation.html">菜鸟教程-Java 注解（Annotation）</a></li><li>《Java疯狂讲义 第十四章 注解》</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;初识注解&quot;&gt;&lt;a href=&quot;#初识注解&quot; class=&quot;headerlink&quot; title=&quot;初识注解&quot;&gt;&lt;/a&gt;初识注解&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h</summary>
      
    
    
    
    <category term="Java" scheme="https://gmet233.gitee.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://gmet233.gitee.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>编写脚本读取文件并执行命令</title>
    <link href="https://gmet233.gitee.io/2021/12/21/%E7%BC%96%E5%86%99%E8%84%9A%E6%9C%AC%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E5%B9%B6%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4/"/>
    <id>https://gmet233.gitee.io/2021/12/21/%E7%BC%96%E5%86%99%E8%84%9A%E6%9C%AC%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E5%B9%B6%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4/</id>
    <published>2021-12-21T13:38:58.000Z</published>
    <updated>2021-12-21T13:41:30.569Z</updated>
    
    <content type="html"><![CDATA[<p>最近遇到如下需求：</p><blockquote><p>有一个文件，文件格式大概是这样</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;filename1&gt;\t&lt;download_url1&gt;</span><br><span class="line"></span><br><span class="line">&lt;filename2&gt;\t&lt;download_url2&gt;</span><br></pre></td></tr></table></figure><p>编写一个脚本循环读取该文件的每一行，使用<code>axel</code>命令将<code>download_url</code>下载下来，保存为本地文件<code>filename</code></p></blockquote><h1 id="Bash"><a href="#Bash" class="headerlink" title="Bash"></a>Bash</h1><p>先给出Code：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ./download.sh &lt;filename&gt;</span></span><br><span class="line"></span><br><span class="line">cat <span class="variable">$1</span> | <span class="keyword">while</span> <span class="built_in">read</span> line</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="comment"># echo $&#123;line&#125;</span></span><br><span class="line">    array=(<span class="variable">$&#123;line// / &#125;</span>) <span class="comment"># array=($&#123;line//\t/ &#125;) 不生效</span></span><br><span class="line">    <span class="comment"># echo $&#123;array[0]&#125; + &quot;;&quot; + $&#123;array[1]&#125; </span></span><br><span class="line">    cmd=<span class="string">&#x27;axel -o &#x27;</span><span class="variable">$&#123;array[0]&#125;</span><span class="string">&#x27; &quot;&#x27;</span><span class="variable">$&#123;array[1]&#125;</span><span class="string">&#x27;&quot;&#x27;</span></span><br><span class="line">    <span class="built_in">eval</span> <span class="variable">$cmd</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>下面对code逐一解释</p><h2 id="bin-bash"><a href="#bin-bash" class="headerlink" title="#! /bin/bash"></a>#! /bin/bash</h2><p><strong>#!/bin/bash</strong>是指此脚本使用**/bin/bash**来解释执行，Bash脚本首行固定写法。</p><h2 id="Bash注释"><a href="#Bash注释" class="headerlink" title="Bash注释"></a>Bash注释</h2><p>Bash中使用<code>#</code>进行单行注释，见如上代码第三行</p><h2 id="Bash-接收外部参数"><a href="#Bash-接收外部参数" class="headerlink" title="Bash 接收外部参数"></a>Bash 接收外部参数</h2><p>我们可以在执行 Shell 脚本时，向脚本传递参数，脚本内获取参数的格式为：**$n<strong>。</strong>n** 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推……</p><p>特殊的 ，**$0** 表示脚本名称（含路径）。</p><p>另外，**$#** 表示传递参数的个数。</p><p>上面代码中<code>cat $1 |</code>就是将第一个参数作为文件名，读取文件中的内容，通过管道命令<code>|</code>将文件内容传给while循环</p><h2 id="Bash-循环读取每一行"><a href="#Bash-循环读取每一行" class="headerlink" title="Bash 循环读取每一行"></a>Bash 循环读取每一行</h2><p>最简单的</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> line</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$line</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>还可以使用for循环等，详细可参见参考资料1。</p><h2 id="Bash按指定字符分割字符串"><a href="#Bash按指定字符分割字符串" class="headerlink" title="Bash按指定字符分割字符串"></a>Bash按指定字符分割字符串</h2><p>接上文，line是待处理的字符串，则指定分隔符<code>\t</code>将line分割后的字符串数组存放到array，</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">array=(<span class="variable">$&#123;line// / &#125;</span>)</span><br></pre></td></tr></table></figure><p>注意这里<code>//</code>和<code>/</code>之间是一个制表符，而不是空格。</p><p>我也曾使用<code>array=($&#123;line//\t/ &#125;)</code>来进行分割，但是测试后发现它会按照字符<code>t</code>对字符串进行分割。</p><p><em>还没弄明白语法规则</em></p><h2 id="Bash字符串拼接"><a href="#Bash字符串拼接" class="headerlink" title="Bash字符串拼接"></a>Bash字符串拼接</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmd=<span class="string">&#x27;axel -o &#x27;</span><span class="variable">$&#123;array[0]&#125;</span><span class="string">&#x27; &quot;&#x27;</span><span class="variable">$&#123;array[1]&#125;</span><span class="string">&#x27;&quot;&#x27;</span></span><br></pre></td></tr></table></figure><p>这一行就是取array中的值进行字符串拼接，注意取值的语法<code>$&#123;&#125;</code></p><ul><li><p>Bash中对字符串拼接不需要使用<code>+</code>进行连接</p></li><li><p>这里使用单引号是为了避免对双引号转义</p></li></ul><h2 id="Bash执行cmd"><a href="#Bash执行cmd" class="headerlink" title="Bash执行cmd"></a>Bash执行cmd</h2><p><code>eval $cmd</code>是读取变量cmd的值当作一条Shell命令进行执行</p><h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><p>上面的代码先读取每一行，在对行按照制表符进行分割。其实可以更简洁：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> filenameurl</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="comment">#echo $filename</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>同样的需要注意<code>filename</code>，<code>url</code>之间是一个制表符而不是空格。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>当url过长时，该脚本并不能完整的读取url。例如，当文件如下时</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">covid19-image-dataset-collection-volumes-folder.ziphttps://storage.googleapis.com/kaggle-data-sets/862993/1470970/bundle/archive.zip?X-Goog-Algorithm=GOOG4-RSA-SHA256&amp;X-Goog-Credential=gcp-kaggle-com%40kaggle-161607.iam.gserviceaccount.com%2F20211221%2Fauto%2Fstorage%2Fgoog4_request&amp;X-Goog-Date=20211221T052609Z&amp;X-Goog-Expires=259199&amp;X-Goog-SignedHeaders=host&amp;X-Goog-Signature=6549111df89ca0440058e7061ba9a13d72ea22ed7bcfdbcfc56ddadaf7a54ec4d3285487b269808d60cf0568264db1803899989475d8ca0aeec0777891f54df612a6a8f7ba808c8df3899feda1a94ca0507a580e407c0e42371d97e3ce1c75d598bed1f693bf841f7d4660294488e99fc944d6e1498c5ec38b431b969e5f13eda5f2d8029e855ea368c57eab60897a32f7556df116a96bfd321dd4d214dfe847d4c8ca11fdb7c3472ebac9f7a9eb20b44a148df51ecb2f93acdc5459800a894cdc2d62a0cc2c2e42e6711e568827f44b82d6faaa02aa1357c8d93140eb2c72bde9b8c1716e565800ac3ff812df304ce7a54c2a83896696ac5fa935329afa66ef</span><br></pre></td></tr></table></figure><p>读取并拼接后的命令字符串如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">axel -o covid19-image-dataset-collection-volumes-folder.zip &quot;https://storage.googleapis.com/kaggle-data-sets/862993/1470970/bundle/archive.zip?X-Goog-Algorithm=GOOG4-RSA-SHA256&amp;X-Goog-Credential=gcp-kaggle-com%40kaggle-161607.iam.gserviceaccount.com%2F20211221%2Fauto%2Fstorage%2Fgoog4_request&amp;X-Goog-Date=20211221T052609Z&amp;X-Goog-Expires=259199&amp;X-Goog-SignedHeaders=host&amp;X-Goog-Signature=6549111df89ca0440058e7061ba9a13d72ea22ed7bcfdbcfc56ddadaf7a54ec4d3285487b269808d60cf0568264db1803899989475d8ca0aeec0777891f54df612a6a8f7ba808c8df3899feda1a94ca0507a580e407c0e42371d97e3ce1c75d598bed1f693bf841f7d4660294488e99fc944d6e1498c5ec38b431b969e5f13eda5f2d8029e855ea368c57eab60897a32f7556df116a96bfd321dd4d214dfe847d4c8ca11fdb7c3472ebac9f7a9eb20b44a148df51ecb2f93acdc5459800a894cdc2d62a0cc2c2e42e6711e568827f44b82d6faaa02aa1357c8d93140eb2c72bde9b8c1716e565800ac3ff812df304ce7a54c2a83896696ac5fa9353&quot;9afa66ef</span><br></pre></td></tr></table></figure><p>注意引号外面还有数据，这是不符合预期的。</p><p><em>目前还没有解决该问题</em></p><h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><p>由于本人对Bash不是很熟悉，所以改用Python来完成这一需求。</p><p>下面给出完整代码</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#python download.py -f list</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    parser = argparse.ArgumentParser(description=<span class="string">&quot;download kaggle dataset according to file&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;-f&#x27;</span>, <span class="string">&#x27;--filename&#x27;</span>, required=<span class="literal">True</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, <span class="built_in">help</span>=<span class="string">&#x27;filename&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">    filename = args.filename</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        lines = f.readlines()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        arr = line.split(<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">        save_name = arr[<span class="number">0</span>]</span><br><span class="line">        url = arr[<span class="number">1</span>].replace(<span class="string">&quot;\n&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        cmd = <span class="string">&#x27;axel -o &#x27;</span> + save_name + <span class="string">&#x27; &quot;&#x27;</span> + url + <span class="string">&#x27;&quot;&#x27;</span></span><br><span class="line">        <span class="comment"># print(cmd)</span></span><br><span class="line">        res_f = os.popen(cmd)  <span class="comment"># 返回的是一个文件对象</span></span><br><span class="line">        <span class="built_in">print</span>(res_f.read())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="Python-main函数"><a href="#Python-main函数" class="headerlink" title="Python main函数"></a>Python main函数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>这是Python的main函数，Python脚本总会从该“函数“进入。</p><h2 id="Python-接收外部参数"><a href="#Python-接收外部参数" class="headerlink" title="Python 接收外部参数"></a>Python 接收外部参数</h2><p>使用类库<code>argparse</code>来读取外部参数。上述代码给出了一个简单的示例</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">parser = argparse.ArgumentParser(description=<span class="string">&quot;download kaggle dataset according to file&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">第一、二个参数是指定参数名，第一个是简写形式</span></span><br><span class="line"><span class="string">在调用命令的时候，可以使用python script.py -f &lt;param&gt;或者python script.py --filename &lt;param&gt;</span></span><br><span class="line"><span class="string">required=True 表示该参数必填</span></span><br><span class="line"><span class="string">type=str 指定参数类型</span></span><br><span class="line"><span class="string">help=&#x27;filename&#x27; 指定提示语</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">parser.add_argument(<span class="string">&#x27;-f&#x27;</span>, <span class="string">&#x27;--filename&#x27;</span>, required=<span class="literal">True</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, <span class="built_in">help</span>=<span class="string">&#x27;filename&#x27;</span> 指定提示语)</span><br><span class="line"></span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">filename = args.filename  <span class="comment"># filename存放了外部参数的值</span></span><br></pre></td></tr></table></figure><p>详细请参见<code>参考资料2</code></p><h2 id="Python文件、字符串操作"><a href="#Python文件、字符串操作" class="headerlink" title="Python文件、字符串操作"></a>Python文件、字符串操作</h2><p>略</p><h2 id="在Python中执行Shell命令"><a href="#在Python中执行Shell命令" class="headerlink" title="在Python中执行Shell命令"></a>在Python中执行Shell命令</h2><p>有两种方式。使用<code>os.system(&quot;command&quot;)</code>执行无返回值的Shell命令；使用<code>f = os.popen(&quot;command&quot;)</code>执行有输出的Shell命令，其返回值<code>f</code>是一个文件对象，通过<code>f.read()</code>来读取命令输出内容。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="http://c.biancheng.net/shell/">Shell 脚本学习指南</a></li><li><a href="https://docs.python.org/zh-cn/3/howto/argparse.html">Python Argparse 教程</a></li><li><a href="https://blog.csdn.net/qq_27825451/article/details/102909772">python执行shell脚本的几种方法</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近遇到如下需求：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有一个文件，文件格式大概是这样&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;</summary>
      
    
    
    
    <category term="Linux" scheme="https://gmet233.gitee.io/categories/Linux/"/>
    
    <category term="Scripts" scheme="https://gmet233.gitee.io/categories/Linux/Scripts/"/>
    
    
    <category term="Linux Bash" scheme="https://gmet233.gitee.io/tags/Linux-Bash/"/>
    
    <category term="Python" scheme="https://gmet233.gitee.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>田忌赛马与贪心法则</title>
    <link href="https://gmet233.gitee.io/2021/12/20/%E7%94%B0%E5%BF%8C%E8%B5%9B%E9%A9%AC%E4%B8%8E%E8%B4%AA%E5%BF%83%E6%B3%95%E5%88%99/"/>
    <id>https://gmet233.gitee.io/2021/12/20/%E7%94%B0%E5%BF%8C%E8%B5%9B%E9%A9%AC%E4%B8%8E%E8%B4%AA%E5%BF%83%E6%B3%95%E5%88%99/</id>
    <published>2021-12-20T13:59:45.000Z</published>
    <updated>2021-12-20T14:01:55.082Z</updated>
    
    <content type="html"><![CDATA[<p>本文涉及*<a href="https://leetcode-cn.com/problems/advantage-shuffle/">LeetCode 870. 优势洗牌</a>*</p><blockquote><p>给定两个大小相等的数组 A 和 B，A 相对于 B 的优势可以用满足 A[i] &gt; B[i] 的索引 i 的数目来描述。返回 A 的任意排列，使其相对于 B 的优势最大化。</p><p>示例 1：</p><p>输入：A = [2,7,11,15], B = [1,10,4,11]<br>输出：[2,11,7,15]<br>示例 2：</p><p>输入：A = [12,24,8,32], B = [13,25,32,11]<br>输出：[24,32,8,12]</p></blockquote><p>这就像⽥忌赛⻢的情景，nums1 就是⽥忌的⻢，nums2 就是⻬王的⻢，数组中的元素就是⻢的战⽃⼒：</p><p>算法策略是：<strong>将⻬王和⽥忌的⻢按照战⽃⼒排序，然后按照排名⼀⼀对⽐。如果⽥忌的⻢能赢，那就⽐赛，如果赢不了，那就换个垫底的来送⼈头，保存实⼒。</strong></p><p>这里要注意一个问题：是否需要保存实力，即如果⽥忌的⼆号选⼿也能⼲得过⻬王的⼀号选⼿，此时让⼆号选⼿去对决⻬王的⼀号选⼿，不是更节约？</p><p>这种节约的策略是没问题的，但是<strong>没有必要</strong>。</p><p>我们暂且把⽥忌的⼀号选⼿称为 T1，⼆号选⼿称为 T2，⻬王的⼀号选⼿称为 Q1。如果 T2 能赢 Q1，你试图保存⼰⽅实⼒，让 T2 去战 Q1，把 T1 留着是为了对付谁？显然，你担⼼⻬王还有战⼒⼤于 T2 的⻢，可以让 T1 去对付。但是你仔细想想，现在 T2 已经是可以战胜 Q1 的，Q1 可是⻬王的最快的⻢，⻬王剩下的那些⻢⾥，怎么可能还有⽐ T2 更强的⻢？</p><p>所以没必要节约。</p><p>根据上述思路得到的代码逻辑如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对两个数组nums1和nums2排序</span><br><span class="line">对两个数组的元素挨个比较，如果nums1[i]&gt;nums2[i]那就比，否则就换上nums1最小的元素进行比较。</span><br></pre></td></tr></table></figure><p>由于需要对两个数组排序，但是返回结果依赖nums2的顺序，所以不能直接对nums2进行排序，而是利用优先级队列。（将(index, nums2[index]放入优先级队列，出队优先级按照nums2[index]大小，index记录索引值）</p><p>此外，解法还是用到双指针技巧。完整代码如下。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] advantageCount(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums1.length;</span><br><span class="line">    <span class="comment">// 给 nums2 降序排序</span></span><br><span class="line">    PriorityQueue&lt;<span class="keyword">int</span>[]&gt; maxpq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(</span><br><span class="line">        (<span class="keyword">int</span>[] pair1, <span class="keyword">int</span>[] pair2) -&gt; &#123; </span><br><span class="line">            <span class="keyword">return</span> pair2[<span class="number">1</span>] - pair1[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        maxpq.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, nums2[i]&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 给 nums1 升序排序</span></span><br><span class="line">    Arrays.sort(nums1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// nums1[left] 是最小值，nums1[right] 是最大值</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!maxpq.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] pair = maxpq.poll();</span><br><span class="line">        <span class="comment">// maxval 是 nums2 中的最大值，i 是对应索引</span></span><br><span class="line">        <span class="keyword">int</span> i = pair[<span class="number">0</span>], maxval = pair[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (maxval &lt; nums1[right]) &#123;</span><br><span class="line">            <span class="comment">// 如果 nums1[right] 能胜过 maxval，那就自己上</span></span><br><span class="line">            res[i] = nums1[right];</span><br><span class="line">            right--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则用最小值去换nums2的最大值</span></span><br><span class="line">            res[i] = nums1[left];</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247491139&idx=1&sn=10cb35e0056ac8f8c540fccd0156f333&scene=21&ascene=7&devicetype=iOS15.2&version=1800103a&nettype=WIFI&abtest_cookie=AAACAA==&lang=zh_CN&fontScale=100&exportkey=A2t5E2fVKmwEJxWEKsScbfU=&pass_ticket=n3zshxiiR8IMf1IfoZgzB+PSm6RatluaPa8vtuS3bDtR2ttHhdhxmZkQCXMUyC9L&wx_header=1">labuladong: 算法大师——孙膑</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文涉及*&lt;a href=&quot;https://leetcode-cn.com/problems/advantage-shuffle/&quot;&gt;LeetCode 870. 优势洗牌&lt;/a&gt;*&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定两个大小相等的数组 A 和 B，A 相对于 B </summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://gmet233.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="数组/链表" scheme="https://gmet233.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84-%E9%93%BE%E8%A1%A8/"/>
    
    
    <category term="数据结构与算法" scheme="https://gmet233.gitee.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="贪心" scheme="https://gmet233.gitee.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>PriorityQueue 概述</title>
    <link href="https://gmet233.gitee.io/2021/12/19/PriorityQueue-%E6%A6%82%E8%BF%B0/"/>
    <id>https://gmet233.gitee.io/2021/12/19/PriorityQueue-%E6%A6%82%E8%BF%B0/</id>
    <published>2021-12-19T08:58:37.000Z</published>
    <updated>2021-12-19T09:06:39.869Z</updated>
    
    <content type="html"><![CDATA[<h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><p><code>Queue</code>是一个严格的先进先出（FIFO）的队列。</p><p>但有时候这并不能满足我们的需求。当我们需要对队列中的元素重排，按照重排后的元素顺序出队时，这时候就需要<code>PriorityQueue</code>。</p><p><code>PriorityQueue</code>和<code>Queue</code>的区别在于，它的出队顺序与元素的优先级有关，对<code>PriorityQueue</code>调用<code>remove()</code>或<code>poll()</code>方法，返回的总是优先级最高的元素。</p><p>要使用<code>PriorityQueue</code>，我们就必须给每个元素定义“优先级”。请看下面的例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPriorityQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Queue&lt;User&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(</span><br><span class="line">                (User user1, User user2) -&gt; &#123;</span><br><span class="line">                    <span class="keyword">return</span> user2.getLevel() - user1.getLevel();</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">        queue.offer(<span class="keyword">new</span> User(<span class="string">&quot;sb_1&quot;</span>, <span class="number">1</span>)); <span class="comment">//优先级低</span></span><br><span class="line">        queue.offer(<span class="keyword">new</span> User(<span class="string">&quot;vip_1&quot;</span>, <span class="number">2</span>)); <span class="comment">//优先级高</span></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            User user = queue.poll();</span><br><span class="line">            System.out.println(user.getName());</span><br><span class="line">        &#125; <span class="comment">//出队的顺序是vip_1, sb_1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> level;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.level = level;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//getter、setter</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的例子使用lambda表达式实现了排序。你也可以自定义排序器（实现Comparable接口），然后将排序器对象传递给<code>PriorityQueue</code>构造器。构造函数签名如下：</p><p><code>public PriorityQueue(Comparator&lt;? super E&gt; comparator)</code></p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>通过堆实现，具体说是通过完全二叉树（<em>complete binary tree</em>）实现的<strong>小顶堆</strong>（任意一个非叶子节点的权值，都不大于其左右子节点的权值）。</p><p>具体请参考<strong>堆排序</strong>。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1265120632401152">https://www.liaoxuefeng.com/wiki/1252599548343744/1265120632401152</a></li><li><a href="https://www.cnblogs.com/CarpenterLee/p/5488070.html">https://www.cnblogs.com/CarpenterLee/p/5488070.html</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;快速入门&quot;&gt;&lt;a href=&quot;#快速入门&quot; class=&quot;headerlink&quot; title=&quot;快速入门&quot;&gt;&lt;/a&gt;快速入门&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Queue&lt;/code&gt;是一个严格的先进先出（FIFO）的队列。&lt;/p&gt;
&lt;p&gt;但有时候这并不能满足我们的需求。</summary>
      
    
    
    
    <category term="Java" scheme="https://gmet233.gitee.io/categories/Java/"/>
    
    <category term="集合" scheme="https://gmet233.gitee.io/categories/Java/%E9%9B%86%E5%90%88/"/>
    
    
    <category term="Java" scheme="https://gmet233.gitee.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>单例设计模式</title>
    <link href="https://gmet233.gitee.io/2021/12/16/%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://gmet233.gitee.io/2021/12/16/%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-12-16T13:19:39.000Z</published>
    <updated>2021-12-16T13:48:11.500Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>单例模式确保一个类只有一个实例，并提供了一个全局访问点。</p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>线程池，数据库连接对象。</p><h1 id="经典单例模式"><a href="#经典单例模式" class="headerlink" title="经典单例模式"></a>经典单例模式</h1><p>一个经典的单例模式实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> This is not thread safe!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> uniqueInstance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该实现是线程不安全的。可以想象有两个线程同时进入了getInstance()方法。</p><h1 id="解决经典单例模式线程安全问题"><a href="#解决经典单例模式线程安全问题" class="headerlink" title="解决经典单例模式线程安全问题"></a>解决经典单例模式线程安全问题</h1><p>解决方案，给getInstance方法加上synchronized关键字，迫使每个线程进入该方法前都需要等待别的线程离开该方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> uniqueInstance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该解决方案得缺点就是只有第一次执行该方法才真正需要线程同步。</p><h1 id="更进一步…"><a href="#更进一步…" class="headerlink" title="更进一步…"></a>更进一步…</h1><p>这里给出三种改善方案：</p><ol><li>如果getInstance得性能对于应用程序不是很关键，就什么也别做。</li><li>使用“急切”创建实例，而不用延迟实例化的做法。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>使用<strong>双重检查加锁</strong>，在getInstance中减少使用同步。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>备注：</p><ul><li>首先检查实例是否存在，如果不存在再进入同步代码块。</li><li>进入区块后在检查一次，如果仍然是null则创建实例。</li><li>volatile关键字确保：当instance变量初始化后，多个线程正确的处理instance变量。</li></ul><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><blockquote><p>两个类加载器可能有机会创建自己的单例实例？</p></blockquote><p>是的。所以如果你的程序有多个类加载器又同时使用了单例模式，请小心。解决方法是自行指定类加载器，并指定同一个类加载器。</p><blockquote><p>类如果能做两件事，就违反了OO设计。单例模式是否违反了这样的观念呢？</p></blockquote><p>单例类不止负责管理自己的实例，还在应用程序中担任角色，所以可以视为是两个责任。但是由类管理自己的实例的做法并不少见，也可以让设计更简单。</p><blockquote><p>我想把单例类当成超类，设计出子类。究竟可不可以继承单例类。</p></blockquote><p>不能。继承单例类遇到的一个问题就是构造器是私有的。你不能用私有构造器来扩展类。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《Head First设计模式》(中文版)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;单例模式确保一个类只有一个实例，并提供了一个全局访问点。&lt;/p&gt;
&lt;h1 id=&quot;应用&quot;&gt;&lt;a href=&quot;#应用&quot; class=&quot;head</summary>
      
    
    
    
    <category term="设计模式" scheme="https://gmet233.gitee.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="Java" scheme="https://gmet233.gitee.io/tags/Java/"/>
    
    <category term="设计模式" scheme="https://gmet233.gitee.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
