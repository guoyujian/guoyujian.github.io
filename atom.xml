<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Gmet Blog</title>
  
  <subtitle>Eureka!</subtitle>
  <link href="https://gmet233.gitee.io/atom.xml" rel="self"/>
  
  <link href="https://gmet233.gitee.io/"/>
  <updated>2021-12-21T13:41:30.569Z</updated>
  <id>https://gmet233.gitee.io/</id>
  
  <author>
    <name>Met Guo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>编写脚本读取文件并执行命令</title>
    <link href="https://gmet233.gitee.io/2021/12/21/%E7%BC%96%E5%86%99%E8%84%9A%E6%9C%AC%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E5%B9%B6%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4/"/>
    <id>https://gmet233.gitee.io/2021/12/21/%E7%BC%96%E5%86%99%E8%84%9A%E6%9C%AC%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E5%B9%B6%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4/</id>
    <published>2021-12-21T13:38:58.000Z</published>
    <updated>2021-12-21T13:41:30.569Z</updated>
    
    <content type="html"><![CDATA[<p>最近遇到如下需求：</p><blockquote><p>有一个文件，文件格式大概是这样</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;filename1&gt;\t&lt;download_url1&gt;</span><br><span class="line"></span><br><span class="line">&lt;filename2&gt;\t&lt;download_url2&gt;</span><br></pre></td></tr></table></figure><p>编写一个脚本循环读取该文件的每一行，使用<code>axel</code>命令将<code>download_url</code>下载下来，保存为本地文件<code>filename</code></p></blockquote><h1 id="Bash"><a href="#Bash" class="headerlink" title="Bash"></a>Bash</h1><p>先给出Code：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ./download.sh &lt;filename&gt;</span></span><br><span class="line"></span><br><span class="line">cat <span class="variable">$1</span> | <span class="keyword">while</span> <span class="built_in">read</span> line</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="comment"># echo $&#123;line&#125;</span></span><br><span class="line">    array=(<span class="variable">$&#123;line// / &#125;</span>) <span class="comment"># array=($&#123;line//\t/ &#125;) 不生效</span></span><br><span class="line">    <span class="comment"># echo $&#123;array[0]&#125; + &quot;;&quot; + $&#123;array[1]&#125; </span></span><br><span class="line">    cmd=<span class="string">&#x27;axel -o &#x27;</span><span class="variable">$&#123;array[0]&#125;</span><span class="string">&#x27; &quot;&#x27;</span><span class="variable">$&#123;array[1]&#125;</span><span class="string">&#x27;&quot;&#x27;</span></span><br><span class="line">    <span class="built_in">eval</span> <span class="variable">$cmd</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>下面对code逐一解释</p><h2 id="bin-bash"><a href="#bin-bash" class="headerlink" title="#! /bin/bash"></a>#! /bin/bash</h2><p><strong>#!/bin/bash</strong>是指此脚本使用**/bin/bash**来解释执行，Bash脚本首行固定写法。</p><h2 id="Bash注释"><a href="#Bash注释" class="headerlink" title="Bash注释"></a>Bash注释</h2><p>Bash中使用<code>#</code>进行单行注释，见如上代码第三行</p><h2 id="Bash-接收外部参数"><a href="#Bash-接收外部参数" class="headerlink" title="Bash 接收外部参数"></a>Bash 接收外部参数</h2><p>我们可以在执行 Shell 脚本时，向脚本传递参数，脚本内获取参数的格式为：**$n<strong>。</strong>n** 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推……</p><p>特殊的 ，**$0** 表示脚本名称（含路径）。</p><p>另外，**$#** 表示传递参数的个数。</p><p>上面代码中<code>cat $1 |</code>就是将第一个参数作为文件名，读取文件中的内容，通过管道命令<code>|</code>将文件内容传给while循环</p><h2 id="Bash-循环读取每一行"><a href="#Bash-循环读取每一行" class="headerlink" title="Bash 循环读取每一行"></a>Bash 循环读取每一行</h2><p>最简单的</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> line</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$line</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>还可以使用for循环等，详细可参见参考资料1。</p><h2 id="Bash按指定字符分割字符串"><a href="#Bash按指定字符分割字符串" class="headerlink" title="Bash按指定字符分割字符串"></a>Bash按指定字符分割字符串</h2><p>接上文，line是待处理的字符串，则指定分隔符<code>\t</code>将line分割后的字符串数组存放到array，</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">array=(<span class="variable">$&#123;line// / &#125;</span>)</span><br></pre></td></tr></table></figure><p>注意这里<code>//</code>和<code>/</code>之间是一个制表符，而不是空格。</p><p>我也曾使用<code>array=($&#123;line//\t/ &#125;)</code>来进行分割，但是测试后发现它会按照字符<code>t</code>对字符串进行分割。</p><p><em>还没弄明白语法规则</em></p><h2 id="Bash字符串拼接"><a href="#Bash字符串拼接" class="headerlink" title="Bash字符串拼接"></a>Bash字符串拼接</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmd=<span class="string">&#x27;axel -o &#x27;</span><span class="variable">$&#123;array[0]&#125;</span><span class="string">&#x27; &quot;&#x27;</span><span class="variable">$&#123;array[1]&#125;</span><span class="string">&#x27;&quot;&#x27;</span></span><br></pre></td></tr></table></figure><p>这一行就是取array中的值进行字符串拼接，注意取值的语法<code>$&#123;&#125;</code></p><ul><li><p>Bash中对字符串拼接不需要使用<code>+</code>进行连接</p></li><li><p>这里使用单引号是为了避免对双引号转义</p></li></ul><h2 id="Bash执行cmd"><a href="#Bash执行cmd" class="headerlink" title="Bash执行cmd"></a>Bash执行cmd</h2><p><code>eval $cmd</code>是读取变量cmd的值当作一条Shell命令进行执行</p><h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><p>上面的代码先读取每一行，在对行按照制表符进行分割。其实可以更简洁：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> filenameurl</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="comment">#echo $filename</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>同样的需要注意<code>filename</code>，<code>url</code>之间是一个制表符而不是空格。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>当url过长时，该脚本并不能完整的读取url。例如，当文件如下时</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">covid19-image-dataset-collection-volumes-folder.ziphttps://storage.googleapis.com/kaggle-data-sets/862993/1470970/bundle/archive.zip?X-Goog-Algorithm=GOOG4-RSA-SHA256&amp;X-Goog-Credential=gcp-kaggle-com%40kaggle-161607.iam.gserviceaccount.com%2F20211221%2Fauto%2Fstorage%2Fgoog4_request&amp;X-Goog-Date=20211221T052609Z&amp;X-Goog-Expires=259199&amp;X-Goog-SignedHeaders=host&amp;X-Goog-Signature=6549111df89ca0440058e7061ba9a13d72ea22ed7bcfdbcfc56ddadaf7a54ec4d3285487b269808d60cf0568264db1803899989475d8ca0aeec0777891f54df612a6a8f7ba808c8df3899feda1a94ca0507a580e407c0e42371d97e3ce1c75d598bed1f693bf841f7d4660294488e99fc944d6e1498c5ec38b431b969e5f13eda5f2d8029e855ea368c57eab60897a32f7556df116a96bfd321dd4d214dfe847d4c8ca11fdb7c3472ebac9f7a9eb20b44a148df51ecb2f93acdc5459800a894cdc2d62a0cc2c2e42e6711e568827f44b82d6faaa02aa1357c8d93140eb2c72bde9b8c1716e565800ac3ff812df304ce7a54c2a83896696ac5fa935329afa66ef</span><br></pre></td></tr></table></figure><p>读取并拼接后的命令字符串如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">axel -o covid19-image-dataset-collection-volumes-folder.zip &quot;https://storage.googleapis.com/kaggle-data-sets/862993/1470970/bundle/archive.zip?X-Goog-Algorithm=GOOG4-RSA-SHA256&amp;X-Goog-Credential=gcp-kaggle-com%40kaggle-161607.iam.gserviceaccount.com%2F20211221%2Fauto%2Fstorage%2Fgoog4_request&amp;X-Goog-Date=20211221T052609Z&amp;X-Goog-Expires=259199&amp;X-Goog-SignedHeaders=host&amp;X-Goog-Signature=6549111df89ca0440058e7061ba9a13d72ea22ed7bcfdbcfc56ddadaf7a54ec4d3285487b269808d60cf0568264db1803899989475d8ca0aeec0777891f54df612a6a8f7ba808c8df3899feda1a94ca0507a580e407c0e42371d97e3ce1c75d598bed1f693bf841f7d4660294488e99fc944d6e1498c5ec38b431b969e5f13eda5f2d8029e855ea368c57eab60897a32f7556df116a96bfd321dd4d214dfe847d4c8ca11fdb7c3472ebac9f7a9eb20b44a148df51ecb2f93acdc5459800a894cdc2d62a0cc2c2e42e6711e568827f44b82d6faaa02aa1357c8d93140eb2c72bde9b8c1716e565800ac3ff812df304ce7a54c2a83896696ac5fa9353&quot;9afa66ef</span><br></pre></td></tr></table></figure><p>注意引号外面还有数据，这是不符合预期的。</p><p><em>目前还没有解决该问题</em></p><h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><p>由于本人对Bash不是很熟悉，所以改用Python来完成这一需求。</p><p>下面给出完整代码</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#python download.py -f list</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    parser = argparse.ArgumentParser(description=<span class="string">&quot;download kaggle dataset according to file&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;-f&#x27;</span>, <span class="string">&#x27;--filename&#x27;</span>, required=<span class="literal">True</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, <span class="built_in">help</span>=<span class="string">&#x27;filename&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">    filename = args.filename</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        lines = f.readlines()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        arr = line.split(<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">        save_name = arr[<span class="number">0</span>]</span><br><span class="line">        url = arr[<span class="number">1</span>].replace(<span class="string">&quot;\n&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        cmd = <span class="string">&#x27;axel -o &#x27;</span> + save_name + <span class="string">&#x27; &quot;&#x27;</span> + url + <span class="string">&#x27;&quot;&#x27;</span></span><br><span class="line">        <span class="comment"># print(cmd)</span></span><br><span class="line">        res_f = os.popen(cmd)  <span class="comment"># 返回的是一个文件对象</span></span><br><span class="line">        <span class="built_in">print</span>(res_f.read())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="Python-main函数"><a href="#Python-main函数" class="headerlink" title="Python main函数"></a>Python main函数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>这是Python的main函数，Python脚本总会从该“函数“进入。</p><h2 id="Python-接收外部参数"><a href="#Python-接收外部参数" class="headerlink" title="Python 接收外部参数"></a>Python 接收外部参数</h2><p>使用类库<code>argparse</code>来读取外部参数。上述代码给出了一个简单的示例</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">parser = argparse.ArgumentParser(description=<span class="string">&quot;download kaggle dataset according to file&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">第一、二个参数是指定参数名，第一个是简写形式</span></span><br><span class="line"><span class="string">在调用命令的时候，可以使用python script.py -f &lt;param&gt;或者python script.py --filename &lt;param&gt;</span></span><br><span class="line"><span class="string">required=True 表示该参数必填</span></span><br><span class="line"><span class="string">type=str 指定参数类型</span></span><br><span class="line"><span class="string">help=&#x27;filename&#x27; 指定提示语</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">parser.add_argument(<span class="string">&#x27;-f&#x27;</span>, <span class="string">&#x27;--filename&#x27;</span>, required=<span class="literal">True</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, <span class="built_in">help</span>=<span class="string">&#x27;filename&#x27;</span> 指定提示语)</span><br><span class="line"></span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">filename = args.filename  <span class="comment"># filename存放了外部参数的值</span></span><br></pre></td></tr></table></figure><p>详细请参见<code>参考资料2</code></p><h2 id="Python文件、字符串操作"><a href="#Python文件、字符串操作" class="headerlink" title="Python文件、字符串操作"></a>Python文件、字符串操作</h2><p>略</p><h2 id="在Python中执行Shell命令"><a href="#在Python中执行Shell命令" class="headerlink" title="在Python中执行Shell命令"></a>在Python中执行Shell命令</h2><p>有两种方式。使用<code>os.system(&quot;command&quot;)</code>执行无返回值的Shell命令；使用<code>f = os.popen(&quot;command&quot;)</code>执行有输出的Shell命令，其返回值<code>f</code>是一个文件对象，通过<code>f.read()</code>来读取命令输出内容。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="http://c.biancheng.net/shell/">Shell 脚本学习指南</a></li><li><a href="https://docs.python.org/zh-cn/3/howto/argparse.html">Python Argparse 教程</a></li><li><a href="https://blog.csdn.net/qq_27825451/article/details/102909772">python执行shell脚本的几种方法</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近遇到如下需求：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有一个文件，文件格式大概是这样&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;</summary>
      
    
    
    
    <category term="Linux" scheme="https://gmet233.gitee.io/categories/Linux/"/>
    
    <category term="Scripts" scheme="https://gmet233.gitee.io/categories/Linux/Scripts/"/>
    
    
    <category term="Linux Bash" scheme="https://gmet233.gitee.io/tags/Linux-Bash/"/>
    
    <category term="Python" scheme="https://gmet233.gitee.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>田忌赛马与贪心法则</title>
    <link href="https://gmet233.gitee.io/2021/12/20/%E7%94%B0%E5%BF%8C%E8%B5%9B%E9%A9%AC%E4%B8%8E%E8%B4%AA%E5%BF%83%E6%B3%95%E5%88%99/"/>
    <id>https://gmet233.gitee.io/2021/12/20/%E7%94%B0%E5%BF%8C%E8%B5%9B%E9%A9%AC%E4%B8%8E%E8%B4%AA%E5%BF%83%E6%B3%95%E5%88%99/</id>
    <published>2021-12-20T13:59:45.000Z</published>
    <updated>2021-12-20T14:01:55.082Z</updated>
    
    <content type="html"><![CDATA[<p>本文涉及*<a href="https://leetcode-cn.com/problems/advantage-shuffle/">LeetCode 870. 优势洗牌</a>*</p><blockquote><p>给定两个大小相等的数组 A 和 B，A 相对于 B 的优势可以用满足 A[i] &gt; B[i] 的索引 i 的数目来描述。返回 A 的任意排列，使其相对于 B 的优势最大化。</p><p>示例 1：</p><p>输入：A = [2,7,11,15], B = [1,10,4,11]<br>输出：[2,11,7,15]<br>示例 2：</p><p>输入：A = [12,24,8,32], B = [13,25,32,11]<br>输出：[24,32,8,12]</p></blockquote><p>这就像⽥忌赛⻢的情景，nums1 就是⽥忌的⻢，nums2 就是⻬王的⻢，数组中的元素就是⻢的战⽃⼒：</p><p>算法策略是：<strong>将⻬王和⽥忌的⻢按照战⽃⼒排序，然后按照排名⼀⼀对⽐。如果⽥忌的⻢能赢，那就⽐赛，如果赢不了，那就换个垫底的来送⼈头，保存实⼒。</strong></p><p>这里要注意一个问题：是否需要保存实力，即如果⽥忌的⼆号选⼿也能⼲得过⻬王的⼀号选⼿，此时让⼆号选⼿去对决⻬王的⼀号选⼿，不是更节约？</p><p>这种节约的策略是没问题的，但是<strong>没有必要</strong>。</p><p>我们暂且把⽥忌的⼀号选⼿称为 T1，⼆号选⼿称为 T2，⻬王的⼀号选⼿称为 Q1。如果 T2 能赢 Q1，你试图保存⼰⽅实⼒，让 T2 去战 Q1，把 T1 留着是为了对付谁？显然，你担⼼⻬王还有战⼒⼤于 T2 的⻢，可以让 T1 去对付。但是你仔细想想，现在 T2 已经是可以战胜 Q1 的，Q1 可是⻬王的最快的⻢，⻬王剩下的那些⻢⾥，怎么可能还有⽐ T2 更强的⻢？</p><p>所以没必要节约。</p><p>根据上述思路得到的代码逻辑如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对两个数组nums1和nums2排序</span><br><span class="line">对两个数组的元素挨个比较，如果nums1[i]&gt;nums2[i]那就比，否则就换上nums1最小的元素进行比较。</span><br></pre></td></tr></table></figure><p>由于需要对两个数组排序，但是返回结果依赖nums2的顺序，所以不能直接对nums2进行排序，而是利用优先级队列。（将(index, nums2[index]放入优先级队列，出队优先级按照nums2[index]大小，index记录索引值）</p><p>此外，解法还是用到双指针技巧。完整代码如下。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] advantageCount(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums1.length;</span><br><span class="line">    <span class="comment">// 给 nums2 降序排序</span></span><br><span class="line">    PriorityQueue&lt;<span class="keyword">int</span>[]&gt; maxpq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(</span><br><span class="line">        (<span class="keyword">int</span>[] pair1, <span class="keyword">int</span>[] pair2) -&gt; &#123; </span><br><span class="line">            <span class="keyword">return</span> pair2[<span class="number">1</span>] - pair1[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        maxpq.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, nums2[i]&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 给 nums1 升序排序</span></span><br><span class="line">    Arrays.sort(nums1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// nums1[left] 是最小值，nums1[right] 是最大值</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!maxpq.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] pair = maxpq.poll();</span><br><span class="line">        <span class="comment">// maxval 是 nums2 中的最大值，i 是对应索引</span></span><br><span class="line">        <span class="keyword">int</span> i = pair[<span class="number">0</span>], maxval = pair[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (maxval &lt; nums1[right]) &#123;</span><br><span class="line">            <span class="comment">// 如果 nums1[right] 能胜过 maxval，那就自己上</span></span><br><span class="line">            res[i] = nums1[right];</span><br><span class="line">            right--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则用最小值去换nums2的最大值</span></span><br><span class="line">            res[i] = nums1[left];</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247491139&idx=1&sn=10cb35e0056ac8f8c540fccd0156f333&scene=21&ascene=7&devicetype=iOS15.2&version=1800103a&nettype=WIFI&abtest_cookie=AAACAA==&lang=zh_CN&fontScale=100&exportkey=A2t5E2fVKmwEJxWEKsScbfU=&pass_ticket=n3zshxiiR8IMf1IfoZgzB+PSm6RatluaPa8vtuS3bDtR2ttHhdhxmZkQCXMUyC9L&wx_header=1">labuladong: 算法大师——孙膑</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文涉及*&lt;a href=&quot;https://leetcode-cn.com/problems/advantage-shuffle/&quot;&gt;LeetCode 870. 优势洗牌&lt;/a&gt;*&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定两个大小相等的数组 A 和 B，A 相对于 B </summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://gmet233.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="数组/链表" scheme="https://gmet233.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84-%E9%93%BE%E8%A1%A8/"/>
    
    
    <category term="数据结构与算法" scheme="https://gmet233.gitee.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="贪心" scheme="https://gmet233.gitee.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>PriorityQueue 概述</title>
    <link href="https://gmet233.gitee.io/2021/12/19/PriorityQueue-%E6%A6%82%E8%BF%B0/"/>
    <id>https://gmet233.gitee.io/2021/12/19/PriorityQueue-%E6%A6%82%E8%BF%B0/</id>
    <published>2021-12-19T08:58:37.000Z</published>
    <updated>2021-12-19T09:06:39.869Z</updated>
    
    <content type="html"><![CDATA[<h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><p><code>Queue</code>是一个严格的先进先出（FIFO）的队列。</p><p>但有时候这并不能满足我们的需求。当我们需要对队列中的元素重排，按照重排后的元素顺序出队时，这时候就需要<code>PriorityQueue</code>。</p><p><code>PriorityQueue</code>和<code>Queue</code>的区别在于，它的出队顺序与元素的优先级有关，对<code>PriorityQueue</code>调用<code>remove()</code>或<code>poll()</code>方法，返回的总是优先级最高的元素。</p><p>要使用<code>PriorityQueue</code>，我们就必须给每个元素定义“优先级”。请看下面的例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPriorityQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Queue&lt;User&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(</span><br><span class="line">                (User user1, User user2) -&gt; &#123;</span><br><span class="line">                    <span class="keyword">return</span> user2.getLevel() - user1.getLevel();</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">        queue.offer(<span class="keyword">new</span> User(<span class="string">&quot;sb_1&quot;</span>, <span class="number">1</span>)); <span class="comment">//优先级低</span></span><br><span class="line">        queue.offer(<span class="keyword">new</span> User(<span class="string">&quot;vip_1&quot;</span>, <span class="number">2</span>)); <span class="comment">//优先级高</span></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            User user = queue.poll();</span><br><span class="line">            System.out.println(user.getName());</span><br><span class="line">        &#125; <span class="comment">//出队的顺序是vip_1, sb_1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> level;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.level = level;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//getter、setter</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的例子使用lambda表达式实现了排序。你也可以自定义排序器（实现Comparable接口），然后将排序器对象传递给<code>PriorityQueue</code>构造器。构造函数签名如下：</p><p><code>public PriorityQueue(Comparator&lt;? super E&gt; comparator)</code></p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>通过堆实现，具体说是通过完全二叉树（<em>complete binary tree</em>）实现的<strong>小顶堆</strong>（任意一个非叶子节点的权值，都不大于其左右子节点的权值）。</p><p>具体请参考<strong>堆排序</strong>。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1265120632401152">https://www.liaoxuefeng.com/wiki/1252599548343744/1265120632401152</a></li><li><a href="https://www.cnblogs.com/CarpenterLee/p/5488070.html">https://www.cnblogs.com/CarpenterLee/p/5488070.html</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;快速入门&quot;&gt;&lt;a href=&quot;#快速入门&quot; class=&quot;headerlink&quot; title=&quot;快速入门&quot;&gt;&lt;/a&gt;快速入门&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Queue&lt;/code&gt;是一个严格的先进先出（FIFO）的队列。&lt;/p&gt;
&lt;p&gt;但有时候这并不能满足我们的需求。</summary>
      
    
    
    
    <category term="Java" scheme="https://gmet233.gitee.io/categories/Java/"/>
    
    <category term="集合" scheme="https://gmet233.gitee.io/categories/Java/%E9%9B%86%E5%90%88/"/>
    
    
    <category term="Java" scheme="https://gmet233.gitee.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>单例设计模式</title>
    <link href="https://gmet233.gitee.io/2021/12/16/%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://gmet233.gitee.io/2021/12/16/%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-12-16T13:19:39.000Z</published>
    <updated>2021-12-16T13:48:11.500Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>单例模式确保一个类只有一个实例，并提供了一个全局访问点。</p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>线程池，数据库连接对象。</p><h1 id="经典单例模式"><a href="#经典单例模式" class="headerlink" title="经典单例模式"></a>经典单例模式</h1><p>一个经典的单例模式实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> This is not thread safe!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> uniqueInstance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该实现是线程不安全的。可以想象有两个线程同时进入了getInstance()方法。</p><h1 id="解决经典单例模式线程安全问题"><a href="#解决经典单例模式线程安全问题" class="headerlink" title="解决经典单例模式线程安全问题"></a>解决经典单例模式线程安全问题</h1><p>解决方案，给getInstance方法加上synchronized关键字，迫使每个线程进入该方法前都需要等待别的线程离开该方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> uniqueInstance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该解决方案得缺点就是只有第一次执行该方法才真正需要线程同步。</p><h1 id="更进一步…"><a href="#更进一步…" class="headerlink" title="更进一步…"></a>更进一步…</h1><p>这里给出三种改善方案：</p><ol><li>如果getInstance得性能对于应用程序不是很关键，就什么也别做。</li><li>使用“急切”创建实例，而不用延迟实例化的做法。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>使用<strong>双重检查加锁</strong>，在getInstance中减少使用同步。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>备注：</p><ul><li>首先检查实例是否存在，如果不存在再进入同步代码块。</li><li>进入区块后在检查一次，如果仍然是null则创建实例。</li><li>volatile关键字确保：当instance变量初始化后，多个线程正确的处理instance变量。</li></ul><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><blockquote><p>两个类加载器可能有机会创建自己的单例实例？</p></blockquote><p>是的。所以如果你的程序有多个类加载器又同时使用了单例模式，请小心。解决方法是自行指定类加载器，并指定同一个类加载器。</p><blockquote><p>类如果能做两件事，就违反了OO设计。单例模式是否违反了这样的观念呢？</p></blockquote><p>单例类不止负责管理自己的实例，还在应用程序中担任角色，所以可以视为是两个责任。但是由类管理自己的实例的做法并不少见，也可以让设计更简单。</p><blockquote><p>我想把单例类当成超类，设计出子类。究竟可不可以继承单例类。</p></blockquote><p>不能。继承单例类遇到的一个问题就是构造器是私有的。你不能用私有构造器来扩展类。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《Head First设计模式》(中文版)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;单例模式确保一个类只有一个实例，并提供了一个全局访问点。&lt;/p&gt;
&lt;h1 id=&quot;应用&quot;&gt;&lt;a href=&quot;#应用&quot; class=&quot;head</summary>
      
    
    
    
    <category term="设计模式" scheme="https://gmet233.gitee.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://gmet233.gitee.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="Java" scheme="https://gmet233.gitee.io/tags/Java/"/>
    
  </entry>
  
</feed>
