<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Gmet&#39;s Blog</title>
  
  <subtitle>Eureka!</subtitle>
  <link href="https://gmet233.gitee.io/atom.xml" rel="self"/>
  
  <link href="https://gmet233.gitee.io/"/>
  <updated>2022-03-09T14:09:12.964Z</updated>
  <id>https://gmet233.gitee.io/</id>
  
  <author>
    <name>Met Guo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【笔记】BFS 算法解题套路框架</title>
    <link href="https://gmet233.gitee.io/2022/03/09/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91BFS-%E7%AE%97%E6%B3%95%E8%A7%A3%E9%A2%98%E5%A5%97%E8%B7%AF%E6%A1%86%E6%9E%B6/"/>
    <id>https://gmet233.gitee.io/2022/03/09/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91BFS-%E7%AE%97%E6%B3%95%E8%A7%A3%E9%A2%98%E5%A5%97%E8%B7%AF%E6%A1%86%E6%9E%B6/</id>
    <published>2022-03-09T14:08:06.000Z</published>
    <updated>2022-03-09T14:09:12.964Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文FROM《labuladong 算法秘籍》</p></blockquote><h1 id="什么是-BFS"><a href="#什么是-BFS" class="headerlink" title="什么是 BFS"></a>什么是 BFS</h1><p>BFS(Breadth First Search)，广度优先搜索，起源于<strong>树的层次遍历</strong>。其核心是利用<strong>队列</strong>这种数据结构。</p><p>BFS 的核心思想应该不难理解的，就是把⼀些问题抽象成图，从⼀个点开始，向四周开始扩散。 </p><h1 id="BFS-的应用场景"><a href="#BFS-的应用场景" class="headerlink" title="BFS 的应用场景"></a>BFS 的应用场景</h1><p>BFS 算法常见于求最值的场景，因为 BFS 的算法逻辑保证了算法第⼀次到达目标时的代价是最小的（？）。</p><p>举例⼀下 BFS 出现的常见场景好吧，问题的本质就是让你在⼀幅「图」中找到从起点 start 到终点 target 的最近距离。</p><p>这个广义的描述可以有各种变体，比如走迷宫，有的格子是围墙不能走，从起点到终点的最短距离是多少？如果这个迷宫带「传送门」可以瞬间传送呢？再比如说两个单词，要求你通过某些替换，把其中一个变成另一个，每次只能替换一个字符，最少要替换几次？再比如说连连看游戏，两个方块消除的条件不仅仅是图案相同，还得保证两个方块之间的最短连线不能多于两个拐点。你玩连连看，点击两个坐标，游戏是如何判断它俩的最短连线有几个拐点的？</p><h1 id="BFS-框架代码"><a href="#BFS-框架代码" class="headerlink" title="BFS 框架代码"></a>BFS 框架代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算从起点 start 到终点 target 的最近距离</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(Node start, Node target)</span> </span>&#123;</span><br><span class="line">    Queue&lt;Node&gt; q; <span class="comment">// 核心数据结构</span></span><br><span class="line">    Set&lt;Node&gt; visited; <span class="comment">// 避免走回头路</span></span><br><span class="line">    </span><br><span class="line">    q.offer(start); <span class="comment">// 将起点加入队列</span></span><br><span class="line">    visited.add(start);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>; <span class="comment">// 记录扩散的步数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (q not empty) &#123;</span><br><span class="line">        <span class="keyword">int</span> sz = q.size();</span><br><span class="line">        <span class="comment">/* 将当前队列中的所有节点向四周扩散 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            Node cur = q.poll();</span><br><span class="line">            <span class="comment">/* 划重点：这里判断是否到达终点 */</span></span><br><span class="line">            <span class="keyword">if</span> (cur is target)</span><br><span class="line">                <span class="keyword">return</span> step;</span><br><span class="line">            <span class="comment">/* 将 cur 的相邻节点加入队列 */</span></span><br><span class="line">            <span class="keyword">for</span> (Node x : cur.adj()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x not in visited) &#123;</span><br><span class="line">                    q.offer(x);</span><br><span class="line">                    visited.add(x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 划重点：更新步数在这里 */</span></span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>队列 <code>q</code> 就不说了，BFS 的核心数据结构；<code>cur.adj()</code> 泛指 <code>cur</code> 相邻的节点，比如说二维数组中，<code>cur</code> 上下左右四面的位置就是相邻节点；<code>visited</code> 的主要作用是防止走回头路，大部分时候都是必须的，但是像一般的二叉树结构，没有子节点到父节点的指针，不会走回头路就不需要 <code>visited</code>。</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p>LeetCode 111、752</p><h1 id="双向BFS（了解）"><a href="#双向BFS（了解）" class="headerlink" title="双向BFS（了解）"></a>双向BFS（了解）</h1><p>传统的 BFS 框架就是从起点开始向四周扩散，遇到终点时停止；而双向 BFS 则是从起点和终点同时开始扩散，当两边有交集的时候停止。</p><h1 id="BFS-与-DFS"><a href="#BFS-与-DFS" class="headerlink" title="BFS 与 DFS"></a>BFS 与 DFS</h1><blockquote><p>这部分不是很懂，后面再看</p></blockquote><p>BFS 相对 DFS 的最主要的区别是：BFS 找到的路径⼀定是最短的，但代价就是空间复杂度可能比 DFS 大很多。</p><p><strong>1、为什么 BFS 可以找到最短距离，DFS 不行吗</strong>？</p><p>首先，你看 BFS 的逻辑，<code>depth</code> 每增加一次，队列中的所有节点都向前迈一步，这保证了第一次到达终点的时候，走的步数是最少的。</p><p>DFS 不能找最短路径吗？其实也是可以的，但是时间复杂度相对高很多。你想啊，DFS 实际上是靠递归的堆栈记录走过的路径，你要找到最短路径，肯定得把二叉树中所有树杈都探索完才能对比出最短的路径有多长对不对？而 BFS 借助队列做到一次一步「齐头并进」，是可以在不遍历完整棵树的条件下找到最短距离的。</p><p>形象点说，DFS 是线，BFS 是面；DFS 是单打独斗，BFS 是集体行动。这个应该比较容易理解吧。</p><p><strong>2、既然 BFS 那么好，为啥 DFS 还要存在</strong>？</p><p>BFS 可以找到最短距离，但是空间复杂度高，而 DFS 的空间复杂度较低。</p><p>还是拿刚才我们处理二叉树问题的例子，假设给你的这个二叉树是满二叉树，节点数为 <code>N</code>，对于 DFS 算法来说，空间复杂度无非就是递归堆栈，最坏情况下顶多就是树的高度，也就是 <code>O(logN)</code>。</p><p>但是你想想 BFS 算法，队列中每次都会储存着二叉树一层的节点，这样的话最坏情况下空间复杂度应该是树的最底层节点的数量，也就是 <code>N/2</code>，用 Big O 表示的话也就是 <code>O(N)</code>。</p><p>由此观之，BFS 还是有代价的，一般来说在找最短路径的时候使用 BFS，其他时候还是 DFS 使用得多一些（主要是递归代码好写）。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://labuladong.gitee.io/algo/4/30/113/">BFS 算法解题套路框架</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文FROM《labuladong 算法秘籍》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;什么是-BFS&quot;&gt;&lt;a href=&quot;#什么是-BFS&quot; class=&quot;headerlink&quot; title=&quot;什么是 BFS&quot;&gt;&lt;/a&gt;什么是 BFS</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://gmet233.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="BFS" scheme="https://gmet233.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/BFS/"/>
    
    
    <category term="算法" scheme="https://gmet233.gitee.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="BFS" scheme="https://gmet233.gitee.io/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>什么是端到端（end-to-end）的学习模型</title>
    <link href="https://gmet233.gitee.io/2022/03/07/%E4%BB%80%E4%B9%88%E6%98%AF%E7%AB%AF%E5%88%B0%E7%AB%AF%EF%BC%88end-to-end%EF%BC%89%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B/"/>
    <id>https://gmet233.gitee.io/2022/03/07/%E4%BB%80%E4%B9%88%E6%98%AF%E7%AB%AF%E5%88%B0%E7%AB%AF%EF%BC%88end-to-end%EF%BC%89%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B/</id>
    <published>2022-03-07T12:25:03.000Z</published>
    <updated>2022-03-07T12:25:29.762Z</updated>
    
    <content type="html"><![CDATA[<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p><strong>端到端的学习模型</strong>是指将原始数据不做任何的预处理直接将原始数据输入到模型当中，最后得到的输出结果与期望结果有误差，这误差在反向传播模型的各层中，将参数进行优化，一直到期望结果结束。<strong>非端到端</strong>是将原始数据进行标注，得到具有特征的处理后的数据，然后在作为输入，这样的弊端是如果提取数据特征时出现错误，将无法调整。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://www.its203.com/article/qq_42514225/108835224?2022-03-07">什么是端到端的学习模型</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;&gt;&lt;/a&gt;正文&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;端到端的学习模型&lt;/strong&gt;是指将原始数据不做任何的预处理直接将原始数据输入到模型当中，最后得到的输出结果与期望结果有</summary>
      
    
    
    
    <category term="机器学习" scheme="https://gmet233.gitee.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="机器学习" scheme="https://gmet233.gitee.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>最大M对齐子集</title>
    <link href="https://gmet233.gitee.io/2022/03/01/%E6%9C%80%E5%A4%A7M%E5%AF%B9%E9%BD%90%E5%AD%90%E9%9B%86/"/>
    <id>https://gmet233.gitee.io/2022/03/01/%E6%9C%80%E5%A4%A7M%E5%AF%B9%E9%BD%90%E5%AD%90%E9%9B%86/</id>
    <published>2022-03-01T13:52:37.000Z</published>
    <updated>2022-03-01T13:53:34.808Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>有 N 个点位于一条线上，编号从 0 到 N-1 ，其坐标在数组 A 中给出。对于每个I (0 ≤ l &lt;N)，直线上点数 I 的坐标为 A[l] 。点的坐标可能相同。</p><p>对于给定的整数 M ，如果子集内任意两个点之间的距离可被M整除，则称这些点的子集为M<strong>对齐</strong>。您的任务是查找给定 N 个点集的最大 M 对齐子集的大小。</p><p>例如，考虑整数 M=3 和数组 A，如下所示：</p><blockquote><p>A[0] = -3  A[1] = -2  A[2] = 1  A[3] = 0  A[4] = 8  A[5] = 7  A[6] = 1</p></blockquote><p>包含编号为1、2、5和6的点的子集，坐标分别为-2、1、7和1，是3对齐子集的示例，因为：</p><ul><li>编号为1和2的点之间的距离为abs(A[1] - A[2]) = 3，</li><li>从5号点到编号1和2的点的距离分别为9和6，</li><li>从6号点到编号为1、2和5的点的距离分别为3、0和6，</li></ul><p>这些距离都可以被 M=3 整除。此子集的大小为4，并且没有更大的3对齐子集。</p><p>编写一个函数:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> M)</span></span>;</span><br></pre></td></tr></table></figure><p>给定一个由 N 个整数和一个整数 M 组成的数组 A，返回最大 M 对齐子集的大小。</p><p>例如，给定 M=3 且 A=[-3，-2，1，0，8，7，1]，函数应返回4，如上所述；</p><p>给定 M=8 且 A=[7，1，11，8,4，10]，函数应返回1。</p><h1 id="解"><a href="#解" class="headerlink" title="解"></a>解</h1><p>把所有按 M 的余数存成一组就可以，<strong>同组的刚好把余数消掉就是距离整除</strong>。返回最大即为所求。</p><p><strong>注意</strong>：余数为负的，需要转为最小正余数（+M）</p><h2 id="Java实现"><a href="#Java实现" class="headerlink" title="Java实现"></a>Java实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> M)</span></span>&#123;</span><br><span class="line">    <span class="comment">//remainders[i] = j, 表示余数为i的频次是j</span></span><br><span class="line">    <span class="keyword">int</span>[] remainders = <span class="keyword">new</span> <span class="keyword">int</span>[M];</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>; <span class="comment">// 记录最大的频次</span></span><br><span class="line">    <span class="keyword">int</span> N = A.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> remainder = A[i] % M;</span><br><span class="line">        <span class="keyword">if</span>(remainder &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            remainder += M;</span><br><span class="line">        &#125;</span><br><span class="line">        remainders[remainder] ++;</span><br><span class="line">        ans = Math.max(ans, remainders[remainder]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;有 N 个点位于一条线上，编号从 0 到 N-1 ，其坐标在数组 A 中给出。对于每个I (0 ≤ l &amp;lt;N)，直线上点数 I 的坐标</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://gmet233.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="数论" scheme="https://gmet233.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/"/>
    
    
    <category term="算法" scheme="https://gmet233.gitee.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数论" scheme="https://gmet233.gitee.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>求数字1在所有不超过N的十进制正整数中出现的次数</title>
    <link href="https://gmet233.gitee.io/2022/03/01/%E6%B1%82%E6%95%B0%E5%AD%971%E5%9C%A8%E6%89%80%E6%9C%89%E4%B8%8D%E8%B6%85%E8%BF%87N%E7%9A%84%E5%8D%81%E8%BF%9B%E5%88%B6%E6%AD%A3%E6%95%B4%E6%95%B0%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/"/>
    <id>https://gmet233.gitee.io/2022/03/01/%E6%B1%82%E6%95%B0%E5%AD%971%E5%9C%A8%E6%89%80%E6%9C%89%E4%B8%8D%E8%B6%85%E8%BF%87N%E7%9A%84%E5%8D%81%E8%BF%9B%E5%88%B6%E6%AD%A3%E6%95%B4%E6%95%B0%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</id>
    <published>2022-03-01T13:51:19.000Z</published>
    <updated>2022-03-01T13:52:07.445Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>写一个函数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span> N)</span></span>;</span><br></pre></td></tr></table></figure><p>即给定一个整数N，返回数字1在所有不超过 N 的正整数的十进制表示中出现的次数。</p><p>例如，给定N = 13，该函数应返回6，因为：</p><ul><li>所有不超过13的正整数是1、2、3、4、5、6、7、8、9、10、11、12 和13；</li><li>数字1共出现六次：一次在数字1中，一次在数字10中，两次在数字11中，一次在数字12中，一次在数字13中。</li></ul><p>N 是[0.. 100,000,000]范围内的整数。</p><h1 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h1><p>暴力求解：遍历每一个数，对每一个数求1的个数，然后加起来得和。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span> N)</span><span class="comment">//统计1-n中1的个数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&gt;<span class="number">0</span>; j/=<span class="number">10</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(j%<span class="number">10</span>==<span class="number">1</span>)</span><br><span class="line">ans ++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法时间复杂度：$O(nlgn)$</p><h1 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h1><p>考虑两位数。将一个正整数中1的个数分成两部分，一部分是个位上出现1的数目f1(n)，一部分是十位上出现1的数目f2(n) 。</p><p>n=10， f1(10)=1（1-10个位出现的1的个数为1），f2(10)=1（1-10个位出现的1的十数为1）。</p><p>举一些代表性的数：</p><div class="table-container"><table><thead><tr><th>n</th><th>f1(n)</th><th>f2(n)</th><th>f(n)</th></tr></thead><tbody><tr><td>10</td><td>1</td><td>1</td><td>2</td></tr><tr><td>11</td><td>2</td><td>2</td><td>4</td></tr><tr><td>12</td><td>2</td><td>3</td><td>5</td></tr><tr><td>13</td><td>2</td><td>4</td><td>6</td></tr><tr><td>20</td><td>2</td><td>10</td><td>12</td></tr><tr><td>21</td><td>3</td><td>10</td><td>13</td></tr><tr><td>22</td><td>3</td><td>10</td><td>13</td></tr><tr><td>23</td><td>3</td><td>10</td><td>13</td></tr><tr><td>30</td><td>3</td><td>10</td><td>13</td></tr><tr><td>31</td><td>4</td><td>10</td><td>14</td></tr><tr><td>32</td><td>4</td><td>10</td><td>14</td></tr><tr><td>33</td><td>4</td><td>10</td><td>14</td></tr></tbody></table></div><p>先来看十位，当十位上的数为1时，</p><div class="table-container"><table><thead><tr><th>n</th><th>f2(n)</th></tr></thead><tbody><tr><td>10</td><td>1</td></tr><tr><td>11</td><td>2</td></tr><tr><td>12</td><td>3</td></tr><tr><td>13</td><td>4</td></tr></tbody></table></div><p>f2(n)=当前数个位数字+1；</p><p>当十位上的数大于1时，</p><div class="table-container"><table><thead><tr><th>n</th><th>f2(n)</th></tr></thead><tbody><tr><td>20</td><td>10</td></tr><tr><td>21</td><td>10</td></tr><tr><td>22</td><td>10</td></tr><tr><td>23</td><td>10</td></tr><tr><td>30</td><td>10</td></tr><tr><td>31</td><td>10</td></tr><tr><td>32</td><td>10</td></tr><tr><td>33</td><td>10</td></tr></tbody></table></div><p>f2(n) = 10，也就是说此时十位上1的数目仅仅和十位有关系，也就是<strong>十位的位因子</strong>10。</p><p>再来看个位，当个位上的数为1的时候</p><div class="table-container"><table><thead><tr><th>n</th><th>f1(n)</th></tr></thead><tbody><tr><td>11</td><td>2</td></tr><tr><td>21</td><td>3</td></tr><tr><td>31</td><td>4</td></tr></tbody></table></div><p>f1(n) = 当前数十位数字+1；</p><p>当个位上的数大于1时，</p><div class="table-container"><table><thead><tr><th>n</th><th>f1(n)</th></tr></thead><tbody><tr><td>22</td><td>3</td></tr><tr><td>23</td><td>3</td></tr><tr><td>32</td><td>4</td></tr><tr><td>33</td><td>4</td></tr></tbody></table></div><p>f1(n) = 当前数十位数字+1；</p><p>还有当个位上的数等于0时，</p><div class="table-container"><table><thead><tr><th>n</th><th>f1(n)</th></tr></thead><tbody><tr><td>10</td><td>1</td></tr><tr><td>20</td><td>2</td></tr><tr><td>30</td><td>3</td></tr></tbody></table></div><p>f1(n) = 当前数十位数字。</p><p>这还不够，我们还没有分析两位数以上的数字，根据上面的分析，我们将当前位分为三种情况：=0，=1，&gt;1。</p><p>当百位上的数字是0的时候，假设n=12013。此时1-12013的所有整数中，百位上出现1的数是100~199，1100~1199，2100~2199……11100~11199。也就是12个100，1200个。也就是说此时百位上1的数目是由高位（12）决定的，而且等于高位（12）* 当前位因子（100）。</p><p>当百位上的数字是1的时候，假设n=12113。此时1-12113的所有整数中，百位上出现1的数是100~199，1100~1199，2100~2199……11100~11199，12100~12113。也就是13个100，1300个。也就是说此时百位上1的数目是由高位（12）决定的，而且等于（高位（12）+1）* 当前位因子（100）。</p><p>还有一个小问题就是如何求一个数的高位和低位，还有当前位。这和当前位的位因子有关系。</p><p>对于12345，假设当前位是百位（100），则</p><ul><li>低位数字：12345 - (12345 / 100) *100 = 45</li><li>高位数字：12345 / (100 * 10) = 12</li><li>当前位数字：12345 / 100 = 123，123 % 10 = 3。</li></ul><p>以上分析可以写出完整代码。</p><h2 id="Java实现"><a href="#Java实现" class="headerlink" title="Java实现"></a>Java实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> lowNum = <span class="number">0</span>; <span class="comment">// 当前位的低位的数字</span></span><br><span class="line">    <span class="keyword">int</span> currNum = <span class="number">0</span>; <span class="comment">// 当前位数字</span></span><br><span class="line">    <span class="keyword">int</span> highNum = <span class="number">0</span>; <span class="comment">// 当前位的高位的数字</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> factor = <span class="number">1</span>; factor &lt;= N; factor *= <span class="number">10</span>) &#123; <span class="comment">// 位因子</span></span><br><span class="line">        lowNum = N - (N / factor) * factor;</span><br><span class="line">        currNum = (N / factor) % <span class="number">10</span>;</span><br><span class="line">        highNum = N / (factor * <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span>(currNum == <span class="number">0</span>) &#123;</span><br><span class="line">            ans += highNum * factor;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(currNum == <span class="number">1</span>) &#123;</span><br><span class="line">            ans += highNum * factor + lowNum +<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans += (highNum + <span class="number">1</span>) * factor;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度只与N的位数有关，为$O(lgn)$。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://blog.csdn.net/liangbopirates/article/details/9323727">求1-N中十进制正整数1的个数</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;写一个函数&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://gmet233.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://gmet233.gitee.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【不会做】矩阵路径形成的最大整数</title>
    <link href="https://gmet233.gitee.io/2022/03/01/%E3%80%90%E4%B8%8D%E4%BC%9A%E5%81%9A%E3%80%91%E7%9F%A9%E9%98%B5%E8%B7%AF%E5%BE%84%E5%BD%A2%E6%88%90%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B4%E6%95%B0/"/>
    <id>https://gmet233.gitee.io/2022/03/01/%E3%80%90%E4%B8%8D%E4%BC%9A%E5%81%9A%E3%80%91%E7%9F%A9%E9%98%B5%E8%B7%AF%E5%BE%84%E5%BD%A2%E6%88%90%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B4%E6%95%B0/</id>
    <published>2022-03-01T13:47:55.000Z</published>
    <updated>2022-03-01T13:50:26.391Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>您将获得一个由 N 行和 M 列组成的板。电路板的每个字段（其实就是数组中的一个坐标点，作者注）都包含一个数字 (0-9)。</p><p>您希望查找由四个相邻字段组成的路径。如果两个字段共享一个共同点，则它们是相邻的。此外，路径中的字段应该是不同的（不能两次访问同一字段）。</p><p>路径的四位数字（按您访问它们的顺序）创建一个 整数。通过这种方式可以实现的最大整数是多少?</p><p>编写函数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span> <span class="params">(<span class="keyword">int</span>[][] board)</span> </span>;</span><br></pre></td></tr></table></figure><p>给定表示为由 N 行和 M 列组成的整数矩阵的板，则返回在长度为 4 的路径中连接值时可以实现的最大整数。<br>例子：给定以下板（N=3, M=5） :</p><p><img src="image-20220228105252210.png" alt="图1"></p><p>该函数应返回9121。您可以选择以下路径（第一 个字段用红色表示)：</p><p><img src="image-20220228105416502.png" alt="图2"></p><h1 id="解"><a href="#解" class="headerlink" title="解"></a>解</h1><p>知道用回溯或者BFS，但是代码写不出来。😓</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;您将获得一个由 N 行和 M 列组成的板。电路板的每个字段（其实就是数组中的一个坐标点，作者注）都包含一个数字 (0-9)。&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://gmet233.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="回溯" scheme="https://gmet233.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF/"/>
    
    
    <category term="算法" scheme="https://gmet233.gitee.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="回溯" scheme="https://gmet233.gitee.io/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>个人比较喜欢的健身动作</title>
    <link href="https://gmet233.gitee.io/2022/02/28/%E4%B8%AA%E4%BA%BA%E6%AF%94%E8%BE%83%E5%96%9C%E6%AC%A2%E7%9A%84%E5%81%A5%E8%BA%AB%E5%8A%A8%E4%BD%9C/"/>
    <id>https://gmet233.gitee.io/2022/02/28/%E4%B8%AA%E4%BA%BA%E6%AF%94%E8%BE%83%E5%96%9C%E6%AC%A2%E7%9A%84%E5%81%A5%E8%BA%AB%E5%8A%A8%E4%BD%9C/</id>
    <published>2022-02-28T15:31:17.000Z</published>
    <updated>2022-03-03T12:52:44.478Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文整理一下个人比较喜欢健身动作。并备注动作要点</p></blockquote><h1 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h1><h2 id="平板支撑"><a href="#平板支撑" class="headerlink" title="平板支撑"></a>平板支撑</h2><p>改善的平板支撑：</p><ol><li>身体后移</li><li>骨盆后倾：收紧臀部，感觉上向后顶</li><li>纠正身体位置。肩膀用力向前推，上肢离地更远。</li></ol><p>新手先做到第二点延长到60秒，再两点一起做。</p><p>禁忌：</p><ol><li>手臂后缩</li><li>提臀或者臀太低。相反要用力收紧骨盆</li></ol><h1 id="臀腿"><a href="#臀腿" class="headerlink" title="臀腿"></a>臀腿</h1><h2 id="深蹲"><a href="#深蹲" class="headerlink" title="深蹲"></a>深蹲</h2><p>使用弹力带加大深蹲的阻力。</p><h2 id="单腿罗马尼亚硬拉"><a href="#单腿罗马尼亚硬拉" class="headerlink" title="单腿罗马尼亚硬拉"></a>单腿罗马尼亚硬拉</h2><p>锻炼臀肌、腘绳肌，锻炼单腿站立的稳定性，膝关节得稳定性。</p><p>视频：<a href="https://www.bilibili.com/video/BV1Ci4y1R72o?spm_id_from=333.999.0.0">https://www.bilibili.com/video/BV1Ci4y1R72o?spm_id_from=333.999.0.0</a></p><h1 id="背部"><a href="#背部" class="headerlink" title="背部"></a>背部</h1><h2 id="引体向上"><a href="#引体向上" class="headerlink" title="引体向上"></a>引体向上</h2><p>如果做不来可以使用弹力绳辅助。</p><h1 id="前锯肌"><a href="#前锯肌" class="headerlink" title="前锯肌"></a>前锯肌</h1><p>待整理：<a href="https://www.bilibili.com/video/BV1qq4y1k7oP?spm_id_from=333.999.0.0">https://www.bilibili.com/video/BV1qq4y1k7oP?spm_id_from=333.999.0.0</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://www.bilibili.com/video/BV1SP4y1j71R?spm_id_from=333.999.0.0">核心太弱，肚子肯定大（3个技巧快速改善）</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文整理一下个人比较喜欢健身动作。并备注动作要点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;核心&quot;&gt;&lt;a href=&quot;#核心&quot; class=&quot;headerlink&quot; title=&quot;核心&quot;&gt;&lt;/a&gt;核心&lt;/h1&gt;&lt;h2 id=&quot;平板支撑&quot;&gt;</summary>
      
    
    
    
    <category term="方法论" scheme="https://gmet233.gitee.io/categories/%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
    <category term="健身" scheme="https://gmet233.gitee.io/categories/%E6%96%B9%E6%B3%95%E8%AE%BA/%E5%81%A5%E8%BA%AB/"/>
    
    
    <category term="健身" scheme="https://gmet233.gitee.io/tags/%E5%81%A5%E8%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>Keep上不错的课程合集</title>
    <link href="https://gmet233.gitee.io/2022/02/28/Keep%E4%B8%8A%E4%B8%8D%E9%94%99%E7%9A%84%E8%AF%BE%E7%A8%8B%E5%90%88%E9%9B%86/"/>
    <id>https://gmet233.gitee.io/2022/02/28/Keep%E4%B8%8A%E4%B8%8D%E9%94%99%E7%9A%84%E8%AF%BE%E7%A8%8B%E5%90%88%E9%9B%86/</id>
    <published>2022-02-28T15:24:57.000Z</published>
    <updated>2022-02-28T15:30:37.068Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文整理了一些适合自己的Keep课程，这些课程都亲自做过一遍。</p><p>本文会不断更新。</p></blockquote><div class="table-container"><table><thead><tr><th>课程名称</th><th>课程链接</th><th>难度</th><th>部位</th><th>器械</th><th>感受</th></tr></thead><tbody><tr><td>HIIT - 腹肌塑造</td><td><a href="https://show.gotokeep.com/course/607fefaa1310a35004149bc4">https://show.gotokeep.com/course/607fefaa1310a35004149bc4</a></td><td>3</td><td>腹部</td><td>不需要</td><td>挺累的，但是不难。做完腹部有明显酸痛</td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table></div>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文整理了一些适合自己的Keep课程，这些课程都亲自做过一遍。&lt;/p&gt;
&lt;p&gt;本文会不断更新。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;课程名</summary>
      
    
    
    
    <category term="方法论" scheme="https://gmet233.gitee.io/categories/%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
    <category term="健身" scheme="https://gmet233.gitee.io/categories/%E6%96%B9%E6%B3%95%E8%AE%BA/%E5%81%A5%E8%BA%AB/"/>
    
    
    <category term="健身" scheme="https://gmet233.gitee.io/tags/%E5%81%A5%E8%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>银行转账</title>
    <link href="https://gmet233.gitee.io/2022/02/27/%E9%93%B6%E8%A1%8C%E8%BD%AC%E8%B4%A6/"/>
    <id>https://gmet233.gitee.io/2022/02/27/%E9%93%B6%E8%A1%8C%E8%BD%AC%E8%B4%A6/</id>
    <published>2022-02-27T02:06:55.000Z</published>
    <updated>2022-02-28T15:10:27.229Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文FROM 微软 软开 笔试题</p></blockquote><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>您将获得两个银行之间的N次转账列表（编号0到N-1）：银行A和银行B，第K次传输由两个值描述：</p><ul><li>R[K]（A或B）代表收款人（转账发送到的银行）；</li><li>V[K]表示通过传输发送的值。</li></ul><p>所有转移均按他们在列表中出现的顺序完成。银行不想负债（即他们的账户余额可能不会低于0）。每家银行的初始账户余额最低是多少才能完成转账？</p><p>编写一个函数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] solution(String R, <span class="keyword">int</span>[] V);</span><br></pre></td></tr></table></figure><p>给定一个字符串R和一个长度均为N的整数数组V，返回一个由两个整数组成的数组。证书应按以下顺序表示银行A和B的最小初始账户余额：[银行A, 银行B]。</p><p>结果数组应作为整数向量返回。</p><p>例子：</p><ol><li>给定R = “BAABA”且V=[2,4,1,1,2]，函数应该返回[2, 4]。每次转账后的银行账户余额如下表所示：</li></ol><div class="table-container"><table><thead><tr><th></th><th>A</th><th>B</th></tr></thead><tbody><tr><td>初始余额</td><td>2</td><td>4</td></tr><tr><td>A -&gt; B：转移 2</td><td>0</td><td>6</td></tr><tr><td>B -&gt; A：转移 4</td><td>4</td><td>2</td></tr><tr><td>B -&gt; A：转移 1</td><td>5</td><td>1</td></tr><tr><td>A -&gt; B：转移 1</td><td>4</td><td>2</td></tr><tr><td>B -&gt; A：转移 2</td><td>6</td><td>0</td></tr></tbody></table></div><ol><li>给定R = “ABAB”且V=[10,5,10,15]，函数应返回[0, 15]。</li><li>给定R = “B”且V=[100]，函数应返回[100, 0]。</li></ol><p>为以下假设编写有效算法。</p><h1 id="解"><a href="#解" class="headerlink" title="解"></a>解</h1><p>以例1为例，设计银行A的初始余额为X，银行B的初始余额为Y。则每一次转账后A的余额分别为：</p><p>X-2, X+2, X+3, X+2, X+4；B的余额分别为：</p><p>Y+2, Y-2, Y-3, Y-2, Y-4；</p><p>根据题目要求得any(X, X-2, X+2, X+3, X+2, X+4) &gt;=0 &amp;&amp; any(Y, Y+2, Y-2, Y-3, Y-2, Y-4)&gt;=0</p><p>即要求X-2&gt;=0; Y-4&gt;=0;</p><p>题目求最小初始余额，可得，X=2； Y=4</p><p>下面是代码实现。</p><h2 id="Java实现"><a href="#Java实现" class="headerlink" title="Java实现"></a>Java实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] solution(String R, <span class="keyword">int</span>[] V) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = V.length;</span><br><span class="line">    <span class="keyword">int</span>[] A = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">int</span>[] B = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span>(R.charAt(<span class="number">0</span>) == <span class="string">&#x27;B&#x27;</span>) &#123;</span><br><span class="line">        B[<span class="number">0</span>] = V[<span class="number">0</span>];</span><br><span class="line">        A[<span class="number">0</span>] = -V[<span class="number">0</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        B[<span class="number">0</span>] = -V[<span class="number">0</span>];</span><br><span class="line">        A[<span class="number">0</span>] = V[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> min_A = A[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> min_B = B[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(R.charAt(i) == <span class="string">&#x27;B&#x27;</span>) &#123;</span><br><span class="line">            A[i] = A[i-<span class="number">1</span>] - V[i];</span><br><span class="line">            B[i] = B[i-<span class="number">1</span>] + V[i];</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            A[i] = A[i-<span class="number">1</span>] + V[i];</span><br><span class="line">            B[i] = B[i-<span class="number">1</span>] - V[i];</span><br><span class="line">        &#125;</span><br><span class="line">        min_A = Math.min(min_A, A[i]);</span><br><span class="line">        min_B = Math.min(min_B, B[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//min_A和min_B不能是负数</span></span><br><span class="line">    min_A = Math.max(<span class="number">0</span>, -min_A);</span><br><span class="line">    min_B = Math.max(<span class="number">0</span>, -min_B);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;min_A, min_B&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文FROM 微软 软开 笔试题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;您将获得两个银行之间的N次转账列表（编</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://gmet233.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="数组" scheme="https://gmet233.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/"/>
    
    
    <category term="算法" scheme="https://gmet233.gitee.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数组" scheme="https://gmet233.gitee.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>找到数组中比左边元素都大同时比右边元素都小的元素</title>
    <link href="https://gmet233.gitee.io/2022/02/23/%E6%89%BE%E5%88%B0%E6%95%B0%E7%BB%84%E4%B8%AD%E6%AF%94%E5%B7%A6%E8%BE%B9%E5%85%83%E7%B4%A0%E9%83%BD%E5%A4%A7%E5%90%8C%E6%97%B6%E6%AF%94%E5%8F%B3%E8%BE%B9%E5%85%83%E7%B4%A0%E9%83%BD%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/"/>
    <id>https://gmet233.gitee.io/2022/02/23/%E6%89%BE%E5%88%B0%E6%95%B0%E7%BB%84%E4%B8%AD%E6%AF%94%E5%B7%A6%E8%BE%B9%E5%85%83%E7%B4%A0%E9%83%BD%E5%A4%A7%E5%90%8C%E6%97%B6%E6%AF%94%E5%8F%B3%E8%BE%B9%E5%85%83%E7%B4%A0%E9%83%BD%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/</id>
    <published>2022-02-23T12:33:29.000Z</published>
    <updated>2022-02-23T12:34:38.886Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>求数组中比左边元素都大同时比右边元素都小的元素，返回这些元素的索引。要求时间复杂度$O(N)$</p><blockquote><p>输入：[2, 3, 1, 8, 9, 20, 12]<br>输出：3, 4<br>解释：数组中 8, 9 满足题目要求，他们的索引分别是 3、4</p></blockquote><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>最简单最暴力的就是没从头到尾遍历元素，对于每个元素分别往前、往后遍历一下，看看是否它是否满足条件。</p><p>这种解法的时间复杂度为$O(N^2)$，不符合题目要求。</p><p>通过分析可以得到，对于每个元素，如果它比<strong>左侧最大的值</strong>要大，同时比<strong>右侧最小的值</strong>要小，就满足条件。</p><p>那如果有这样两个数组，</p><p><code>left_max[i]</code> 表示原数组 [0, i) 的最大值</p><p><code>right_min[i]</code> 表示原数组 (i, n) 的最小值</p><p>内循环就可以通过 <code>left_max[i] &lt; nums[i] &amp;&amp; nums[i] &lt; right_min[i]</code> 来判断了。</p><p>对于 left_max 和 right_min 这两数组，提前先算好，每个数组都能$O(N)$得到。</p><p>left_max 和 right_min 递推式如下：</p><blockquote><p>left_max[i] = max(left_max[i-1], nums[i])</p><p>right_min[i] = min(right_min[i-1], nums[i])</p></blockquote><p>总时间复杂度为 $O(N)$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ...</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] left_max = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span>[] right_min = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(left_max, Integer.MIN_VALUE);</span><br><span class="line">        Arrays.fill(right_min, Integer.MAX_VALUE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            left_max[i] = Math.max(left_max[i-<span class="number">1</span>], nums[i-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n-<span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            right_min[i] = Math.min(right_min[i+<span class="number">1</span>], nums[i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; left_max[i] &amp;&amp; nums[i] &lt; right_min[i]) &#123;</span><br><span class="line">                res.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://mp.weixin.qq.com/s/ilOdw4qdu_EJZNXvybqdag">一道热乎的字节三面原创题</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;求数组中比左边元素都大同时比右边元素都小的元素，返回这些元素的索引。要求时间复杂度$O(N)$&lt;/p&gt;
&lt;blockquot</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://gmet233.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="数组/链表" scheme="https://gmet233.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84-%E9%93%BE%E8%A1%A8/"/>
    
    
    <category term="算法" scheme="https://gmet233.gitee.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数组" scheme="https://gmet233.gitee.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>如何读论文</title>
    <link href="https://gmet233.gitee.io/2022/02/22/%E5%A6%82%E4%BD%95%E8%AF%BB%E8%AE%BA%E6%96%87/"/>
    <id>https://gmet233.gitee.io/2022/02/22/%E5%A6%82%E4%BD%95%E8%AF%BB%E8%AE%BA%E6%96%87/</id>
    <published>2022-02-22T13:37:55.000Z</published>
    <updated>2022-02-22T14:51:44.730Z</updated>
    
    <content type="html"><![CDATA[<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>一篇论文往往分为<strong>标题，摘要，导言，算法，实验，结论</strong>。</p><p><strong>算法</strong>就是论文作者提出的新的方法；<strong>实验</strong>是为了证明提出的算法。</p><h2 id="读第一遍"><a href="#读第一遍" class="headerlink" title="读第一遍"></a>读第一遍</h2><p>关注<strong>标题</strong>，<strong>摘要</strong>和<strong>结论</strong>；结论和摘要往往是一个东西，但是结论会把摘要的问题给证明一下；顺便看一下算法和实验部分的图标。</p><p><strong>目的</strong>：</p><ul><li>这篇论文介绍了什么</li><li>是否与自己相关</li><li>质量怎么样</li><li>是否继续读下去</li></ul><h2 id="读第二遍"><a href="#读第二遍" class="headerlink" title="读第二遍"></a>读第二遍</h2><p>如果第一遍认为该论文需要读下去，则进行第二遍通读，可以忽略很细节的部分，例如公式证明。</p><p>圈出引用的重要的相关的文献，例如，作者解决的问题是哪篇论文提出的，作者的方法是哪篇论文改进来的。</p><p><strong>目的：</strong></p><ul><li>掌握论文中的每一个图、表是什么意思；</li><li>作者的方法和别人的方法是怎么对比的，差距有多大</li></ul><h2 id="读第三遍"><a href="#读第三遍" class="headerlink" title="读第三遍"></a>读第三遍</h2><p>详细阅读第三遍，读懂每一句话，每一个细节。感同身受的去读。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://www.bilibili.com/video/BV1H44y1t75x">如何读论文 - 李沐</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;&gt;&lt;/a&gt;正文&lt;/h1&gt;&lt;p&gt;一篇论文往往分为&lt;strong&gt;标题，摘要，导言，算法，实验，结论&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;算法&lt;/strong&gt;</summary>
      
    
    
    
    <category term="方法论" scheme="https://gmet233.gitee.io/categories/%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
    <category term="阅读AI论文" scheme="https://gmet233.gitee.io/categories/%E6%96%B9%E6%B3%95%E8%AE%BA/%E9%98%85%E8%AF%BBAI%E8%AE%BA%E6%96%87/"/>
    
    
    <category term="方法论" scheme="https://gmet233.gitee.io/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>_Python 抛出异常后程序继续执行</title>
    <link href="https://gmet233.gitee.io/2022/02/22/Python-%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E5%90%8E%E7%A8%8B%E5%BA%8F%E7%BB%A7%E7%BB%AD%E6%89%A7%E8%A1%8C/"/>
    <id>https://gmet233.gitee.io/2022/02/22/Python-%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E5%90%8E%E7%A8%8B%E5%BA%8F%E7%BB%A7%E7%BB%AD%E6%89%A7%E8%A1%8C/</id>
    <published>2022-02-22T13:09:15.000Z</published>
    <updated>2022-02-22T13:16:04.092Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是一个知识碎片</p></blockquote><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>当遇到异常时，为了让程序继续执行而不中断，代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 可能抛出异常的代码块</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>注：<strong>这样做需要谨慎</strong>，原因如下：</p><ol><li>这样做抛出异常的类型不明确。可能抛出了你并不想忽略的异常；</li><li>这样做过于敷衍（除非你是有目的的这么做）</li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://blog.csdn.net/weixin_43307577/article/details/87710251">Python异常处理 -跳过异常继续执行</a></li><li><a href="https://developer.aliyun.com/article/803360">问题：为什么“except:pass”是一个不好的编程习惯？</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文是一个知识碎片&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;&gt;&lt;/a&gt;正文&lt;/h1&gt;&lt;p&gt;当遇到异常时，为了让程序继续执行而不中断，代码如下：</summary>
      
    
    
    
    <category term="Python" scheme="https://gmet233.gitee.io/categories/Python/"/>
    
    <category term="异常" scheme="https://gmet233.gitee.io/categories/Python/%E5%BC%82%E5%B8%B8/"/>
    
    
    <category term="Python" scheme="https://gmet233.gitee.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>《动手学深度学习》读书笔记（三）CNN的填充、步幅、通道、池化</title>
    <link href="https://gmet233.gitee.io/2022/02/15/%E3%80%8A%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89CNN%E7%9A%84%E5%A1%AB%E5%85%85%E3%80%81%E6%AD%A5%E5%B9%85%E3%80%81%E9%80%9A%E9%81%93%E3%80%81%E6%B1%A0%E5%8C%96/"/>
    <id>https://gmet233.gitee.io/2022/02/15/%E3%80%8A%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89CNN%E7%9A%84%E5%A1%AB%E5%85%85%E3%80%81%E6%AD%A5%E5%B9%85%E3%80%81%E9%80%9A%E9%81%93%E3%80%81%E6%B1%A0%E5%8C%96/</id>
    <published>2022-02-15T14:51:25.000Z</published>
    <updated>2022-02-15T15:20:18.519Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文FROM《动手学深度学习》第六章 卷积神经网络 6.3、6.4和6.5小节</p><p>虽然标题中，填充、步幅、通道、池化放在一起，但是实际这四者并非并列关系。</p></blockquote><h1 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h1><p>在卷积神经网络中，卷积的输出形状取决于输入形状和卷积核的形状。</p><p>例如，一个 240×240 像素的图像，经过 10 层 5×5 的卷积后，将减少到 200×200 像素。如此一来，原始图像的边界丢失了许多有用信息。而<strong>填充</strong>是解决此问题最有效的方法。</p><p>下面的图展示了带填充的二维互相关。</p><p><img src="conv-pad.svg" alt="带填充的二维互相关"></p><p>设网络输入宽高分别为 $n_w$ 和 $n_h$，卷积核宽高分别为 $k_w$ 和 $k_h$，如果我们添加 $p_h$ 行填充（大约一半在顶部，一半在底部）和 $p_w$ 列填充（左侧大约一半，右侧一半），则输出形状将为</p><script type="math/tex; mode=display">(n_h-k_h+p_h+1)\times(n_w-k_w+p_w+1)。</script><p>这意味着输出的高度和宽度将分别增加 $p_h$ 和 $p_w$。</p><p>在许多情况下，我们需要设置 $p_h=k_h-1$ 和 $p_w=k_w-1$，使输入和输出具有相同的高度和宽度。这样可以在构建网络时更容易地预测每个图层的输出形状。假设 $k_h$ 是奇数，我们将在高度的两侧填充 $p_h/2$ 行。<br>如果 $k_h$ 是偶数，则一种可能性是在输入顶部填充 $\lceil p_h/2\rceil$ 行，在底部填充 $\lfloor p_h/2\rfloor$ 行。填充宽度的两侧同理。</p><p>卷积神经网络中卷积核的高度和宽度通常为奇数，例如 1、3、5 或 7。选择奇数的好处是，保持空间维度的同时，我们可以在顶部和底部填充相同数量的行，在左侧和右侧填充相同数量的列。</p><p>此外，使用奇数核和填充也提供了书写上的便利。对于任何二维张量 $X$，当满足：</p><ol><li>内核的大小是奇数；</li><li>所有边的填充行数和列数相同；</li><li>输出与输入具有相同高度和宽度</li></ol><p>则可以得出：输出 $Y[i, j]$ 是通过以输入 $X[i, j]$ 为中心，与卷积核进行互相关计算得到的。比如，在下面的例子中，我们创建一个高度和宽度为3的二维卷积层，并<strong>在所有侧边填充1个像素</strong>。给定高度和宽度为8的输入，则输出的高度和宽度也是8。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 为了方便起见，我们定义了一个计算卷积层的函数。</span></span><br><span class="line"><span class="comment"># 此函数初始化卷积层权重，并对输入和输出提高和缩减相应的维数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">comp_conv2d</span>(<span class="params">conv2d, X</span>):</span></span><br><span class="line">    <span class="comment"># 这里的（1，1）表示批量大小和通道数都是1</span></span><br><span class="line">    X = X.reshape((<span class="number">1</span>, <span class="number">1</span>) + X.shape)</span><br><span class="line">    Y = conv2d(X)  <span class="comment"># 将X输入到卷积层中，输出Y</span></span><br><span class="line">    <span class="comment"># 省略前两个维度：批量大小和通道</span></span><br><span class="line">    <span class="keyword">return</span> Y.reshape(Y.shape[<span class="number">2</span>:])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 请注意，这里每边都填充了1行或1列，因此总共添加了2行或2列</span></span><br><span class="line">conv2d = nn.Conv2d(<span class="number">1</span>, <span class="number">1</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>)  <span class="comment"># 这里定义了一个卷积层</span></span><br><span class="line">X = torch.rand(size=(<span class="number">8</span>, <span class="number">8</span>))</span><br><span class="line">comp_conv2d(conv2d, X).shape</span><br></pre></td></tr></table></figure><pre><code>torch.Size([8, 8])</code></pre><p>当卷积核的高度和宽度不同时，我们可以填充不同的高度和宽度，使输出和输入具有相同的高度和宽度。在如下示例中，我们使用高度为5，宽度为3的卷积核，高度和宽度两边的填充分别为2和1。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">conv2d = nn.Conv2d(<span class="number">1</span>, <span class="number">1</span>, kernel_size=(<span class="number">5</span>, <span class="number">3</span>), padding=(<span class="number">2</span>, <span class="number">1</span>))</span><br><span class="line">comp_conv2d(conv2d, X).shape</span><br></pre></td></tr></table></figure><pre><code>torch.Size([8, 8])</code></pre><h1 id="步幅"><a href="#步幅" class="headerlink" title="步幅"></a>步幅</h1><p>在计算互相关时，卷积窗口从输入张量的左上角开始，向下、向右滑动。 在前面的例子中，我们默认每次滑动一个元素。 但是，有时候为了高效计算或是缩减采样次数，卷积窗口可以跳过中间位置，每次滑动多个元素。</p><p>我们将每次滑动元素的数量称为步幅（stride）。下图展示了垂直步幅为 3 ，水平步幅为 2 的二维互相关运算。</p><p><img src="conv-stride.svg" alt="垂直步幅为 $3$，水平步幅为 $2$ 的二维互相关运算"></p><p>可以看到，为了计算输出中第一列的第二个元素和第一行的第二个元素，卷积窗口分别向下滑动三行和向右滑动两列。但是，当卷积窗口继续向右滑动两列时，没有输出，因为输入元素无法填充窗口（除非我们添加另一列填充）。</p><p>通常，当垂直步幅为 $s_h$ 、水平步幅为 $s_w$ 时，输出形状为</p><script type="math/tex; mode=display">\lfloor(n_h-k_h+p_h+s_h)/s_h\rfloor \times \lfloor(n_w-k_w+p_w+s_w)/s_w\rfloor.</script><p>如果我们设置了 $p_h=k_h-1$ 和 $p_w=k_w-1$，则输出形状将简化为 $\lfloor(n_h+s_h-1)/s_h\rfloor \times \lfloor(n_w+s_w-1)/s_w\rfloor$。<br>更进一步，如果输入的高度和宽度可以被垂直和水平步幅整除，则输出形状将为 $(n_h/s_h) \times (n_w/s_w)$。</p><p>下面，我们<strong>将高度和宽度的步幅设置为2</strong>，从而将输入的高度和宽度减半。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">conv2d = nn.Conv2d(<span class="number">1</span>, <span class="number">1</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>, stride=<span class="number">2</span>)</span><br><span class="line">comp_conv2d(conv2d, X).shape</span><br></pre></td></tr></table></figure><pre><code>torch.Size([4, 4])</code></pre><p>为了简洁起见，当输入高度和宽度两侧的填充数量分别为 $p_h$ 和 $p_w$ 时，我们称之为填充 $(p_h, p_w)$。当 $p_h = p_w = p$ 时，填充是 $p$。同理，当高度和宽度上的步幅分别为 $s_h$ 和 $s_w$ 时，我们称之为步幅 $(s_h, s_w)$。当时的步幅为 $s_h = s_w = s$ 时，步幅为 $s$。默认情况下，填充为 0，步幅为 1。<strong>在实践中，我们很少使用不一致的步幅或填充，也就是说，我们通常有 $p_h = p_w$ 和 $s_h = s_w$。</strong></p><h1 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h1><p>当我们添加通道时，我们的输入和隐藏的表示从二维张量变成了三维张量。例如，每个RGB输入图像具有 3×h×w 的形状。我们将这个大小为 3 的轴称为通道（channel）维度。</p><p>通道分为输入通道和输出通道。灰度图的输入通道为1，RGB图的输入通道为3。而输出通道是自定义的。灰度图的输出通道也可以大于1，RGB图的输出通道也可以为1，这取决于如何定义卷积核和输出。</p><h2 id="多输入通道"><a href="#多输入通道" class="headerlink" title="多输入通道"></a>多输入通道</h2><p>当输入包含多个通道时，需要构造一个与输入数据具有相同输入通道数目的卷积核，以便与输入数据进行互相关运算。假设输入的通道数为 $c_i$，那么卷积核的输入通道数也需要为 $c_i$ 。如果卷积核的窗口形状是 $k_h\times k_w$，那么当 $c_i=1$ 时，我们可以把卷积核看作形状为 $k_h\times k_w$ 的二维张量。</p><p>然而，当 $c_i&gt;1$ 时，我们卷积核的每个输入通道将包含形状为 $k_h\times k_w$ 的张量。将这些张量 $c_i$ 连结在一起可以得到形状为 $c_i\times k_h\times k_w$ 的卷积核。由于输入和卷积核都有 $c_i$ 个通道，我们可以对每个通道输入的二维张量和卷积核的二维张量进行互相关运算，再对通道求和（将 $c_i$ 的结果相加）得到二维张量。这是多通道输入和多输入通道卷积核之间进行二维互相关运算的结果。</p><p>下图我们演示了一个具有两个输入通道的二维互相关运算的示例。</p><p><img src="conv-multi-in.svg" alt="两个输入通道的互相关计算。"></p><p>多输入通道互相关运算的实现如下。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">corr2d_multi_in</span>(<span class="params">X, K</span>):</span></span><br><span class="line">    <span class="comment"># 先遍历“X”和“K”的第0个维度（通道维度），再把它们加在一起</span></span><br><span class="line">    <span class="comment"># for x, k in zip(X, K) 拿出X, K对应维度里的矩阵</span></span><br><span class="line">    <span class="comment"># d2l.corr2d()函数：完成互相关运算</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(d2l.corr2d(x, k) <span class="keyword">for</span> x, k <span class="keyword">in</span> <span class="built_in">zip</span>(X, K))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = torch.tensor([[[<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>], [<span class="number">3.0</span>, <span class="number">4.0</span>, <span class="number">5.0</span>], [<span class="number">6.0</span>, <span class="number">7.0</span>, <span class="number">8.0</span>]],</span><br><span class="line">               [[<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>], [<span class="number">4.0</span>, <span class="number">5.0</span>, <span class="number">6.0</span>], [<span class="number">7.0</span>, <span class="number">8.0</span>, <span class="number">9.0</span>]]])</span><br><span class="line">K = torch.tensor([[[<span class="number">0.0</span>, <span class="number">1.0</span>], [<span class="number">2.0</span>, <span class="number">3.0</span>]], [[<span class="number">1.0</span>, <span class="number">2.0</span>], [<span class="number">3.0</span>, <span class="number">4.0</span>]]])</span><br><span class="line"></span><br><span class="line">corr2d_multi_in(X, K)</span><br></pre></td></tr></table></figure><pre><code>tensor([[ 56.,  72.],        [104., 120.]])</code></pre><h2 id="多输出通道"><a href="#多输出通道" class="headerlink" title="多输出通道"></a>多输出通道</h2><p>到目前为止，不论有多少输入通道，我们还只有一个输出通道。然而，这是不够的。在最流行的神经网络架构中，随着神经网络层数的加深，我们常会<strong>增加输出通道的维数，通过减少空间分辨率以获得更大的通道深度</strong>。直观地说，我们可以将每个通道看作是对不同特征的响应。而现实可能更为复杂一些，因为每个通道不是独立学习的，而是为了共同使用而优化的。因此，多输出通道并不仅是学习多个单通道的检测器。</p><p>用 $c_i$ 和 $c_o$ 分别表示输入和输出通道的数目，并让 $k_h$ 和 $k_w$ 为卷积核的高度和宽度。为了获得多个通道的输出，我们可以为每个输出通道创建一个形状为 $c_i\times k_h\times k_w$ 的卷积核张量，这样卷积核的形状是 $c_o\times c_i\times k_h\times k_w$。在互相关运算中，每个输出通道先获取所有输入通道，再以对应该输出通道的卷积核计算出结果。</p><p>如下所示，我们实现一个<strong>计算多个通道的输出的互相关函数</strong>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">corr2d_multi_in_out</span>(<span class="params">X, K</span>):</span></span><br><span class="line">    <span class="comment"># 迭代“K”的第0个维度，每次都对输入“X”执行互相关运算。</span></span><br><span class="line">    <span class="comment"># 最后将所有结果都叠加在一起</span></span><br><span class="line">    <span class="comment"># `corr2d_multi_in(X, k) for k in K`意思是在拿出每一个二维卷积核k，都对完整的输入X做互相关运算</span></span><br><span class="line">    <span class="comment"># torch.stack(…, 0)意思是将结果在0的维度上“堆”起来</span></span><br><span class="line">    <span class="keyword">return</span> torch.stack([corr2d_multi_in(X, k) <span class="keyword">for</span> k <span class="keyword">in</span> K], <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>上面代码中，<code>torch.stack(…, 0)</code>是将结果在0的维度上“堆”起来。下面通过将核张量K与K+1（K中每个元素加 1 ）和K+2连接起来，构造了一个具有 3 个输出通道的卷积核。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">K = torch.stack((K, K + <span class="number">1</span>, K + <span class="number">2</span>), <span class="number">0</span>)</span><br><span class="line">K.shape  <span class="comment"># 原始K的维度是(2,2,2)</span></span><br></pre></td></tr></table></figure><pre><code>torch.Size([3, 2, 2, 2])</code></pre><p>下面，我们对输入张量X与卷积核张量K执行互相关运算。现在的输出包含 3 个通道，</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">corr2d_multi_in_out(X, K)</span><br></pre></td></tr></table></figure><pre><code>tensor([[[ 56.,  72.],         [104., 120.]],        [[ 76., 100.],         [148., 172.]],        [[ 96., 128.],         [192., 224.]]])</code></pre><h2 id="1-times-1-卷积层"><a href="#1-times-1-卷积层" class="headerlink" title="$1\times 1$ 卷积层"></a>$1\times 1$ 卷积层</h2><p>$1\times 1$ 卷积，即 $k_h = k_w = 1$，看起来似乎没有多大意义。<br>毕竟，卷积的本质是有效提取相邻像素间的相关特征，而 $1 \times 1$ 卷积显然没有此作用。<br>尽管如此，$1 \times 1$ 仍然十分流行，时常包含在复杂深层网络的设计中。下面，让我们详细地解读一下它的实际作用。</p><p>因为使用了最小窗口，$1\times 1$ 卷积失去了卷积层的特有能力——在高度和宽度维度上，识别相邻元素间相互作用的能力。<br>其实 $1\times 1$ 卷积的唯一计算发生在通道上。</p><p>下图展示了使用 $1\times 1$ 卷积核与 $3$ 个输入通道和 $2$ 个输出通道的互相关计算。这里输入和输出具有相同的高度和宽度，输出中的每个元素都是从输入图像中同一位置的元素的线性组合。我们可以将 $1\times 1$ 卷积层看作是在每个像素位置应用的全连接层，以 $c_i$ 个输入值转换为 $c_o$ 个输出值。因为这仍然是一个卷积层，所以跨像素的权重是一致的。同时，$1\times 1$ 卷积层需要的权重维度为 $c_o\times c_i$ ，再额外加上一个偏置。</p><p><img src="conv-1x1.svg" alt="互相关计算使用了具有3个输入通道和2个输出通道的 $1\times 1$ 卷积核。其中，输入和输出具有相同的高度和宽度。"></p><p>下面，我们使用全连接层实现 $1 \times 1$ 卷积。请注意，我们需要对输入和输出的数据形状进行微调。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">corr2d_multi_in_out_1x1</span>(<span class="params">X, K</span>):</span></span><br><span class="line">    c_i, h, w = X.shape</span><br><span class="line">    c_o = K.shape[<span class="number">0</span>]</span><br><span class="line">    X = X.reshape((c_i, h * w))</span><br><span class="line">    K = K.reshape((c_o, c_i))</span><br><span class="line">    <span class="comment"># 全连接层中的矩阵乘法</span></span><br><span class="line">    Y = torch.matmul(K, X)</span><br><span class="line">    <span class="keyword">return</span> Y.reshape((c_o, h, w))</span><br></pre></td></tr></table></figure><p>当执行 $1\times 1$ 卷积运算时，上述函数相当于先前实现的互相关函数<code>corr2d_multi_in_out</code>。让我们用一些样本数据来验证这一点。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = torch.normal(<span class="number">0</span>, <span class="number">1</span>, (<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line">K = torch.normal(<span class="number">0</span>, <span class="number">1</span>, (<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Y1 = corr2d_multi_in_out_1x1(X, K)</span><br><span class="line">Y2 = corr2d_multi_in_out(X, K)</span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">float</span>(torch.<span class="built_in">abs</span>(Y1 - Y2).<span class="built_in">sum</span>()) &lt; <span class="number">1e-6</span></span><br></pre></td></tr></table></figure><h1 id="pooling"><a href="#pooling" class="headerlink" title="pooling"></a>pooling</h1><p>通常当我们处理图像时，我们希望逐渐降低隐藏表示的空间分辨率，聚集信息，这样随着我们在神经网络中层叠的上升，每个神经元对其敏感的感受野（输入）就越大。</p><p>而我们的机器学习任务通常会跟全局图像的问题有关（例如，“图像是否包含一只猫呢？”）， 所以我们最后一层的神经元应该对整个输入的全局敏感。通过逐渐聚合信息，生成越来越粗糙的映射，最终实现学习全局表示的目标，同时将卷积图层的所有优势保留在中间层。</p><p>此外，当检测较底层的特征时，我们通常希望这些特征保持某种程度上的平移不变性。例如，如果我们拍摄黑白之间轮廓清晰的图像 $X$，并将整个图像向右移动一个像素，即 $Z[i, j] = X[i, j + 1]$，则新图像 $Z$ 的输出可能大不相同。而在现实中，随着拍摄角度的移动，任何物体几乎不可能发生在同一像素上。即使用三脚架拍摄一个静止的物体，由于快门的移动而引起的相机振动，可能会使所有物体左右移动一个像素。</p><p>本节将介绍 <em>池化</em>（pooling）层，它具有双重目的：降低卷积层对位置的敏感性，同时降低对空间降采样表示的敏感性。</p><h2 id="最大汇聚层和平均汇聚层"><a href="#最大汇聚层和平均汇聚层" class="headerlink" title="最大汇聚层和平均汇聚层"></a>最大汇聚层和平均汇聚层</h2><p>与卷积层类似，汇聚层运算符由一个固定形状的窗口组成，该窗口根据其步幅大小在输入的所有区域上滑动，为固定形状窗口（有时称为 <em>池化窗口</em>）遍历的每个位置计算一个输出。</p><p>然而，不同于卷积层中的输入与卷积核之间的互相关计算，汇聚层不包含参数。<br>相反，池运算符是确定性的，我们通常计算池化窗口中所有元素的最大值或平均值。这些操作分别称为 <em>最大汇聚层</em> （maximum pooling）和 <em>平均汇聚层</em> （average pooling）。</p><p>在这两种情况下，与互相关运算符一样，池化窗口从输入张量的左上角开始，从左到右、从上到下的在输入张量内滑动。在池化窗口到达的每个位置，它计算该窗口中输入子张量的最大值或平均值，具体取决于是使用了最大汇聚层还是平均汇聚层。</p><p><img src="pooling.svg" alt="池化窗口形状为 $2\times 2$ 的最大汇聚层。着色部分是第一个输出元素，以及用于计算这个输出的输入元素: $\max(../img/pooling.svg)=4$."></p><p>上图中输出张量的高度为 $2$，宽度为 $2$。这四个元素为每个池化窗口中的最大值：</p><script type="math/tex; mode=display">\max(0, 1, 3, 4)=4,\\\max(1, 2, 4, 5)=5,\\\max(3, 4, 6, 7)=7,\\\max(4, 5, 7, 8)=8.\\</script><p>池化窗口形状为 $p \times q$ 的汇聚层称为 $p \times q$ 汇聚层，池化操作称为 $p \times q$ 池化。</p><p>回到本节开头提到的对象边缘检测示例，现在我们将使用卷积层的输出作为 $2\times 2$ 最大池化的输入。设置卷积层输入为 $X$，汇聚层输出为 $Y$。无论 $X[i, j]$ 和 $X[i, j + 1]$ 的值是否不同，或 $X[i, j + 1]$ 和 $X[i, j + 2]$ 的值是否不同，汇聚层始终输出 $Y[i, j] = 1$。也就是说，使用 $2\times 2$ 最大汇聚层，即使在高度或宽度上移动一个元素，卷积层仍然可以识别到模式。</p><p>在下面的代码中的 <code>pool2d</code> 函数，我们<strong>实现汇聚层的正向传播</strong>。然而，这里我们没有卷积核，输出为输入中每个区域的最大值或平均值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pool2d</span>(<span class="params">X, pool_size, mode=<span class="string">&#x27;max&#x27;</span></span>):</span></span><br><span class="line">    p_h, p_w = pool_size</span><br><span class="line">    Y = torch.zeros((X.shape[<span class="number">0</span>] - p_h + <span class="number">1</span>, X.shape[<span class="number">1</span>] - p_w + <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(Y.shape[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(Y.shape[<span class="number">1</span>]):</span><br><span class="line">            <span class="keyword">if</span> mode == <span class="string">&#x27;max&#x27;</span>:</span><br><span class="line">                Y[i, j] = X[i: i + p_h, j: j + p_w].<span class="built_in">max</span>()</span><br><span class="line">            <span class="keyword">elif</span> mode == <span class="string">&#x27;avg&#x27;</span>:</span><br><span class="line">                Y[i, j] = X[i: i + p_h, j: j + p_w].mean()</span><br><span class="line">    <span class="keyword">return</span> Y</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 构建输入X，验证最大池化的输出</span></span><br><span class="line">X = torch.tensor([[<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>], [<span class="number">3.0</span>, <span class="number">4.0</span>, <span class="number">5.0</span>], [<span class="number">6.0</span>, <span class="number">7.0</span>, <span class="number">8.0</span>]])</span><br><span class="line">pool2d(X, (<span class="number">2</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure><pre><code>tensor([[4., 5.],        [7., 8.]])</code></pre><h2 id="填充与步幅"><a href="#填充与步幅" class="headerlink" title="填充与步幅"></a>填充与步幅</h2><p>与卷积层一样，汇聚层也可以改变输出形状。和以前一样，我们可以通过填充和步幅以获得所需的输出形状。 下面，我们用深度学习框架中内置的二维最大汇聚层，来演示汇聚层中填充和步幅的使用。 我们首先构造了一个输入张量X，它有四个维度，其中样本数和通道数都是1。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = torch.arange(<span class="number">16</span>, dtype=torch.float32).reshape((<span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">4</span>))</span><br><span class="line">X</span><br></pre></td></tr></table></figure><pre><code>tensor([[[[ 0.,  1.,  2.,  3.],          [ 4.,  5.,  6.,  7.],          [ 8.,  9., 10., 11.],          [12., 13., 14., 15.]]]])</code></pre><p>默认情况下，深度学习框架中的步幅与汇聚窗口的大小相同。 因此，如果我们使用形状为(3, 3)的汇聚窗口，那么默认情况下，我们得到的步幅形状为(3, 3)</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pool2d = nn.MaxPool2d(<span class="number">3</span>)</span><br><span class="line">pool2d(X)</span><br></pre></td></tr></table></figure><pre><code>tensor([[[[10.]]]])</code></pre><p>填充和步幅可以手动设定：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pool2d = nn.MaxPool2d(<span class="number">3</span>, padding=<span class="number">1</span>, stride=<span class="number">2</span>)</span><br><span class="line">pool2d(X)</span><br></pre></td></tr></table></figure><p>当然，我们可以设定一个任意大小的矩形汇聚窗口，并分别设定填充和步幅的高度和宽度。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pool2d = nn.MaxPool2d((<span class="number">2</span>, <span class="number">3</span>), stride=(<span class="number">2</span>, <span class="number">3</span>), padding=(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">pool2d(X)</span><br></pre></td></tr></table></figure><pre><code>tensor([[[[ 5.,  7.],          [13., 15.]]]])</code></pre><h2 id="多个通道"><a href="#多个通道" class="headerlink" title="多个通道"></a>多个通道</h2><p>在处理多通道输入数据时，汇聚层在每个输入通道上单独运算，而不是像卷积层一样在通道上对输入进行汇总。 这意味着汇聚层的输出通道数与输入通道数相同。 下面，我们将在通道维度上连结张量X和X + 1，以构建具有2个通道的输入。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = torch.cat((X, X + <span class="number">1</span>), <span class="number">1</span>)</span><br><span class="line">X</span><br></pre></td></tr></table></figure><pre><code>tensor([[[[ 0.,  1.,  2.,  3.],          [ 4.,  5.,  6.,  7.],          [ 8.,  9., 10., 11.],          [12., 13., 14., 15.]],         [[ 1.,  2.,  3.,  4.],          [ 5.,  6.,  7.,  8.],          [ 9., 10., 11., 12.],          [13., 14., 15., 16.]]]])</code></pre><p>pooling后输出通道的数量仍然是2。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pool2d = nn.MaxPool2d(<span class="number">3</span>, padding=<span class="number">1</span>, stride=<span class="number">2</span>)</span><br><span class="line">pool2d(X)</span><br></pre></td></tr></table></figure><pre><code>tensor([[[[ 5.,  7.],          [13., 15.]],         [[ 6.,  8.],          [14., 16.]]]])</code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>《动手学深度学习》6.3、6.4、6.5节</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文FROM《动手学深度学习》第六章 卷积神经网络 6.3、6.4和6.5小节&lt;/p&gt;
&lt;p&gt;虽然标题中，填充、步幅、通道、池化放在一起，但是实际这四者并非并列关系。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;填充&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="深度学习" scheme="https://gmet233.gitee.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="动手学深度学习" scheme="https://gmet233.gitee.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="深度学习" scheme="https://gmet233.gitee.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="动手学深度学习" scheme="https://gmet233.gitee.io/tags/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Java 多线程基础</title>
    <link href="https://gmet233.gitee.io/2022/01/24/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <id>https://gmet233.gitee.io/2022/01/24/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</id>
    <published>2022-01-24T13:38:18.000Z</published>
    <updated>2022-01-24T13:57:11.310Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇博客叙述Java多线程的基本知识和基本操作。</p><blockquote><p>待补充的部分：</p><ul><li>[ ] 线程调度</li><li>[ ] AtomicInteger</li><li>[ ] Semaphore</li><li>[ ] 阻塞队列的实现类详解</li><li>[ ] 多线程共享数据的方法</li><li>[ ] ConcurrentHashMap</li><li>[ ] Java并发关键字</li><li>[ ] 进程调度算法</li><li>[ ] CAS/ABA/AQS</li></ul></blockquote><h1 id="线程概述"><a href="#线程概述" class="headerlink" title="线程概述"></a>线程概述</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>当一个程序进入内存运行时，即变成一个进程。进程是处于运行过程中的程序，并且具有一定独立的功能，进程是系统进行资源分配和调度的一个独立单位。</p><p>一般而言，进程包含三个特征：独立性；动态性；并发性。、</p><p>并发和并行是两个概念，并行是指同一时刻，有多条指令在多个处理器上同时执行；并发指在同一时刻只能有一条指令执行，但多个进程指令被快速轮换执行，使得宏观上具有多个进程同时执行的效果。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>多线程扩展了多进程的概念，使得同一个进程可以同时并发处理多个任务。</p><p>线程是进程的执行单元，是进程的组成部分，一个进程可以拥有多个线程，一个线程必须有一个父进程。线程可以拥有自己的堆栈、自己的程序计数器和自己的局部变量。</p><p>多个线程共享父进程里的全部资源，可以与其他线程共享父进程中的共享变量和部分环境。</p><p>线程是独立于运行的，他并不知道进程中是否还有其他线程存在。现成的执行是抢占式的，也就是说，当前运行的线程在任何时候都可能被挂起，以便另一个线程可以运行。</p><p>一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行。</p><p>从逻辑的角度，多线程存在于一个应用程序中，让一个应用程序中可以有多个执行部分同时执行，但操作系统无须将多个线程看作多个独立的应用，对多线程实现调度和管理以及资源分配。线程的调度和管理由进程本身负责完成。</p><h2 id="线程优势"><a href="#线程优势" class="headerlink" title="线程优势"></a>线程优势</h2><p>进程中线程的之间的隔离程度更小。</p><p>多个线程共享同一个进程虚拟空间。线程共享的环境包括：进程代码段、进程的共有数据等。<br>总结起来，使用多线程编程具有如下优点：</p><ul><li>进程之间不能共享内存，但线程之间共享内存很容易</li><li>系统创建进程时，需要位该进程重新分配系统资源，但创建线程则代价小很多，因此使用多线程实现多任务并发比多进程的效率高。</li><li>Java语言内置了多线程功能支持，而不是单纯的作为底层操作系统的调度方式，从而简化了Java的多线程编程。</li></ul><h1 id="线程创建和启动"><a href="#线程创建和启动" class="headerlink" title="线程创建和启动"></a>线程创建和启动</h1><p>有三种方式创建线程类</p><h2 id="继承Thread类创建线程类"><a href="#继承Thread类创建线程类" class="headerlink" title="继承Thread类创建线程类"></a>继承Thread类创建线程类</h2><ol><li>定义Thread的子类，并重写run方法，该run方法的方法题就代表了线程需要完成的任务。（线程执行体）</li><li>创建Thread子类的实例，即创建了线程对象。</li><li>调用线程对象的start方法来启动该线程。</li></ol><h2 id="实现Runnable接口创建线程类"><a href="#实现Runnable接口创建线程类" class="headerlink" title="实现Runnable接口创建线程类"></a>实现Runnable接口创建线程类</h2><ol><li>定义Runnable接口的实现类，并重写该接口的run方法。该run方法的方法体同样是该线程的线程执行体。</li><li>创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。</li></ol><blockquote><p>代码</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTester</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> firstThread().start();</span><br><span class="line">        <span class="keyword">new</span> firstThread().start();</span><br><span class="line">        Runnable tt = <span class="keyword">new</span> secondThread();</span><br><span class="line">        <span class="keyword">new</span> Thread(tt, <span class="string">&quot;新线程1&quot;</span>).start(); <span class="comment">//可以给线程命名</span></span><br><span class="line">        <span class="keyword">new</span> Thread(tt, <span class="string">&quot;新线程2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">firstThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(getName() + <span class="string">&quot;：&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">secondThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：&quot;</span> + i); <span class="comment">//只能使用Thread.currentThread().getName()来获得线程名</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注</p><ul><li>使用继承Thread类的方法来创建线程类时，多个线程之间无法共享线程类的实例变量。</li><li>Runnable对象仅作为Thread对象的target，Runnable实现类里包含的run方法仅作为线程执行体。而实际的线程对象依然是Thread实例，只是该Thread线程负责执行其target的run方法。</li><li>通过实现Runnable接口来获得当前线程对象，则必须使用Thread.currentThread()方法。</li><li>从Java8开始，Runnable接口使用了@FunctionalInterface，也就是说，可以使用Lambda表达式创建Runnable对象。下面介绍的Callable接口也是函数式接口。</li></ul><h2 id="使用Callable和Future创建线程"><a href="#使用Callable和Future创建线程" class="headerlink" title="使用Callable和Future创建线程"></a>使用Callable和Future创建线程</h2><p>Callable接口提供了一个call方法可以作为线程执行体，但call方法比run方法功能更强大。</p><ul><li>call方法有返回值。</li><li>call可以声明抛出异常。</li></ul><p>完全可以提供一个Callable对象作为Thread的target，而该线程的线程执行体就是该Callable对象的call方法。但Callable接口不是Runnable接口的子接口，所以Callable对象不能直接作为Thread的target。</p><p>Java5提供了Future接口来代表Callable接口里call方法的返回值，并为Future接口提供了一个FutureTask实现类，该实现类实现了Future接口并实现了Runnable接口，可以作为Thread类的target。</p><p><img src="20160713174739239.png" alt="FutureTask"></p><p>Future接口中定义了如下公共方法来控制它关联的Callable任务。</p><ul><li><code>boolean cancel(boolean mayInterroutIfRunning)</code>：试图取消该Future里关联的Callable任务。</li><li><code>V get()</code>：返回Callable任务里的call方法的返回值。调用该方法将导致程序阻塞，必须等待子线程接口后才会得到返回值。</li><li><code>V get(long timeout, TimeUnit unit)</code>：返回Callable任务里的call方法的返回值。该方法让程序最多阻塞timeout和unit指定的时间，如果经过指定时间后Callable任务依然没有返回值，将会抛出TimeoutException异常。</li><li><code>boolean isCancelled()</code>如果Callable任务正常完成前被取消，则返回true。</li><li><code>boolean isDone()</code>如果Callable任务已完成，则返回true。</li></ul><p>创建并启动有返回值的线程步骤如下：</p><ol><li>创建Callable接口的实现类，并实现call方法（注意泛型），该call方法将作为线程执行体，且该call方法有返回值，再创建Callable实现类的实例。</li><li>使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call方法的返回值。</li><li>使用FutureTask对象作为Thread对象的target创建并启动新线程。</li><li>调用FutureTask对象的get方法来获得子线程执行结束后的返回值。</li></ol><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableTester</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> thirdThread()); <span class="comment">//也可以使用lambda表达式生成Callable对象</span></span><br><span class="line">        <span class="keyword">new</span> Thread(task, <span class="string">&quot;有返回值的线程1&quot;</span>).start();</span><br><span class="line"><span class="comment">//        new Thread(task, &quot;有返回值的线程2&quot;).start(); // 不生效，task对象只能用一次？</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程返回值：&quot;</span>+task.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">thirdThread</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span>(; i &lt; <span class="number">10</span> ; i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：Callable接口有泛型限制，Callable接口里的泛型形参类型与call方法返回值类型相同。</p><h2 id="三种创建线程的方式对比"><a href="#三种创建线程的方式对比" class="headerlink" title="三种创建线程的方式对比"></a>三种创建线程的方式对比</h2><ul><li>实现Runnable接口和实现Callable接口的方式基本相同，只是Callable接口里定义的方法有返回值，可以声明抛出异常而已。</li><li>采用实现Runnable、Callable接口的方式的优点是<ul><li>线程类还可以继承其他类</li><li>多个线程可以共享一个target对象，非常适合多个相同线程来处理同一份资源的情况。</li></ul></li><li>采用继承Thread类方式创建多线程的优点是：<ul><li>编写简单</li></ul></li></ul><h1 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h1><p>一个线程要经过新建（New）、就绪（Ready）、运行（Running）、阻塞（Blocked）、死亡（Dead）5种状态。</p><p>线程状态以及转换图如下：</p><p><img src="image-20210709151939392.png" alt="线程生命周期"></p><h2 id="新建和就绪状态"><a href="#新建和就绪状态" class="headerlink" title="新建和就绪状态"></a>新建和就绪状态</h2><p>当程序使用了new关键字创建了一个线程之后，该线程就处于新建状态。</p><p>当线程调用了start方法后，该线程就处于就绪状态。处于就绪状态的线程并没有开始运行，只是表示该线程可以运行了。</p><h2 id="运行和阻塞状态"><a href="#运行和阻塞状态" class="headerlink" title="运行和阻塞状态"></a>运行和阻塞状态</h2><p>如果处于就绪状态的线程获得了CPU，开始执行run方法的线程执行体，则该线程就处于运行状态。</p><p>线程在运行过程种需要被中断，目的是使其他线程获得执行的机会。当前执行的线程被阻塞后，其他线程就可以获得执行的机会。被阻塞的线程会在合适的时候将重新进入<strong>就绪状态</strong>。</p><p>比较特殊的情况，调用yield方法可以让运行状态的线程转入就绪状态。、</p><h2 id="线程死亡"><a href="#线程死亡" class="headerlink" title="线程死亡"></a>线程死亡</h2><p>线程可以以如上图三种方式死亡。</p><p>为了测试某个线程是否死亡，可以调用线程对象的isAlive方法，当线程处于就绪、运行、阻塞三种状态时，该方法将返回true；当线程处于新建、死亡两种状态时，该方法将返回false。</p><p>注意：</p><ul><li>当主线程结束时，其他线程不受影响，并不会随之结束。一旦子线程启动起来后，他就拥有和主线程相同的地位，他不会受主线程的影响。</li><li>不要试图对一个已经死亡的线程调用start方法使他重新启动。</li><li>对于新建状态的线程两次调用start方法也是错误的。</li></ul><h1 id="控制线程"><a href="#控制线程" class="headerlink" title="控制线程"></a>控制线程</h1><h2 id="join线程"><a href="#join线程" class="headerlink" title="join线程"></a>join线程</h2><p>Thread提供了一个让线程等待另一个线程完成的方法——join方法。当在某个车光绪执行流中调用其他线程的join方法时，调用线程将被阻塞，直到被join方法加入的join线程执行完为止。</p><p>join方法通常由使用线程的程序调用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinTester</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread jt = <span class="keyword">new</span> joinThread();</span><br><span class="line">        jt.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">20</span>) &#123;</span><br><span class="line">                jt.join();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">joinThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="image-20210709163027111.png" alt="join 运行结果"></p><p>由于在主线程调用了子线程的join方法，则主线程必须等到子线程（被Join的线程）执行完毕才能继续执行。</p><h2 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h2><p>有一种线程，他是在后台运行的，他的任务是为其他线程提供服务，这种线程被称为“后台线程（Daemon Thread）”，又称为守护线程或精灵线程。</p><p>后台线程有个特征：<strong>如果前台线程都死亡，后台线程会自动死亡。</strong></p><p>调用Thread的setDaemon(true)方法可将指定线程设置为后台线程。</p><p>Thread类还提供一个isDaemon方法，用于判断指定线程是否为后台线程。</p><p>前台线程创建的子线程默认就是前台线程，后台线程创建的子程序默认是后台线程。</p><p>注意：要将某个线程设置为后台线程，必须在该线程启动之前设置，也就是说setDaemon(true)比如在start方法之前调用。否则会引发异常。</p><h2 id="线程睡眠sleep"><a href="#线程睡眠sleep" class="headerlink" title="线程睡眠sleep"></a>线程睡眠sleep</h2><p><code>Thread.sleep(long milis)</code></p><p>Thread提供了一个与sleep方法有点相似的yield方法，后者也可以让当前正在执行的线程暂停，但他不会阻塞该线程，他只是将该线程转入就绪状态。yield只是让当前线程暂停一下。让系统的线程调度器重新调度一次。</p><p>关于sleep方法和yield方法的区别如下：</p><ul><li>sleep方法暂停当前线程后，会给其他线程执行机会，不会理会其他线程的优先级；但yield方法只会给同优先级相同，或优先级更高的线程执行机会。</li><li>sleep方法会将线程转入阻塞状态，直到经过阻塞时间才会转入就绪状态；而yield不会讲线程转入阻塞状态，他只是强制当前线程进入就绪状态。因此完全有可能某个线程被yield方法暂停之后，立即再次获得处理器资源被执行。</li><li>sleep方法声明抛出了异常，所以调用sleep方法必须捕捉或者显式声明抛出该异常；而yield没有声明抛出任何异常。</li><li>sleep方法比yield方法具有更好的移植性，更推荐用于控制并发线程的执行。</li></ul><h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><p>每个线程执行都具有一定的优先级，优先级高的线程获得较多的执行机会，而优先级低的线程则获得较少的执行机会。</p><p>每个线程默认的优先级都与创建它的父线程的优先级相同，在默认情况下，main线程具有普通优先级，由main线程创建的子线程也具有普通优先级。</p><p>Thread类提供了setPriority(int newPriority)、getPriority方法来指定或返回指定线程的优先级。其中setPriority的参数可以是一个整数，范围是1~10之间，也可以使用Thread类的如下三个静态常量。</p><ul><li>MAX_PRIORITY：其值为10</li><li>MIN_PRIORITY：其值为1</li><li>NORM_PRIORITY：其值为5</li></ul><p>这些优先级需要操作系统的支持，因此应该尽量避免直接为线程指定优先级，而应该使用上述三个静态常量。</p><h1 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h1><h2 id="抢占式调度"><a href="#抢占式调度" class="headerlink" title="抢占式调度"></a>抢占式调度</h2><h2 id="协同式调度"><a href="#协同式调度" class="headerlink" title="协同式调度"></a>协同式调度</h2><h2 id="Java的线程调度方式：抢占式"><a href="#Java的线程调度方式：抢占式" class="headerlink" title="Java的线程调度方式：抢占式"></a>Java的线程调度方式：抢占式</h2><h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><p>线程安全的经典问题：银行取钱问题。下面使用两个线程模拟两个人从一个银行账户中取钱。接下来定义一个账户类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String accountNo;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> balance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Account</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(String accountNo, <span class="keyword">double</span> balance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.accountNo = accountNo;</span><br><span class="line">        <span class="keyword">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略getter、setter</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBalance</span><span class="params">(<span class="keyword">double</span> balance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Account account = (Account) o;</span><br><span class="line">        <span class="keyword">return</span> account.accountNo.equals(accountNo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accountNo.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后是取钱线程类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DrawThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="comment">//账户</span></span><br><span class="line">    <span class="keyword">private</span> Account account;</span><br><span class="line">    <span class="comment">//取得钱数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> drawAmount;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DrawThread</span><span class="params">(String name, Account account, <span class="keyword">double</span> drawAmount)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.account = account;</span><br><span class="line">        <span class="keyword">this</span>.drawAmount = drawAmount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(account.getBalance() &gt;= drawAmount) &#123;</span><br><span class="line">            System.out.println(getName() + <span class="string">&quot;取钱成功，吐出钞票：&quot;</span> + drawAmount);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            account.setBalance(account.getBalance() - drawAmount);</span><br><span class="line">            System.out.println(<span class="string">&quot;余额为：&quot;</span>+ account.getBalance());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(getName() + <span class="string">&quot;取钱失败，余额不足&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是主程序</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DrawTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个账户</span></span><br><span class="line">        Account account = <span class="keyword">new</span> Account(<span class="string">&quot;0001&quot;</span>, <span class="number">1000</span>);</span><br><span class="line">        <span class="comment">//模拟两个线程取钱</span></span><br><span class="line">        <span class="keyword">new</span> DrawThread(<span class="string">&quot;甲&quot;</span>, account, <span class="number">800</span>).start();</span><br><span class="line">        <span class="keyword">new</span> DrawThread(<span class="string">&quot;乙&quot;</span>, account, <span class="number">800</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果<strong>可能</strong>为如下：</p><p><img src="image-20210710000053047.png" alt="线程同步 运行结果"></p><p>这就涉及了线程同步问题。</p><h2 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h2><p>之所以出现上述结果，是因为run方法的方法体不具有线程安全性，程序有两个并发线程在修改Account对象。</p><p>为了解决这样的问题，Java的多线程支持引入了同步监视器来解决这个问题，使用让同步监视器的通用方法就是同步代码块，语法格式如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(obj) &#123;</span><br><span class="line">    <span class="comment">//此处的代码就是同步代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：</p><ol><li>上述obj就是同步监视器，上面代码的含义是线程开始执行同步代码块之前必须先获得对同步监视器的锁定。</li><li>任何时刻只能有一个线程可以获得对同步监视器的锁定，当同步代码块执行完成后，该线程会释放对同步监视器的锁定。</li><li>通常推荐使用可能被并发访问的共享资源充当同步监视器。</li></ol><blockquote><p>synchronized属于独占式的悲观锁，同时属于可重入锁。</p><p>Synchronized的实现原理：详见《Offer来了 原理篇》P87</p></blockquote><p>根据上述修改代码考虑使用Account作为同步监视器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DrawThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="comment">//账户</span></span><br><span class="line">    <span class="keyword">private</span> Account account;</span><br><span class="line">    <span class="comment">//取得钱数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> drawAmount;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DrawThread</span><span class="params">(String name, Account account, <span class="keyword">double</span> drawAmount)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.account = account;</span><br><span class="line">        <span class="keyword">this</span>.drawAmount = drawAmount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//同步代码块：使用account作为同步监视器，任何线程进入下面同步代码块之前，必须先获得对account账户的锁定，其他线程无法获得锁也就无法修改它，这种做法符合“加锁，修改，释放锁”的逻辑</span></span><br><span class="line">        <span class="keyword">synchronized</span> (account) &#123;</span><br><span class="line">            <span class="keyword">if</span>(account.getBalance() &gt;= drawAmount) &#123;</span><br><span class="line">                System.out.println(getName() + <span class="string">&quot;取钱成功，吐出钞票：&quot;</span> + drawAmount);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                account.setBalance(account.getBalance() - drawAmount);</span><br><span class="line">                System.out.println(<span class="string">&quot;余额为：&quot;</span>+ account.getBalance());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(getName() + <span class="string">&quot;取钱失败，余额不足&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这种方式就可以保证并发线程在任一时刻只有一个线程可以进入修改共享资源的代码区（也被称为临界区），所以同一时刻只有一个线程处于临界区内，从而保证了线程安全性。</p><h2 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h2><p>同步方法就是使用synchronized关键字来修饰某个方法，则该方法称为同步方法，对于synchronized修饰的实例方法（而非静态方法），无需显式指定同步监视器，同步方法的同步监视器是this，也就是调用该方法的对象。</p><p>下面将Account的balance的访问设置成线程安全的，那么只要把修改balance的方法编程同步方法即可。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String accountNo;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> balance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Account</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(String accountNo, <span class="keyword">double</span> balance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.accountNo = accountNo;</span><br><span class="line">        <span class="keyword">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//getter、setter</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAccountNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accountNo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    public void setBalance(double balance) &#123;</span></span><br><span class="line"><span class="comment">//        this.balance = balance;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//账户余额不允许修改，所以只为balance提供getter方法，</span></span><br><span class="line">    <span class="comment">//提供一线程安全的draw方法来完成取钱操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">double</span> drawAmount)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(balance &gt;= drawAmount) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;取钱成功！吐出钞票：&quot;</span>+drawAmount);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            balance -= drawAmount;</span><br><span class="line">            System.out.println(<span class="string">&quot;余额为：&quot;</span>+ balance);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;取钱失败，余额不足&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略equals和hashCode方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>因为Account提供了draw方法，而且取消了setBalance方法，DrawThread的run方法需要改写。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    account.draw(drawAmount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：</p><ol><li>synchronized关键字可以修饰方法，代码块但是布恩那个修饰构造器、成员变量等。</li><li>经过上述修改，DrawThread类无需自己实现取钱操作，而是直接调用account的draw方法。由于draw方法使用了synchronized修饰，同步方法的监视器是this。在上面的示例种，this是account，因此多个线程并发访问同一份account之前必须先对account加锁。这就保证了线程安全。</li><li>在Account里定义draw方法，而不是直接在run方法种实现取钱逻辑，这种做法更符合面向对象的规则。在面向对象里有一种流行的设计：Domain Driven Design（<strong>领域驱动设计</strong>，DDD），这种方式认为每个类都应该是完备的领域对象，例如账户类应该提供账户的相关方法。</li><li>为了减少线程安全带来的降低程序运行效率的影响应该：不要对线程安全类的所有方法进行同步，只对那些改变京城资源的方法进行同；如果可变类有两种运行环境：单线程运行环境和多线程运行环境，则应该为可变类提供两种版本。</li></ol><h2 id="释放同步监视器的锁定"><a href="#释放同步监视器的锁定" class="headerlink" title="释放同步监视器的锁定"></a>释放同步监视器的锁定</h2><p>程序无法显式释放对同步监视器的锁定，线程会在如下几种情况下释放对同步监视器的锁定。</p><ul><li>当前线程的同步方法、同步代码块执行结束。</li><li>当前线程在同步代码块，同步方法中遇到了break、return终止了该代码块、该方法的继续执行。</li><li>当前线程在同步代码块，同步方法中遇到了未处理的Error或Exception</li><li>程序执行了同步监视器对象的wait方法，则当前线程暂停，并释放同步监视器。</li></ul><p>在如下情况下，线程不会释放同步监视器。</p><ul><li>程序调用了Thread.sleep、Thread.yield方法来暂停当前线程的执行，</li><li>其他线程调用了该线程的suspend方法将线程挂起。</li></ul><h2 id="同步锁"><a href="#同步锁" class="headerlink" title="同步锁"></a>同步锁</h2><p>Lock提供了比synchronized方法和synchronized代码块更广泛更灵活的操作。</p><p>Lock是控制多个线程对共享资源进行访问的工具，通常，锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。</p><p>Lock接口的主要方法：</p><ul><li><code>void lock();</code> 加锁</li><li><code>void lockInterruptibly()</code> 当前线程未被中断则获取该锁。</li><li><code>boolean tryLock();</code>试图加锁，但不会阻塞</li><li><code>boolean tryLock(long time, TimeUnit unit)</code> 创建定时锁</li><li><code>void unlock();</code> 释放锁</li><li><code>Condition newCondition();</code> 创建条件对象，获取等待通知组件。</li></ul><p>Lock、ReadWriteLock是J5提供的两个根接口，并为Lock提供了ReentrantLock（可重入锁）【常用】实现类，为ReadWriteLock提供了ReentrantReadWriteLock实现类。</p><p>J8新增了StampedLock类，在大多数场景下可以替代传统的ReentrantReadWriteLock。ReentrantReadWriteLock为读写操作提供了三种锁模式：Writing、ReadingOptimistic、Reading</p><p>通常使用ReentrantLock的代码格式如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">//定义需要保证线程安全的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//需要保证线程安全的代码</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ReentrantLock是一个可重入的独占锁。通过AQS来实现锁的获取和释放。</p><p>ReentrantLock不但提供了Synchronized对锁的操作功能。还提供了诸如可响应中断锁、可轮询锁请求，定时锁等避免多线程死锁的方法。</p></blockquote><p>根据Lock的使用修改Account的代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String accountNo;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> balance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Account</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(String accountNo, <span class="keyword">double</span> balance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.accountNo = accountNo;</span><br><span class="line">        <span class="keyword">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//getter、setter</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAccountNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accountNo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    public void setBalance(double balance) &#123;</span></span><br><span class="line"><span class="comment">//        this.balance = balance;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//账户余额不允许修改，所以只为balance提供getter方法，</span></span><br><span class="line">    <span class="comment">//提供一线程安全的draw方法来完成取钱操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">double</span> drawAmount)</span></span>&#123;</span><br><span class="line">        lock.lock(); <span class="comment">//加锁</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(balance &gt;= drawAmount) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;取钱成功！吐出钞票：&quot;</span>+drawAmount);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                balance -= drawAmount;</span><br><span class="line">                System.out.println(<span class="string">&quot;余额为：&quot;</span>+ balance);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;取钱失败，余额不足&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">//释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//省略hashCode、equals</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用Lock与使用同步方法有点相似，只是使用Lock时显式使用Lock对象作为同步锁，而使用同步方法时系统隐式使用当前对象作为同步监视器。</p><p>同步方法或同步代码块使用竞争资源相关的、隐式的同步监视器，并且强制要求加锁和释放锁要出现在一个块结构中。并且获取了多个锁时，他们必须以相反的顺序释放。所以同步方法或同步代码块的范围机制使得多线程安全编程非常方便，可以避免很多锁的常见编程错误。</p><p>Lock提供了同步方法或同步代码块所没有的其他功能，包括tryLock方法，以及试图获取可中断锁的lockInterruptibly方法，还可以获取超时失效锁的tryLock(long, TimeUnit)方法</p><p>ReentrantLock锁具有可重入性，也就是说，一个线程可以对已加锁的ReentrantLock锁再次加锁，ReentrantLock对象会维持一个计数器来追踪lock方法的嵌套调用，线程在每次调用lock加锁后，必须显式调用unlock来释放锁，所以一段被所保护的代码可以调用另一个被相同锁保护的方法。</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>编写程序时应尽量避免死锁。</p><ul><li>避免多次锁定：尽量避免同一个线程对多个同步监视器进行锁定</li><li>具有相同的加锁顺序：如果多个线程需要对多个同步监视器进行锁定，则应该保证他们以相同的顺序请求加锁。</li><li>使用定时锁：设置锁的超时时间。</li><li>依靠算法进行死锁检测。</li></ul><h1 id="Java锁详解"><a href="#Java锁详解" class="headerlink" title="Java锁详解"></a>Java锁详解</h1><p>Java中的锁主要保障多并发线程情况下的数据一致性。</p><p>锁从乐观和悲观的角度可分为乐观锁和悲观锁，从获取资源的公平性角度可分为公平锁和非公平锁，从是否共享资源的角度可分为共享锁和独占锁，从锁的状态可分为偏向锁，轻量级锁和重量级锁。此外JVM还设计了自旋锁来更快的使用CPU。</p><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>乐观锁，在每次读取数据时都认为别人不会修改数据，所以不会上锁，但在更新时会判断在此期间别人有没有更新该数据，通常在写时先读出当前版本号然后加锁的方法。具体过程是，比较当前版本号和上一版本号，如果版本号一致，则更新，否则重复进行读、比较、写操作。</p><p>Java中的乐观锁大部分是通过CAS算法实现的。</p><h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p>悲观锁，在每次读取数据时都认为别人会修改数据，所以每次在读写数据都会上锁，这样别人像读写这个数据就会阻塞、等待直到拿到锁。</p><p>Java中的悲观锁大部分是通过AQS架构实现的。许多同步类的实现都依赖于它，例如Synchronized、ReentrantLock、Semaphore、CountDownLatch。该框架下的锁先尝试以乐观锁去获取锁，如果获取不到，则会转为悲观锁。</p><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>自旋锁认为，如果持有锁的线程能够在很短时间内释放锁，那么等待竞争的锁线程不需要阻塞、挂起状态切换，只需要等一等（内旋），在持有锁的线程释放锁之后即可立即获得锁，这样减少了时间损耗。</p><p>线程自选时会占用CPU，所以需要设置一个自选等待的最大时间。</p><p>自旋锁的优缺点：</p><ul><li>优点：减少了CPU上下文的切换，对于占用锁的时间非常短或锁竞争不激烈的代码块来说，性能大幅提升。</li><li>缺点：线程如果在自旋过程中长时间获取不到锁资源，将会引起CPU的浪费。</li></ul><h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><p>可重入锁是指该锁支持一个线程对同一个资源多次加锁。Synchronized、ReentrantLock都是可重入锁。</p><h2 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h2><p>允许多个线程同时获取该锁，并发访问共享资源。ReentrantReadWriteLock中的读锁为共享锁的实现。</p><p>共享锁采用了乐观的加锁策略，允许多个执行读操作的线程同时访问共享资源。</p><h2 id="独占锁"><a href="#独占锁" class="headerlink" title="独占锁"></a>独占锁</h2><p>也叫互斥锁。每次只允许一个线程持有该锁。ReentrantLock为独占锁的实现。</p><p>独占锁是一种悲观的加锁策略。同一时刻只允许一个读线程读取锁资源，限制了读操作的并发性。</p><h2 id="重量级锁、轻量级锁和偏向锁"><a href="#重量级锁、轻量级锁和偏向锁" class="headerlink" title="重量级锁、轻量级锁和偏向锁"></a>重量级锁、轻量级锁和偏向锁</h2><p>以后再说。</p><h2 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h2><ul><li>公平锁指再分配锁之前检查是否有线程在排队等待获取锁，优先将锁分配给排队时间最长的线程。</li><li>非公平锁指在分配锁时不考虑线程排队的情况，直接尝试获取锁，在获取不到锁时在排到队尾等待。</li></ul><p>公平锁需要在多核的情况下维护一个锁线程等待队列，基于该队列进行锁的分配，因此效率比非公平锁低很多。</p><p>Java中的Synchronized、ReentrantLock默认lock方法都是非公平锁。</p><h2 id="读写锁：ReadWriteLock"><a href="#读写锁：ReadWriteLock" class="headerlink" title="读写锁：ReadWriteLock"></a>读写锁：ReadWriteLock</h2><p>Lock接口及对象加的锁是普通锁，这种锁不区分读写。为了提高性能，Java提供了读写锁。</p><p>读写锁分为读锁和写锁。多个读锁不互斥，读锁和写锁互斥。在没有写锁的情况下，读是无阻塞的。</p><p>一般做法是分别定义一个读锁和写锁。在Java中使用ReentrantReadWriteLock来完成对读写锁的定义和使用。</p><h2 id="分段锁"><a href="#分段锁" class="headerlink" title="分段锁"></a>分段锁</h2><p>分段锁是一种思想。用于将数据分段并在每个分段上都单独加锁，把锁进一步细粒度化，以提高并发效率。例如：ConcurrentHashMap</p><h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><ul><li>减少锁的持有时间</li><li>减少锁粒度</li><li>锁分离</li><li>锁粗化</li><li>锁消除</li></ul><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>不再赘述。</p><h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h2><p>不再赘述。</p><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>以后再说</p><h2 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h2><p>以后再说</p><h1 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h1><p>通过一个案例，来学习线程通信部分的知识。</p><p>假设系统有一个特殊的需求：系统要求存款者和取款者不断重复地存款取款，而且要求每当存款者将钱存入账户，取款者就立刻去除这笔钱，不允许连续两次存钱，也不允许连续两次取钱。</p><h2 id="传统的线程通信"><a href="#传统的线程通信" class="headerlink" title="传统的线程通信"></a>传统的线程通信</h2><p>为了实现上述功能，可以借助Object类提供的wait、notify、notifyAll方法。这三个方法不属于Thread，但是这三个方法必须由同步监视器对象来调用。</p><ul><li>对于synchronized修饰的同步方法，this就是同步监视器对象，所以可以直接在同步方法中直接调用这三个方法。</li><li>对于synchronized修饰的同步代码块，同步监视器是synchronized后括号里的对象，必须使用该对象调用这三个方法。</li></ul><p>下面介绍这三个方法：</p><ul><li>wait：导致当前线程等待，直到其他线程调用该同步监视器的notify或notifyAll来唤醒该线程。无参数的wait方法会一直等待，带时间参数的wait方法线程会在指定时间后自动苏醒。</li><li>notify：唤醒在此同步监视器上等待的单个线程。唤醒是任意的。只有当前线程放弃对该同步监视器的锁定后，才可以执行被唤醒的线程。</li><li>notifyAll：唤醒在此同步监视器上等待的所有线程。</li></ul><p>本程序为Account类提供了draw方法和deposit方法，分别对应账户的取钱和存钱操作。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String accountNo;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> balance; <span class="comment">//账户余额</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>; <span class="comment">//是否已有存款</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Account</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(String accountNo, <span class="keyword">double</span> balance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.accountNo = accountNo;</span><br><span class="line">        <span class="keyword">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//getter、setter</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAccountNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accountNo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    public void setBalance(double balance) &#123;</span></span><br><span class="line"><span class="comment">//        this.balance = balance;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//账户余额不允许修改，所以只为balance提供getter方法，</span></span><br><span class="line">    <span class="comment">//提供一线程安全的draw方法来完成取钱操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">double</span> drawAmount)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!flag) &#123; <span class="comment">//无存款，则取钱线程阻塞</span></span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;取钱：&quot;</span> + drawAmount);</span><br><span class="line">                balance -= drawAmount;</span><br><span class="line">                System.out.println(<span class="string">&quot;账户余额：&quot;</span>+ balance);</span><br><span class="line">                flag = <span class="keyword">false</span>; <span class="comment">//存款标志设置为false</span></span><br><span class="line">                notifyAll(); <span class="comment">//唤醒其他线程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">deposit</span><span class="params">(<span class="keyword">double</span> depositAmount)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag) &#123; <span class="comment">//有存款，则存款线程阻塞</span></span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;存款：&quot;</span> + depositAmount);</span><br><span class="line">                balance += depositAmount;</span><br><span class="line">                System.out.println(<span class="string">&quot;账户余额：&quot;</span>+ balance);</span><br><span class="line">                flag = <span class="keyword">true</span>; <span class="comment">//存款标志设置为false</span></span><br><span class="line">                notifyAll(); <span class="comment">//唤醒其他线程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略hashCode、equals</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来是取款者和存款者线程</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取款线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DrawThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="comment">//账户</span></span><br><span class="line">    <span class="keyword">private</span> Account account;</span><br><span class="line">    <span class="comment">//取得钱数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> drawAmount;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DrawThread</span><span class="params">(String name, Account account, <span class="keyword">double</span> drawAmount)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.account = account;</span><br><span class="line">        <span class="keyword">this</span>.drawAmount = drawAmount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            account.draw(drawAmount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//存款线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DepositThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="comment">//账户</span></span><br><span class="line">    <span class="keyword">private</span> Account account;</span><br><span class="line">    <span class="comment">//取得钱数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> depositAmount;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DepositThread</span><span class="params">(String name, Account account, <span class="keyword">double</span> depositAmount)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.account = account;</span><br><span class="line">        <span class="keyword">this</span>.depositAmount = depositAmount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            account.deposit(depositAmount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后是主程序：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个账户</span></span><br><span class="line">    Account account = <span class="keyword">new</span> Account(<span class="string">&quot;0001&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//一个取款线程，两个存款线程</span></span><br><span class="line">    <span class="keyword">new</span> DrawThread(<span class="string">&quot;取款者&quot;</span>, account, <span class="number">800</span>).start();</span><br><span class="line">    <span class="keyword">new</span> DepositThread(<span class="string">&quot;存款者1&quot;</span>, account, <span class="number">800</span>).start();</span><br><span class="line">    <span class="keyword">new</span> DepositThread(<span class="string">&quot;存款者2&quot;</span>, account, <span class="number">800</span>).start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主程序设置了一个取款者和两个存款者，最后线程会阻塞这是因为两个存款者会有200次存款操作，而一个取款者只有100次取款操作。运行程序可以发现，存取款线程交替执行。</p><h2 id="使用Condition控制线程通信"><a href="#使用Condition控制线程通信" class="headerlink" title="使用Condition控制线程通信"></a>使用Condition控制线程通信</h2><p>如果程序不使用synchronized关键字来保证同步，而是使用Lock对象来保证同步，则系统中不存在隐式的同步监视器，也就不能使用wait、notify、notifyAll方法进行通信了。</p><p>当使用Lock对象来保证同步时，Java提供了一个Condition类来保持协调，使用Condition可以让那些已经得到Lock对象却无法继续执行的线程释放Lock对象，Condition对象也可以唤醒其他处于等待的线程。</p><p>Condition实例被绑定在一个Lock对象上。要获得Lock实例的Condition实例，需要调用Lock都西昂的newCondition方法。Condition提供了如下三个方法</p><ul><li>await：类似于wait方法，导致线程等待，直到其他线程调用该Condition的signal、signalAll方法来唤醒该线程。</li><li>signal：唤醒此Lock对象上等待的单个线程。只有当前线程放弃对该Lock对象的锁定后，才可以执行被唤醒的进程。</li><li>signalAll：唤醒此Lock对象上等待的所有线程。</li></ul><p>根据上面改写Account类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock(); <span class="comment">//定义Lock对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition condition = lock.newCondition();<span class="comment">//获得指定的Condition</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String accountNo;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> balance; <span class="comment">//账户余额</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>; <span class="comment">//是否已有存款</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Account</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(String accountNo, <span class="keyword">double</span> balance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.accountNo = accountNo;</span><br><span class="line">        <span class="keyword">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//getter、setter</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAccountNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accountNo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    public void setBalance(double balance) &#123;</span></span><br><span class="line"><span class="comment">//        this.balance = balance;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//账户余额不允许修改，所以只为balance提供getter方法，</span></span><br><span class="line">    <span class="comment">//提供一线程安全的draw方法来完成取钱操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">double</span> drawAmount)</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!flag) &#123; <span class="comment">//无存款，则取钱线程阻塞</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;取钱：&quot;</span> + drawAmount);</span><br><span class="line">                balance -= drawAmount;</span><br><span class="line">                System.out.println(<span class="string">&quot;账户余额：&quot;</span>+ balance);</span><br><span class="line">                flag = <span class="keyword">false</span>; <span class="comment">//存款标志设置为false</span></span><br><span class="line">                condition.signalAll(); <span class="comment">//唤醒其他线程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">deposit</span><span class="params">(<span class="keyword">double</span> depositAmount)</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag) &#123; <span class="comment">//有存款，则存款线程阻塞</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;存款：&quot;</span> + depositAmount);</span><br><span class="line">                balance += depositAmount;</span><br><span class="line">                System.out.println(<span class="string">&quot;账户余额：&quot;</span>+ balance);</span><br><span class="line">                flag = <span class="keyword">true</span>; <span class="comment">//存款标志设置为false</span></span><br><span class="line">                condition.signalAll(); <span class="comment">//唤醒其他线程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//忽略hashCode、equals</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用阻塞队列控制线程通信"><a href="#使用阻塞队列控制线程通信" class="headerlink" title="使用阻塞队列控制线程通信"></a>使用阻塞队列控制线程通信</h2><p>Java5提供了一个BlockingQueue接口，它主要用作线程同步工具，而非容器。</p><p>BlockingQueue有一个特征：当生产者线程试图向BlockingQueue中放入元素时，如果该队列已满，则该线程被阻塞。当消费者线程试图从BlockingQueue取出元素时，如果该队列已空，则该线程被阻塞。</p><p>程序的两个线程通过交替向BlockingQueue放入取出元素，即可很好的控制线程的通信。</p><p>BlockingQueue包含的方法对应关系如图：</p><div class="table-container"><table><thead><tr><th></th><th>抛出异常</th><th>返回boolean</th><th>阻塞线程</th><th>指定超时市场</th></tr></thead><tbody><tr><td>队尾插入元素</td><td>add(e)</td><td>offer(e)</td><td>put(e)</td><td>offer(e, time, unit)</td></tr><tr><td>队头删除元素</td><td>remove()</td><td>poll()</td><td>take()</td><td>poll(time, unit)</td></tr><tr><td>获取、不删除元素</td><td>element()</td><td>peek()</td><td>无</td><td>无</td></tr></tbody></table></div><p>BlockingQueue与实现类之间类图如下：</p><p><img src="image-20210710181645057.png" alt="BlockingQueue 类图"></p><p>可以看到BlockingQueue的五个实现类</p><p>下面使用BlockingQueue来实现生产者消费者的线程通信。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingQueueTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> Producer(<span class="string">&quot;产品A&quot;</span>, queue).start();</span><br><span class="line">        <span class="keyword">new</span> Producer(<span class="string">&quot;产品B&quot;</span>, queue).start();</span><br><span class="line">        <span class="keyword">new</span> Consumer(queue).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;String&gt; queue;</span><br><span class="line">    <span class="keyword">private</span> String productName ;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(String productName, BlockingQueue&lt;String&gt; queue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.productName = productName;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(productName + i); <span class="comment">//尝试放入元素，如果队列满，则阻塞</span></span><br><span class="line">                System.out.println(getName() + <span class="string">&quot;生产完成：&quot;</span> + queue);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;String&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(BlockingQueue&lt;String&gt; queue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(getName() + <span class="string">&quot;消费元素：&quot;</span> + queue.take());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>该程序不符合预期，原因不明。</strong></p><p><img src="image-20210710190620858.png" alt="阻塞队列 运行结果"></p><h1 id="多线程共享数据"><a href="#多线程共享数据" class="headerlink" title="多线程共享数据"></a>多线程共享数据</h1><h2 id="将数据抽象成一个类，并将这个数据的操作封装到这个类中"><a href="#将数据抽象成一个类，并将这个数据的操作封装到这个类中" class="headerlink" title="将数据抽象成一个类，并将这个数据的操作封装到这个类中"></a>将数据抽象成一个类，并将这个数据的操作封装到这个类中</h2><h2 id="将Runnable对象作为一个类的内部类，将共享数据作为这个类的成员变量"><a href="#将Runnable对象作为一个类的内部类，将共享数据作为这个类的成员变量" class="headerlink" title="将Runnable对象作为一个类的内部类，将共享数据作为这个类的成员变量"></a>将Runnable对象作为一个类的内部类，将共享数据作为这个类的成员变量</h2><h1 id="线程组和未处理的异常"><a href="#线程组和未处理的异常" class="headerlink" title="线程组和未处理的异常"></a>线程组和未处理的异常</h1><h2 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h2><p>Java使用ThreadGroup来表示线程组，Java允许程序对线程组进行控制。用户创建的所有线程都属于指定线程组。如果程序没有显式指定线程属于哪个线程组，则该线程属于默认线程组。默认情况下， 子线程和创建它的父线程处于同一个线程组。</p><p>线程运行中途不能改变它所属的线程组。</p><p>下面是Thread类提供的构造器来设置线程属于哪个线程组：</p><ul><li>Thread(ThreadGroup group, Runnable target)：以target的run方法作为线程执行体创建新线程，属于group线程组。</li><li>Thread(ThreadGroup group, Runnable target, String name)</li><li>Thread(ThreadGroup group, String name)</li></ul><p>Thread提供了一个getThreadGroup方法来返回线程所属的线程组。</p><p>ThreadGroup提供了两个构造器来创建实例。</p><ul><li>ThreadGroup(String name)</li><li>ThreadGroup(ThreadGroup parent, String name)：以指定名字、指定父线程组创建一个新线程组。</li></ul><p>其中name参数是指定线程组的名字，线程组的名字可以通过getName方法得到，但是不能修改。</p><p>ThreadGroup的常用方法：</p><ul><li>int activeCount()</li><li>void isDaemon()</li><li>void interrupt()</li><li>void setDaemon(boolean daemon)</li><li>void setMaxPriority(int pri)</li></ul><p>ThreadGroup内定义了一个很有用的方法：<code>void uncaughtException(Thread t, Throwable e)</code>，该方法可以处理该线程组内的任意线程所抛出的未处理异常。</p><h2 id="线程异常"><a href="#线程异常" class="headerlink" title="线程异常"></a>线程异常</h2><p>Java5之后，如果线程执行过程中抛出了一个未处理的异常，JVM在结束之前会自动查找是否有对应的Thread.UncaughtExceptionHandler对象，如果有，则会调用该对象的<code>uncaughtException(Thread t, Throwable e)</code>来处理异常。</p><p>Thread类提供了两个方法来设置异常处理器：</p><ul><li>setUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh)：为指定线程实例设置默认的异常处理器</li><li>static setDefaultUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh)：为该线程类的所有实例设置默认的异常处理器。</li></ul><p>ThreadGroup类实现了Thread.UncaughtExceptionHandler接口。</p><p>所以线程处理异常的流程如下：</p><ol><li>如果线程设置了异常处理器，则调用该异常处理器处理异常</li><li>查找线程是否属于线程组：<ol><li>如果所属线程组有父线程组，则调用父线程组的uncaughtException方法</li><li>如果该线程组有异常处理器，则使用该异常处理器处理异常。</li></ol></li></ol><p>注意：当使用catch捕获异常时，异常不会向上传播给上一级调用者；但使用异常处理器对异常进行处理后，异常依然会传播给上一级调用者。</p><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>当程序需要创建大量生存期很短暂的线程时，更应该考虑使用线程池。</p><p>线程池在系统启动时即创建大量空闲线程，程序将一个Runnable/Callable对象传给线程池，线程池就会启动一个空闲线程来执行run/call方法，方法执行完毕后，线程不会死亡而是返回线程池成为空闲状态。</p><p>线程池的主要作用是线程复用，线程资源管理，控制操作系统的最大并发数，以保证系统高效（通过线程资源复用实现）且安全（通过控制最大线程并发数实现）的运行。</p><h2 id="线程池的核心组件和核心类"><a href="#线程池的核心组件和核心类" class="headerlink" title="线程池的核心组件和核心类"></a>线程池的核心组件和核心类</h2><p>Java线程池主要由4个核心组件组成。</p><ul><li>线程池管理器：用于创建并管理线程</li><li>工作线程：线程池中执行具体任务的线程。</li><li>任务接口：用于定义工作线程的调度和执行策略，只有线程实现了该接口，线程中的任务才能够被线程池调度。</li><li>任务队列：存放待处理的任务，新的任务将会不断被加入队列中，执行完成的任务将被从队列中移除。</li></ul><p>Java线程池用到了Executor、Executors、ExecutorService、ThreadPoolExecutor、Callable、Future、FutureTask这几个核心类，具体继承关系如下：</p><p><img src="image-20210803000256474.png" alt="线程池核心类 类图"></p><p>ThreadPoolExecutor是构建线程池的核心实现。</p><h2 id="使用Executors管理线程"><a href="#使用Executors管理线程" class="headerlink" title="使用Executors管理线程"></a>使用Executors管理线程</h2><p>Java5以前，开发者必须实现自己的线程池，从Java5开始，新增了一个Executors工厂类来产生线程池。它包含如下静态工厂方法：</p><ul><li>ExecutorService newCachedThreadPool()：创建一个具有缓存功能的线程池</li><li>ExecutorService newFixedThreadPool(int nThreads)：创建一个可重用的、具有固定线程数的线程池</li><li>ExecutorService newSingleThreadExecutor()：创建一个只有单线程的线程池，相当于newFixedThreadPool(1)</li><li>ScheduledExecutorService newScheduledThreadPool(int corePoolSize)：创建具有指定线程数的线程池。参数指出池中所保存的线程数。</li><li>ScheduledExecutorService newSingleThreadScheduledExecutor()：创建只有一个现成的线程池</li><li>ExecutorService newWorkStealingPool(int parallelism)：创建持有足够的线程的线程池来支持给定的并行级别</li><li>ExecutorService newWorkStealingPool()：相当于前一个方法的简化版本，假设当前机器有4个CPU，则相当于前一个方法传入4</li></ul><p>前面介绍的方法中返回值类型中ExecutorService代表线程池，它可以执行Runnable/Callable所代表的线程；ScheduledExecutorService 是ExecutorService的子类，它可以在指定延迟后执行线程任务。</p><p>最后两个方法是J8新增，他们成分利用了多CPU的并行能力，这两个方法创建的相当于后台线程池。</p><p>ExecutorService代表尽快执行线程的线程池：</p><ul><li><code>Future&lt;?&gt; submit(Runnable task)</code>：将一个Runnable对象提交给线程池，线程池将在有空闲线程时执行Runnable对象代表的任务。其中Future对象代表Runnable的返回值，但是run方法没有返回值，所以Future对象将在run方法执行结束后返回null</li><li><code>&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result)</code>：同上一个方法类似，但本方法将在run方法结束后返回result</li><li><code>&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)</code></li></ul><p>ScheduledExecutorService 代表在指定延迟后或周期性的执行线程任务，它提供了四个主要方法：</p><ul><li><code>&lt;V&gt; ScheduledFuture&lt;V&gt; schedule(Callable&lt;V&gt; callable, long delay, TimeUnit unit)</code>：</li><li><code>ScheduledFuture&lt;?&gt; schedule(Runnable command, long delay, TimeUnit unit)</code></li><li><code>ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)</code>：可设定频率重复执行线程任务</li><li><code>ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)</code>：每一次执行终止和下一次执行开始之间都存在一个给定的延迟。</li></ul><p>当用完一个线程池后，应该调用该线程池的shutdown方法，调用shutdown方法后，线程池不再接受新的任务，但会将以前所有已提交任务执行完成。</p><p>使用线程池执行线程任务的步骤如下：</p><ol><li>调用Executors类的静态工厂方法创建一个线程池</li><li>创建Runnable/Callable实例</li><li>调用submit方法提交Runnable/Callable实例</li><li>调用线程池的shutdown方法关闭线程池。</li></ol><p>举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个固定线程处的线程池</span></span><br><span class="line">        ExecutorService pool = Executors.newFixedThreadPool(<span class="number">6</span>);</span><br><span class="line">        Runnable target = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;的i值为：&quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//向线程池提交两个线程</span></span><br><span class="line">        pool.submit(target);</span><br><span class="line">        pool.submit(target);</span><br><span class="line"></span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用ForkJoinPool利用多CPU"><a href="#使用ForkJoinPool利用多CPU" class="headerlink" title="使用ForkJoinPool利用多CPU"></a>使用ForkJoinPool利用多CPU</h2><p>Java7提供了ForkJoinPool来支持多CPU计算。ForkJoinPool是ExecutorService的实现类，因此是一个特殊的线程池。</p><p>ForkJoinPool有两个构造器：</p><ul><li>ForkJoinPool(int parallelism)：创建一个包含parallelism个并行线程的ForkJoinPool</li><li>ForkJoinPool()：以Runtime.availableProcessors方法的返回值作为parallelism参数创建ForkJoinPool</li></ul><p>J8进一步扩展了ForkJoinPool的功能。J8通过提供如下两个静态方法为ForkJoinPool增加了通用池功能。</p><ul><li>ForkJoinPool commonPool()：该方法返回一个通用池，通用池不会受到shutdown或shutdownNow方法的影响。</li><li>int getCommonPoolParallelism：该方法返回通用池的并行级别。</li></ul><p>在创建ForkJoinPool实例之后就可以调用它的submit(ForkJoinTask<T> task)方法来执行指定任务。ForkJoinTask是一个抽象类，他代表一个可并行、合并的任务。他有两个抽象子类。RecursiveAction和RecursiveTask。RecursiveAction代表无返回值的任务，RecursiveTask代表有返回值的任务。</p><p>举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinPoolTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">        Random rand = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = rand.nextInt(<span class="number">20</span>);</span><br><span class="line">            total += (arr[i] = tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;单线程累加的结果为：&quot;</span> + total);</span><br><span class="line"></span><br><span class="line">        Future&lt;Integer&gt; future = pool.submit(<span class="keyword">new</span> CalTask(arr, <span class="number">0</span>, arr.length));</span><br><span class="line">        System.out.println(<span class="string">&quot;并行CPU累加的结果为：&quot;</span> + future.get());</span><br><span class="line"></span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CalTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD = <span class="number">20</span>; <span class="comment">//每个小人物最多累加20个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CalTask</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.arr = arr;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(end - start &lt; THRESHOLD) &#123; <span class="comment">//当数组数量小于THRESHOLD时开始累加</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">                sum += arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//分解成子任务</span></span><br><span class="line">            CalTask left = <span class="keyword">new</span> CalTask(arr, start, mid);</span><br><span class="line">            CalTask right = <span class="keyword">new</span> CalTask(arr, mid, end);</span><br><span class="line">            left.fork();<span class="comment">//执行任务</span></span><br><span class="line">            right.fork();</span><br><span class="line">            <span class="keyword">return</span> left.join() + right.join(); <span class="comment">//返回结果</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="*ThreadPoolExecutor"></a>*ThreadPoolExecutor</h2><p>Java提供了Excutors工具类，适用于小项目，对于一些大型程序还是需要自己创建ThreadPoolExecutor类。这样做的好处有：</p><ul><li>使用ThreadPoolExecutor更加明确线程池的运行规则，规避资源耗尽的风险。</li><li>Excutors的newFixedThreadPool和newSingleThreadExecutor的主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至OOM；Excutors的newCachedThreadPool和newScheduledThreadPool主要问题是线程最大数为Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至OOM。</li></ul><p>ThreadPoolExecutor是构建线程池的核心实现，定义如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="params"><span class="function">                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="params"><span class="function">                              RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体参数如表格：</p><div class="table-container"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>corePoolSize</td><td>线程池中核心线程的数量</td></tr><tr><td>maximumPoolSize</td><td>线程池中最大线程数量</td></tr><tr><td>keepAliveTime</td><td>当前线程数量超过corePoolSize时，空闲线程的存活时间</td></tr><tr><td>unit</td><td>keepAliveTime的时间单位</td></tr><tr><td>workQueue</td><td>任务队列，被提交但尚未被执行的任务存放的地方</td></tr><tr><td>threadFactory</td><td>线程工厂，用于创建线程，可使用默认的线程工厂或自定义</td></tr><tr><td>handler</td><td>由于任务过多或其他原因导致线程池无法处理时的任务拒绝策略</td></tr></tbody></table></div><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>通过调用ThreadPoolExecutor的构造方法来创建一个线程池。线程池刚被创建时，只是向系统申请一个用于执行线程队列和管理线程池的线程资源。在添加一个任务时，当前现有线程数（设为n）：</p><ol><li>n&lt;corePoolSize，线程池就会立刻创建线程并执行该线程任务。</li><li>n&gt;=corePoolSize，该任务就会进入阻塞队列。</li><li>如果队列已满，且n&lt;maximumPoolSize时，线程池会创建非核心线程立刻执行该线程任务。</li><li>如果队列已满，且n&gt;=maximumPoolSize时，线程池将拒绝执行该线程任务并抛出RejectExecutionException异常。</li><li>线程任务执行完毕，该任务将从线程池队列中移除，线程池将从队列中取出下一个线程任务继续执行。</li><li>在线程处于空闲状态的实践超过keepAliveTime时，正在运行的线程数量超过corePoolSize，该线程将被认定为空闲线程并停止。因此，在线程池中所有线程任务都执行完毕，线程池会收缩到corePoolSize大小。</li></ol><h3 id="入队策略"><a href="#入队策略" class="headerlink" title="入队策略"></a>入队策略</h3><ol><li>直接传递：SynchronousQueue（待补充）</li><li>无界队列：使用无界队列（LinkedBlockingQueue）作为等待队列，当所有核心线程都在处理任务时，新提交的任务都会进入等待队列。此时maximumPoolSize将失去作用。</li><li>有界队列：有界队列（ArrayBlockingQueue）可以防止资源耗尽，但是难以调整和控制。队列大小和线程池大小可以相互作用，使用大队列和小线程数可以减少CPU使用率、系统资源和上下文切换的开销，但是会导致吞吐量变低，如果任务频繁阻塞，系统就能为更多的线程调度执行时间。使用小队列通常需要更多的线程数，这样可以最大化CPU使用率。但可能会需要更大的调度开销，从而降低吞吐量。</li></ol><h3 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h3><p>JDK内置的拒绝策略有AbortPolicy、CallerRunsPolicy、DiscardOldestPolicy、DiscardPolicy这四种。</p><ul><li>AbortPolicy：默认策略，抛出RejectExecutionException异常</li><li>CallerRunsPolicy：在execute方法的调用线程中运行被拒绝的任务，如果线程已关闭，任务将被丢弃。</li><li>DiscardOldestPolicy：丢弃队列中等待时间最长的任务并执行当前提交的任务。</li><li>DiscardPolicy：直接丢弃任务。</li><li>自定义拒绝策略需要实现RejectedExecutionHandler接口，实现<code>rejectedExecution(Runnable r, ThreadPoolExecutor executor)</code>方法。</li></ul><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> corePoolSize = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> maximumPoolSize = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">long</span> keepAliveTime = <span class="number">2</span>;</span><br><span class="line">    TimeUnit unit = TimeUnit.SECONDS;</span><br><span class="line">    BlockingQueue&lt;Runnable&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">    ThreadPoolExecutor pool = <span class="keyword">null</span>;</span><br><span class="line">    pool = <span class="keyword">new</span> ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, unit, queue);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> index = i+<span class="number">1</span>;</span><br><span class="line">        pool.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我是线程&quot;</span> + index);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//每个任务提交后休眠500ms在执行下一个任务，用于保证提交顺序。</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pool.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是运行结果。</p><p><img src="image-20210730173914926.png" alt="拒绝策略 运行截图"></p><p>对该运行结果进行分析：</p><ol><li>由于corePoolSize设置的为3，所以任务1、2、3正常提交且开始执行。</li><li>提交任务4，5时，任务123还在运行，所以任务4，5进入到阻塞队列。</li><li>提交任务6，7，8时，正在运行的任务等于corePoolSize且小于maximumPoolSize，阻塞队列满，所以会立即创建非核心线程执行任务678</li><li>当任务1执行完毕后，取出队列中的任务4开始执行。</li><li>当任务2执行完毕后，取出队列中的任务5开始执行。</li></ol><p>为了演示默认的拒绝策略，将上述案例增加一个线程。结果如图</p><p><img src="image-20210730174640219.png" alt="拒绝策略 截图"></p><h1 id="线程相关类"><a href="#线程相关类" class="headerlink" title="线程相关类"></a>线程相关类</h1><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>ThreadLocal是Therad的局部变量的维护类，在Java中是作为一个特殊的变量存储在。当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。</p><p>因为每个Thread内有自己的实例副本，且该副本只能由当前Thread使用，也就不存在多线程间共享的问题。</p><p>总的来说，ThreadLocal适用于每个线程需要自己独立的实例且该实例需要在多个方法中被使用，也即变量在线程间隔离而在方法或类间共享的场景。</p><p>比如，有一个变量count，在多线程并发时操作count++会出现线程安全问题。但是通过ThreadLocal就可以为每个线程创建只属于当前线程的count副本，各自操作各自的副本，不会影响到其他线程。</p><p>使用示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; HOLDER = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ThreadLocalTest().execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HOLDER.set(<span class="string">&quot;main&quot;</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程ThreadLocal中的值：&quot;</span> + HOLDER.get());</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程ThreadLocal中的值：&quot;</span> + HOLDER.get());</span><br><span class="line">            HOLDER.set(<span class="string">&quot;thread&quot;</span>); <span class="comment">//设置当前线程的值</span></span><br><span class="line">            System.out.println(<span class="string">&quot;重新设置后，&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;线程ThreadLocal中的值：&quot;</span> + HOLDER.get());</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程执行结束&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程ThreadLocal中的值：&quot;</span> + HOLDER.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行程序，打印结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main线程ThreadLocal中的值：程序新视界</span><br><span class="line">Thread-0线程ThreadLocal中的值：null</span><br><span class="line">重新设置之后，Thread-0线程ThreadLocal中的值：《程序新视界》</span><br><span class="line">Thread-0线程执行结束</span><br><span class="line">main线程ThreadLocal中的值：程序新视界</span><br></pre></td></tr></table></figure><p>对照程序和输出结果，你会发现，主线程和Thread-0各自独享自己的变量存储。主线程并没有因为Thread-0调用了HOLDER的set方法而被改变。</p><p>之所以能达到这个效果，正是因为在ThreadLocal中，每个线程Thread拥有一份自己的副本变量，多个线程互不干扰。</p><p>ThreadLocal和其他同步机制一样，都是为了解决多线程对同一变量的访问冲突。在普通的同步机制中，试图用过对对象枷锁来实现多个线程对同一变量的安全访问的。ThreadLocal从另一个角度来解决多线程并发访问，ThreadLocal将需要并发访问的资源复制多分，每个线程拥有一份资源，从而就没有必要再对该变量进行同步了。在编写多线程代码时，可以把不安全的整个变量封装进ThreadLocal，或者把该对象与线程相关的状态使用ThreadLocal保存。</p><p>ThreadLocal不能代替同步机制，两者面向的领域不同。同步机制是为了同步多个线程对相同资源的并发访问，是多个线程之间通信的有效方式；而ThreadLocal是为了隔离多个线程的数据共享，从根本上避免了多个线程对共享资源的竞争。</p><p><em>参考资料：<a href="https://zhuanlan.zhihu.com/p/368293603">https://zhuanlan.zhihu.com/p/368293603</a></em></p><h2 id="包装线程不安全集合"><a href="#包装线程不安全集合" class="headerlink" title="包装线程不安全集合"></a>包装线程不安全集合</h2><p>在Java集合中所讲的ArrayList、LinkedList、HashSet、TreeSet、HashMap、TreeMap都是线程不安全的。Collections提供的类方法可以把这些集合包装成线程安全的集合。</p><ul><li>static <T> Collection<T> synchronizedCollection(Collection<T> c)</li><li>static <T> List<T> synchronizedList(List<T> list)</li><li>static <K,V> Map<K,V> synchronizedMap(Map<K,V> m)</li><li>static <T> Set<T> synchronizedSet(Set<T> s)</li><li>static <K,V> SortedMap<K,V> synchronizedSortedMap(SortedMap<K,V> m)</li><li>static <T> SortedSet<T> synchronizedSortedSet(SortedSet<T> s)</li></ul><p>例如需要使用线程安全的HashMap对象，则采用下面的代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;&gt;()); <span class="comment">//在创建后立即包装</span></span><br></pre></td></tr></table></figure><h2 id="线程安全集合类"><a href="#线程安全集合类" class="headerlink" title="线程安全集合类"></a>线程安全集合类</h2><p><img src="image-20210711190905713.png" alt="线程安全的集合类"></p><p>线程安全的集合类可以分为两种：</p><ul><li>以Concurrent开头的集合类：代表了支持并发访问的集合，对这种集合的写入操作都是线程安全的，但读取操作不必锁定。</li><li>以CopyOnWrite开头的集合类：采用了更复杂的算法（复制底层数组的方式实现写操作）来保证永远不会锁住集合，因此并发写入时有较好的性能。</li></ul><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><ul><li>默认支持16个线程并发写入，可以通过设置构造参数来支持更多的并发。</li><li>J8扩展了ConcurrentHashMap的功能，新增的方法分为如下三类<ul><li>forEach</li><li>search</li><li>reduce</li></ul></li></ul><h2 id="J9新增的发布-订阅框架"><a href="#J9新增的发布-订阅框架" class="headerlink" title="J9新增的发布-订阅框架"></a>J9新增的发布-订阅框架</h2><p>略</p><h1 id="Java并发关键字"><a href="#Java并发关键字" class="headerlink" title="Java并发关键字"></a>Java并发关键字</h1><h2 id="CountDownLacth"><a href="#CountDownLacth" class="headerlink" title="CountDownLacth"></a>CountDownLacth</h2><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><h2 id="Semaphore-1"><a href="#Semaphore-1" class="headerlink" title="Semaphore"></a>Semaphore</h2><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><h1 id="补充：进程调度算法"><a href="#补充：进程调度算法" class="headerlink" title="补充：进程调度算法"></a>补充：进程调度算法</h1><h2 id="优先调度算法"><a href="#优先调度算法" class="headerlink" title="优先调度算法"></a>优先调度算法</h2><h2 id="高优先权优先调度算法"><a href="#高优先权优先调度算法" class="headerlink" title="高优先权优先调度算法"></a>高优先权优先调度算法</h2><h2 id="时间片的轮转调度算法"><a href="#时间片的轮转调度算法" class="headerlink" title="时间片的轮转调度算法"></a>时间片的轮转调度算法</h2><h1 id="补充：CAS、ABA、AQS"><a href="#补充：CAS、ABA、AQS" class="headerlink" title="补充：CAS、ABA、AQS"></a>补充：CAS、ABA、AQS</h1><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>《疯狂Java讲义》 多线程篇</li><li><a href="https://mp.weixin.qq.com/s/F8PbZ5PnwGNI4jRiylCRpQ">为什么阿里不允许用Executors创建线程池，而是通过ThreadPoolExecutor的方式？</a></li><li>《Offer 来了 Java面试核心知识点讲解 原理篇》 多线程</li><li><a href="https://zhuanlan.zhihu.com/p/368293603">ThreadLocal全攻略：使用实战，源码分析，内存泄露分析</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本篇博客叙述Java多线程的基本知识和基本操作。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;待补充的部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[ ] </summary>
      
    
    
    
    <category term="Java" scheme="https://gmet233.gitee.io/categories/Java/"/>
    
    <category term="多线程" scheme="https://gmet233.gitee.io/categories/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="https://gmet233.gitee.io/tags/Java/"/>
    
    <category term="多线程" scheme="https://gmet233.gitee.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>_Python实现一个简单的多线程程序</title>
    <link href="https://gmet233.gitee.io/2022/01/20/Python%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%A8%8B%E5%BA%8F/"/>
    <id>https://gmet233.gitee.io/2022/01/20/Python%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%A8%8B%E5%BA%8F/</id>
    <published>2022-01-20T14:40:08.000Z</published>
    <updated>2022-01-20T14:49:42.410Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是一个知识碎片，以后再做详细整理。</p></blockquote><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>我尝试使用多线程批量下载图片。代码框架如下，</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing.pool <span class="keyword">import</span> ThreadPool</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">下载输入的url保存为图片</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_urls</span>(<span class="params">url</span>):</span></span><br><span class="line">    r = requests.request(<span class="string">&#x27;GET&#x27;</span>, url, headers=&#123;&#125;)</span><br><span class="line">    <span class="keyword">if</span> r.status_code == <span class="number">200</span>:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;save_path&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(r.content)</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># urls</span></span><br><span class="line">url_list = [<span class="string">&#x27;...&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 单线程</span></span><br><span class="line"><span class="comment">#  for url in url_list:</span></span><br><span class="line"><span class="comment">#      download_urls(url)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 多线程</span></span><br><span class="line"><span class="comment"># 设置线程池线程数</span></span><br><span class="line">pool = ThreadPool(<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 传入下载函数和下载list</span></span><br><span class="line">pool.imap_unordered(download_urls, url_list)</span><br><span class="line"></span><br><span class="line">pool.close()</span><br><span class="line">pool.join()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>目前我不明白的是，</p><ul><li><strong>不能使用main函数将代码包含进去，否则起不来多线程，为什么？</strong></li><li>Python多线程的基本知识；</li><li>Python GIL等。</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://blog.csdn.net/weixin_36896856/article/details/108016558">Python下载文件的11种方式</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文是一个知识碎片，以后再做详细整理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;&gt;&lt;/a&gt;正文&lt;/h1&gt;&lt;p&gt;我尝试使用多线程批量下载图片。代</summary>
      
    
    
    
    <category term="Python" scheme="https://gmet233.gitee.io/categories/Python/"/>
    
    <category term="多线程" scheme="https://gmet233.gitee.io/categories/Python/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="多线程" scheme="https://gmet233.gitee.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="Python" scheme="https://gmet233.gitee.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>《动手学深度学习》读书笔记（二）从全连接层到卷积层</title>
    <link href="https://gmet233.gitee.io/2022/01/20/%E3%80%8A%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E4%BB%8E%E5%85%A8%E8%BF%9E%E6%8E%A5%E5%B1%82%E5%88%B0%E5%8D%B7%E7%A7%AF%E5%B1%82/"/>
    <id>https://gmet233.gitee.io/2022/01/20/%E3%80%8A%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E4%BB%8E%E5%85%A8%E8%BF%9E%E6%8E%A5%E5%B1%82%E5%88%B0%E5%8D%B7%E7%A7%AF%E5%B1%82/</id>
    <published>2022-01-20T12:40:24.000Z</published>
    <updated>2022-01-20T13:00:13.670Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文FROM《动手学深度学习》第六章 卷积神经网络 6.1和6.2小节</p></blockquote><h1 id="从全连接层到卷积"><a href="#从全连接层到卷积" class="headerlink" title="从全连接层到卷积"></a>从全连接层到卷积</h1><p>假设我们使用之前的全连接层来训练图片数据集。一张普通图像都是百万像素，如果把图像的每一个像素作为一个特征传入MLP，那么网络的每次输入都是百万维度，这是不可接受的；其次，之前我们处理二维图像时，把二维图像的所有像素作为一个一维向量输入MLP，丢失了图像的结构特征。</p><p><strong>卷积神经网络</strong>（convolutional neural networks，CNN）应运而生，它是机器学习利用自然图像中一些已知结构的创造性方法。</p><h2 id="自然图像的两个性质"><a href="#自然图像的两个性质" class="headerlink" title="自然图像的两个性质"></a>自然图像的两个性质</h2><p>我们根据自然图像的两个性质，来设计适合于计算机视觉的神经网络架构：</p><ol><li><em>平移不变性</em>（translation invariance）：不管检测对象出现在图像中的哪个位置，神经网络的前面几层应该对相同的图像区域具有相似的反应，即为“平移不变性”。</li><li><em>局部性</em>（locality）：神经网络的前面几层应该只探索输入图像中的局部区域，而不过度在意图像中相隔较远区域的关系，这就是“局部性”原则。最终，可以聚合这些局部特征，以在整个图像级别进行预测。</li></ol><h2 id="MLP的限制"><a href="#MLP的限制" class="headerlink" title="MLP的限制"></a>MLP的限制</h2><p>首先，多层感知机的输入是二维图像$\mathbf{X}$，其隐藏表示 $\mathbf{H}$ 在数学上是一个矩阵，在代码中表示为二维张量。其中 $\mathbf{X}$ 和 $\mathbf{H}$ 具有相同的形状。</p><p>为了方便理解，我们可以认为，无论是输入还是隐藏表示都拥有空间结构。</p><blockquote><p>所谓隐藏表示是指输入经过MLP的一层后得到的输出。</p></blockquote><p>使用  $[\mathbf{X}]<em>{i, j}$ 和 $[\mathbf{H}]</em>{i, j}$ 分别表示输入图像和隐藏表示中位置($i$, $j$)处的像素。</p><p>为了使每个隐藏神经元都能接收到每个输入像素的信息，我们将参数从权重矩阵（如同我们先前在多层感知机中所做的那样）替换为四阶权重张量 $\mathsf{W}$。假设 $\mathbf{U}$ 包含偏置参数，我们可以将全连接层形式化地表示为</p><blockquote><p>在之前输入输出都是一维张量时，权重为二维张量。现在输入输出都是二维张量，则权重为四维张量。</p></blockquote><script type="math/tex; mode=display">\begin{aligned} \left[\mathbf{H}\right]_{i, j} &= [\mathbf{U}]_{i, j} + \sum_k \sum_l[\mathsf{W}]_{i, j, k, l}  [\mathbf{X}]_{k, l}\\ &=  [\mathbf{U}]_{i, j} +\sum_a \sum_b [\mathsf{V}]_{i, j, a, b}  [\mathbf{X}]_{i+a, j+b}.\end{aligned}</script><blockquote><p>这里 $\mathsf{W}$ 和 $\mathsf{V}$ 的转换仅仅是重新进行了索引。我们只需重新索引下标 $(k, l)$，使 $k = i+a$、$l = j+b$， 由此可得 $[\mathsf{V}]<em>{i, j, a, b} = [\mathsf{W}]</em>{i, j, i+a, j+b}$。</p><p>索引 $a$ 和 $b$ 通过在正偏移和负偏移之间移动覆盖了整个图像。对于隐藏表示中任意给定位置（$i$, $j$）处的像素值$[\mathbf{H}]<em>{i, j}$，可以通过在 $x$ 中以 $(i, j)$ 为中心对像素进行加权求和得到，加权使用的权重为 $[\mathsf{V}]</em>{i, j, a, b}$ 。</p></blockquote><h3 id="平移不变性"><a href="#平移不变性" class="headerlink" title="平移不变性"></a>平移不变性</h3><p>现在引用上述的第一个原则：平移不变性。这意味着检测对象在输入 $\mathbf{X}$ 中的平移，应该仅仅导致隐藏表示 $\mathbf{H}$ 中的平移。也就是说， $\mathsf{V}$ 和 $\mathbf{U}$ 实际上不依赖于 $(i, j)$ 的值，即 $[\mathsf{V}]<em>{i, j, a, b} = [\mathbf{V}]</em>{a, b}$。并且  $\mathbf{U}$ 是一个常数，比如 $u$。因此，我们可以简化 $\mathbf{H}$ 定义为：</p><script type="math/tex; mode=display">[\mathbf{H}]_{i, j} = u + \sum_a\sum_b [\mathbf{V}]_{a, b} [\mathbf{X}]_{i+a, j+b}.</script><p>这就是 <em>卷积</em> （convolution）。我们是在使用系数 $[\mathbf{V}]<em>{a, b}$ 对位置 $(i, j)$ 附近的像素 $(i+a, j+b)$ 进行加权得到$[\mathbf{H}]</em>{i, j}$。</p><p>注意，$[\mathbf{V}]<em>{a, b}$ 的系数比 $[\mathsf{V}]</em>{i, j, a, b}$ 少很多，因为前者不再依赖于图像中的位置。这就是显著的进步！</p><h3 id="局部性"><a href="#局部性" class="headerlink" title="局部性"></a>局部性</h3><p>现在引用上述的第二个原则：局部性。如上所述，为了收集用来训练参数 $[\mathbf{H}]<em>{i, j}$ 的相关信息，我们不应偏离到距 $(i, j)$ 很远的地方。这意味着在 $|a|&gt; \Delta$ 或 $|b| &gt; \Delta$ 的范围之外，我们可以设置 $[\mathbf{V}]</em>{a, b} = 0$。因此，我们可以将 $[\mathbf{H}]_{i, j}$ 重写为</p><script type="math/tex; mode=display">[\mathbf{H}]_{i, j} = u + \sum_{a = -\Delta}^{\Delta} \sum_{b = -\Delta}^{\Delta} [\mathbf{V}]_{a, b}  [\mathbf{X}]_{i+a, j+b}. \tag{$1$}</script><p>简而言之， 公式（1）代表的是一个 <em>卷积层</em> （convolutional layer），而卷积神经网络是包含卷积层的一类特殊的神经网络。</p><p>在深度学习研究社区中， $\mathbf{V}$ 被称为 <em>卷积核</em> （convolution kernel） 或者  <em>滤波器</em> （filter），它仅仅是可学习的一个层的权重。</p><p>当图像处理的局部区域很小时，卷积神经网络与多层感知机的训练差异可能是巨大的：以前，多层感知机可能需要数十亿个参数来表示网络中的一层，而现在卷积神经网络通常只需要几百个参数，而且不需要改变输入或隐藏表示的维数。</p><p>参数大幅减少的代价是，我们的特征现在是平移不变的，并且当确定每个隐藏激活的值时，每一层只能包含局部的信息。</p><p>以上所有的权重学习都将依赖于归纳偏置。当这种偏置与现实相符时，我们就能得到样本有效的模型，并且这些模型能很好地泛化到未知数据中。</p><p>但如果这偏置与现实不符时，比如当图像不满足平移不变时，我们的模型可能难以拟合我们的训练数据。</p><h2 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h2><p>在进一步讨论之前，我们先简要回顾一下为什么上面的操作被称为卷积。在数学中，两个函数（比如 $f, g: \mathbb{R}^d \to \mathbb{R}$）之间的“卷积”被定义为</p><script type="math/tex; mode=display">(f * g)(\mathbf{x}) = \int f(\mathbf{z}) g(\mathbf{x}-\mathbf{z}) d\mathbf{z}.</script><p>也就是说，卷积是测量 $f$ 和 $g$ 之间（把其中一个函数“翻转”并移位 $\mathbf{x}$ 时）的重叠。</p><p>当我们有离散对象时，积分就变成求和。例如：对于由索引为$\mathbb{Z}$的、平方可和的、无限维向量集合中抽取的向量，我们得到以下定义：</p><script type="math/tex; mode=display">(f * g)(i) = \sum_a f(a) g(i-a).</script><p>对于二维张量，则为 $f$ 的索引 $(a, b)$ 和 $g$ 的索引 $(i-a, j-b)$ 上的对应和：</p><script type="math/tex; mode=display">(f * g)(i, j) = \sum_a\sum_b f(a, b) g(i-a, j-b).  \tag{$2$}</script><p>这看起来类似于公式（1），但有一个主要区别：这里不是使用 $(i+a, j+b)$ ，而是使用差值。然而，这种区别主要是装饰性的，因为我们总是可以匹配公式（1）和公式（2）之间的符号。我们在公式（1）中的原始定义更正确地描述了<em>互相关</em>（cross-correlation）。</p><h2 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h2><p>然而（上述）这种方法有一个问题：我们忽略了图像一般包含三个通道/三种原色（红色、绿色和蓝色）。实际上，图像不是二维张量，而是一个由高度、宽度和颜色组成的三维张量，比如包含 $1024 \times 1024 \times 3$ 个像素。前两个轴与像素的空间位置有关，而第三个轴可以看作是每个像素的多维表示。因此，我们将 $\mathsf{X}$ 索引为 $[\mathsf{X}]<em>{i, j, k}$ 。由此卷积相应地调整为 $[\mathsf{V}]</em>{a,b,c}$ ，而不是 $[\mathbf{V}]_{a,b}$ 。</p><p>此外，由于输入图像是三维的，我们的隐藏表示 $\mathsf{H}$ 也最好采用三维张量。换句话说，对于每一个空间位置，我们想要采用一组而不是一个隐藏表示。这样一组隐藏表示可以想象成一些互相堆叠的二维网格。因此，我们可以把隐藏表示想象为一系列具有二维张量的 <em>通道</em> （channel）。这些通道有时也被称为 <em>特征映射</em> （feature maps），因为每个通道都向后续层提供一组空间化的学习特征。直观上你可以想象在靠近输入的底层，一些通道专门识别边，而其他通道专门识别纹理。</p><p>为了支持输入 $\mathsf{X}$ 和隐藏表示 $\mathsf{H}$ 中的多个通道，我们可以在 $\mathsf{V}$ 中添加第四个坐标，即 $[\mathsf{V}]_{a, b, c, d}$ 。综上所述，</p><script type="math/tex; mode=display">[\mathsf{H}]_{i,j,d} = \sum_{a = -\Delta}^{\Delta} \sum_{b = -\Delta}^{\Delta} \sum_c [\mathsf{V}]_{a, b, c, d} [\mathsf{X}]_{i+a, j+b, c}, \tag{$3$}</script><p>其中隐藏表示 $\mathsf{H}$ 中的 $d$ 索引表示输出通道，而随后的输出将继续以三维张量 $\mathsf{H}$ 作为输入进入下一个卷积层。所以，公式（3）可以定义具有多个通道的卷积层，而其中 $\mathsf{V}$ 是该卷积层的权重。</p><h1 id="图像卷积"><a href="#图像卷积" class="headerlink" title="图像卷积"></a>图像卷积</h1><h2 id="互相关运算"><a href="#互相关运算" class="headerlink" title="互相关运算"></a>互相关运算</h2><p>严格来说，卷积层是个错误的叫法，因为它所表达的运算其实是 <em>互相关运算</em> (cross-correlation)，而不是卷积运算。为了与深度学习文献中的标准术语保持一致，我们将继续把“互相关运算”称为卷积运算，尽管严格地说，它们略有不同.此外，对于卷积核张量上的权重，我们称其为<em>元素</em>。</p><p>根据上一节的描述，在卷积层中，输入张量和核张量通过(<strong>互相关运算</strong>)产生输出张量。</p><p>首先，我们暂时忽略通道（第三维）这一情况，看看如何处理二维图像数据和隐藏表示。在下图中，输入是高度为 $3$、宽度为 $3$ 的二维张量（即形状为 $3 \times 3$ ）。卷积核的高度和宽度都是 $2$。</p><p><img src="correlation.svg" alt="图1: 二维互相关运算。阴影部分是第一个输出元素，以及用于计算这个输出的输入和核张量元素：$0\times0+1\times1+3\times2+4\times3=19$."></p><p>在二维互相关运算中，卷积窗口从输入张量的左上角开始，从左到右、从上到下滑动。当卷积窗口滑动到新一个位置时，包含在该窗口中的部分张量与卷积核张量进行按元素相乘，得到的张量再求和得到一个单一的标量值，由此我们得出了这一位置的输出张量值。</p><p>在如上例子中，输出张量的四个元素由二维互相关运算得到，这个输出高度为 $2$ 、宽度为 $2$ ，如下所示：</p><script type="math/tex; mode=display">0\times0+1\times1+3\times2+4\times3=19,\\1\times0+2\times1+4\times2+5\times3=25,\\3\times0+4\times1+6\times2+7\times3=37,\\4\times0+5\times1+7\times2+8\times3=43.</script><p>注意，输出大小略小于输入大小。这是因为卷积核的宽度和高度大于1，而卷积核只与图像中每个大小完全适合的位置进行互相关运算。所以，输出大小等于输入大小 $n_h \times n_w$ 减去卷积核大小 $k_h \times k_w$，即：</p><script type="math/tex; mode=display">(n_h-k_h+1) \times (n_w-k_w+1).</script><p>这是因为我们需要足够的空间在图像上“移动”卷积核。稍后，我们将看到如何通过在图像边界周围填充零来保证有足够的空间移动内核，从而保持输出大小不变。接下来，我们在 <code>corr2d</code> 函数中实现如上过程，该函数接受输入张量 <code>X</code> 和卷积核张量  <code>K</code> ，并返回输出张量 <code>Y</code> 。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br><span class="line"><span class="comment"># 输入张量X和卷积核张量K</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">corr2d</span>(<span class="params">X, K</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算二维互相关运算&quot;&quot;&quot;</span></span><br><span class="line">    h, w = K.shape</span><br><span class="line">    <span class="comment"># 根据X和K得到输出Y的形状</span></span><br><span class="line">    Y = torch.zeros((X.shape[<span class="number">0</span>] - h + <span class="number">1</span>, X.shape[<span class="number">1</span>] - w + <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(Y.shape[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(Y.shape[<span class="number">1</span>]):</span><br><span class="line">            Y[i, j] = (X[i:i + h, j:j + w] * K).<span class="built_in">sum</span>()</span><br><span class="line">    <span class="keyword">return</span> Y</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对上述函数进行验证</span></span><br><span class="line">X = torch.tensor([[<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>], [<span class="number">3.0</span>, <span class="number">4.0</span>, <span class="number">5.0</span>], [<span class="number">6.0</span>, <span class="number">7.0</span>, <span class="number">8.0</span>]])</span><br><span class="line">K = torch.tensor([[<span class="number">0.0</span>, <span class="number">1.0</span>], [<span class="number">2.0</span>, <span class="number">3.0</span>]])</span><br><span class="line">corr2d(X, K)</span><br></pre></td></tr></table></figure><pre><code>tensor([[19., 25.],        [37., 43.]])</code></pre><h2 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h2><p>卷积层对输入和卷积核权重进行互相关运算，并在添加标量偏置之后产生输出。所以，卷积层中的两个被训练的参数是<strong>卷积核权重</strong>和<strong>标量偏置</strong>。就像我们之前随机初始化全连接层一样，在训练基于卷积层的模型时，我们也随机初始化卷积核权重。</p><p>基于上面定义的 <code>corr2d</code> 函数[<strong>实现二维卷积层</strong>]。在 <code>__init__</code> 构造函数中，将 <code>weight</code> 和 <code>bias</code> 声明为两个模型参数。前向传播函数调用 <code>corr2d</code> 函数并添加偏置。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Conv2D</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, kernel_size</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.weight = nn.Parameter(torch.rand(kernel_size))</span><br><span class="line">        self.bias = nn.Parameter(torch.zeros(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="keyword">return</span> corr2d(x, self.weight) + self.bias</span><br></pre></td></tr></table></figure><p>高度和宽度分别为 $h$ 和 $w$的卷积核可以被称为 $h \times w$ 卷积或 $h \times w$ 卷积核。我们也将带有 $h \times w$ 卷积核的卷积层称为 $h \times w$ 卷积层。</p><h2 id="图像中目标的边缘检测"><a href="#图像中目标的边缘检测" class="headerlink" title="图像中目标的边缘检测"></a>图像中目标的边缘检测</h2><p>如下是<strong>卷积层的一个简单应用：</strong>通过找到像素变化的位置，来<strong>检测图像中不同颜色的边缘</strong>。<br>首先，我们构造一个 $6\times 8$ 像素的黑白图像。中间四列为黑色（$0$），其余像素为白色（$1$）。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = torch.ones((<span class="number">6</span>, <span class="number">8</span>))</span><br><span class="line">X[:, <span class="number">2</span>:<span class="number">6</span>] = <span class="number">0</span></span><br><span class="line">X</span><br></pre></td></tr></table></figure><pre><code>tensor([[1., 1., 0., 0., 0., 0., 1., 1.],        [1., 1., 0., 0., 0., 0., 1., 1.],        [1., 1., 0., 0., 0., 0., 1., 1.],        [1., 1., 0., 0., 0., 0., 1., 1.],        [1., 1., 0., 0., 0., 0., 1., 1.],        [1., 1., 0., 0., 0., 0., 1., 1.]])</code></pre><p>接下来，我们构造一个高度为 $1$ 、宽度为 $2$ 的卷积核 <code>K</code> 。当进行互相关运算时，如果水平相邻的两元素相同，则输出为零，否则输出为非零。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">K = torch.tensor([[<span class="number">1.0</span>, -<span class="number">1.0</span>]])</span><br></pre></td></tr></table></figure><p>现在，我们对参数 <code>X</code> （输入）和 <code>K</code> （卷积核）执行互相关运算。如下所示，<strong>输出<code>Y</code>中的1代表从白色到黑色的边缘，-1代表从黑色到白色的边缘</strong>，其他情况的输出为 $0$。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Y = corr2d(X, K)</span><br><span class="line">Y</span><br></pre></td></tr></table></figure><pre><code>tensor([[ 0.,  1.,  0.,  0.,  0., -1.,  0.],        [ 0.,  1.,  0.,  0.,  0., -1.,  0.],        [ 0.,  1.,  0.,  0.,  0., -1.,  0.],        [ 0.,  1.,  0.,  0.,  0., -1.,  0.],        [ 0.,  1.,  0.,  0.,  0., -1.,  0.],        [ 0.,  1.,  0.,  0.,  0., -1.,  0.]])</code></pre><p>现在我们将输入的二维图像转置，再进行如上的互相关运算。其输出如下，之前检测到的垂直边缘消失了。不出所料，这个<strong>卷积核<code>K</code>只可以检测垂直边缘</strong>，无法检测水平边缘。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">corr2d(X.t(), K)</span><br></pre></td></tr></table></figure><pre><code>tensor([[0., 0., 0., 0., 0.],        [0., 0., 0., 0., 0.],        [0., 0., 0., 0., 0.],        [0., 0., 0., 0., 0.],        [0., 0., 0., 0., 0.],        [0., 0., 0., 0., 0.],        [0., 0., 0., 0., 0.],        [0., 0., 0., 0., 0.]])</code></pre><h2 id="学习卷积核"><a href="#学习卷积核" class="headerlink" title="学习卷积核"></a>学习卷积核</h2><p>在卷积神经网络中，卷积核是需要学习的参数。</p><p>现在让我们看看是否可以通过仅查看“输入-输出”对来学习由 <code>X</code> 生成 <code>Y</code> 的卷积核。我们先构造一个卷积层，并将其卷积核初始化为随机张量。接下来，在每次迭代中，我们比较  <code>Y</code> 与卷积层输出的平方误差，然后计算梯度来更新卷积核。为了简单起见，我们在此使用内置的二维卷积层，并忽略偏置。</p><blockquote><p><strong>这一段有几个问题</strong>：</p><ol><li>conv2d是什么，是nn.Conv2d函数本身，还是nn.Conv2d的返回值</li><li>为什么要将XY转换为四维。</li><li>l（loss）和conv2d之间是怎么建立起联系的？</li></ol></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 构造一个二维卷积层，它具有1个输出通道和形状为（1，2）的卷积核</span></span><br><span class="line"><span class="comment"># 第一二个参数指明了输入、输出的通道数</span></span><br><span class="line">conv2d = nn.Conv2d(<span class="number">1</span>,<span class="number">1</span>, kernel_size=(<span class="number">1</span>, <span class="number">2</span>), bias=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个二维卷积层使用四维输入和输出格式（批量大小、通道、高度、宽度），</span></span><br><span class="line"><span class="comment"># 其中批量大小和通道数都为1</span></span><br><span class="line">X = X.reshape((<span class="number">1</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">8</span>))</span><br><span class="line">Y = Y.reshape((<span class="number">1</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">7</span>))</span><br><span class="line">lr = <span class="number">3e-2</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">    Y_hat = conv2d(X)</span><br><span class="line">    l = (Y_hat - Y) ** <span class="number">2</span></span><br><span class="line">    conv2d.zero_grad()</span><br><span class="line">    l.<span class="built_in">sum</span>().backward()</span><br><span class="line">    <span class="comment"># 根据梯度迭代卷积核</span></span><br><span class="line">    conv2d.weight.data[:] -= lr * conv2d.weight.grad</span><br><span class="line">    <span class="keyword">if</span> (i + <span class="number">1</span>) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;epoch <span class="subst">&#123;i+<span class="number">1</span>&#125;</span>, loss <span class="subst">&#123;l.<span class="built_in">sum</span>():<span class="number">.3</span>f&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>epoch 2, loss 7.561epoch 4, loss 2.024epoch 6, loss 0.649epoch 8, loss 0.236epoch 10, loss 0.091epoch 12, loss 0.037epoch 14, loss 0.015epoch 16, loss 0.006epoch 18, loss 0.002epoch 20, loss 0.001</code></pre><p>查看我们所学到的卷积核权重张量，可以发现我们学习到的卷积核权重非常接近我们之前定义的卷积核K。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">conv2d.weight.data.reshape((<span class="number">1</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure><pre><code>tensor([[ 0.9966, -1.0032]])</code></pre><h2 id="特征映射和感受野"><a href="#特征映射和感受野" class="headerlink" title="特征映射和感受野"></a>特征映射和感受野</h2><p>输出的卷积层有时被称为 <em>特征映射</em> （Feature Map），因为它可以被视为一个输入映射到下一层的空间维度的转换器。在CNN中，对于某一层的任意元素 $x$ ，其 <em>感受野</em> （Receptive Field）是指在前向传播期间可能影响 $x$ 计算的所有元素（来自所有先前层）。</p><p>注意，感受野的覆盖率可能大于某层输入的实际区域大小。让我们用<em>图1</em>为例来解释感受野：给定 $2 \times 2$ 卷积核，阴影输出元素值 $19$ 的接收域是输入阴影部分的四个元素。假设之前输出为 $\mathbf{Y}$ ，其大小为 $2 \times 2$ ，现在我们在其后附加一个卷积层，该卷积层以 $\mathbf{Y}$ 为输入，输出单个元素 $z$。在这种情况下， $\mathbf{Y}$ 上的 $z$ 的接收字段包括 $\mathbf{Y}$ 的所有四个元素，而输入的感受野包括最初所有九个输入元素。因此，当一个特征图中的任意元素需要检测更广区域的输入特征时，我们可以构建一个更深的网络。</p><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p><a href="https://github.com/guoyujian/blog-resource/blob/main/d2l-notebooks/conv-layer.ipynb">https://github.com/guoyujian/blog-resource/blob/main/d2l-notebooks/conv-layer.ipynb</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="http://zh-v2.d2l.ai/chapter_convolutional-neural-networks/why-conv.html">《动手学深度学习》6.1. 从全连接层到卷积</a></li><li><a href="http://zh-v2.d2l.ai/chapter_convolutional-neural-networks/conv-layer.html">《动手学深度学习》6.2. 图像卷积</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文FROM《动手学深度学习》第六章 卷积神经网络 6.1和6.2小节&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;从全连接层到卷积&quot;&gt;&lt;a href=&quot;#从全连接层到卷积&quot; class=&quot;headerlink&quot; title=&quot;从全连接层到</summary>
      
    
    
    
    <category term="深度学习" scheme="https://gmet233.gitee.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="动手学深度学习" scheme="https://gmet233.gitee.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="深度学习" scheme="https://gmet233.gitee.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Win10系统下配置深度学习环境</title>
    <link href="https://gmet233.gitee.io/2022/01/16/Win10%E7%B3%BB%E7%BB%9F%E4%B8%8B%E9%85%8D%E7%BD%AE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83/"/>
    <id>https://gmet233.gitee.io/2022/01/16/Win10%E7%B3%BB%E7%BB%9F%E4%B8%8B%E9%85%8D%E7%BD%AE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83/</id>
    <published>2022-01-16T13:12:13.000Z</published>
    <updated>2022-01-16T13:47:24.472Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>之前在本机配置深度学习环境时候踩了很多坑，这里稍作记录备忘。</p></blockquote><h1 id="Anaconda"><a href="#Anaconda" class="headerlink" title="Anaconda"></a>Anaconda</h1><h2 id="安装Anaconda"><a href="#安装Anaconda" class="headerlink" title="安装Anaconda"></a>安装Anaconda</h2><p>在anaconda官网下载安装。</p><p>安装完成后，1. 配置环境变量；2. 修改anaconda的安装源</p><p>验证conda：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda -V</span><br><span class="line">conda env list</span><br></pre></td></tr></table></figure><h2 id="创建conda环境"><a href="#创建conda环境" class="headerlink" title="创建conda环境"></a>创建conda环境</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建一个名称为common的虚拟环境并指定python版本为3.6.8</span><br><span class="line">conda create -n common python=3.6.8</span><br><span class="line"># 激活虚拟环境</span><br><span class="line">activate common</span><br><span class="line"># 列出所有的虚拟环境</span><br><span class="line">conda env list</span><br><span class="line"># 退出虚拟环境</span><br><span class="line">conda deactivate</span><br><span class="line"># 删除虚拟环境</span><br><span class="line">conda remove -n common --all</span><br></pre></td></tr></table></figure><h1 id="安装NVIDIA显卡驱动"><a href="#安装NVIDIA显卡驱动" class="headerlink" title="安装NVIDIA显卡驱动"></a>安装NVIDIA显卡驱动</h1><p>官网选择电脑相应的显卡版本进行下载：<a href="https://www.nvidia.cn/geforce/drivers/">https://www.nvidia.cn/geforce/drivers/</a></p><h1 id="安装CUDA"><a href="#安装CUDA" class="headerlink" title="安装CUDA"></a>安装CUDA</h1><p>nvidia官网下载对应版本：</p><p><a href="https://developer.nvidia.cn/cuda-toolkit-archive">https://developer.nvidia.cn/cuda-toolkit-archive</a></p><p>安装完毕后，1. 添加环境变量（如果安装时自动添加则跳过这一步）2. 检查CUDA是否安装成功</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nvcc -V</span><br></pre></td></tr></table></figure><h1 id="安装CUDNN"><a href="#安装CUDNN" class="headerlink" title="安装CUDNN"></a>安装CUDNN</h1><p>NVIDIA cuDNN是用于深度神经网络的GPU加速库。</p><p>官网地址：<a href="https://developer.nvidia.com/rdp/cudnn-archive">https://developer.nvidia.com/rdp/cudnn-archive</a></p><p>选择和CUDA版本相对应的进行下载。</p><p>下载万恒后，把解压得到的文件夹内的bin、include、lib目录下的dll文件与h文件分别复制到相应的CUDA的安装目录下。</p><p>通过NVIDIA提供的 <code>deviceQuery.exe</code> 和 <code>bandwidthTest.exe</code> 来查看GPU的状态，两者均在安装目录的 <code>extras\demo_suite</code>文件夹中</p><h1 id="安装Pytorch"><a href="#安装Pytorch" class="headerlink" title="安装Pytorch"></a>安装Pytorch</h1><p>在<a href="https://pytorch.org/get-started/previous-versions/">https://pytorch.org/get-started/previous-versions/</a> 中选择与CUDA版本对应的Pytorch版本，执行给出的命令进行安装。</p><blockquote><p>这里推荐pip安装，在尝试的时候发现使用conda命令固然可以安装，但是安装之后<code>torch.cuda.is_available()</code>为False</p><p>后来选择pip安装，报错，后选择Pytorch低一点的版本，成功<code>torch.cuda.is_available()==True</code>。</p></blockquote><p>安装完成后，进入Python命令行，执行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import torch</span><br><span class="line">print(torch.cuda.is_available())</span><br></pre></td></tr></table></figure><p>结果为True则torch-GPU可用。</p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ol><li><strong>从显卡型号到显卡驱动，到CUDA，到CUDNN，到Pytorch，到torchvision，到cudatoolkit这些版本一定要对应好。</strong></li><li>安装pytorch选择命令时，选择pip手动下载whl文件安装较保险。</li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://mp.weixin.qq.com/s/-oNZfkYdOb_UiWPPZCk1Nw">给win11装个深度学习环境</a></li><li><a href="https://www.zhihu.com/question/370243934">为何torch.version.cuda返回None？</a></li><li><a href="https://blog.csdn.net/yinxian9019/article/details/106763892">pytorch gpu不可用 原因核查</a></li><li><a href="https://www.zhihu.com/question/59184480">显卡、显卡驱动、cuda 之间的关系是什么？</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;之前在本机配置深度学习环境时候踩了很多坑，这里稍作记录备忘。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Anaconda&quot;&gt;&lt;a href=&quot;#Anaconda&quot; class=&quot;headerlink&quot; title=&quot;Anaconda&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="深度学习" scheme="https://gmet233.gitee.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="环境" scheme="https://gmet233.gitee.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%8E%AF%E5%A2%83/"/>
    
    
    <category term="深度学习" scheme="https://gmet233.gitee.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>数据库之分析函数</title>
    <link href="https://gmet233.gitee.io/2022/01/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8B%E5%88%86%E6%9E%90%E5%87%BD%E6%95%B0/"/>
    <id>https://gmet233.gitee.io/2022/01/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8B%E5%88%86%E6%9E%90%E5%87%BD%E6%95%B0/</id>
    <published>2022-01-15T12:33:24.000Z</published>
    <updated>2022-01-16T06:27:43.678Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要还是参考了Oracle相关资料，所以文中的语法细节和某些函数在其他DB不会生效。</p><p>我并不希望过多关注语法细节和具体函数（这些都可以自行百度），而更希望对分析函数这块的知识进行抽象。</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>分析函数，也称为窗口函数。</p><p>使用分析函数的查询，基于数据行的分组来计算总量值。尽管与一般的聚合函数提供的分组统计类似，但其主要不同点是，分析函数为每个分组返回多行数据。不同于每个分组只得到一行数据，分析函数可以同时得到所有行的详细数据。区分分析函数和聚合函数的一种方法就是，在体积分析函数中使用的一组数据时，使用数据：<strong>窗口</strong>。</p><p>“窗口”（windows）是通过分析子句定义的。每一行限定在一个滑动窗口中，这些滑动窗口确定了用来计算当前行的数据行范围。</p><p>可以把窗口理解为一个集合，一个窗口就是一个集合，在统计分析中有需要不同的「窗口」，比如一个部门分成不同组，在统计时会按组进行平均、排名等操作。再比如，在一些像时间这种有顺序的数据，我们可能5天分一组、一月分一组再进行排序、求中位数等计算。</p><p><strong>分析函数在SQL执行的顺序</strong>：除了ORDER BY子句，分析函数在查询中是最后执行的运算。</p><h2 id="示例数据"><a href="#示例数据" class="headerlink" title="示例数据"></a>示例数据</h2><p>为了方便讲解和更加直观，我建立了一张数据表，该表名为scores，存放了各班级各学生的数学成绩。建表语句如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table math_scores(</span><br><span class="line">student_id string,</span><br><span class="line">class_num int,</span><br><span class="line">score float);</span><br><span class="line">insert into math_scores(student_id, class_num, score) values(</span><br><span class="line">(&#x27;1&#x27;,1,84),</span><br><span class="line">(&#x27;2&#x27;,1,76),</span><br><span class="line">(&#x27;3&#x27;,1,85),</span><br><span class="line">(&#x27;4&#x27;,1,92),</span><br><span class="line">(&#x27;5&#x27;,2,89),</span><br><span class="line">(&#x27;6&#x27;,2,91),</span><br><span class="line">(&#x27;7&#x27;,2,63),</span><br><span class="line">(&#x27;8&#x27;,3,83),</span><br><span class="line">(&#x27;9&#x27;,3,63),</span><br><span class="line">(&#x27;10&#x27;,3,84)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h1 id="剖析"><a href="#剖析" class="headerlink" title="剖析"></a>剖析</h1><h2 id="与聚合的不同"><a href="#与聚合的不同" class="headerlink" title="与聚合的不同"></a>与聚合的不同</h2><p>窗口函数会按当前所在的分组进行聚合计算，并将聚合计算结果追加在当前行对应的新列，它表达的是当前行与这所在分组的关系。</p><p><img src="sql-windows-functions-01.png" alt="聚合函数与窗口函数"></p><p>窗口函数和 Group By 聚合函数区别在于：窗口函数仅仅只会将结果附加到当前的结果上，它不会对已有的行或列做任何修改。而 Group By 的做法完全不同：对于各个 Group 它仅仅会保留一行聚合结果。</p><p><img src="window-functions-partitioning.jpg" alt="窗口函数计算过程"></p><h2 id="与-group-by-的区别"><a href="#与-group-by-的区别" class="headerlink" title="与 group by 的区别"></a>与 group by 的区别</h2><ul><li>结果数据形式<ul><li>窗口函数可以在保留原表中的全部数据</li><li>group by 只能保留与分组字段聚合的结果</li></ul></li><li>排序范围不同<ul><li>窗口函数中的 order by 只是决定着窗口里的数据的排序方式</li><li>普通的 order by 决定查询出的数据以什么样的方式整体排序</li></ul></li><li>SQL 顺序<ul><li>group by 先进行计算</li><li>窗口函数在 group by 后进行计算</li></ul></li></ul><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>分析函数有三个基本组成部分：分区子句、排序子句以及开窗子句。分析函数的基本语法是：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">function1(argument1, argument2,...argumentN) <span class="keyword">over</span>([<span class="keyword">partition</span><span class="operator">-</span><span class="keyword">by</span><span class="operator">-</span>clause] [<span class="keyword">order</span><span class="operator">-</span><span class="keyword">by</span><span class="operator">-</span>clause] [windowing<span class="operator">-</span>clause])</span><br></pre></td></tr></table></figure><h3 id="function1"><a href="#function1" class="headerlink" title="function1"></a>function1</h3><p>function1是所调用的接收0个或多个参数的分析函数。下表列举了常用的分析函数。（不需要纠结每个函数具体怎么用，大致了解功能，用的时候再细看。）</p><div class="table-container"><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>lag</td><td>访问一个分区或结果集中之前的一行</td></tr><tr><td>lead</td><td>访问一个分区或结果集中之后的一行</td></tr><tr><td>first_value</td><td>访问一个分区或结果集中第一行</td></tr><tr><td>last_value</td><td>访问一个分区或结果集中最后一行</td></tr><tr><td>nth_value</td><td>访问一个分区或结果集中任意一行</td></tr><tr><td>rank</td><td>将数据行值按照排序后的顺序进行排名，在有并列的情况下排名值将被跳过</td></tr><tr><td>dense_rank</td><td>将数据行值按照排序后的顺序进行排名，在有并列的情况下也不跳过排名值</td></tr><tr><td>row_number</td><td>对行进行排序并为每一行增加唯一编号。这是一个非确定函数</td></tr><tr><td>ratio_to_report</td><td>计算报告中值得比例</td></tr><tr><td>percent_rank</td><td>将计算得到的排名值标准化为0-1之间的值</td></tr><tr><td>percentile_cont</td><td>取出与指定的排名百分比相匹配的值。是percent_rank的反函数</td></tr><tr><td>percentile_dist</td><td>取出与指定的排名百分比相匹配的值。采用谨慎分布模型</td></tr><tr><td>ntile</td><td>将数据行分组为单元</td></tr><tr><td>listagg</td><td>将来自不同行的列值转化为列表格式</td></tr></tbody></table></div><p><strong>除了上述分析函数，function1还可以是min/max/avg/count等聚合函数</strong>。</p><h3 id="分区子句"><a href="#分区子句" class="headerlink" title="分区子句"></a>分区子句</h3><p>分区子句按照分区列的值对数据行进行分组。所有分区列的值相同的数据行被组合为一个数据分区。例如<code>partition by class_num</code>就是按班级进行分区。</p><h3 id="排序子句"><a href="#排序子句" class="headerlink" title="排序子句"></a>排序子句</h3><p>排序子句对数据分区中的行进行排序。排序可以按照升序或者降序，使用<code>NULLS FIRST</code>或<code>NULLS LAST</code>子句可以将空值放到数据分区的最上面或最下面。</p><h3 id="开窗子句"><a href="#开窗子句" class="headerlink" title="开窗子句"></a>开窗子句</h3><p>之前的窗口是固定的数据分组窗口，但有时候我们需要根据数据的前后再分配窗口，比如在股票、气温等数据场景下，数据的前后会有影响，就适用于移动窗口计算。</p><p>开窗子句指定了分析函数进行运算的数据子集。这个窗口可以是动态的，他有一个很恰当的名字——<strong>滑动窗口</strong>。使用窗口说明子句来指定滑动窗口的上下边界条件。窗口子句的语法如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">ROWS</span> <span class="operator">|</span> <span class="keyword">RANGE</span>] <span class="keyword">BETWEEN</span> <span class="operator">&lt;</span><span class="keyword">start</span> expr<span class="operator">&gt;</span> <span class="keyword">AND</span> <span class="operator">&lt;</span><span class="keyword">end</span> expr<span class="operator">&gt;</span></span><br><span class="line">Whereas</span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">start</span> expr<span class="operator">&gt;</span> <span class="keyword">is</span> [UNBOUNDED PRECEDING <span class="operator">|</span> <span class="keyword">CURRENT</span> <span class="type">ROW</span> <span class="operator">|</span> n PRECEDING <span class="operator">|</span> n FOLLOWING]</span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">end</span> expr<span class="operator">&gt;</span> <span class="keyword">is</span> [UNBOUNDED PRECEDING <span class="operator">|</span> <span class="keyword">CURRENT</span> <span class="type">ROW</span> <span class="operator">|</span> n PRECEDING <span class="operator">|</span> n FOLLOWING]</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>移动范围设定<ul><li>rows: 物理窗口，rows 后的 n 是指相对当前行偏移n位（当前行也参与计算），可以与 between 搭配使用表达范围</li><li>range: 逻辑窗口，是指定当前行对应值的范围取值。</li><li>rows和range的区别见<em>参考资料3</em></li></ul></li><li>偏移方向<ul><li>precending: 向当前行之前</li><li>following: 向当前行之后</li></ul></li></ul><p>同时，preceding 与 following 可以相结合，例1：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">rows</span> <span class="keyword">between</span> <span class="number">1</span> precending <span class="keyword">and</span> <span class="number">2</span> following</span><br></pre></td></tr></table></figure><p>表示当前行的前一行和后两行，共 4 行（包括当前行）作为汇总的依据。</p><p>例2：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">rows</span> <span class="keyword">between</span> unbounded preceding <span class="keyword">and</span> <span class="keyword">current</span> <span class="type">row</span></span><br></pre></td></tr></table></figure><p>表示窗口最上一行是当前分区中的第一行而窗口最下一行是当前的数据行。</p><blockquote><p>并不是所有的分析函数都支持开窗子句；</p><p>分析函数不能嵌套。</p><p>窗口子句不能单独存在，必须有order by子句时才能出现。</p><p><strong>默认窗口</strong>分两种情况：</p><ul><li>有order by时，无窗口子句，则默认的窗口是<code>unbounded preceding and current row</code>，即当前组的第一行到当前行</li><li>无order by时，无窗口子句，则默认的窗口是<code>unbounded preceding and unbounded following</code>，即整个组</li></ul></blockquote><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><ul><li>下面sql指出了每位学生所在班级的平均数学成绩</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> student_id, class_num, <span class="built_in">AVG</span>(score) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> class_num) <span class="keyword">AS</span> math_avg</span><br><span class="line"><span class="keyword">FROM</span> math_scores</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">student_idclass_numscorealg_avg</span><br><span class="line">118484.25</span><br><span class="line">217684.25</span><br><span class="line">318584.25</span><br><span class="line">419284.25</span><br><span class="line">528981</span><br><span class="line">629181</span><br><span class="line">726381</span><br><span class="line">838376.67</span><br><span class="line">936376.67</span><br><span class="line">1038476.67</span><br></pre></td></tr></table></figure><ul><li>计算每位同学数学成绩的班级排名</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> student_id, class_num, score, <span class="built_in">RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> class_num <span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">DESC</span>) <span class="keyword">AS</span> rankk</span><br><span class="line"><span class="keyword">FROM</span> math_scores</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">student_idclass_numscorerankk</span><br><span class="line">41921</span><br><span class="line">31852</span><br><span class="line">11843</span><br><span class="line">21764</span><br><span class="line">62911</span><br><span class="line">52892</span><br><span class="line">72633</span><br><span class="line">103841</span><br><span class="line">83832</span><br><span class="line">93633</span><br></pre></td></tr></table></figure><h1 id="lead和lag"><a href="#lead和lag" class="headerlink" title="lead和lag"></a>lead和lag</h1><p>lead函数支持访问结果集中后面的行，lag能够访问结果集中前面的行。</p><p>lead和lag的语法如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">lag</span>(expr [, <span class="keyword">offset</span>] [, <span class="keyword">default</span>]) <span class="keyword">OVER</span> ([partition_by_clause] order_by_clause)</span><br><span class="line"><span class="built_in">lead</span>(expr [, <span class="keyword">offset</span>] [, <span class="keyword">default</span>]) <span class="keyword">OVER</span>([partition_by_clause] order_by_clause)</span><br></pre></td></tr></table></figure><p>lead和lag<strong>不支持开窗子句</strong>。这两个函数仅支持partition_by子句和order_by子句。</p><p>下面的sql给出当前数据行前一行的数学成绩（成绩从大到小排序）</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> student_id, class_num, score, <span class="built_in">lag</span>(score, <span class="number">1</span>) <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">DESC</span>) <span class="keyword">AS</span> last_score</span><br><span class="line"><span class="keyword">FROM</span> math_scores</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">student_idclass_numscorelast_score</span><br><span class="line">4192NULL</span><br><span class="line">629192</span><br><span class="line">528991</span><br><span class="line">318589</span><br><span class="line">1038485</span><br><span class="line">118484</span><br><span class="line">838384</span><br><span class="line">217683</span><br><span class="line">936376</span><br><span class="line">726363</span><br></pre></td></tr></table></figure><p>由于第一行没有前一行，所以第一行last_score为NULL，如果不想让它为NULL ，可以使用lag/lead的第三个参数指定默认值。</p><blockquote><p>理解offset是行偏移，而不是数据值偏移</p></blockquote><h1 id="first-value和last-value"><a href="#first-value和last-value" class="headerlink" title="first_value和last_value"></a>first_value和last_value</h1><p>first_value和last_value分别从数据行窗口返回第一行的列值和最后一行的列值。其语法如下</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">first_value</span>(expr) <span class="keyword">over</span>([<span class="keyword">partition</span><span class="operator">-</span><span class="keyword">by</span><span class="operator">-</span>clause] [<span class="keyword">order</span><span class="operator">-</span><span class="keyword">by</span><span class="operator">-</span>clause] [windowing<span class="operator">-</span>clause])</span><br><span class="line"><span class="built_in">last_value</span>(expr) <span class="keyword">over</span>([<span class="keyword">partition</span><span class="operator">-</span><span class="keyword">by</span><span class="operator">-</span>clause] [<span class="keyword">order</span><span class="operator">-</span><span class="keyword">by</span><span class="operator">-</span>clause] [windowing<span class="operator">-</span>clause])</span><br></pre></td></tr></table></figure><p>例如，使用first_value可以实现计算<em>每个班级的数学成绩最高分</em>。（自行思考）</p><p>使用开窗语句，可以为这些函数运算定义动态滑动窗口，例如计算到<em>目前为止的最大销售额</em></p><h2 id="处理空值"><a href="#处理空值" class="headerlink" title="处理空值"></a>处理空值</h2><p>空值通过[RESPECT NULLS | IGNORE NULLS]处理。RESPECT NULLS子句是默认值。默认情况下，如果第一行的列值为空，first_value函数就会返回空值。如果指定了IGNORE NULLS子句，则first_value函数将会返回在窗口中第一个列值不为空的行的值。</p><h1 id="rank-dense-rank-row-number"><a href="#rank-dense-rank-row-number" class="headerlink" title="rank/dense_rank/row_number"></a>rank/dense_rank/row_number</h1><p>这三个函数都是返回排名，不同之处在于他们对排名相同行的处理。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rank</span>() <span class="keyword">OVER</span>([partition_by_clause] order_by_clause); <span class="comment">-- 间断，相同值同序号，如 1、1、3、4、5</span></span><br><span class="line"><span class="built_in">row_number</span>() <span class="keyword">OVER</span>([partition_by_clause] order_by_clause); <span class="comment">-- 不间断，序号不重复，如 1、2、3、4、5</span></span><br><span class="line"><span class="built_in">dense_rank</span>() <span class="keyword">OVER</span>([partition_by_clause] order_by_clause) <span class="comment">-- 不间断，相同值同序号，如 1、1、2、3、3</span></span><br></pre></td></tr></table></figure><p>row_number是一个非确定函数，如果数据分区中的两行具有同样的值，row_number的值是不确定的。</p><p>这三个函数都不能使用开窗子句</p><h1 id="其他分析函数"><a href="#其他分析函数" class="headerlink" title="其他分析函数"></a>其他分析函数</h1><h2 id="nth-value"><a href="#nth-value" class="headerlink" title="nth_value"></a>nth_value</h2><p>first_value和last_value函数能够获取排序过的结果集中第一行或最后一行的数据。使用nth_value函数，可以获取排过序的结果集中的任意一行。</p><p>语法如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">nth_value</span>(measure, n) [<span class="keyword">FROM</span> <span class="keyword">FIRST</span> <span class="operator">|</span> <span class="keyword">FROM</span> <span class="keyword">LAST</span> ] [RESPECT NULLS <span class="operator">|</span> IGNORE NULLS] <span class="keyword">OVER</span>(...)</span><br></pre></td></tr></table></figure><p>其中第一个参数是列名，第二个参数为窗口位移量。</p><h2 id="ratio-to-report"><a href="#ratio-to-report" class="headerlink" title="ratio_to_report"></a>ratio_to_report</h2><p>ratio_to_report计算数据分区中某个值与和值的比率。</p><h2 id="listagg-Oracle"><a href="#listagg-Oracle" class="headerlink" title="listagg(Oracle)"></a>listagg(Oracle)</h2><p>这是Oracle 11gR2中引入的分析函数。这个分析函数能够将来自多个行的列值转化为列表格式。</p><p>listagg语法如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">listagg</span>(string, separator) <span class="keyword">within</span> <span class="keyword">group</span> (<span class="keyword">order</span><span class="operator">-</span><span class="keyword">by</span><span class="operator">-</span>clause) <span class="keyword">over</span>(<span class="keyword">partition</span><span class="operator">-</span><span class="keyword">by</span><span class="operator">-</span>clause)</span><br></pre></td></tr></table></figure><blockquote><p>在HIVE中可以使用<code>collect_list</code>或<code>collect_set</code>以及数组转字符串函数<code>concat_ws(&#39;,&#39;, COLLECT_LIST(&lt;cloumn&gt;))</code>来实现相同的效果。</p><p>listagg函数的一个<strong>局限</strong>就是，他的结果强制为VARCHAR2数据类型的最大长度。</p></blockquote><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>《精通Oracle SQL》 第八章</li><li><a href="https://www.gairuo.com/p/hive-sql-tutorial">HIVE SQL教程</a> 窗口计算 </li><li><a href="http://blog.itpub.net/21251711/viewspace-1068855/">分析函数用法及窗口子句 range/rows差别</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文主要还是参考了Oracle相关资料，所以文中的语法细节和某些函数在其他DB不会生效。&lt;/p&gt;
&lt;p&gt;我并不希望过多关注语法细节和具体函数（这些都可以自行百度），而更希望对分析函数这块的知识进行抽象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 </summary>
      
    
    
    
    <category term="数据库" scheme="https://gmet233.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="分析函数" scheme="https://gmet233.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%88%86%E6%9E%90%E5%87%BD%E6%95%B0/"/>
    
    
    <category term="数据库" scheme="https://gmet233.gitee.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="分析函数" scheme="https://gmet233.gitee.io/tags/%E5%88%86%E6%9E%90%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>HTTP协议的幂等性</title>
    <link href="https://gmet233.gitee.io/2022/01/15/HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7/"/>
    <id>https://gmet233.gitee.io/2022/01/15/HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7/</id>
    <published>2022-01-15T09:13:31.000Z</published>
    <updated>2022-01-15T10:03:07.201Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>基于HTTP协议的Web API是时下最为流行的一种分布式服务提供方式。无论是在大型互联网应用还是企业级架构中，我们都见到了越来越多的SOA或RESTful的Web API。为什么Web API如此流行呢？我认为很大程度上应归功于简单有效的HTTP协议。</p><p>HTTP协议是一种分布式的面向资源的网络<strong>应用层协议</strong>，无论是服务器端提供Web服务，还是客户端消费Web服务都非常简单。再加上浏览器、Javascript、AJAX、JSON以及HTML5等技术和工具的发展，互联网应用架构设计表现出了从传统的PHP、JSP、ASP.NET等服务器端动态网页向Web API + RIA（富互联网应用）过渡的趋势。Web API专注于提供业务服务，RIA专注于用户界面和交互设计，从此两个领域的分工更加明晰。在这种趋势下，Web API设计将成为服务器端程序员的必修课。然而，正如简单的Java语言并不意味着高质量的Java程序，简单的HTTP协议也不意味着高质量的Web API。要想设计出高质量的Web API，还需要深入理解分布式系统及HTTP协议的特性。</p><h1 id="幂等性定义"><a href="#幂等性定义" class="headerlink" title="幂等性定义"></a>幂等性定义</h1><p>本文所要探讨的正是HTTP协议涉及到的一种重要性质：幂等性(Idempotence)。在HTTP/1.1规范中幂等性的定义是：</p><blockquote><p>Methods can also have the property of “idempotence” in that (aside from error or expiration issues) the side-effects of N &gt; 0 identical requests is the same as for a single request.</p></blockquote><p>从定义上看，<strong>HTTP方法的幂等性是指一次和多次请求某一个资源应该具有同样的副作用。</strong>幂等性属于语义范畴，正如编译器只能帮助检查语法错误一样，HTTP规范也没有办法通过消息格式等语法手段来定义它，这可能是它不太受到重视的原因之一。但实际上，幂等性是分布式系统设计中十分重要的概念，而HTTP的分布式本质也决定了它在HTTP中具有重要地位。</p><h1 id="分布式事务-vs-幂等设计"><a href="#分布式事务-vs-幂等设计" class="headerlink" title="分布式事务 vs 幂等设计"></a>分布式事务 vs 幂等设计</h1><p>为什么需要幂等性呢？我们先从一个例子说起，假设有一个从账户取钱的远程API（可以是HTTP的，也可以不是），我们暂时用类函数的方式记为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool withdraw(account_id, amount)</span><br></pre></td></tr></table></figure><p>withdraw的语义是从account_id对应的账户中扣除amount数额的钱；如果扣除成功则返回true，账户余额减少amount；如果扣除失败则返回false，账户余额不变。值得注意的是：和本地环境相比，我们不能轻易假设分布式环境的可靠性。一种典型的情况是withdraw请求已经被服务器端正确处理，但服务器端的返回结果由于网络等原因被掉丢了，导致客户端无法得知处理结果。如果是在网页上，一些不恰当的设计可能会使用户认为上一次操作失败了，然后刷新页面，这就导致了withdraw被调用两次，账户也被多扣了一次钱。如图1所示：</p><p><img src="20110810171503575.png" alt="图1"></p><p>这个问题的<strong>解决方案一</strong>是采用分布式事务，通过引入支持分布式事务的中间件来保证withdraw功能的事务性。分布式事务的优点是对于调用者很简单，复杂性都交给了中间件来管理。缺点则是一方面架构太重量级，容易被绑在特定的中间件上，不利于异构系统的集成；另一方面分布式事务虽然能保证事务的ACID性质，而但却无法提供性能和可用性的保证。</p><p>另一种更<strong>轻量级的解决方案</strong>是幂等设计。我们可以通过一些技巧把withdraw变成幂等的，比如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int create_ticket() </span><br><span class="line">bool idempotent_withdraw(ticket_id, account_id, amount)</span><br></pre></td></tr></table></figure><p>create_ticket的语义是获取一个服务器端生成的唯一的处理号ticket_id，它将用于标识后续的操作。idempotent_withdraw和withdraw的区别在于关联了一个ticket_id，<strong>一个ticket_id表示的操作至多只会被处理一次</strong>，每次调用都将返回第一次调用时的处理结果。这样，idempotent_withdraw就符合幂等性了，客户端就可以放心地多次调用。</p><p>基于幂等性的解决方案中一个完整的取钱流程被分解成了两个步骤：1.调用create_ticket()获取ticket_id；2.调用idempotent_withdraw(ticket_id, account_id, amount)。虽然create_ticket不是幂等的，但在这种设计下，它对系统状态的影响可以忽略，加上idempotent_withdraw是幂等的，所以任何一步由于网络等原因失败或超时，客户端都可以重试，直到获得结果。如图2所示：</p><p><img src="201106042051069339.png" alt="图2"></p><p>和分布式事务相比，幂等设计的优势在于它的轻量级，容易适应异构环境，以及性能和可用性方面。在某些性能要求比较高的应用，幂等设计往往是唯一的选择。</p><h1 id="HTTP的幂等性"><a href="#HTTP的幂等性" class="headerlink" title="HTTP的幂等性"></a>HTTP的幂等性</h1><p>HTTP协议本身是一种面向资源的应用层协议，但对HTTP协议的使用实际上存在着两种不同的方式：<strong>一种是RESTful的，它把HTTP当成应用层协议，比较忠实地遵守了HTTP协议的各种规定；另一种是SOA的，它并没有完全把HTTP当成应用层协议，而是把HTTP协议作为了传输层协议，</strong>然后在HTTP之上建立了自己的应用层协议。本文所讨论的HTTP幂等性主要针对RESTful风格的，不过正如上一节所看到的那样，幂等性并不属于特定的协议，它是分布式系统的一种特性；所以，不论是SOA还是RESTful的Web API设计都应该考虑幂等性。下面将介绍HTTP GET、DELETE、PUT、POST四种主要方法的语义和幂等性。</p><p><strong>HTTP GET方法用于获取资源，不应有副作用，所以是幂等的。</strong>比如：GET <a href="http://www.bank.com/account/123456，不会改变资源的状态，不论调用一次还是N次都没有副作用。请注意，这里强调的是一次和N次具有相同的副作用，而不是每次GET的结果相同。GET">http://www.bank.com/account/123456，不会改变资源的状态，不论调用一次还是N次都没有副作用。请注意，这里强调的是一次和N次具有相同的副作用，而不是每次GET的结果相同。GET</a> <a href="http://www.news.com/latest-news这个HTTP请求可能会每次得到不同的结果，但它本身并没有产生任何副作用，因而是满足幂等性的。">http://www.news.com/latest-news这个HTTP请求可能会每次得到不同的结果，但它本身并没有产生任何副作用，因而是满足幂等性的。</a></p><p><strong>HTTP DELETE方法用于删除资源，有副作用，但它应该满足幂等性。</strong>比如：DELETE <a href="http://www.forum.com/article/4231，调用一次和N次对系统产生的副作用是相同的，即删掉id为4231的帖子；因此，调用者可以多次调用或刷新页面而不必担心引起错误。">http://www.forum.com/article/4231，调用一次和N次对系统产生的副作用是相同的，即删掉id为4231的帖子；因此，调用者可以多次调用或刷新页面而不必担心引起错误。</a></p><p>比较容易混淆的是HTTP POST和PUT。POST和PUT的区别容易被简单地误认为“POST表示创建资源，PUT表示更新资源”；而实际上，二者均可用于创建资源，更为本质的差别是在幂等性方面。在HTTP规范中对POST和PUT是这样定义的：</p><blockquote><p>The POST method is used to request that the origin server accept the entity enclosed in the request as a new subordinate of the resource identified by the Request-URI in the Request-Line …… If a resource has been created on the origin server, the response SHOULD be 201 (Created) and contain an entity which describes the status of the request and refers to the new resource, and a Location header.</p><p>The PUT method requests that the enclosed entity be stored under the supplied Request-URI. If the Request-URI refers to an already existing resource, the enclosed entity SHOULD be considered as a modified version of the one residing on the origin server. If the Request-URI does not point to an existing resource, and that URI is capable of being defined as a new resource by the requesting user agent, the origin server can create the resource with that URI.</p></blockquote><p><strong>POST所对应的URI并非创建的资源本身，而是资源的接收者。</strong>比如：POST <a href="http://www.forum.com/articles的语义是在http://www.forum.com/articles下创建一篇帖子，HTTP响应中应包含帖子的创建状态以及帖子的URI。两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI；所以，**POST方法不具备幂等性**。而PUT所对应的URI是要创建或更新的资源本身。比如：PUT">http://www.forum.com/articles的语义是在http://www.forum.com/articles下创建一篇帖子，HTTP响应中应包含帖子的创建状态以及帖子的URI。两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI；所以，**POST方法不具备幂等性**。而PUT所对应的URI是要创建或更新的资源本身。比如：PUT</a> <a href="http://www.forum/articles/4231的语义是创建或更新ID为4231的帖子。对同一URI进行多次PUT的副作用和一次PUT是相同的；因此，**PUT方法具有幂等性。**">http://www.forum/articles/4231的语义是创建或更新ID为4231的帖子。对同一URI进行多次PUT的副作用和一次PUT是相同的；因此，**PUT方法具有幂等性。**</a></p><p><strong>在介绍了几种操作的语义和幂等性之后，我们来看看如何通过Web API的形式实现前面所提到的取款功能。很简单，用POST /tickets来实现create_ticket；用PUT /accounts/account_id/ticket_id?amount=xxx来实现idempotent_withdraw。值得注意的是严格来讲amount参数不应该作为URI的一部分，真正的URI应该是/accounts/account_id/ticket_id，而amount应该放在请求的body中。这种模式可以应用于很多场合，比如：论坛网站中防止意外的重复发帖。</strong></p><h2 id="如何防范-POST-重复提交"><a href="#如何防范-POST-重复提交" class="headerlink" title="如何防范 POST 重复提交"></a>如何防范 POST 重复提交</h2><p>HTTP POST 操作既不是安全的，也不是幂等的（至少在 HTTP 规范里没有保证）。当我们因为反复刷新浏览器导致多次提交表单，多次发出同样的 POST 请求，导致远端服务器重复创建出了资源。</p><p>为了避免这种情形，有以下几种解决方法：</p><ol><li>上述所说的幂等性设计；</li><li>PRG(Post/Redirect/Get模式)：服务器端收到 POST 请求，在操作成功后必须 302 跳转到另外一个页面，这样即使用户刷新页面，也不会重复提交表单。</li><li>用JavaScript的方式在客户端处理：表单提交之后，将提交按钮设置为不可用；</li><li>后端 WebService 一定要做到幂等性：<ol><li>使用Session设置令牌。客户端请求页面时，服务器为每次产生的Form表单分配唯一的随机标识号，并且在orm的一个隐藏字段中设置这个标识号，同时在当前用户的Session中保存这个标识号。当提交表单时，服务器比较hidden和session中的标识号是否相同，相同则继续，处理完后清空Session，否则服务器忽略请求。注意：恶意用户可利用这一性质，不断重复访问页面，以致Session中保存的标识号不断增多，最终严重消耗服务器内存。可以采用在Session中记录用户发帖的时间，然后通过一个时间间隔来限制用户连续发帖的数量来解决这一问题。</li><li>在数据库添加唯一字段。在数据库建表的时候在ID字段添加主键约束，账号，名称的信息添加唯一性约束。确保数据库只可以添加一条数据。</li></ol></li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://www.cnblogs.com/weidagang2046/archive/2011/06/04/idempotence.html">理解HTTP幂等性</a></li><li><a href="https://blog.csdn.net/qq_33945246/article/details/104613726">HTTP协议的补充（POST、GET请求方法、幂等性）</a></li><li><a href="https://juejin.cn/post/6968747879682801672">防止表单重复提交的解决方案整理</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;基于HTTP协议的Web API是时下最为流行的一种分布式服务提供方式。无论是在大型互联网应用还是企业级架构中，我们都见到了越来越多的SOA</summary>
      
    
    
    
    <category term="计算机网络" scheme="https://gmet233.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="HTTP协议" scheme="https://gmet233.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="计算机网络" scheme="https://gmet233.gitee.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="HTTP协议" scheme="https://gmet233.gitee.io/tags/HTTP%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>神经网络训练初体验: 房价预测比赛</title>
    <link href="https://gmet233.gitee.io/2022/01/12/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E8%AE%AD%E7%BB%83%E5%88%9D%E4%BD%93%E9%AA%8C-%E6%88%BF%E4%BB%B7%E9%A2%84%E6%B5%8B%E6%AF%94%E8%B5%9B/"/>
    <id>https://gmet233.gitee.io/2022/01/12/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E8%AE%AD%E7%BB%83%E5%88%9D%E4%BD%93%E9%AA%8C-%E6%88%BF%E4%BB%B7%E9%A2%84%E6%B5%8B%E6%AF%94%E8%B5%9B/</id>
    <published>2022-01-12T15:05:47.000Z</published>
    <updated>2022-01-12T15:25:51.531Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文FROM《动手学深度学习》第四章第十节，链接详见<em>参考资料1</em></p></blockquote><h1 id="工作环境"><a href="#工作环境" class="headerlink" title="工作环境"></a>工作环境</h1><div class="table-container"><table><thead><tr><th>软件名称</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td>anaconda</td><td>Python环境和开源模块管理工具</td><td>默认</td></tr><tr><td>Python</td><td>开发语言</td><td>3.8</td></tr><tr><td>torch、torchvision</td><td>深度学习框架</td><td>默认</td></tr><tr><td>d2l</td><td>动手学深度学习官方模块</td><td>默认</td></tr><tr><td>VS Code</td><td>开发IDE</td><td>默认</td></tr></tbody></table></div><h1 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h1><p>创建项目文件夹<code>kaggle-house-prices</code>（自定义命名）以及<code>code</code>子文件夹，<code>code/</code>下创建Jupyter notebook，所有代码写在这里面。</p><p>生成的项目结构如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kaggle-house-prices/</span><br><span class="line">code/</span><br><span class="line">kaggle-house-prices.ipynb</span><br></pre></td></tr></table></figure><h1 id="下载数据集"><a href="#下载数据集" class="headerlink" title="下载数据集"></a>下载数据集</h1><p>数据集来自于Kaggle上的一个竞赛。网址：<a href="https://www.kaggle.com/c/house-prices-advanced-regression-techniques/data">https://www.kaggle.com/c/house-prices-advanced-regression-techniques/data</a></p><p>你可以直接从上面下载数据集；（包含训练集、测试集、数据描述和提交样例）</p><p>或者你可以使用书中的方式下载代码，这里我把完整的代码贴一下。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> tarfile</span><br><span class="line"><span class="keyword">import</span> zipfile</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个二元组包含数据集的url和验证文件完整性的sha-1密钥</span></span><br><span class="line">DATA_HUB = <span class="built_in">dict</span>()</span><br><span class="line">DATA_URL = <span class="string">&#x27;http://d2l-data.s3-accelerate.amazonaws.com/&#x27;</span></span><br><span class="line">DATA_HUB[<span class="string">&#x27;kaggle_house_train&#x27;</span>] = (</span><br><span class="line">    DATA_URL + <span class="string">&#x27;kaggle_house_pred_train.csv&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;585e9cc93e70b39160e7921475f9bcd7d31219ce&#x27;</span>)</span><br><span class="line"></span><br><span class="line">DATA_HUB[<span class="string">&#x27;kaggle_house_test&#x27;</span>] = (</span><br><span class="line">    DATA_URL + <span class="string">&#x27;kaggle_house_pred_test.csv&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;fa19780a7b011d9b009e8bff8e99922a8ee2eb90&#x27;</span>)</span><br><span class="line"></span><br><span class="line">DATA_URL = <span class="string">&#x27;http://d2l-data.s3-accelerate.amazonaws.com/&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">定义了一堆下载、解压的函数</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download</span>(<span class="params">name, cache_dir=os.path.join(<span class="params"><span class="string">&#x27;..&#x27;</span>, <span class="string">&#x27;data&#x27;</span></span>)</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;下载一个DATA_HUB中的文件，返回本地文件名&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">assert</span> name <span class="keyword">in</span> DATA_HUB, <span class="string">f&quot;<span class="subst">&#123;name&#125;</span> 不存在于 <span class="subst">&#123;DATA_HUB&#125;</span>&quot;</span></span><br><span class="line">    url, sha1_hash = DATA_HUB[name]</span><br><span class="line">    os.makedirs(cache_dir, exist_ok=<span class="literal">True</span>)</span><br><span class="line">    fname = os.path.join(cache_dir, url.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">if</span> os.path.exists(fname):</span><br><span class="line">        sha1 = hashlib.sha1()</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(fname, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                data = f.read(<span class="number">1048576</span>)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                sha1.update(data)</span><br><span class="line">        <span class="keyword">if</span> sha1.hexdigest() == sha1_hash:</span><br><span class="line">            <span class="keyword">return</span> fname  <span class="comment"># 命中缓存</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;正在从<span class="subst">&#123;url&#125;</span>下载<span class="subst">&#123;fname&#125;</span>...&#x27;</span>)</span><br><span class="line">    r = requests.get(url, stream=<span class="literal">True</span>, verify=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(fname, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(r.content)</span><br><span class="line">    <span class="keyword">return</span> fname</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_extract</span>(<span class="params">name, folder=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;下载并解压zip/tar文件&quot;&quot;&quot;</span></span><br><span class="line">    fname = download(name)</span><br><span class="line">    base_dir = os.path.dirname(fname)</span><br><span class="line">    data_dir, ext = os.path.splitext(fname)</span><br><span class="line">    <span class="keyword">if</span> ext == <span class="string">&#x27;.zip&#x27;</span>:</span><br><span class="line">        fp = zipfile.ZipFile(fname, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> ext <span class="keyword">in</span> (<span class="string">&#x27;.tar&#x27;</span>, <span class="string">&#x27;.gz&#x27;</span>):</span><br><span class="line">        fp = tarfile.<span class="built_in">open</span>(fname, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">assert</span> <span class="literal">False</span>, <span class="string">&#x27;只有zip/tar文件可以被解压缩&#x27;</span></span><br><span class="line">    fp.extractall(base_dir)</span><br><span class="line">    <span class="keyword">return</span> os.path.join(base_dir, folder) <span class="keyword">if</span> folder <span class="keyword">else</span> data_dir</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_all</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;下载DATA_HUB中的所有文件&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> DATA_HUB:</span><br><span class="line">        download(name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载训练集和测试集</span></span><br><span class="line">download_all()</span><br></pre></td></tr></table></figure><pre><code>正在从http://d2l-data.s3-accelerate.amazonaws.com/kaggle_house_pred_train.csv下载..\data\kaggle_house_pred_train.csv...正在从http://d2l-data.s3-accelerate.amazonaws.com/kaggle_house_pred_test.csv下载..\data\kaggle_house_pred_test.csv...</code></pre><p>使用书中的代码下载的数据集存放在<code>../data/</code>中。结构目录如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kaggle-house-prices/</span><br><span class="line">code/</span><br><span class="line">kaggle-house-prices.ipynb</span><br><span class="line">    data/</span><br><span class="line">    kaggle_house_pred_train.csv</span><br><span class="line">    kaggle_house_pred_test.csv</span><br></pre></td></tr></table></figure><p>下面进行数据读取和预处理。</p><h1 id="读取数据集"><a href="#读取数据集" class="headerlink" title="读取数据集"></a>读取数据集</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果pandas没有被安装，请取消下一句的注释。</span></span><br><span class="line"><span class="comment"># !pip install pandas</span></span><br><span class="line"></span><br><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train_data = pd.read_csv(<span class="string">&quot;../data/kaggle_house_pred_train.csv&quot;</span>)</span><br><span class="line">test_data = pd.read_csv(<span class="string">&quot;../data/kaggle_house_pred_train.csv&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打印他们的行列数，这里test_data的列比train_data少1，少的是标签一列</span></span><br><span class="line"><span class="built_in">print</span>(train_data.shape)</span><br><span class="line"><span class="built_in">print</span>(test_data.shape)</span><br></pre></td></tr></table></figure><pre><code>(1460, 81)(1460, 81)</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># print train_data 两个参数分别指出打印的行（样本）和列（特征）</span></span><br><span class="line"><span class="built_in">print</span>(train_data.iloc[<span class="number">0</span>:<span class="number">4</span>, [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, -<span class="number">3</span>, -<span class="number">2</span>, -<span class="number">1</span>]])</span><br></pre></td></tr></table></figure><pre><code>   Id  MSSubClass MSZoning  LotFrontage SaleType SaleCondition  SalePrice0   1          60       RL         65.0       WD        Normal     2085001   2          20       RL         80.0       WD        Normal     1815002   3          60       RL         68.0       WD        Normal     2235003   4          70       RL         60.0       WD       Abnorml     140000</code></pre><p>将train_data和test_data去掉第一个特征（第一个特征是ID，对训练无意义）的所有特征都放到all_features中：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">all_features = pd.concat((train_data.iloc[:, <span class="number">1</span>:-<span class="number">1</span>], test_data.iloc[:, <span class="number">1</span>:]))</span><br></pre></td></tr></table></figure><h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><p>在开始建模之前，我们需要对数据进行预处理。</p><p>对于数字特征，首先，<strong>将所有缺失的值替换为相应特征的平均值；</strong></p><p>然后，为了将所有特征放在一个共同的尺度上，我们<strong>通过将特征重新缩放到零均值和单位方差来标准化数据</strong>：</p><script type="math/tex; mode=display">x \leftarrow \frac{x - \mu}{\sigma}.</script><p>此时，特征即具有零均值和单位方差，即 $E[\frac{x-\mu}{\sigma}] = \frac{\mu - \mu}{\sigma} = 0$和$E[(x-\mu)^2] = (\sigma^2 + \mu^2) - 2\mu^2+\mu^2 = \sigma^2$。</p><p>标准化数据有两个原因：</p><ul><li>方便优化；</li><li>我们不知道哪些特征是相关的，所以我们不想让惩罚分配给一个特征的系数比分配给其他任何特征的系数更大；</li><li>取消由于量纲不同、自身变异或者数值相差较大所引起的误差。</li></ul><p>更多关于标准化的知识请见<em>参考资料2</em></p><p>这里可以看到，书中提到的是先处理缺失值，再标准化；而实际代码是先标准化，再处理缺失值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 若无法获得测试数据，则可根据训练数据计算均值和标准差</span></span><br><span class="line"><span class="comment"># 取出数字类型的特征索引</span></span><br><span class="line">numeric_features = all_features.dtypes[all_features.dtypes != <span class="string">&#x27;object&#x27;</span>].index</span><br><span class="line"><span class="comment"># 将数字类型的特征标准化</span></span><br><span class="line">all_features[numeric_features] = all_features[numeric_features].apply(</span><br><span class="line">    <span class="keyword">lambda</span> x: (x - x.mean()) / (x.std()))</span><br><span class="line"><span class="comment"># 在标准化数据之后，所有均值消失，因此我们可以将缺失值设置为0</span></span><br><span class="line">all_features[numeric_features] = all_features[numeric_features].fillna(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>对于离散值，我们使用one-hot编码，就是特征的离散值转换为向量。例如，特征“type”的值包括cat，dog，rat，那么经过one-hot编码后会生成三个特征“type_cat”，“type_dog”，“type_rat”。如果原来“type”=cat，则“type_cat”=1，“type_dog”=0，“type_rat”=0。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># “Dummy_na=True”将“na”（缺失值）视为有效的特征值，并为其创建指示符特征</span></span><br><span class="line">all_features = pd.get_dummies(all_features, dummy_na=<span class="literal">True</span>)</span><br><span class="line">all_features.shape</span><br></pre></td></tr></table></figure><pre><code>(2920, 332)</code></pre><p>可以看到，此转换会将特征的总数量从79个增加到331个。 最后，通过values属性，我们可以 从pandas格式中提取NumPy格式，并将其转换为张量表示用于训练。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n_train = train_data.shape[<span class="number">0</span>]  <span class="comment"># 取得train_data的行数</span></span><br><span class="line"><span class="comment"># 取出all_features的train_data转换成tensor</span></span><br><span class="line">train_features = torch.tensor(all_features[:n_train].values, dtype=torch.float32)</span><br><span class="line"><span class="comment"># 取出all_features的test_data转换成tensor</span></span><br><span class="line">test_features = torch.tensor(all_features[n_train:].values, dtype=torch.float32)</span><br><span class="line"><span class="comment"># train_labels.shape[0] == n_train</span></span><br><span class="line"><span class="comment"># reshape(-1, 1)相当于把labels一行转为一列和train_features一一对应</span></span><br><span class="line">train_labels = torch.tensor(</span><br><span class="line">    train_data.SalePrice.values.reshape(-<span class="number">1</span>, <span class="number">1</span>), dtype=torch.float32)</span><br></pre></td></tr></table></figure><h1 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h1><p>首先，我们训练一个带有损失平方的线性模型。如果一切顺利，线性模型将作为基线（baseline）模型， 让我们直观地知道最好的模型有超出简单的模型多少。</p><p>损失函数：MSE Loss</p><p>基线模型：（个人理解）最先想到的、最简单的、结果比较差、一般在此基础上进行优化的模型。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">loss = nn.MSELoss()</span><br><span class="line">in_features = train_features.shape[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_net</span>():</span></span><br><span class="line">    net = nn.Sequential(nn.Linear(in_features,<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> net</span><br></pre></td></tr></table></figure><p>对于房价，就像股票价格一样，我们关心的是相对数量，而不是绝对数量。因此，[<strong>我们更关心相对误差$\frac{y - \hat{y}}{y}$，</strong>]而不是绝对误差$y - \hat{y}$。例如，如果我们在俄亥俄州农村地区估计一栋房子的价格时，我们的预测偏差了10万美元，在那里一栋典型的房子的价值是12.5万美元，那么我们可能做得很糟糕。另一方面，如果我们在加州豪宅区的预测出现了这个数字的偏差，这可能是一个惊人的准确预测（在那里，房价均值超过400万美元）。</p><p>(<strong>解决这个问题的一种方法是用价格预测的对数来衡量差异</strong>)。事实上，这也是比赛中官方用来评价提交质量的误差指标。即将 $\delta$ for $|\log y - \log \hat{y}| \leq \delta$转换为$e^{-\delta} \leq \frac{\hat{y}}{y} \leq e^\delta$。这使得预测价格的对数与真实标签价格的对数之间出现以下均方根误差：</p><script type="math/tex; mode=display">\sqrt{\frac{1}{n}\sum_{i=1}^n\left(\log y_i -\log \hat{y}_i\right)^2}.</script><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log_rmse</span>(<span class="params">net, features, labels</span>):</span></span><br><span class="line">    <span class="comment"># 为了在取对数时进一步稳定该值，将小于1的值设置为1</span></span><br><span class="line">    <span class="comment"># clamp方法说明详见 参考资料5</span></span><br><span class="line">    clipped_preds = torch.clamp(net(features), <span class="number">1</span>, <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>))</span><br><span class="line">    rmse = torch.sqrt(loss(torch.log(clipped_preds),</span><br><span class="line">                           torch.log(labels)))</span><br><span class="line">    <span class="keyword">return</span> rmse.item()</span><br></pre></td></tr></table></figure><blockquote><p>在这里，我一开始对损失函数（loss）和评价指标（metrics）没有理解，所以我对loss和log_rmse纠结了很久。</p><p>这里我的理解是，</p><p>loss是需要丢到网络里的，是网络优化的目标函数；因为需要通过梯度下降来反向传播，所以必须是可导的；</p><p>metrics是评价网络的一种指标，不参与优化；不需要可导。</p><p>更多关于损失函数和评价指标请参见<em>参考资料3</em>，<em>参考资料4</em></p></blockquote><hr><p>我们的训练函数将借助Adam优化器。</p><p>Adam优化器的主要吸引力在于它对初始学习率不那么敏感。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span>(<span class="params">net, train_features, train_labels, test_features, test_labels,</span></span></span><br><span class="line"><span class="params"><span class="function">          num_epochs, learning_rate, weight_decay, batch_size</span>):</span></span><br><span class="line">    train_ls, test_ls = [], []</span><br><span class="line">    train_iter = d2l.load_array((train_features, train_labels), batch_size)</span><br><span class="line">    <span class="comment"># 这里使用的是Adam优化算法</span></span><br><span class="line">    optimizer = torch.optim.Adam(net.parameters(),</span><br><span class="line">                                 lr = learning_rate,</span><br><span class="line">                                 weight_decay = weight_decay)</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">        <span class="keyword">for</span> X, y <span class="keyword">in</span> train_iter:</span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            l = loss(net(X), y)</span><br><span class="line">            l.backward()</span><br><span class="line">            optimizer.step()</span><br><span class="line">        train_ls.append(log_rmse(net, train_features, train_labels))</span><br><span class="line">        <span class="keyword">if</span> test_labels <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            test_ls.append(log_rmse(net, test_features, test_labels))</span><br><span class="line">    <span class="keyword">return</span> train_ls, test_ls</span><br></pre></td></tr></table></figure><h1 id="K-折交叉验证"><a href="#K-折交叉验证" class="headerlink" title="K-折交叉验证"></a>K-折交叉验证</h1><p>所谓K-折交叉验证就是把train data分为K份，每次1/K份作为验证集，把另外的1 - 1/K份作为训练集。事实上，<code>get_k_fold_data</code>就是在做这件事。</p><p>K-折交叉验证有助于模型选择和超参数调整。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_k_fold_data</span>(<span class="params">k, i, X, y</span>):</span></span><br><span class="line">    <span class="keyword">assert</span> k &gt; <span class="number">1</span></span><br><span class="line">    fold_size = X.shape[<span class="number">0</span>] // k</span><br><span class="line">    X_train, y_train = <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">        <span class="comment"># slice方法说明详见参考资料6</span></span><br><span class="line">        idx = <span class="built_in">slice</span>(j * fold_size, (j + <span class="number">1</span>) * fold_size)</span><br><span class="line">        X_part, y_part = X[idx, :], y[idx]</span><br><span class="line">        <span class="keyword">if</span> j == i:</span><br><span class="line">            X_valid, y_valid = X_part, y_part</span><br><span class="line">        <span class="keyword">elif</span> X_train <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            X_train, y_train = X_part, y_part</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            X_train = torch.cat([X_train, X_part], <span class="number">0</span>) <span class="comment"># 将已有的X_train和X_part连接起来</span></span><br><span class="line">            y_train = torch.cat([y_train, y_part], <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> X_train, y_train, X_valid, y_valid</span><br></pre></td></tr></table></figure><p><code>k_fold</code>中先求每一折得到的trian-loss, valid-loss，注意train_ls和valid_ls是一个list，存放了每次迭代后loss值，我们取train_ls[-1]，也就是最终的那个loss</p><p>最后把所有K-折得到的train-loss的平均和valid-loss的平均</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">k_fold</span>(<span class="params">k, X_train, y_train, num_epochs, learning_rate, weight_decay,</span></span></span><br><span class="line"><span class="params"><span class="function">           batch_size</span>):</span></span><br><span class="line">    train_l_sum, valid_l_sum = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">        <span class="comment"># 这里data实际是一个元组(X_train, y_train, X_valid, y_valid)</span></span><br><span class="line">        data = get_k_fold_data(k, i, X_train, y_train)</span><br><span class="line">        net = get_net()</span><br><span class="line">        <span class="comment"># 把data这个元组传入，对应train中的train_features, train_labels, test_features, test_labels四个参数</span></span><br><span class="line">        train_ls, valid_ls = train(net, *data, num_epochs, learning_rate,</span><br><span class="line">                                   weight_decay, batch_size)</span><br><span class="line">        train_l_sum += train_ls[-<span class="number">1</span>]</span><br><span class="line">        valid_l_sum += valid_ls[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">            d2l.plot(<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, num_epochs + <span class="number">1</span>)), [train_ls, valid_ls],</span><br><span class="line">                     xlabel=<span class="string">&#x27;epoch&#x27;</span>, ylabel=<span class="string">&#x27;rmse&#x27;</span>, xlim=[<span class="number">1</span>, num_epochs],</span><br><span class="line">                     legend=[<span class="string">&#x27;train&#x27;</span>, <span class="string">&#x27;valid&#x27;</span>], yscale=<span class="string">&#x27;log&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;折<span class="subst">&#123;i + <span class="number">1</span>&#125;</span>，训练log rmse<span class="subst">&#123;<span class="built_in">float</span>(train_ls[-<span class="number">1</span>]):f&#125;</span>, &#x27;</span></span><br><span class="line">              <span class="string">f&#x27;验证log rmse<span class="subst">&#123;<span class="built_in">float</span>(valid_ls[-<span class="number">1</span>]):f&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> train_l_sum / k, valid_l_sum / k</span><br></pre></td></tr></table></figure><h1 id="模型选择"><a href="#模型选择" class="headerlink" title="模型选择"></a>模型选择</h1><p>下面是一组超参数，后面我们可以对此进行调优（改改数， run run code）</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">k, num_epochs, lr, weight_decay, batch_size = <span class="number">5</span>, <span class="number">100</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">64</span></span><br><span class="line">train_l, valid_l = k_fold(k, train_features, train_labels, num_epochs, lr,</span><br><span class="line">                          weight_decay, batch_size)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;k&#125;</span>-折验证: 平均训练log rmse: <span class="subst">&#123;<span class="built_in">float</span>(train_l):f&#125;</span>, &#x27;</span></span><br><span class="line">      <span class="string">f&#x27;平均验证log rmse: <span class="subst">&#123;<span class="built_in">float</span>(valid_l):f&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>折1，训练log rmse0.168934, 验证log rmse0.158768折2，训练log rmse0.162051, 验证log rmse0.186553折3，训练log rmse0.163633, 验证log rmse0.167966折4，训练log rmse0.167716, 验证log rmse0.154111折5，训练log rmse0.161381, 验证log rmse0.1841885-折验证: 平均训练log rmse: 0.164743, 平均验证log rmse: 0.170317</code></pre><p><img src="kaggle-house-prices_31_1.svg" alt="svg"></p><p>请注意，有时一组超参数的训练误差可能非常低，但 K 折交叉验证的误差要高得多， 这表明模型过拟合了。 在整个训练过程中，你将希望监控训练误差和验证误差这两个数字。 较少的过拟合可能表明现有数据可以支撑一个更强大的模型， 较大的过拟合可能意味着我们可以通过正则化技术来获益。</p><h1 id="提交Kaggle预测"><a href="#提交Kaggle预测" class="headerlink" title="提交Kaggle预测"></a>提交Kaggle预测</h1><p>当我们用上面的K-折交叉验证确定参数后，我们将超参数固定住，把所有的train data拿来train。</p><p>如果测试集上的预测与 K 倍交叉验证过程中的预测相似， 那就是时候把它们上传到Kaggle了。 下面的代码将生成一个名为submission.csv的文件。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_and_pred</span>(<span class="params">train_features, test_feature, train_labels, test_data,</span></span></span><br><span class="line"><span class="params"><span class="function">                   num_epochs, lr, weight_decay, batch_size</span>):</span></span><br><span class="line">    net = get_net()</span><br><span class="line">    train_ls, _ = train(net, train_features, train_labels, <span class="literal">None</span>, <span class="literal">None</span>,</span><br><span class="line">                        num_epochs, lr, weight_decay, batch_size)</span><br><span class="line">    d2l.plot(np.arange(<span class="number">1</span>, num_epochs + <span class="number">1</span>), [train_ls], xlabel=<span class="string">&#x27;epoch&#x27;</span>,</span><br><span class="line">             ylabel=<span class="string">&#x27;log rmse&#x27;</span>, xlim=[<span class="number">1</span>, num_epochs], yscale=<span class="string">&#x27;log&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;训练log rmse：<span class="subst">&#123;<span class="built_in">float</span>(train_ls[-<span class="number">1</span>]):f&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="comment"># 将网络应用于测试集。</span></span><br><span class="line">    preds = net(test_features).detach().numpy()</span><br><span class="line">    <span class="comment"># 将其重新格式化以导出到Kaggle</span></span><br><span class="line">    test_data[<span class="string">&#x27;SalePrice&#x27;</span>] = pd.Series(preds.reshape(<span class="number">1</span>, -<span class="number">1</span>)[<span class="number">0</span>])</span><br><span class="line">    submission = pd.concat([test_data[<span class="string">&#x27;Id&#x27;</span>], test_data[<span class="string">&#x27;SalePrice&#x27;</span>]], axis=<span class="number">1</span>)</span><br><span class="line">    submission.to_csv(<span class="string">&#x27;submission.csv&#x27;</span>, index=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">train_and_pred(train_features, test_features, train_labels, test_data,</span><br><span class="line">               num_epochs, lr, weight_decay, batch_size)</span><br></pre></td></tr></table></figure><pre><code>训练log rmse：0.162150</code></pre><p><img src="kaggle-house-prices_34_1.svg" alt="svg"></p><p>接下来我们将生成的<code>submission.csv</code>文件提交到Kaggle：</p><ul><li>访问<a href="https://www.kaggle.com/c/house-prices-advanced-regression-techniques/data">https://www.kaggle.com/c/house-prices-advanced-regression-techniques/data</a></li><li>点击“Submit Predictions”</li><li>选择你要上传的预测文件<code>submission.csv</code></li><li>点击页面底部的“Make Submission”按钮，即可查看结果。</li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul><li>真实数据通常混合了不同的数据类型，需要进行预处理。</li><li>常用的预处理方法：将实值数据重新缩放为零均值和单位方法；用均值替换缺失值。</li><li>将类别特征转化为指标特征，可以使我们把这个特征当作一个独热向量来对待。</li><li>我们可以使用 K 折交叉验证来选择模型并调整超参数。</li><li>对数对于相对误差很有用。</li></ul><h1 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h1><p>这里是书中给出的一些思考问题，我没做，但是依然列出来供参考：</p><ol><li>将试图预测价格改为试图预测价格的对数，会发生什么？</li><li>用平均值替换缺失值总是好主意吗？提示：你能构造一个不随机丢失值的情况吗？</li><li>通过 K 折交叉验证调整超参数，从而提高Kaggle的得分。</li><li>通过改进模型（例如，层、权重衰减和dropout）来提高分数。</li><li>如果我们没有像本节所做的那样标准化连续的数值特征，会发生什么？</li></ol><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>我仔细阅读原文，捋了一边代码。</p><p>基础比较差，有些地方认识不太清晰，全凭自己理解，如有错误，请多包涵，或直接邮箱联系我。</p><p>我原以为会有训练模型错误率不断降低的成就感。。但实际上全是复制粘贴run code。</p><p>好像学到了又好像没学到。🤦‍</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="http://zh-v2.d2l.ai/chapter_multilayer-perceptrons/kaggle-house-price.html#id6">《动手学深度学习》 4.10. 实战Kaggle比赛：预测房价</a></li><li><a href="https://www.cnblogs.com/wangqiang9/p/9285594.html">数据预处理之中心化（零均值化）与标准化（归一化）</a></li><li><a href="https://zhuanlan.zhihu.com/p/373032887">机器学习——损失函数(loss)与评价指标(metric)的区别？</a></li><li><a href="https://codeantenna.com/a/7p6uOqnNhx">keras中compile方法的 loss 和 metrics 区别</a></li><li><a href="https://pytorch.org/docs/stable/generated/torch.clamp.html">torch.clamp方法说明</a></li><li><a href="https://www.runoob.com/python/python-func-slice.html">Python slice方法说明</a></li><li><a href="https://blog.csdn.net/m0_37871195/article/details/79829488">深度学习中iteration、epoch、batchsize的定义</a></li><li><a href="https://pytorch.org/docs/1.9.1/generated/torch.Tensor.detach.html">torch.detach方法说明</a></li><li><a href="https://pytorch.org/docs/stable/generated/torch.cat.html#torch.cat">torch.cat方法说明</a></li><li><a href="https://csbwang.github.io/dl_ch2">机器学习基础</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文FROM《动手学深度学习》第四章第十节，链接详见&lt;em&gt;参考资料1&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;工作环境&quot;&gt;&lt;a href=&quot;#工作环境&quot; class=&quot;headerlink&quot; title=&quot;工作环境&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="深度学习" scheme="https://gmet233.gitee.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="动手学深度学习" scheme="https://gmet233.gitee.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="深度学习" scheme="https://gmet233.gitee.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>《动手学深度学习》读书笔记（一） 前言</title>
    <link href="https://gmet233.gitee.io/2022/01/10/%E3%80%8A%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89-%E5%89%8D%E8%A8%80/"/>
    <id>https://gmet233.gitee.io/2022/01/10/%E3%80%8A%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89-%E5%89%8D%E8%A8%80/</id>
    <published>2022-01-10T10:00:11.000Z</published>
    <updated>2022-01-12T15:15:33.301Z</updated>
    
    <content type="html"><![CDATA[<p><em>本博客记录阅读《动手学深度学习》的读书笔记。</em></p><blockquote><p>原文地址：<a href="http://zh-v2.d2l.ai/chapter_introduction/index.html">http://zh-v2.d2l.ai/chapter_introduction/index.html</a></p></blockquote><h1 id="日常生活中的机器学习"><a href="#日常生活中的机器学习" class="headerlink" title="日常生活中的机器学习"></a>日常生活中的机器学习</h1><p>我们可以把<strong>参数</strong>看作旋钮，我们可以转动旋钮来调整程序的行为。</p><p>任一调整参数后的程序，我们称为<strong>模型</strong>（model）。</p><p>通过操作参数而生成的所有不同程序（输入-输出映射）的集合称为“<strong>模型族</strong>”。</p><p>使用数据集来选择参数的元程序被称为<strong>学习算法</strong>（learning algorithm）。</p><p>在我们开始用机器学习算法解决问题之前，我们必须精确地定义问题，确定<strong>输入（input）和输出（output）</strong>的性质，并选择合适的模型族。</p><p>在机器学习中，<strong>学习</strong>（learning）是一个训练模型的过程。 通过这个过程，我们可以发现正确的参数集，从而使模型强制执行所需的行为。 换句话说，我们用数据<strong>训练</strong>（train）我们的模型。 </p><p>训练过程通常包含如下步骤：</p><ol><li>从一个随机初始化参数的模型开始，这个模型基本毫不“智能”。</li><li>获取一些数据样本（例如，音频片段以及对应的{是,否}标签）。</li><li>调整参数，使模型在这些样本中表现得更好。</li><li>重复第2步和第3步，直到模型在任务中的表现令你满意。</li></ol><p><img src="ml-loop.png" alt="典型的训练过程"></p><h1 id="关键组件"><a href="#关键组件" class="headerlink" title="关键组件"></a>关键组件</h1><p>无论我们遇到什么类型的机器学习问题，这些组件都将伴随我们左右：</p><ol><li>我们可以学习的<strong>数据</strong>（data）。</li><li>如何转换数据的<strong>模型</strong>（model）。</li><li>一个<strong>目标函数</strong>（objective function），用来量化模型的有效性。</li><li>调整模型参数以优化目标函数的<strong>算法</strong>（algorithm）。</li></ol><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p>每个数据集由一个个<strong>样本</strong>（example, sample）组成，大多时候，它们遵循独立同分布(independently and identically distributed, i.i.d.)。 样本有时也叫做<strong>数据点</strong>（data point）或者<strong>数据实例</strong>（data instance），通常每个样本由一组称为<strong>特征</strong>（features，或<strong>协变量</strong>（covariates））的属性组成。 机器学习模型会根据这些属性进行预测。 </p><p><strong>标签</strong>：预测的一个特殊属性，例如是/否，猫/狗等。</p><p>当每个样本的特征类别数量都是相同的时候，其特征向量是固定长度的，这个长度被称为数据的维数（dimensionality）。 固定长度的特征向量是一个方便的属性，它有助于我们量化学习大量样本。</p><p>然而，并不是所有的数据都可以用“固定长度”的向量表示。例如不同的图片大小，文本长度。与传统机器学习方法相比，深度学习的一个主要优势是可以处理不同长度的数据。</p><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><h2 id="目标函数"><a href="#目标函数" class="headerlink" title="目标函数"></a>目标函数</h2><p>在机器学习中，我们需要定义模型的优劣程度的度量，这个度量在大多数情况是“可优化”的，我们称之为<strong>目标函数</strong>（objective function）。 我们通常定义一个目标函数，并希望优化它到最低点。 因为越低越好，所以这些函数有时被称为<strong>损失函数</strong>（loss function，或cost function）。</p><p>当任务在试图预测数值时，最常见的损失函数是<strong>平方误差</strong>（squared error），即预测值与实际值之差的平方。 当试图解决分类问题时，最常见的目标函数是最小化错误率，即预测与实际情况不符的样本比例。 有些目标函数（如平方误差）很容易被优化，有些目标（如错误率）由于不可微性或其他复杂性难以直接优化。 在这些情况下，通常会优化替代目标。</p><p> 在一个数据集上，我们通过最小化总损失来学习模型参数的最佳值。 该数据集由一些为训练而收集的样本组成，称为<strong>训练数据集</strong>（training dataset，或称为训练集（training set））。 然而，在训练数据上表现良好的模型，并不一定在“新数据集”上有同样的效能，这里的“新数据集”通常称为测试数据集（test dataset，或称为<strong>测试集</strong>（test set））。</p><p>综上所述，我们通常将可用数据集分成两部分：<strong>训练数据集用于拟合模型参数，测试数据集用于评估拟合的模型。</strong> 然后我们观察模型在这两部分数据集的效能。 你可以把“一个模型在训练数据集上的效能”想象成“一个学生在模拟考试中的分数”。 这个分数用来为一些真正的期末考试做参考，即使成绩令人鼓舞，也不能保证期末考试成功。 换言之，测试性能可能会显著偏离训练性能。 当一个模型在训练集上表现良好，但不能推广到测试集时，我们说这个模型是“<strong>过拟合</strong>”（overfitting）的。</p><h2 id="优化算法"><a href="#优化算法" class="headerlink" title="优化算法"></a>优化算法</h2><p>一旦我们获得了一些数据源及其表示、一个模型和一个合适的损失函数，我们接下来就需要一种算法，它能够搜索出最佳参数，以最小化损失函数。 深度学习中，大多流行的优化算法通常基于一种基本方法–<strong>梯度下降</strong>（gradient descent）。 简而言之，在每个步骤中，梯度下降法都会检查每个参数，看看如果你仅对该参数进行少量变动，训练集损失会朝哪个方向移动。 然后，它在可以减少损失的方向上优化参数。</p><h1 id="各种机器学习问题"><a href="#各种机器学习问题" class="headerlink" title="各种机器学习问题"></a>各种机器学习问题</h1><h2 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h2><p>监督学习（supervised learning）擅长在“<strong>给定输入特征</strong>”的情况下预测标签。</p><p>监督学习举例：根据计算机断层扫描（CT）肿瘤图像，预测是否为癌症；根据本月的财务报告数据，预测下个月股票的价格。</p><p>在工业中，大部分机器学习的成功应用都是监督学习。 这是因为在一定程度上，许多重要的任务可以清晰地描述为：在给定一组特定的可用数据的情况下，估计未知事物的概率。</p><p><img src="supervised-learning.png" alt="监督学习"></p><h3 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h3><p>回归（regression）是最简单的监督学习任务之一。</p><p>当标签取任意数值时，我们称之为回归问题。 我们的目标是生成一个模型，它的预测非常接近实际标签值。</p><p>回归问题举例：预测房价；预测用户对一部电影的评分。</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>二分类，多分类。</p><p>分类可能变得比二元分类、多元分类复杂得多。 例如，有一些分类任务的变体可以用于寻找层次结构，层次结构假定在许多类之间存在某种关系。因此，并不是所有的错误都是均等的。 我们宁愿错误地分入一个相关的类别，也不愿错误地分入一个遥远的类别，这通常被称为<strong>层次分类</strong>(hierarchical classification)。</p><h3 id="标记问题"><a href="#标记问题" class="headerlink" title="标记问题"></a>标记问题</h3><p>学习预测不相互排斥的类别的问题称为<strong>多标签分类</strong>（multi-label classification）。</p><p> 举个例子，人们在技术博客上贴的标签，比如“机器学习”、“技术”、“小工具”、“编程语言”、“Linux”、“云计算”。 一篇典型的文章可能会用5-10个标签，因为这些概念是相互关联的。</p><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>在信息检索领域，我们希望对一组项目进行排序。 以网络搜索为例，我们的目标不是简单的“查询（query）-网页（page）”分类，而是在海量搜索结果中找到用户最需要的那部分。</p><h3 id="推荐系统"><a href="#推荐系统" class="headerlink" title="推荐系统"></a>推荐系统</h3><h3 id="序列学习"><a href="#序列学习" class="headerlink" title="序列学习"></a>序列学习</h3><p>有些时候，输入是连续的。我们的模型可能就需要拥有“记忆”功能。</p><p>比如文字序列，图像序列（视频）</p><p>以下是序列学习的特殊情况：</p><ul><li><strong>标记和解析</strong></li><li><strong>语音识别</strong></li><li><strong>文本到语音</strong></li><li><strong>机器翻译</strong></li></ul><h2 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h2><p> 比如，你的老板可能会给你一大堆数据，然后让你用它做一些数据科学研究，却没有对结果有要求。 我们称这类数据中不含有“目标”的机器学习问题为<strong>无监督学习</strong>（unsupervised learning）</p><p>以下列举了集中无监督学习：</p><ul><li><strong>聚类</strong>（clustering）问题：没有标签的情况下，我们是否能给数据分类</li><li><strong>主成分分析</strong>（principal component analysis）问题：我们能否找到少量的参数来准确地捕捉数据的线性相关属性？比如，一个球的运动轨迹可以用球的速度、直径和质量来描述。</li><li><strong>因果关系</strong>（causality）和概率图模型（probabilistic graphical models）问题：我们能否描述观察到的许多数据的根本原因？</li><li><strong>生成对抗性网络</strong>（generative adversarial networks）：为我们提供一种合成数据的方法，甚至像图像和音频这样复杂的结构化数据。</li></ul><h3 id="与环境互动"><a href="#与环境互动" class="headerlink" title="与环境互动"></a>与环境互动</h3><p>到目前为止，不管是监督学习还是无监督学习，我们都会预先获取大量数据，然后启动模型，不再与环境交互。 这里所有学习都是在算法与环境断开后进行的，被称为<strong>离线学习</strong>（offline learning）。</p><p>这种简单的离线学习有它的魅力。 好的一面是，我们可以孤立地进行模式识别，而不必分心于其他问题。 但缺点是，解决的问题相当有限。 与预测不同，“与真实环境互动”实际上会影响环境。 这里的人工智能是“智能代理”，而不仅是“预测模型”。 因此，我们必须考虑到它的行为可能会影响未来的观察结果。</p><p>考虑“与真实环境互动”将打开一整套新的建模问题。以下只是几个例子：</p><ul><li>环境还记得我们以前做过什么吗？</li><li>环境是否有助于我们建模？例如，用户将文本读入语音识别器。</li><li>环境是否想要打败模型？例如，一个对抗性的设置，如垃圾邮件过滤或玩游戏？</li><li>环境是否重要？</li><li>环境是否变化？例如，未来的数据是否总是与过去相似，还是随着时间的推移会发生变化？是自然变化还是响应我们的自动化工具而发生变化？</li></ul><p>当训练和测试数据不同时，最后一个问题提出了<strong>分布偏移</strong>（distribution shift）的问题。 接下来，我们将简要描述强化学习问题，这是一类明确考虑与环境交互的问题。</p><h3 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h3><p><em>不是太懂</em></p><p>在强化学习问题中，agent在一系列的时间步骤上与环境交互。 在每个特定时间点，agent从环境接收一些观察（observation），并且必须选择一个动作（action），然后通过某种机制（有时称为执行器）将其传输回环境，最后agent从环境中获得奖励（reward）。 此后新一轮循环开始，agent接收后续观察，并选择后续操作，依此类推。</p><p><img src="rl-environment.png" alt="强化学习"></p><p>强化学习框架的通用性十分强大。 例如，我们可以将任何监督学习问题转化为强化学习问题。</p><p>当然，强化学习还可以解决许多监督学习无法解决的问题。 例如，在监督学习中，我们总是希望<strong>输入与正确的标签相关联</strong>。 但在强化学习中，我们<strong>并不假设环境告诉agent每个观测的最优动作</strong>。 一般来说，agent只是得到一些奖励。 此外，环境甚至可能不会告诉我们是哪些行为导致了奖励。</p><p>强化学习可能还必须处理部分可观测性问题。 也就是说，当前的观察结果可能无法阐述有关当前状态的所有信息。 比方说，一个清洁机器人发现自己被困在一个许多相同的壁橱的房子里。 推断机器人的精确位置（从而推断其状态），需要在进入壁橱之前考虑它之前的观察结果。</p><p>最后，在任何时间点上，强化学习agent可能知道一个好的策略，但可能有许多更好的策略从未尝试过的。 强化学习agent必须不断地做出选择：是应该利用当前最好的策略，还是探索新的策略空间（放弃一些短期回报来换取知识）。</p><p>一般的强化学习问题是一个非常普遍的问题。 agent的动作会影响后续的观察，而奖励只与所选的动作相对应。 环境可以是完整观察到的，也可以是部分观察到的，解释所有这些复杂性可能会对研究人员要求太高。 此外，并不是每个实际问题都表现出所有这些复杂性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;em&gt;本博客记录阅读《动手学深度学习》的读书笔记。&lt;/em&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;http://zh-v2.d2l.ai/chapter_introduction/index.html&quot;&gt;http://zh-v2.d2l.a</summary>
      
    
    
    
    <category term="深度学习" scheme="https://gmet233.gitee.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="动手学深度学习" scheme="https://gmet233.gitee.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="深度学习" scheme="https://gmet233.gitee.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
