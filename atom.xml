<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Gmet&#39;s Blog</title>
  
  <subtitle>Eureka!</subtitle>
  <link href="https://guoyujian.github.io/atom.xml" rel="self"/>
  
  <link href="https://guoyujian.github.io/"/>
  <updated>2024-03-08T07:40:53.849Z</updated>
  <id>https://guoyujian.github.io/</id>
  
  <author>
    <name>Met Guo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python 并发编程小结1</title>
    <link href="https://guoyujian.github.io/2024/03/08/Python-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%B0%8F%E7%BB%931/"/>
    <id>https://guoyujian.github.io/2024/03/08/Python-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%B0%8F%E7%BB%931/</id>
    <published>2024-03-08T07:23:02.000Z</published>
    <updated>2024-03-08T07:40:53.849Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>KeyWords:</p><ul><li>threading.Thread</li><li>threading.Event</li><li>使用队列queue.Queue，task_down()、join()实现线程通信</li><li>Lock的上下文管理、RLock、信号量Semaphore</li><li>死锁</li><li>创建对其他线程不可见的线程状态：threading.local()</li><li>线程池: concurrent.futures.ThreadPoolExecutor</li><li>并行编程：concurrent.futures.ProcessPoolExecutor、multiprocessing</li><li>GIL全局解释器的影响和解决方案</li><li>Actor模式</li><li>（本文未提到的）生成器、协程与asyncio</li><li>（本文未提到的）消息发布/订阅模型、多线程轮询</li></ul></blockquote><h1 id="启动和停止线程"><a href="#启动和停止线程" class="headerlink" title="启动和停止线程"></a>启动和停止线程</h1><p><code>threading</code>​ 库可以在单独的线程中执行任何的在 Python 中可以调用的对象。你可以创建一个 <code>Thread</code>​ 对象并将你要执行的对象以 target 参数的形式提供给该对象。 下面是一个简单的例子：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Code to execute in an independent thread</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">countdown</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;T-minus&#x27;</span>, n)</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line">        time.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create and launch a thread</span></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line">t = Thread(target=countdown, args=(<span class="number">10</span>,))</span><br><span class="line">t.start()</span><br></pre></td></tr></table></figure><p>当你创建好一个线程对象后，该对象并不会立即执行，除非你调用它的 <code>&lt;span class=&quot;pre&quot;&gt;start()&lt;/span&gt;</code>​ 方法（当你调用 <code>&lt;span class=&quot;pre&quot;&gt;start()&lt;/span&gt;</code>​ 方法时，它会调用你传递进来的函数，并把你传递进来的参数传递给该函数）。Python中的线程会在一个单独的系统级线程中执行（比如说一个 POSIX 线程或者一个 Windows 线程），这些线程将由操作系统来全权管理。线程一旦启动，将独立执行直到目标函数返回。你可以查询一个线程对象的状态，看它是否还在执行：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if t.is_alive():</span><br><span class="line">    print(&#x27;Still running&#x27;)</span><br><span class="line">else:</span><br><span class="line">    print(&#x27;Completed&#x27;)</span><br></pre></td></tr></table></figure><p>你也可以将一个线程加入到当前线程，并等待它终止：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">t.join()</span><br></pre></td></tr></table></figure><p>Python解释器直到所有线程都终止前仍保持运行。对于需要长时间运行的线程或者需要一直运行的后台任务，你应当考虑使用后台线程。 例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">t = Thread(target=countdown, args=(10,), daemon=True)</span><br><span class="line">t.start()</span><br></pre></td></tr></table></figure><p>后台线程无法等待，不过，这些线程会在主线程终止时自动销毁。 除了如上所示的两个操作，并没有太多可以对线程做的事情。你无法结束一个线程，无法给它发送信号，无法调整它的调度，也无法执行其他高级操作。如果需要这些特性，你需要自己添加。比如说，如果你需要终止线程，那么这个线程必须通过编程在某个特定点轮询来退出。你可以像下边这样把线程放入一个类中：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CountdownTask</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._running = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">terminate</span>(<span class="params">self</span>):</span><br><span class="line">        self._running = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self, n</span>):</span><br><span class="line">        <span class="keyword">while</span> self._running <span class="keyword">and</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;T-minus&#x27;</span>, n)</span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line">            time.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">c = CountdownTask()</span><br><span class="line">t = Thread(target=c.run, args=(<span class="number">10</span>,))</span><br><span class="line">t.start()</span><br><span class="line">c.terminate() <span class="comment"># Signal termination</span></span><br><span class="line">t.join()      <span class="comment"># Wait for actual termination (if needed)</span></span><br></pre></td></tr></table></figure><p>如果线程执行一些像I/O这样的阻塞操作，那么通过轮询来终止线程将使得线程之间的协调变得非常棘手。比如，如果一个线程一直阻塞在一个I/O操作上，它就永远无法返回，也就无法检查自己是否已经被结束了。要正确处理这些问题，你需要利用超时循环来小心操作线程。 例子如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IOTask</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">terminate</span>(<span class="params">self</span>):</span><br><span class="line">        self._running = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self, sock</span>):</span><br><span class="line">        <span class="comment"># sock is a socket</span></span><br><span class="line">        sock.settimeout(<span class="number">5</span>)        <span class="comment"># Set timeout period</span></span><br><span class="line">        <span class="keyword">while</span> self._running:</span><br><span class="line">            <span class="comment"># Perform a blocking I/O operation w/ timeout</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                data = sock.recv(<span class="number">8192</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">except</span> socket.timeout:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># Continued processing</span></span><br><span class="line">            ...</span><br><span class="line">        <span class="comment"># Terminated</span></span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure><h2 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h2><p>由于全局解释锁（GIL）的原因，Python 的线程被限制到同一时刻只允许一个线程执行这样一个执行模型。所以，Python 的线程更适用于处理I/O和其他需要并发执行的阻塞操作（比如等待I/O、等待从数据库获取数据等等），而不是需要多处理器并行的计算密集型任务。</p><p>有时你会看到下边这种通过继承 <code>Thread</code>​ 类来实现的线程：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from threading import Thread</span><br><span class="line"></span><br><span class="line">class CountdownThread(Thread):</span><br><span class="line">    def __init__(self, n):</span><br><span class="line">        super().__init__()</span><br><span class="line">        self.n = n</span><br><span class="line">    def run(self):</span><br><span class="line">        while self.n &gt; 0:</span><br><span class="line"></span><br><span class="line">            print(&#x27;T-minus&#x27;, self.n)</span><br><span class="line">            self.n -= 1</span><br><span class="line">            time.sleep(5)</span><br><span class="line"></span><br><span class="line">c = CountdownThread(5)</span><br><span class="line">c.start()</span><br></pre></td></tr></table></figure><p>尽管这样也可以工作，但这使得你的代码依赖于 <code>threading</code>​ 库，所以你的这些代码只能在线程上下文中使用。上文所写的那些代码、函数都是与 <code>threading</code>​ 库无关的，这样就使得这些代码可以被用在其他的上下文中，可能与线程有关，也可能与线程无关。比如，你可以通过 <code>multiprocessing</code>​ 模块在一个单独的进程中执行你的代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import multiprocessing</span><br><span class="line">c = CountdownTask(5)</span><br><span class="line">p = multiprocessing.Process(target=c.run)</span><br><span class="line">p.start()</span><br></pre></td></tr></table></figure><p>再次重申，这段代码仅适用于 CountdownTask 类是以独立于实际的并发手段（多线程、多进程等等）实现的情况。</p><h1 id="判断线程是否启动"><a href="#判断线程是否启动" class="headerlink" title="判断线程是否启动"></a>判断线程是否启动</h1><p>你已经启动了一个线程，但是你想知道它是不是真的已经开始运行了。</p><p>线程的一个关键特性是每个线程都是独立运行且状态不可预测。如果程序中的其他线程需要通过判断某个线程的状态来确定自己下一步的操作，这时线程同步问题就会变得非常棘手。为了解决这些问题，我们需要使用 <code>threading</code>​ 库中的 <code>Event</code>​ 对象。 <code>Event</code>​ 对象包含一个可由线程设置的信号标志，它允许线程等待某些事件的发生。在初始情况下，event 对象中的信号标志被设置为假。如果有线程等待一个 event 对象，而这个 event 对象的标志为假，那么这个线程将会被一直阻塞直至该标志为真。一个线程如果将一个 event 对象的信号标志设置为真，它将唤醒所有等待这个 event 对象的线程。如果一个线程等待一个已经被设置为真的 event 对象，那么它将忽略这个事件，继续执行。 下边的代码展示了如何使用 <code>Event</code>​ 来协调线程的启动：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Event</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># Code to execute in an independent thread</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">countdown</span>(<span class="params">n, started_evt</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;countdown starting&#x27;</span>)</span><br><span class="line">    started_evt.<span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;T-minus&#x27;</span>, n)</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line">        time.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create the event object that will be used to signal startup</span></span><br><span class="line">started_evt = Event()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Launch the thread and pass the startup event</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Launching countdown&#x27;</span>)</span><br><span class="line">t = Thread(target=countdown, args=(<span class="number">10</span>,started_evt))</span><br><span class="line">t.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Wait for the thread to start</span></span><br><span class="line">started_evt.wait()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;countdown is running&#x27;</span>)</span><br></pre></td></tr></table></figure><p>当你执行这段代码，“countdown is running” 总是显示在 “countdown starting” 之后显示。这是由于使用 event 来协调线程，使得主线程要等到 <code>countdown()</code>​ 函数输出启动信息后，才能继续执行。</p><h2 id="讨论-1"><a href="#讨论-1" class="headerlink" title="讨论"></a>讨论</h2><p>event 对象最好单次使用，就是说，你创建一个 event 对象，让某个线程等待这个对象，一旦这个对象被设置为真，你就应该丢弃它。尽管可以通过 <code>clear()</code>​ 方法来重置 event 对象，但是很难确保安全地清理 event 对象并对它重新赋值。很可能会发生错过事件、死锁或者其他问题（特别是，你无法保证重置 event 对象的代码会在线程再次等待这个 event 对象之前执行）。如果一个线程需要不停地重复使用 event 对象，你最好使用 <code>Condition</code>​ 对象来代替。下面的代码使用 <code>Condition</code>​ 对象实现了一个周期定时器，每当定时器超时的时候，其他线程都可以监测到：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PeriodicTimer</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, interval</span>):</span><br><span class="line">        self._interval = interval</span><br><span class="line">        self._flag = <span class="number">0</span></span><br><span class="line">        self._cv = threading.Condition()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start</span>(<span class="params">self</span>):</span><br><span class="line">        t = threading.Thread(target=self.run)</span><br><span class="line">        t.daemon = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        Run the timer and notify waiting threads after each interval</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            time.sleep(self._interval)</span><br><span class="line">            <span class="keyword">with</span> self._cv:</span><br><span class="line">                 self._flag ^= <span class="number">1</span></span><br><span class="line">                 self._cv.notify_all()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wait_for_tick</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        Wait for the next tick of the timer</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">with</span> self._cv:</span><br><span class="line">            last_flag = self._flag</span><br><span class="line">            <span class="keyword">while</span> last_flag == self._flag:</span><br><span class="line">                self._cv.wait()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example use of the timer</span></span><br><span class="line">ptimer = PeriodicTimer(<span class="number">5</span>)</span><br><span class="line">ptimer.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Two threads that synchronize on the timer</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">countdown</span>(<span class="params">nticks</span>):</span><br><span class="line">    <span class="keyword">while</span> nticks &gt; <span class="number">0</span>:</span><br><span class="line">        ptimer.wait_for_tick()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;T-minus&#x27;</span>, nticks)</span><br><span class="line">        nticks -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">countup</span>(<span class="params">last</span>):</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; last:</span><br><span class="line">        ptimer.wait_for_tick()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Counting&#x27;</span>, n)</span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">threading.Thread(target=countdown, args=(<span class="number">10</span>,)).start()</span><br><span class="line">threading.Thread(target=countup, args=(<span class="number">5</span>,)).start()</span><br></pre></td></tr></table></figure><p>event对象的一个重要特点是当它被设置为真时会唤醒所有等待它的线程。如果你只想唤醒单个线程，最好是使用信号量或者 <code>Condition</code>​ 对象来替代。考虑一下这段使用信号量实现的代码：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Worker thread</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">worker</span>(<span class="params">n, sema</span>):</span><br><span class="line">    <span class="comment"># Wait to be signaled</span></span><br><span class="line">    sema.acquire()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Do some work</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Working&#x27;</span>, n)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create some threads</span></span><br><span class="line">sema = threading.Semaphore(<span class="number">0</span>)</span><br><span class="line">nworkers = <span class="number">10</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(nworkers):</span><br><span class="line">    t = threading.Thread(target=worker, args=(n, sema,))</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure><p>运行上边的代码将会启动一个线程池，但是并没有什么事情发生。这是因为所有的线程都在等待获取信号量。每次信号量被释放，只有一个线程会被唤醒并执行，示例如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; sema.release()</span><br><span class="line">Working 0</span><br><span class="line">&gt;&gt;&gt; sema.release()</span><br><span class="line">Working 1</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>编写涉及到大量的线程间同步问题的代码会让你痛不欲生。比较合适的方式是使用队列来进行线程间通信或者每个把线程当作一个Actor，利用Actor模型来控制并发。下一节将会介绍到队列，而Actor模型将在12.10节介绍。</p><h1 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h1><p>从一个线程向另一个线程发送数据最安全的方式可能就是使用 <code>queue</code>​ 库中的队列了。创建一个被多个线程共享的 <code>Queue</code>​ 对象，这些线程通过使用 <code>put()</code>​ 和 <code>get()</code>​ 操作来向队列中添加或者删除元素。 例如：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="comment"># A thread that produces data</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">producer</span>(<span class="params">out_q</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># Produce some data</span></span><br><span class="line">        ...</span><br><span class="line">        out_q.put(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># A thread that consumes data</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">consumer</span>(<span class="params">in_q</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="comment"># Get some data</span></span><br><span class="line">        data = in_q.get()</span><br><span class="line">        <span class="comment"># Process the data</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create the shared queue and launch both threads</span></span><br><span class="line">q = Queue()</span><br><span class="line">t1 = Thread(target=consumer, args=(q,))</span><br><span class="line">t2 = Thread(target=producer, args=(q,))</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br></pre></td></tr></table></figure><p><code>Queue</code>​ 对象已经包含了必要的锁，所以你可以通过它在多个线程间多安全地共享数据。 当使用队列时，协调生产者和消费者的关闭问题可能会有一些麻烦。一个通用的解决方法是在队列中放置一个特殊的值，当消费者读到这个值的时候，终止执行。</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="comment"># Object that signals shutdown</span></span><br><span class="line">_sentinel = <span class="built_in">object</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># A thread that produces data</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">producer</span>(<span class="params">out_q</span>):</span><br><span class="line">    <span class="keyword">while</span> running:</span><br><span class="line">        <span class="comment"># Produce some data</span></span><br><span class="line">        ...</span><br><span class="line">        out_q.put(data)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Put the sentinel on the queue to indicate completion</span></span><br><span class="line">    out_q.put(_sentinel)</span><br><span class="line"></span><br><span class="line"><span class="comment"># A thread that consumes data</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">consumer</span>(<span class="params">in_q</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># Get some data</span></span><br><span class="line">        data = in_q.get()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Check for termination</span></span><br><span class="line">        <span class="keyword">if</span> data <span class="keyword">is</span> _sentinel:</span><br><span class="line">            in_q.put(_sentinel)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Process the data</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>本例中有一个特殊的地方：消费者在读到这个特殊值之后立即又把它放回到队列中，将之传递下去。这样，所有监听这个队列的消费者线程就可以全部关闭了。 尽管队列是最常见的线程间通信机制，但是仍然可以自己通过创建自己的数据结构并添加所需的锁和同步机制来实现线程间通信。最常见的方法是使用 <code>Condition</code>​ 变量来包装你的数据结构。下边这个例子演示了如何创建一个线程安全的优先级队列，如同1.5节中介绍的那样。</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PriorityQueue</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._queue = []</span><br><span class="line">        self._count = <span class="number">0</span></span><br><span class="line">        self._cv = threading.Condition()</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">put</span>(<span class="params">self, item, priority</span>):</span><br><span class="line">        <span class="keyword">with</span> self._cv:</span><br><span class="line">            heapq.heappush(self._queue, (-priority, self._count, item))</span><br><span class="line">            self._count += <span class="number">1</span></span><br><span class="line">            self._cv.notify()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">with</span> self._cv:</span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(self._queue) == <span class="number">0</span>:</span><br><span class="line">                self._cv.wait()</span><br><span class="line">            <span class="keyword">return</span> heapq.heappop(self._queue)[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>使用队列来进行线程间通信是一个单向、不确定的过程。通常情况下，你没有办法知道接收数据的线程是什么时候接收到的数据并开始工作的。不过队列对象提供一些基本完成的特性，比如下边这个例子中的 <code>**task_done()**</code> ​ 和 <code>**join()**</code> ​ ：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from queue import Queue</span><br><span class="line">from threading import Thread</span><br><span class="line"></span><br><span class="line"># A thread that produces data</span><br><span class="line">def producer(out_q):</span><br><span class="line">    while running:</span><br><span class="line">        # Produce some data</span><br><span class="line">        ...</span><br><span class="line">        out_q.put(data)</span><br><span class="line"></span><br><span class="line"># A thread that consumes data</span><br><span class="line">def consumer(in_q):</span><br><span class="line">    while True:</span><br><span class="line">        # Get some data</span><br><span class="line">        data = in_q.get()</span><br><span class="line"></span><br><span class="line">        # Process the data</span><br><span class="line">        ...</span><br><span class="line">        # Indicate completion</span><br><span class="line">        in_q.task_done()</span><br><span class="line"></span><br><span class="line"># Create the shared queue and launch both threads</span><br><span class="line">q = Queue()</span><br><span class="line">t1 = Thread(target=consumer, args=(q,))</span><br><span class="line">t2 = Thread(target=producer, args=(q,))</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line"></span><br><span class="line"># Wait for all produced items to be consumed</span><br><span class="line">q.join()</span><br></pre></td></tr></table></figure><p>如果一个线程需要在一个“消费者”线程处理完特定的数据项时立即得到通知，你可以把要发送的数据和一个 <code>Event</code>​ 放到一起使用，这样“生产者”就可以通过这个Event对象来监测处理的过程了。示例如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from queue import Queue</span><br><span class="line">from threading import Thread, Event</span><br><span class="line"></span><br><span class="line"># A thread that produces data</span><br><span class="line">def producer(out_q):</span><br><span class="line">    while running:</span><br><span class="line">        # Produce some data</span><br><span class="line">        ...</span><br><span class="line">        # Make an (data, event) pair and hand it to the consumer</span><br><span class="line">        evt = Event()</span><br><span class="line">        out_q.put((data, evt))</span><br><span class="line">        ...</span><br><span class="line">        # Wait for the consumer to process the item</span><br><span class="line">        evt.wait()</span><br><span class="line"></span><br><span class="line"># A thread that consumes data</span><br><span class="line">def consumer(in_q):</span><br><span class="line">    while True:</span><br><span class="line">        # Get some data</span><br><span class="line">        data, evt = in_q.get()</span><br><span class="line">        # Process the data</span><br><span class="line">        ...</span><br><span class="line">        # Indicate completion</span><br><span class="line">        evt.set()</span><br></pre></td></tr></table></figure><h2 id="讨论-2"><a href="#讨论-2" class="headerlink" title="讨论"></a>讨论</h2><p>基于简单队列编写多线程程序在多数情况下是一个比较明智的选择。从线程安全队列的底层实现来看，你无需在你的代码中使用锁和其他底层的同步机制，这些只会把你的程序弄得乱七八糟。此外，使用队列这种基于消息的通信机制可以被扩展到更大的应用范畴，比如，你可以把你的程序放入多个进程甚至是分布式系统而无需改变底层的队列结构。 使用线程队列有一个要注意的问题是，向队列中添加数据项时并不会复制此数据项，线程间通信实际上是在线程间传递对象引用。如果你担心对象的共享状态，那你最好只传递不可修改的数据结构（如：整型、字符串或者元组）或者一个对象的深拷贝。例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from queue import Queue</span><br><span class="line">from threading import Thread</span><br><span class="line">import copy</span><br><span class="line"></span><br><span class="line"># A thread that produces data</span><br><span class="line">def producer(out_q):</span><br><span class="line">    while True:</span><br><span class="line">        # Produce some data</span><br><span class="line">        ...</span><br><span class="line">        out_q.put(copy.deepcopy(data))</span><br><span class="line"></span><br><span class="line"># A thread that consumes data</span><br><span class="line">def consumer(in_q):</span><br><span class="line">    while True:</span><br><span class="line">        # Get some data</span><br><span class="line">        data = in_q.get()</span><br><span class="line">        # Process the data</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p><code>Queue</code>​ 对象提供一些在当前上下文很有用的附加特性。比如在创建 Queue 对象时提供可选的 <code>size</code>​ 参数来限制可以添加到队列中的元素数量。对于“生产者”与“消费者”速度有差异的情况，为队列中的元素数量添加上限是有意义的。比如，一个“生产者”产生项目的速度比“消费者” “消费”的速度快，那么使用固定大小的队列就可以在队列已满的时候阻塞队列，以免未预期的连锁效应扩散整个程序造成死锁或者程序运行失常。在通信的线程之间进行“流量控制”是一个看起来容易实现起来困难的问题。如果你发现自己曾经试图通过摆弄队列大小来解决一个问题，这也许就标志着你的程序可能存在脆弱设计或者固有的可伸缩问题。 <code>get()</code>​ 和 <code>put()</code>​ 方法都支持非阻塞方式和设定超时，例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import queue</span><br><span class="line">q = queue.Queue()</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    data = q.get(block=False)</span><br><span class="line">except queue.Empty:</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    q.put(item, block=False)</span><br><span class="line">except queue.Full:</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    data = q.get(timeout=5.0)</span><br><span class="line">except queue.Empty:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>这些操作都可以用来避免当执行某些特定队列操作时发生无限阻塞的情况，比如，一个非阻塞的 <code>put()</code>​ 方法和一个固定大小的队列一起使用，这样当队列已满时就可以执行不同的代码。比如输出一条日志信息并丢弃。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def producer(q):</span><br><span class="line">    ...</span><br><span class="line">    try:</span><br><span class="line">        q.put(item, block=False)</span><br><span class="line">    except queue.Full:</span><br><span class="line">        log.warning(&#x27;queued item %r discarded!&#x27;, item)</span><br></pre></td></tr></table></figure><p>如果你试图让消费者线程在执行像 <code>q.get()</code>​ 这样的操作时，超时自动终止以便检查终止标志，你应该使用 <code>q.get()</code>​ 的可选参数 <code>timeout</code>​ ，如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_running = True</span><br><span class="line"></span><br><span class="line">def consumer(q):</span><br><span class="line">    while _running:</span><br><span class="line">        try:</span><br><span class="line">            item = q.get(timeout=5.0)</span><br><span class="line">            # Process item</span><br><span class="line">            ...</span><br><span class="line">        except queue.Empty:</span><br><span class="line">            pass</span><br></pre></td></tr></table></figure><p>最后，有 <code>q.qsize()</code>​ ， <code>q.full()</code>​ ， <code>q.empty()</code>​ 等实用方法可以获取一个队列的当前大小和状态。但要注意，这些方法都不是线程安全的。可能你对一个队列使用 <code>empty()</code>​ 判断出这个队列为空，但同时另外一个线程可能已经向这个队列中插入一个数据项。所以，你最好不要在你的代码中使用这些方法。</p><h1 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h1><p>要在多线程程序中安全使用可变对象，你需要使用 threading 库中的 <code>&lt;span class=&quot;pre&quot;&gt;Lock&lt;/span&gt;</code>​ 对象，就像下边这个例子这样：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line"></span><br><span class="line">class SharedCounter:</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    A counter object that can be shared by multiple threads.</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    def __init__(self, initial_value = 0):</span><br><span class="line">        self._value = initial_value</span><br><span class="line">        self._value_lock = threading.Lock()</span><br><span class="line"></span><br><span class="line">    def incr(self,delta=1):</span><br><span class="line">        &#x27;&#x27;&#x27;</span><br><span class="line">        Increment the counter with locking</span><br><span class="line">        &#x27;&#x27;&#x27;</span><br><span class="line">        with self._value_lock:</span><br><span class="line">             self._value += delta</span><br><span class="line"></span><br><span class="line">    def decr(self,delta=1):</span><br><span class="line">        &#x27;&#x27;&#x27;</span><br><span class="line">        Decrement the counter with locking</span><br><span class="line">        &#x27;&#x27;&#x27;</span><br><span class="line">        with self._value_lock:</span><br><span class="line">             self._value -= delta</span><br></pre></td></tr></table></figure><p><code>&lt;span class=&quot;pre&quot;&gt;Lock&lt;/span&gt;</code>​ 对象和 <code>&lt;span class=&quot;pre&quot;&gt;with&lt;/span&gt;</code>​ 语句块一起使用可以保证互斥执行，就是每次只有一个线程可以执行 with 语句包含的代码块。with 语句会在这个代码块执行前自动获取锁，在执行结束后自动释放锁。</p><h2 id="讨论-3"><a href="#讨论-3" class="headerlink" title="讨论"></a>讨论</h2><p>线程调度本质上是不确定的，因此，在多线程程序中错误地使用锁机制可能会导致随机数据损坏或者其他的异常行为，我们称之为竞争条件。为了避免竞争条件，最好只在临界区（对临界资源进行操作的那部分代码）使用锁。 在一些“老的” Python 代码中，显式获取和释放锁是很常见的。下边是一个上一个例子的变种：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line"></span><br><span class="line">class SharedCounter:</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    A counter object that can be shared by multiple threads.</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    def __init__(self, initial_value = 0):</span><br><span class="line">        self._value = initial_value</span><br><span class="line">        self._value_lock = threading.Lock()</span><br><span class="line"></span><br><span class="line">    def incr(self,delta=1):</span><br><span class="line">        &#x27;&#x27;&#x27;</span><br><span class="line">        Increment the counter with locking</span><br><span class="line">        &#x27;&#x27;&#x27;</span><br><span class="line">        self._value_lock.acquire()</span><br><span class="line">        self._value += delta</span><br><span class="line">        self._value_lock.release()</span><br><span class="line"></span><br><span class="line">    def decr(self,delta=1):</span><br><span class="line">        &#x27;&#x27;&#x27;</span><br><span class="line">        Decrement the counter with locking</span><br><span class="line">        &#x27;&#x27;&#x27;</span><br><span class="line">        self._value_lock.acquire()</span><br><span class="line">        self._value -= delta</span><br><span class="line">        self._value_lock.release()</span><br></pre></td></tr></table></figure><p><strong>相比于这种显式调用的方法，with 语句更加优雅，也更不容易出错</strong>，特别是程序员可能会忘记调用 release() 方法或者程序在获得锁之后产生异常这两种情况（使用 with 语句可以保证在这两种情况下仍能正确释放锁）。 为了避免出现死锁的情况，使用锁机制的程序应该设定为每个线程一次只允许获取一个锁。如果不能这样做的话，你就需要更高级的死锁避免机制，我们将在12.5节介绍。 在 <code>threading</code>​ 库中还提供了其他的同步原语，比如 <code>RLock</code>​ 和 <code>Semaphore</code>​ 对象。但是根据以往经验，这些原语是用于一些特殊的情况，如果你只是需要简单地对可变对象进行锁定，那就不应该使用它们。一个 <code>RLock</code>​ （可重入锁）可以被同一个线程多次获取，主要用来实现基于监测对象模式的锁定和同步。在使用这种锁的情况下，当锁被持有时，只有一个线程可以使用完整的函数或者类中的方法。比如，你可以实现一个这样的 SharedCounter 类：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line"></span><br><span class="line">class SharedCounter:</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    A counter object that can be shared by multiple threads.</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    _lock = threading.RLock()</span><br><span class="line">    def __init__(self, initial_value = 0):</span><br><span class="line">        self._value = initial_value</span><br><span class="line"></span><br><span class="line">    def incr(self,delta=1):</span><br><span class="line">        &#x27;&#x27;&#x27;</span><br><span class="line">        Increment the counter with locking</span><br><span class="line">        &#x27;&#x27;&#x27;</span><br><span class="line">        with SharedCounter._lock:</span><br><span class="line">            self._value += delta</span><br><span class="line"></span><br><span class="line">    def decr(self,delta=1):</span><br><span class="line">        &#x27;&#x27;&#x27;</span><br><span class="line">        Decrement the counter with locking</span><br><span class="line">        &#x27;&#x27;&#x27;</span><br><span class="line">        with SharedCounter._lock:</span><br><span class="line">             self.incr(-delta)</span><br></pre></td></tr></table></figure><p>在上边这个例子中，没有对每一个实例中的可变对象加锁，取而代之的是一个被所有实例共享的类级锁。这个锁用来同步类方法，具体来说就是，这个锁可以保证一次只有一个线程可以调用这个类方法。不过，与一个标准的锁不同的是，已经持有这个锁的方法在调用同样使用这个锁的方法时，无需再次获取锁。比如 decr 方法。 这种实现方式的一个特点是，无论这个类有多少个实例都只用一个锁。因此在需要大量使用计数器的情况下内存效率更高。不过这样做也有缺点，就是在程序中使用大量线程并频繁更新计数器时会有争用锁的问题。 信号量对象是一个建立在共享计数器基础上的同步原语。如果计数器不为0，with 语句将计数器减1，线程被允许执行。with 语句执行结束后，计数器加１。如果计数器为0，线程将被阻塞，直到其他线程结束将计数器加1。尽管你可以在程序中像标准锁一样使用信号量来做线程同步，但是这种方式并不被推荐，<strong>因为使用信号量为程序增加的复杂性会影响程序性能。</strong> 相对于简单地作为锁使用，信号量更适用于那些需要在线程之间引入信号或者限制的程序。比如，你需要限制一段代码的并发访问量，你就可以像下面这样使用信号量完成：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from threading import Semaphore</span><br><span class="line">import urllib.request</span><br><span class="line"></span><br><span class="line"># At most, five threads allowed to run at once</span><br><span class="line">_fetch_url_sema = Semaphore(5)</span><br><span class="line"></span><br><span class="line">def fetch_url(url):</span><br><span class="line">    with _fetch_url_sema:</span><br><span class="line">        return urllib.request.urlopen(url)</span><br></pre></td></tr></table></figure><p>如果你对线程同步原语的底层理论和实现感兴趣，可以参考操作系统相关书籍，绝大多数都有提及。</p><h1 id="防止死锁的加锁机制"><a href="#防止死锁的加锁机制" class="headerlink" title="防止死锁的加锁机制"></a>防止死锁的加锁机制</h1><p>（这一章节我没看）</p><p>在多线程程序中，死锁问题很大一部分是由于线程同时获取多个锁造成的。举个例子：一个线程获取了第一个锁，然后在获取第二个锁的 时候发生阻塞，那么这个线程就可能阻塞其他线程的执行，从而导致整个程序假死。 解决死锁问题的一种方案是为程序中的每一个锁分配一个唯一的id，然后只允许按照升序规则来使用多个锁，这个规则使用上下文管理器 是非常容易实现的，示例如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line">from contextlib import contextmanager</span><br><span class="line"></span><br><span class="line"># Thread-local state to stored information on locks already acquired</span><br><span class="line">_local = threading.local()</span><br><span class="line"></span><br><span class="line">@contextmanager</span><br><span class="line">def acquire(*locks):</span><br><span class="line">    # Sort locks by object identifier</span><br><span class="line">    locks = sorted(locks, key=lambda x: id(x))</span><br><span class="line"></span><br><span class="line">    # Make sure lock order of previously acquired locks is not violated</span><br><span class="line">    acquired = getattr(_local,&#x27;acquired&#x27;,[])</span><br><span class="line">    if acquired and max(id(lock) for lock in acquired) &gt;= id(locks[0]):</span><br><span class="line">        raise RuntimeError(&#x27;Lock Order Violation&#x27;)</span><br><span class="line"></span><br><span class="line">    # Acquire all of the locks</span><br><span class="line">    acquired.extend(locks)</span><br><span class="line">    _local.acquired = acquired</span><br><span class="line"></span><br><span class="line">    try:</span><br><span class="line">        for lock in locks:</span><br><span class="line">            lock.acquire()</span><br><span class="line">        yield</span><br><span class="line">    finally:</span><br><span class="line">        # Release locks in reverse order of acquisition</span><br><span class="line">        for lock in reversed(locks):</span><br><span class="line">            lock.release()</span><br><span class="line">        del acquired[-len(locks):]</span><br></pre></td></tr></table></figure><p>如何使用这个上下文管理器呢？你可以按照正常途径创建一个锁对象，但不论是单个锁还是多个锁中都使用 <code>&lt;span class=&quot;pre&quot;&gt;acquire()&lt;/span&gt;</code>​ 函数来申请锁， 示例如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line">x_lock = threading.Lock()</span><br><span class="line">y_lock = threading.Lock()</span><br><span class="line"></span><br><span class="line">def thread_1():</span><br><span class="line">    while True:</span><br><span class="line">        with acquire(x_lock, y_lock):</span><br><span class="line">            print(&#x27;Thread-1&#x27;)</span><br><span class="line"></span><br><span class="line">def thread_2():</span><br><span class="line">    while True:</span><br><span class="line">        with acquire(y_lock, x_lock):</span><br><span class="line">            print(&#x27;Thread-2&#x27;)</span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target=thread_1)</span><br><span class="line">t1.daemon = True</span><br><span class="line">t1.start()</span><br><span class="line"></span><br><span class="line">t2 = threading.Thread(target=thread_2)</span><br><span class="line">t2.daemon = True</span><br><span class="line">t2.start()</span><br></pre></td></tr></table></figure><p>如果你执行这段代码，你会发现它即使在不同的函数中以不同的顺序获取锁也没有发生死锁。 其关键在于，在第一段代码中，我们对这些锁进行了排序。通过排序，使得不管用户以什么样的顺序来请求锁，这些锁都会按照固定的顺序被获取。 如果有多个 <code>&lt;span class=&quot;pre&quot;&gt;acquire()&lt;/span&gt;</code>​ 操作被嵌套调用，可以通过线程本地存储（TLS）来检测潜在的死锁问题。 假设你的代码是这样写的：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line">x_lock = threading.Lock()</span><br><span class="line">y_lock = threading.Lock()</span><br><span class="line"></span><br><span class="line">def thread_1():</span><br><span class="line"></span><br><span class="line">    while True:</span><br><span class="line">        with acquire(x_lock):</span><br><span class="line">            with acquire(y_lock):</span><br><span class="line">                print(&#x27;Thread-1&#x27;)</span><br><span class="line"></span><br><span class="line">def thread_2():</span><br><span class="line">    while True:</span><br><span class="line">        with acquire(y_lock):</span><br><span class="line">            with acquire(x_lock):</span><br><span class="line">                print(&#x27;Thread-2&#x27;)</span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target=thread_1)</span><br><span class="line">t1.daemon = True</span><br><span class="line">t1.start()</span><br><span class="line"></span><br><span class="line">t2 = threading.Thread(target=thread_2)</span><br><span class="line">t2.daemon = True</span><br><span class="line">t2.start()</span><br></pre></td></tr></table></figure><p>如果你运行这个版本的代码，必定会有一个线程发生崩溃，异常信息可能像这样：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Exception in thread Thread-1:</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/usr/local/lib/python3.3/threading.py&quot;, line 639, in _bootstrap_inner</span><br><span class="line">    self.run()</span><br><span class="line">  File &quot;/usr/local/lib/python3.3/threading.py&quot;, line 596, in run</span><br><span class="line">    self._target(*self._args, **self._kwargs)</span><br><span class="line">  File &quot;deadlock.py&quot;, line 49, in thread_1</span><br><span class="line">    with acquire(y_lock):</span><br><span class="line">  File &quot;/usr/local/lib/python3.3/contextlib.py&quot;, line 48, in __enter__</span><br><span class="line">    return next(self.gen)</span><br><span class="line">  File &quot;deadlock.py&quot;, line 15, in acquire</span><br><span class="line">    raise RuntimeError(&quot;Lock Order Violation&quot;)</span><br><span class="line">RuntimeError: Lock Order Violation</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>发生崩溃的原因在于，每个线程都记录着自己已经获取到的锁。 <code>&lt;span class=&quot;pre&quot;&gt;acquire()&lt;/span&gt;</code>​ 函数会检查之前已经获取的锁列表， 由于锁是按照升序排列获取的，所以函数会认为之前已获取的锁的id必定小于新申请到的锁，这时就会触发异常。</p><h2 id="讨论-4"><a href="#讨论-4" class="headerlink" title="讨论"></a>讨论</h2><p>死锁是每一个多线程程序都会面临的一个问题（就像它是每一本操作系统课本的共同话题一样）。根据经验来讲，尽可能保证每一个 线程只能同时保持一个锁，这样程序就不会被死锁问题所困扰。一旦有线程同时申请多个锁，一切就不可预料了。</p><p>死锁的检测与恢复是一个几乎没有优雅的解决方案的扩展话题。一个比较常用的死锁检测与恢复的方案是引入看门狗计数器。当线程正常 运行的时候会每隔一段时间重置计数器，在没有发生死锁的情况下，一切都正常进行。一旦发生死锁，由于无法重置计数器导致定时器 超时，这时程序会通过重启自身恢复到正常状态。</p><p>避免死锁是另外一种解决死锁问题的方式，在进程获取锁的时候会严格按照对象id升序排列获取，经过数学证明，这样保证程序不会进入 死锁状态。证明就留给读者作为练习了。避免死锁的主要思想是，单纯地按照对象id递增的顺序加锁不会产生循环依赖，而循环依赖是 死锁的一个必要条件，从而避免程序进入死锁状态。</p><p>下面以一个关于线程死锁的经典问题：“哲学家就餐问题”，作为本节最后一个例子。题目是这样的：五位哲学家围坐在一张桌子前，每个人 面前有一碗饭和一只筷子。在这里每个哲学家可以看做是一个独立的线程，而每只筷子可以看做是一个锁。每个哲学家可以处在静坐、 思考、吃饭三种状态中的一个。需要注意的是，每个哲学家吃饭是需要两只筷子的，这样问题就来了：如果每个哲学家都拿起自己左边的筷子， 那么他们五个都只能拿着一只筷子坐在那儿，直到饿死。此时他们就进入了死锁状态。 下面是一个简单的使用死锁避免机制解决“哲学家就餐问题”的实现：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line"></span><br><span class="line"># The philosopher thread</span><br><span class="line">def philosopher(left, right):</span><br><span class="line">    while True:</span><br><span class="line">        with acquire(left,right):</span><br><span class="line">             print(threading.currentThread(), &#x27;eating&#x27;)</span><br><span class="line"></span><br><span class="line"># The chopsticks (represented by locks)</span><br><span class="line">NSTICKS = 5</span><br><span class="line">chopsticks = [threading.Lock() for n in range(NSTICKS)]</span><br><span class="line"></span><br><span class="line"># Create all of the philosophers</span><br><span class="line">for n in range(NSTICKS):</span><br><span class="line">    t = threading.Thread(target=philosopher,</span><br><span class="line">                         args=(chopsticks[n],chopsticks[(n+1) % NSTICKS]))</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure><p>最后，要特别注意到，为了避免死锁，所有的加锁操作必须使用 <code>&lt;span class=&quot;pre&quot;&gt;acquire()&lt;/span&gt;</code>​ 函数。如果代码中的某部分绕过acquire 函数直接申请锁，那么整个死锁避免机制就不起作用了。</p><p>‍</p><h1 id="保存线程的状态信息"><a href="#保存线程的状态信息" class="headerlink" title="保存线程的状态信息"></a>保存线程的状态信息</h1><blockquote><p>和Java ThreadLocal类似，介绍了怎么用</p></blockquote><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>你需要保存正在运行线程的状态，这个状态对于其他的线程是不可见的。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>有时在多线程编程中，你需要只保存当前运行线程的状态。 要这么做，可使用 <code>&lt;span class=&quot;pre&quot;&gt;thread.local()&lt;/span&gt;</code>​ 创建一个本地线程存储对象。 对这个对象的属性的保存和读取操作都只会对执行线程可见，而其他线程并不可见。</p><p>作为使用本地存储的一个有趣的实际例子， 考虑在8.3小节定义过的 <code>&lt;span class=&quot;pre&quot;&gt;LazyConnection&lt;/span&gt;</code>​ 上下文管理器类。 下面我们对它进行一些小的修改使得它可以适用于多线程：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from socket import socket, AF_INET, SOCK_STREAM</span><br><span class="line">import threading</span><br><span class="line"></span><br><span class="line">class LazyConnection:</span><br><span class="line">    def __init__(self, address, family=AF_INET, type=SOCK_STREAM):</span><br><span class="line">        self.address = address</span><br><span class="line">        self.family = AF_INET</span><br><span class="line">        self.type = SOCK_STREAM</span><br><span class="line">        self.local = threading.local()</span><br><span class="line"></span><br><span class="line">    def __enter__(self):</span><br><span class="line">        if hasattr(self.local, &#x27;sock&#x27;):</span><br><span class="line">            raise RuntimeError(&#x27;Already connected&#x27;)</span><br><span class="line">        self.local.sock = socket(self.family, self.type)</span><br><span class="line">        self.local.sock.connect(self.address)</span><br><span class="line">        return self.local.sock</span><br><span class="line"></span><br><span class="line">    def __exit__(self, exc_ty, exc_val, tb):</span><br><span class="line">        self.local.sock.close()</span><br><span class="line">        del self.local.sock</span><br></pre></td></tr></table></figure><p>代码中，自己观察对于 <code>&lt;span class=&quot;pre&quot;&gt;self.local&lt;/span&gt;</code>​ 属性的使用。 它被初始化为一个 <code>&lt;span class=&quot;pre&quot;&gt;threading.local()&lt;/span&gt;</code>​ 实例。 其他方法操作被存储为 <code>&lt;span class=&quot;pre&quot;&gt;self.local.sock&lt;/span&gt;</code>​ 的套接字对象。 有了这些就可以在多线程中安全的使用 <code>&lt;span class=&quot;pre&quot;&gt;LazyConnection&lt;/span&gt;</code>​ 实例了。例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from functools import partial</span><br><span class="line">def test(conn):</span><br><span class="line">    with conn as s:</span><br><span class="line">        s.send(b&#x27;GET /index.html HTTP/1.0\r\n&#x27;)</span><br><span class="line">        s.send(b&#x27;Host: www.python.org\r\n&#x27;)</span><br><span class="line"></span><br><span class="line">        s.send(b&#x27;\r\n&#x27;)</span><br><span class="line">        resp = b&#x27;&#x27;.join(iter(partial(s.recv, 8192), b&#x27;&#x27;))</span><br><span class="line"></span><br><span class="line">    print(&#x27;Got &#123;&#125; bytes&#x27;.format(len(resp)))</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    conn = LazyConnection((&#x27;www.python.org&#x27;, 80))</span><br><span class="line"></span><br><span class="line">    t1 = threading.Thread(target=test, args=(conn,))</span><br><span class="line">    t2 = threading.Thread(target=test, args=(conn,))</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    t1.join()</span><br><span class="line">    t2.join()</span><br></pre></td></tr></table></figure><p>它之所以行得通的原因是每个线程会创建一个自己专属的套接字连接（存储为self.local.sock）。 因此，当不同的线程执行套接字操作时，由于操作的是不同的套接字，因此它们不会相互影响。</p><h2 id="讨论-5"><a href="#讨论-5" class="headerlink" title="讨论"></a>讨论</h2><p>在大部分程序中创建和操作线程特定状态并不会有什么问题。 不过，当出了问题的时候，通常是因为某个对象被多个线程使用到，用来操作一些专用的系统资源， 比如一个套接字或文件。你不能让所有线程共享一个单独对象， 因为多个线程同时读和写的时候会产生混乱。 本地线程存储通过让这些资源只能在被使用的线程中可见来解决这个问题。</p><p>本节中，使用 <code>&lt;span class=&quot;pre&quot;&gt;thread.local()&lt;/span&gt;</code>​ 可以让 <code>&lt;span class=&quot;pre&quot;&gt;LazyConnection&lt;/span&gt;</code>​ 类支持一个线程一个连接， 而不是对于所有的进程都只有一个连接。</p><p>其原理是，每个 <code>&lt;span class=&quot;pre&quot;&gt;threading.local()&lt;/span&gt;</code>​ 实例为每个线程维护着一个单独的实例字典。 所有普通实例操作比如获取、修改和删除值仅仅操作这个字典。 每个线程使用一个独立的字典就可以保证数据的隔离了。</p><p>‍</p><h1 id="创建线程池"><a href="#创建线程池" class="headerlink" title="创建线程池"></a>创建线程池</h1><p><code>concurrent.futures</code>​ 函数库有一个 <code>ThreadPoolExecutor</code>​ 类可以被用来完成这个任务。 下面是一个简单的TCP服务器，使用了一个线程池来响应客户端：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from socket import AF_INET, SOCK_STREAM, socket</span><br><span class="line">from concurrent.futures import ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line">def echo_client(sock, client_addr):</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    Handle a client connection</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    print(&#x27;Got connection from&#x27;, client_addr)</span><br><span class="line">    while True:</span><br><span class="line">        msg = sock.recv(65536)</span><br><span class="line">        if not msg:</span><br><span class="line">            break</span><br><span class="line">        sock.sendall(msg)</span><br><span class="line">    print(&#x27;Client closed connection&#x27;)</span><br><span class="line">    sock.close()</span><br><span class="line"></span><br><span class="line">def echo_server(addr):</span><br><span class="line">    pool = ThreadPoolExecutor(128)</span><br><span class="line">    sock = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">    sock.bind(addr)</span><br><span class="line">    sock.listen(5)</span><br><span class="line">    while True:</span><br><span class="line">        client_sock, client_addr = sock.accept()</span><br><span class="line">        pool.submit(echo_client, client_sock, client_addr)</span><br><span class="line"></span><br><span class="line">echo_server((&#x27;&#x27;,15000))</span><br></pre></td></tr></table></figure><p>如果你想手动创建你自己的线程池， 通常可以使用一个Queue来轻松实现。下面是一个稍微不同但是手动实现的例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from socket import socket, AF_INET, SOCK_STREAM</span><br><span class="line">from threading import Thread</span><br><span class="line">from queue import Queue</span><br><span class="line"></span><br><span class="line">def echo_client(q):</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    Handle a client connection</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    sock, client_addr = q.get()</span><br><span class="line">    print(&#x27;Got connection from&#x27;, client_addr)</span><br><span class="line">    while True:</span><br><span class="line">        msg = sock.recv(65536)</span><br><span class="line">        if not msg:</span><br><span class="line">            break</span><br><span class="line">        sock.sendall(msg)</span><br><span class="line">    print(&#x27;Client closed connection&#x27;)</span><br><span class="line"></span><br><span class="line">    sock.close()</span><br><span class="line"></span><br><span class="line">def echo_server(addr, nworkers):</span><br><span class="line">    # Launch the client workers</span><br><span class="line">    q = Queue()</span><br><span class="line">    for n in range(nworkers):</span><br><span class="line">        t = Thread(target=echo_client, args=(q,))</span><br><span class="line">        t.daemon = True</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line">    # Run the server</span><br><span class="line">    sock = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">    sock.bind(addr)</span><br><span class="line">    sock.listen(5)</span><br><span class="line">    while True:</span><br><span class="line">        client_sock, client_addr = sock.accept()</span><br><span class="line">        q.put((client_sock, client_addr))</span><br><span class="line"></span><br><span class="line">echo_server((&#x27;&#x27;,15000), 128)</span><br></pre></td></tr></table></figure><p>使用 <code>&lt;span class=&quot;pre&quot;&gt;ThreadPoolExecutor&lt;/span&gt;</code>​ 相对于手动实现的一个好处在于它使得 任务提交者更方便的从被调用函数中获取返回值。例如，你可能会像下面这样写：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from concurrent.futures import ThreadPoolExecutor</span><br><span class="line">import urllib.request</span><br><span class="line"></span><br><span class="line">def fetch_url(url):</span><br><span class="line">    u = urllib.request.urlopen(url)</span><br><span class="line">    data = u.read()</span><br><span class="line">    return data</span><br><span class="line"></span><br><span class="line">pool = ThreadPoolExecutor(10)</span><br><span class="line"># Submit work to the pool</span><br><span class="line">a = pool.submit(fetch_url, &#x27;http://www.python.org&#x27;)</span><br><span class="line">b = pool.submit(fetch_url, &#x27;http://www.pypy.org&#x27;)</span><br><span class="line"></span><br><span class="line"># Get the results back</span><br><span class="line">x = a.result()</span><br><span class="line">y = b.result()</span><br></pre></td></tr></table></figure><p>例子中返回的handle对象会帮你处理所有的阻塞与协作，然后从工作线程中返回数据给你。 特别的，<code>&lt;span class=&quot;pre&quot;&gt;a.result()&lt;/span&gt;</code>​ 操作会阻塞进程直到对应的函数执行完成并返回一个结果。</p><h2 id="讨论-6"><a href="#讨论-6" class="headerlink" title="讨论"></a>讨论</h2><p>通常来讲，你应该避免编写线程数量可以无限制增长的程序。例如，看看下面这个服务器：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from threading import Thread</span><br><span class="line">from socket import socket, AF_INET, SOCK_STREAM</span><br><span class="line"></span><br><span class="line">def echo_client(sock, client_addr):</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    Handle a client connection</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    print(&#x27;Got connection from&#x27;, client_addr)</span><br><span class="line">    while True:</span><br><span class="line">        msg = sock.recv(65536)</span><br><span class="line">        if not msg:</span><br><span class="line">            break</span><br><span class="line">        sock.sendall(msg)</span><br><span class="line">    print(&#x27;Client closed connection&#x27;)</span><br><span class="line">    sock.close()</span><br><span class="line"></span><br><span class="line">def echo_server(addr, nworkers):</span><br><span class="line">    # Run the server</span><br><span class="line">    sock = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">    sock.bind(addr)</span><br><span class="line">    sock.listen(5)</span><br><span class="line">    while True:</span><br><span class="line">        client_sock, client_addr = sock.accept()</span><br><span class="line">        t = Thread(target=echo_client, args=(client_sock, client_addr))</span><br><span class="line">        t.daemon = True</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line">echo_server((&#x27;&#x27;,15000))</span><br></pre></td></tr></table></figure><p>尽管这个也可以工作， 但是它不能抵御有人试图通过创建大量线程让你服务器资源枯竭而崩溃的攻击行为。 通过使用预先初始化的线程池，你可以设置同时运行线程的上限数量。</p><p>你可能会关心创建大量线程会有什么后果。 现代操作系统可以很轻松的创建几千个线程的线程池。 甚至，同时几千个线程等待工作并不会对其他代码产生性能影响。 当然了，如果所有线程同时被唤醒并立即在CPU上执行，那就不同了——特别是有了全局解释器锁GIL。 通常，你应该只在I/O处理相关代码中使用线程池。</p><p>创建大的线程池的一个可能需要关注的问题是内存的使用。 例如，如果你在OS X系统上面创建2000个线程，系统显示Python进程使用了超过9GB的虚拟内存。 不过，这个计算通常是有误差的。当创建一个线程时，操作系统会预留一个虚拟内存区域来 放置线程的执行栈（通常是8MB大小）。但是这个内存只有一小片段被实际映射到真实内存中。 因此，Python进程使用到的真实内存其实很小 （比如，对于2000个线程来讲，只使用到了70MB的真实内存，而不是9GB）。 如果你担心虚拟内存大小，可以使用 <code>&lt;span class=&quot;pre&quot;&gt;threading.stack_size()&lt;/span&gt;</code>​ 函数来降低它。例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line">threading.stack_size(65536)</span><br></pre></td></tr></table></figure><p>如果你加上这条语句并再次运行前面的创建2000个线程试验， 你会发现Python进程只使用到了大概210MB的虚拟内存，而真实内存使用量没有变。 注意线程栈大小必须至少为32768字节，通常是系统内存页大小（4096、8192等）的整数倍。</p><p>‍</p><h1 id="简单并行编程"><a href="#简单并行编程" class="headerlink" title="简单并行编程"></a>简单并行编程</h1><p>你有个程序要执行CPU密集型工作，你想让他利用多核CPU的优势来运行的快一点。</p><h2 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h2><p><code>concurrent.futures</code>​ 库提供了一个 <code>ProcessPoolExecutor</code>​ 类， 可被用来在一个单独的Python解释器中执行计算密集型函数。 不过，要使用它，你首先要有一些计算密集型的任务。 我们通过一个简单而实际的例子来演示它。假定你有个Apache web服务器日志目录的gzip压缩包：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">logs/</span><br><span class="line">   20120701.log.gz</span><br><span class="line">   20120702.log.gz</span><br><span class="line">   20120703.log.gz</span><br><span class="line">   20120704.log.gz</span><br><span class="line">   20120705.log.gz</span><br><span class="line">   20120706.log.gz</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure><p>进一步假设每个日志文件内容类似下面这样：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">124.115.6.12 - - [10/Jul/2012:00:18:50 -0500] &quot;GET /robots.txt ...&quot; 200 71</span><br><span class="line">210.212.209.67 - - [10/Jul/2012:00:18:51 -0500] &quot;GET /ply/ ...&quot; 200 11875</span><br><span class="line">210.212.209.67 - - [10/Jul/2012:00:18:51 -0500] &quot;GET /favicon.ico ...&quot; 404 369</span><br><span class="line">61.135.216.105 - - [10/Jul/2012:00:20:04 -0500] &quot;GET /blog/atom.xml ...&quot; 304 -</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面是一个脚本，在这些日志文件中查找出所有访问过robots.txt文件的主机：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># findrobots.py</span><br><span class="line"></span><br><span class="line">import gzip</span><br><span class="line">import io</span><br><span class="line">import glob</span><br><span class="line"></span><br><span class="line">def find_robots(filename):</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    Find all of the hosts that access robots.txt in a single log file</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    robots = set()</span><br><span class="line">    with gzip.open(filename) as f:</span><br><span class="line">        for line in io.TextIOWrapper(f,encoding=&#x27;ascii&#x27;):</span><br><span class="line">            fields = line.split()</span><br><span class="line">            if fields[6] == &#x27;/robots.txt&#x27;:</span><br><span class="line">                robots.add(fields[0])</span><br><span class="line">    return robots</span><br><span class="line"></span><br><span class="line">def find_all_robots(logdir):</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    Find all hosts across and entire sequence of files</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    files = glob.glob(logdir+&#x27;/*.log.gz&#x27;)</span><br><span class="line">    all_robots = set()</span><br><span class="line">    for robots in map(find_robots, files):</span><br><span class="line">        all_robots.update(robots)</span><br><span class="line">    return all_robots</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    robots = find_all_robots(&#x27;logs&#x27;)</span><br><span class="line">    for ipaddr in robots:</span><br><span class="line">        print(ipaddr)</span><br></pre></td></tr></table></figure><p>前面的程序使用了通常的map-reduce风格来编写。 函数 <code>&lt;span class=&quot;pre&quot;&gt;find_robots()&lt;/span&gt;</code>​ 在一个文件名集合上做map操作，并将结果汇总为一个单独的结果， 也就是 <code>&lt;span class=&quot;pre&quot;&gt;find_all_robots()&lt;/span&gt;</code>​ 函数中的 <code>&lt;span class=&quot;pre&quot;&gt;all_robots&lt;/span&gt;</code>​ 集合。 现在，假设你想要修改这个程序让它使用多核CPU。 很简单——只需要将map()操作替换为一个 <code>&lt;span class=&quot;pre&quot;&gt;concurrent.futures&lt;/span&gt;</code>​ 库中生成的类似操作即可。 下面是一个简单修改版本：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># findrobots.py</span><br><span class="line"></span><br><span class="line">import gzip</span><br><span class="line">import io</span><br><span class="line">import glob</span><br><span class="line">from concurrent import futures</span><br><span class="line"></span><br><span class="line">def find_robots(filename):</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    Find all of the hosts that access robots.txt in a single log file</span><br><span class="line"></span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    robots = set()</span><br><span class="line">    with gzip.open(filename) as f:</span><br><span class="line">        for line in io.TextIOWrapper(f,encoding=&#x27;ascii&#x27;):</span><br><span class="line">            fields = line.split()</span><br><span class="line">            if fields[6] == &#x27;/robots.txt&#x27;:</span><br><span class="line">                robots.add(fields[0])</span><br><span class="line">    return robots</span><br><span class="line"></span><br><span class="line">def find_all_robots(logdir):</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    Find all hosts across and entire sequence of files</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    files = glob.glob(logdir+&#x27;/*.log.gz&#x27;)</span><br><span class="line">    all_robots = set()</span><br><span class="line">    with futures.ProcessPoolExecutor() as pool:</span><br><span class="line">        for robots in pool.map(find_robots, files):</span><br><span class="line">            all_robots.update(robots)</span><br><span class="line">    return all_robots</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    robots = find_all_robots(&#x27;logs&#x27;)</span><br><span class="line">    for ipaddr in robots:</span><br><span class="line">        print(ipaddr)</span><br></pre></td></tr></table></figure><p>通过这个修改后，运行这个脚本产生同样的结果，但是在四核机器上面比之前快了3.5倍。 实际的性能优化效果根据你的机器CPU数量的不同而不同。</p><h2 id="讨论-7"><a href="#讨论-7" class="headerlink" title="讨论"></a>讨论</h2><p><code>&lt;span class=&quot;pre&quot;&gt;ProcessPoolExecutor&lt;/span&gt;</code>​ 的典型用法如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from concurrent.futures import ProcessPoolExecutor</span><br><span class="line"></span><br><span class="line">with ProcessPoolExecutor() as pool:</span><br><span class="line">    ...</span><br><span class="line">    do work in parallel using pool</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>其原理是，一个 <code>&lt;span class=&quot;pre&quot;&gt;ProcessPoolExecutor&lt;/span&gt;</code>​ 创建N个独立的Python解释器， N是系统上面可用CPU的个数。你可以通过提供可选参数给 <code>&lt;span class=&quot;pre&quot;&gt;ProcessPoolExecutor(N)&lt;/span&gt;</code>​ 来修改 处理器数量。这个处理池会一直运行到with块中最后一个语句执行完成， 然后处理池被关闭。不过，程序会一直等待直到所有提交的工作被处理完成。</p><p>被提交到池中的工作必须被定义为一个函数。有两种方法去提交。 如果你想让一个列表推导或一个 <code>&lt;span class=&quot;pre&quot;&gt;map()&lt;/span&gt;</code>​ 操作并行执行的话，可使用 <code>&lt;span class=&quot;pre&quot;&gt;pool.map()&lt;/span&gt;</code>​ :</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># A function that performs a lot of work</span><br><span class="line">def work(x):</span><br><span class="line">    ...</span><br><span class="line">    return result</span><br><span class="line"></span><br><span class="line"># Nonparallel code</span><br><span class="line">results = map(work, data)</span><br><span class="line"></span><br><span class="line"># Parallel implementation</span><br><span class="line">with ProcessPoolExecutor() as pool:</span><br><span class="line">    results = pool.map(work, data)</span><br></pre></td></tr></table></figure><p>另外，你可以使用 <code>&lt;span class=&quot;pre&quot;&gt;pool.submit()&lt;/span&gt;</code>​ 来手动的提交单个任务：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Some function</span><br><span class="line">def work(x):</span><br><span class="line">    ...</span><br><span class="line">    return result</span><br><span class="line"></span><br><span class="line">with ProcessPoolExecutor() as pool:</span><br><span class="line">    ...</span><br><span class="line">    # Example of submitting work to the pool</span><br><span class="line">    future_result = pool.submit(work, arg)</span><br><span class="line"></span><br><span class="line">    # Obtaining the result (blocks until done)</span><br><span class="line">    r = future_result.result()</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>如果你手动提交一个任务，结果是一个 <code>&lt;span class=&quot;pre&quot;&gt;Future&lt;/span&gt;</code>​ 实例。 要获取最终结果，你需要调用它的 <code>&lt;span class=&quot;pre&quot;&gt;result()&lt;/span&gt;</code>​ 方法。 它会阻塞进程直到结果被返回来。</p><p>如果不想阻塞，你还可以使用一个回调函数，例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def when_done(r):</span><br><span class="line">    print(&#x27;Got:&#x27;, r.result())</span><br><span class="line"></span><br><span class="line">with ProcessPoolExecutor() as pool:</span><br><span class="line">     future_result = pool.submit(work, arg)</span><br><span class="line">     future_result.add_done_callback(when_done)</span><br></pre></td></tr></table></figure><p>回调函数接受一个 <code>&lt;span class=&quot;pre&quot;&gt;Future&lt;/span&gt;</code>​ 实例，被用来获取最终的结果（比如通过调用它的result()方法）。 尽管处理池很容易使用，在设计大程序的时候还是有很多需要注意的地方，如下几点：</p><ul><li>这种并行处理技术只适用于那些可以被分解为互相独立部分的问题。</li><li>被提交的任务必须是简单函数形式。对于方法、闭包和其他类型的并行执行还不支持。</li><li>函数参数和返回值必须兼容pickle，因为要使用到进程间的通信，所有解释器之间的交换数据必须被序列化</li><li>被提交的任务函数不应保留状态或有副作用。除了打印日志之类简单的事情，</li></ul><p>一旦启动你不能控制子进程的任何行为，因此最好保持简单和纯洁——函数不要去修改环境。</p><ul><li>在Unix上进程池通过调用 <code>&lt;span class=&quot;pre&quot;&gt;fork()&lt;/span&gt;</code>​ 系统调用被创建，</li></ul><p>它会克隆Python解释器，包括fork时的所有程序状态。 而在Windows上，克隆解释器时不会克隆状态。 实际的fork操作会在第一次调用 <code>&lt;span class=&quot;pre&quot;&gt;pool.map()&lt;/span&gt;</code>​ 或 <code>&lt;span class=&quot;pre&quot;&gt;pool.submit()&lt;/span&gt;</code>​ 后发生。</p><ul><li>当你混合使用进程池和多线程的时候要特别小心。</li></ul><p>你应该在创建任何线程之前先创建并激活进程池（比如在程序启动的main线程中创建进程池）。</p><h1 id="Py的全局锁问题"><a href="#Py的全局锁问题" class="headerlink" title="Py的全局锁问题"></a>Py的全局锁问题</h1><p>尽管Python完全支持多线程编程， 但是解释器的C语言实现部分在完全并行执行时并不是线程安全的。 实际上，解释器被一个全局解释器锁保护着，它确保任何时候都只有一个Python线程执行。 GIL最大的问题就是Python的多线程程序并不能利用多核CPU的优势 （比如一个使用了多个线程的计算密集型程序只会在一个单CPU上面运行）。</p><p>在讨论普通的GIL之前，<strong>有一点要强调的是GIL只会影响到那些严重依赖CPU的程序</strong>（比如计算型的）。 如果你的程序大部分只会涉及到I/O，比如网络交互，那么使用多线程就很合适， 因为它们大部分时间都在等待。实际上，你完全可以放心的创建几千个Python线程， 现代操作系统运行这么多线程没有任何压力，没啥可担心的。</p><p>而对于依赖CPU的程序，你需要弄清楚执行的计算的特点。 例如，优化底层算法要比使用多线程运行快得多。 类似的，由于Python是解释执行的，如果你将那些性能瓶颈代码移到一个C语言扩展模块中， 速度也会提升的很快。如果你要操作数组，那么使用NumPy这样的扩展会非常的高效。 最后，你还可以考虑下其他可选实现方案，比如PyPy，它通过一个JIT编译器来优化执行效率 （不过在写这本书的时候它还不能支持Python 3）。</p><p>还有一点要注意的是，线程不是专门用来优化性能的。 一个CPU依赖型程序可能会使用线程来管理一个图形用户界面、一个网络连接或其他服务。 这时候，GIL会产生一些问题，因为如果一个线程长期持有GIL的话会导致其他非CPU型线程一直等待。 事实上，一个写的不好的C语言扩展会导致这个问题更加严重， 尽管代码的计算部分会比之前运行的更快些。</p><p>说了这么多，现在想说的是我们有两种策略来解决GIL的缺点。 首先，如果你完全工作于Python环境中，你可以使用 <code>&lt;span class=&quot;pre&quot;&gt;multiprocessing&lt;/span&gt;</code>​ 模块来创建一个进程池， 并像协同处理器一样的使用它。例如，假如你有如下的线程代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Performs a large calculation (CPU bound)</span><br><span class="line">def some_work(args):</span><br><span class="line">    ...</span><br><span class="line">    return result</span><br><span class="line"></span><br><span class="line"># A thread that calls the above function</span><br><span class="line">def some_thread():</span><br><span class="line">    while True:</span><br><span class="line">        ...</span><br><span class="line">        r = some_work(args)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>修改代码，使用进程池：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Processing pool (see below for initiazation)</span><br><span class="line">pool = None</span><br><span class="line"></span><br><span class="line"># Performs a large calculation (CPU bound)</span><br><span class="line">def some_work(args):</span><br><span class="line">    ...</span><br><span class="line">    return result</span><br><span class="line"></span><br><span class="line"># A thread that calls the above function</span><br><span class="line">def some_thread():</span><br><span class="line">    while True:</span><br><span class="line">        ...</span><br><span class="line">        r = pool.apply(some_work, (args))</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line"># Initiaze the pool</span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    import multiprocessing</span><br><span class="line">    pool = multiprocessing.Pool()</span><br></pre></td></tr></table></figure><p>这个通过使用一个技巧利用进程池解决了GIL的问题。 当一个线程想要执行CPU密集型工作时，会将任务发给进程池。 然后进程池会在另外一个进程中启动一个单独的Python解释器来工作。 当线程等待结果的时候会释放GIL。 并且，由于计算任务在单独解释器中执行，那么就不会受限于GIL了。 在一个多核系统上面，你会发现这个技术可以让你很好的利用多CPU的优势。</p><p>另外一个解决GIL的策略是使用<strong>C扩展编程技术</strong>。 主要思想是将计算密集型任务转移给C，跟Python独立，在工作的时候在C代码中释放GIL。 这可以通过在C代码中插入下面这样的特殊宏来完成：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;Python.h&quot;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">PyObject *pyfunc(PyObject *self, PyObject *args) &#123;</span><br><span class="line">   ...</span><br><span class="line">   Py_BEGIN_ALLOW_THREADS</span><br><span class="line">   // Threaded C code</span><br><span class="line">   ...</span><br><span class="line">   Py_END_ALLOW_THREADS</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你使用其他工具访问C语言，比如对于Cython的ctypes库，你不需要做任何事。 例如，ctypes在调用C时会自动释放GIL。</p><h2 id="讨论-8"><a href="#讨论-8" class="headerlink" title="讨论"></a>讨论</h2><p>许多程序员在面对线程性能问题的时候，马上就会怪罪GIL，什么都是它的问题。 其实这样子太不厚道也太天真了点。 作为一个真实的例子，在多线程的网络编程中神秘的 <code>&lt;span class=&quot;pre&quot;&gt;stalls&lt;/span&gt;</code>​ 可能是因为其他原因比如一个DNS查找延时，而跟GIL毫无关系。 最后你真的需要先去搞懂你的代码是否真的被GIL影响到。 同时还要明白GIL大部分都应该只关注CPU的处理而不是I/O.</p><p>如果你准备使用一个处理器池，注意的是这样做涉及到数据序列化和在不同Python解释器通信。 被执行的操作需要放在一个通过def语句定义的Python函数中，不能是lambda、闭包可调用实例等， 并且函数参数和返回值必须要兼容pickle。 同样，要执行的任务量必须足够大以弥补额外的通信开销。</p><p>另外一个难点是当混合使用线程和进程池的时候会让你很头疼。 如果你要同时使用两者，最好在程序启动时，创建任何线程之前先创建一个单例的进程池。 然后线程使用同样的进程池来进行它们的计算密集型工作。</p><p>C扩展最重要的特征是它们和Python解释器是保持独立的。 也就是说，如果你准备将Python中的任务分配到C中去执行， 你需要确保C代码的操作跟Python保持独立， 这就意味着不要使用Python数据结构以及不要调用Python的C API。 另外一个就是你要确保C扩展所做的工作是足够的，值得你这样做。 也就是说C扩展担负起了大量的计算任务，而不是少数几个计算。</p><p>这些解决GIL的方案并不能适用于所有问题。 例如，某些类型的应用程序如果被分解为多个进程处理的话并不能很好的工作， 也不能将它的部分代码改成C语言执行。 对于这些应用程序，你就要自己需求解决方案了 （比如多进程访问共享内存区，多解析器运行于同一个进程等）。 或者，你还可以考虑下其他的解释器实现，比如PyPy。</p><p>了解更多关于在C扩展中释放GIL，请参考15.7和15.10小节。</p><p>‍</p><h1 id="Actor模式"><a href="#Actor模式" class="headerlink" title="Actor模式"></a>Actor模式</h1><p><strong>actor模式是一种最古老的也是最简单的并行和分布式计算解决方案。</strong>  事实上，它天生的简单性是它如此受欢迎的重要原因之一。 简单来讲，一个actor就是一个并发执行的任务，只是简单的执行发送给它的消息任务。 响应这些消息时，它可能还会给其他actor发送更进一步的消息。 actor之间的通信是单向和异步的。因此，消息发送者不知道消息是什么时候被发送， 也不会接收到一个消息已被处理的回应或通知。</p><p>结合使用一个线程和一个队列可以很容易的定义actor，例如：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Event</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sentinel used for shutdown</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ActorExit</span>(<span class="title class_ inherited__">Exception</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Actor</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._mailbox = Queue()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">send</span>(<span class="params">self, msg</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        Send a message to the actor</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        self._mailbox.put(msg)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recv</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        Receive an incoming message</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        msg = self._mailbox.get()</span><br><span class="line">        <span class="keyword">if</span> msg <span class="keyword">is</span> ActorExit:</span><br><span class="line">            <span class="keyword">raise</span> ActorExit()</span><br><span class="line">        <span class="keyword">return</span> msg</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">close</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        Close the actor, thus shutting it down</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        self.send(ActorExit)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        Start concurrent execution</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        self._terminated = Event()</span><br><span class="line">        t = Thread(target=self._bootstrap)</span><br><span class="line"></span><br><span class="line">        t.daemon = <span class="literal">True</span></span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_bootstrap</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.run()</span><br><span class="line">        <span class="keyword">except</span> ActorExit:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            self._terminated.<span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">join</span>(<span class="params">self</span>):</span><br><span class="line">        self._terminated.wait()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        Run method to be implemented by the user</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            msg = self.recv()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sample ActorTask</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PrintActor</span>(<span class="title class_ inherited__">Actor</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            msg = self.recv()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Got:&#x27;</span>, msg)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sample use</span></span><br><span class="line">p = PrintActor()</span><br><span class="line">p.start()</span><br><span class="line">p.send(<span class="string">&#x27;Hello&#x27;</span>)</span><br><span class="line">p.send(<span class="string">&#x27;World&#x27;</span>)</span><br><span class="line">p.close()</span><br><span class="line">p.join()</span><br></pre></td></tr></table></figure><p>这个例子中，你使用actor实例的 <code>&lt;span class=&quot;pre&quot;&gt;send()&lt;/span&gt;</code>​ 方法发送消息给它们。 其机制是，这个方法会将消息放入一个队里中， 然后将其转交给处理被接受消息的一个内部线程。 <code>&lt;span class=&quot;pre&quot;&gt;close()&lt;/span&gt;</code>​ 方法通过在队列中放入一个特殊的哨兵值（ActorExit）来关闭这个actor。 用户可以通过继承Actor并定义实现自己处理逻辑run()方法来定义新的actor。 <code>&lt;span class=&quot;pre&quot;&gt;ActorExit&lt;/span&gt;</code>​ 异常的使用就是用户自定义代码可以在需要的时候来捕获终止请求 （异常被get()方法抛出并传播出去）。</p><p>如果你放宽对于同步和异步消息发送的要求， 类actor对象还可以通过生成器来简化定义。例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def print_actor():</span><br><span class="line">    while True:</span><br><span class="line"></span><br><span class="line">        try:</span><br><span class="line">            msg = yield      # Get a message</span><br><span class="line">            print(&#x27;Got:&#x27;, msg)</span><br><span class="line">        except GeneratorExit:</span><br><span class="line">            print(&#x27;Actor terminating&#x27;)</span><br><span class="line"></span><br><span class="line"># Sample use</span><br><span class="line">p = print_actor()</span><br><span class="line">next(p)     # Advance to the yield (ready to receive)</span><br><span class="line">p.send(&#x27;Hello&#x27;)</span><br><span class="line">p.send(&#x27;World&#x27;)</span><br><span class="line">p.close()</span><br></pre></td></tr></table></figure><h2 id="讨论-9"><a href="#讨论-9" class="headerlink" title="讨论"></a>讨论</h2><p>actor模式的魅力就在于它的简单性。 实际上，这里仅仅只有一个核心操作 <code>&lt;span class=&quot;pre&quot;&gt;send()&lt;/span&gt;</code>​ . 甚至，对于在基于actor系统中的“消息”的泛化概念可以已多种方式被扩展。 例如，你可以以元组形式传递标签消息，让actor执行不同的操作，如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class TaggedActor(Actor):</span><br><span class="line">    def run(self):</span><br><span class="line">        while True:</span><br><span class="line">             tag, *payload = self.recv()</span><br><span class="line">             getattr(self,&#x27;do_&#x27;+tag)(*payload)</span><br><span class="line"></span><br><span class="line">    # Methods correponding to different message tags</span><br><span class="line">    def do_A(self, x):</span><br><span class="line">        print(&#x27;Running A&#x27;, x)</span><br><span class="line"></span><br><span class="line">    def do_B(self, x, y):</span><br><span class="line">        print(&#x27;Running B&#x27;, x, y)</span><br><span class="line"></span><br><span class="line"># Example</span><br><span class="line">a = TaggedActor()</span><br><span class="line">a.start()</span><br><span class="line">a.send((&#x27;A&#x27;, 1))      # Invokes do_A(1)</span><br><span class="line">a.send((&#x27;B&#x27;, 2, 3))   # Invokes do_B(2,3)</span><br><span class="line">a.close()</span><br><span class="line">a.join()</span><br></pre></td></tr></table></figure><p>作为另外一个例子，下面的actor允许在一个工作者中运行任意的函数， 并且通过一个特殊的Result对象返回结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from threading import Event</span><br><span class="line">class Result:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self._evt = Event()</span><br><span class="line">        self._result = None</span><br><span class="line"></span><br><span class="line">    def set_result(self, value):</span><br><span class="line">        self._result = value</span><br><span class="line"></span><br><span class="line">        self._evt.set()</span><br><span class="line"></span><br><span class="line">    def result(self):</span><br><span class="line">        self._evt.wait()</span><br><span class="line">        return self._result</span><br><span class="line"></span><br><span class="line">class Worker(Actor):</span><br><span class="line">    def submit(self, func, *args, **kwargs):</span><br><span class="line">        r = Result()</span><br><span class="line">        self.send((func, args, kwargs, r))</span><br><span class="line">        return r</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        while True:</span><br><span class="line">            func, args, kwargs, r = self.recv()</span><br><span class="line">            r.set_result(func(*args, **kwargs))</span><br><span class="line"></span><br><span class="line"># Example use</span><br><span class="line">worker = Worker()</span><br><span class="line">worker.start()</span><br><span class="line">r = worker.submit(pow, 2, 3)</span><br><span class="line">worker.close()</span><br><span class="line">worker.join()</span><br><span class="line">print(r.result())</span><br></pre></td></tr></table></figure><p>最后，“发送”一个任务消息的概念可以被扩展到多进程甚至是大型分布式系统中去。 例如，一个类actor对象的 <code>send()</code>​ 方法可以被编程让它能在一个套接字连接上传输数据 或通过某些消息中间件（比如AMQP、ZMQ等）来发送。</p><h1 id="实现消息发布-订阅模型"><a href="#实现消息发布-订阅模型" class="headerlink" title="实现消息发布/订阅模型"></a>实现消息发布/订阅模型</h1><p>TODO</p><h1 id="使用生成器代替线程"><a href="#使用生成器代替线程" class="headerlink" title="使用生成器代替线程"></a>使用生成器代替线程</h1><p>TODO</p><h1 id="多个线程队列轮询"><a href="#多个线程队列轮询" class="headerlink" title="多个线程队列轮询"></a>多个线程队列轮询</h1><p>TODO</p><h1 id="在Unix系统上面启动守护线程"><a href="#在Unix系统上面启动守护线程" class="headerlink" title="在Unix系统上面启动守护线程"></a>在Unix系统上面启动守护线程</h1><p>TODO</p><h1 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h1><p><a href="https://python3-cookbook.readthedocs.io/zh-cn/latest/chapters/p12_concurrency.html">Python CookBook</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;KeyWords:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;threading.Thread&lt;/li&gt;
&lt;li&gt;threading.Event&lt;/li&gt;
&lt;li&gt;使用队列queue.Queue，task_down()、join()实现线程通信&lt;/li&gt;
&lt;li&gt;</summary>
      
    
    
    
    <category term="Python" scheme="https://guoyujian.github.io/categories/Python/"/>
    
    <category term="并发" scheme="https://guoyujian.github.io/categories/Python/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="Python" scheme="https://guoyujian.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Fluent Python笔记持续整理</title>
    <link href="https://guoyujian.github.io/2024/03/08/Fluent-Python%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%95%B4%E7%90%86/"/>
    <id>https://guoyujian.github.io/2024/03/08/Fluent-Python%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%95%B4%E7%90%86/</id>
    <published>2024-03-08T07:22:30.000Z</published>
    <updated>2024-03-08T07:25:33.999Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>后面几节没整理；没有目录；一些重要章节不是很全，仅仅是介绍。</p><p>Ref：<a href="https://www.52pojie.cn/thread-1816710-1-1.html">https://www.52pojie.cn/thread-1816710-1-1.html</a></p></blockquote><p>在Python中，如果一个类定义了<code>__getitem__</code>方法，那么该类的对象可以像序列（如列表、字符串等）一样使用索引运算符[]来访问其元素。 </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Seq</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.data = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, index</span>):</span><br><span class="line">        <span class="keyword">return</span> self.data[index]</span><br><span class="line">    </span><br><span class="line">seq = Seq()</span><br><span class="line">seq[<span class="number">0</span>:<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>这类方法称为魔术方法，类似的还有<code>__len__</code>, <code>__setitem__</code>, <code>__str__</code>, <code>__repr__</code>, <code>__add__</code>, <code>__eq__</code>等</p><p><code>__str__</code>和<code>__repr__</code>用于定义对象的字符串表示形式。<code>__str__</code>方法用于返回对象的人类可读的字符串表示形式，通常用于打印输出或显示给用户。 <code>__repr__</code>方法用于返回对象的官方字符串表示形式，通常用于调试和开发过程中。 下面是一个示例，展示了如何在自定义类中使用<code>__str__</code>和<code>__repr__</code>方法：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x, y</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;print..Point(<span class="subst">&#123;self.x&#125;</span>, <span class="subst">&#123;self.y&#125;</span>)&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;Point(<span class="subst">&#123;self.x&#125;</span>, <span class="subst">&#123;self.y&#125;</span>)&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">p = Point(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(p)</span><br><span class="line"><span class="built_in">repr</span>(p)</span><br></pre></td></tr></table></figure><p>总结魔术方法 TODO</p><hr><p>列表推导式： [expression for item in iterable if condition]<br>在处理大型数据集时，列表推导式可能会影响性能，这时应考虑使用生成器表达式或其他更适合的方法。</p><p>在Python中，map()和filter()是两个内置函数，用于对可迭代对象进行映射和过滤操作。 1. map()函数：   map()函数接受一个函数和一个或多个可迭代对象作为参数，将函数应用于每个可迭代对象中的元素，并返回一个新的迭代器（在Python 3中返回迭代器，在Python 2中返回列表）。    map()函数的语法如下：<br>map(function, iterable, …)  </p><p>filter()函数：   filter()函数接受一个函数和一个可迭代对象作为参数，根据函数的返回值（True或False）来过滤可迭代对象中的元素，并返回一个新的迭代器（在Python 3中返回迭代器，在Python 2中返回列表）。    filter()函数的语法如下：   </p><p>filter(function, iterable)</p><p>使用map()和filter()函数可以简化对列表的处理，使代码更简洁、可读性更高。然而，请注意在处理大型数据集时，这些函数可能会影响性能，这时应考虑使用列表推导式或其他更适合的方法。</p><p>生成器表达式与列表推导式的语法非常相似，只是将[]替换为()，从而创建一个生成器对象而不是列表对象。以下是生成器表达式的一般语法格式</p><p>(expression for item in iterable if condition)</p><p>与列表推导式不同，生成器表达式生成的是一个迭代器，而不是立即生成一个完整的列表。这种延迟计算的特性使得生成器表达式非常适合处理大数据集或无限序列。</p><p>拆包：拆包（Unpacking）是一种将序列（如元组或列表）中的元素分配给变量的操作。它可以方便地将序列中的元素解包并赋值给多个变量。 拆包可以应用于任何可迭代对象，例如元组、列表、集合等。要进行拆包，只需将可迭代对象放在赋值语句的左侧，并使用与元素数量相同的变量进行赋值。</p><p>使用拆包可以简化代码，并使其更易读。它允许一次性访问和操作序列中的多个元素，而不需要使用索引来逐个访问。 需要注意的是，如果拆包的变量数量与序列中的元素数量不匹配，将会引发ValueError异常。如果只想拆包序列中的一部分元素，可以使用占位符（如_）来表示不需要的元素。</p><p>在Python中，* 可以用于拆包操作，它可以将可迭代对象中的剩余元素打包成一个列表。这种用法通常称为“可变长参数”或“可变长参数列表”。 使用号拆包可以处理可变长度的参数列表，无需事先知道可迭代对象中的元素个数。 </p><p>Python支持嵌套拆包</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">a, *rest, b = lst</span><br><span class="line">rest</span><br></pre></td></tr></table></figure><p>序列模式匹配</p><p>从 Python 3.10 版本开始，引入了 match 表达式，以提供更强大的模式匹配功能。match 表达式可以用于匹配和解构各种数据类型，包括序列类型。 以下是一个示例，展示了如何在 Python 3.10 中使用 match 表达式进行模式匹配：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">process_data</span>(<span class="params">data</span>):</span><br><span class="line">    match data:</span><br><span class="line">        case [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;匹配到 [1, 2, 3]&quot;</span>)</span><br><span class="line">        case [<span class="number">4</span>, x, y]:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;匹配到 [4, <span class="subst">&#123;x&#125;</span>, <span class="subst">&#123;y&#125;</span>]&quot;</span>)</span><br><span class="line">        case [a, b, c]:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;匹配到 [<span class="subst">&#123;a&#125;</span>, <span class="subst">&#123;b&#125;</span>, <span class="subst">&#123;c&#125;</span>]&quot;</span>)</span><br><span class="line">        case _:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;未匹配到任何模式&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试示例</span></span><br><span class="line">process_data([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])  <span class="comment"># 输出: 匹配到 [1, 2, 3]</span></span><br><span class="line">process_data([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])  <span class="comment"># 输出: 匹配到 [4, 5, 6]</span></span><br><span class="line">process_data([<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])  <span class="comment"># 输出: 匹配到 [7, 8, 9]</span></span><br><span class="line">process_data([<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>])  <span class="comment"># 输出: 未匹配到任何模式</span></span><br></pre></td></tr></table></figure><p>字典推导式：它类似于列表推导式，但是生成的结果是字典而不是列表。</p><p>{key_expression: value_expression for item in iterable}</p><p>在Python中，defaultdict 是 collections 模块中的一个类，它是 dict 类的一个子类，用于创建具有默认值的字典。 与普通的字典不同，defaultdict 在创建时需要指定一个默认值的类型，当访问一个不存在的键时，它会自动返回默认值，而不会抛出 KeyError 异常。 以下是一个示例，展示了如何使用 defaultdict 创建具有默认值的字典：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line">d = defaultdict(<span class="built_in">int</span>)</span><br><span class="line"></span><br><span class="line">d[<span class="string">&#x27;a&#x27;</span>] = <span class="number">1</span></span><br><span class="line">d[<span class="string">&#x27;b&#x27;</span>]  <span class="comment"># 0 </span></span><br></pre></td></tr></table></figure><p>当我们使用一个字典访问一个不存在的键时，如果字典类中定义了 <code>__missing__</code> 方法，那么在访问不存在的键时，Python 会自动调用该方法，并将所访问的键作为参数传递给它。 以下是一个示例，展示了如何使用 <code>__missing__</code> 方法自定义字典中访问不存在的键的行为：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyDict</span>(<span class="title class_ inherited__">dict</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__missing__</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;Key &#x27;<span class="subst">&#123;key&#125;</span>&#x27; is missing!&quot;</span></span><br><span class="line"></span><br><span class="line">d = MyDict()</span><br><span class="line">d[<span class="string">&#x27;a&#x27;</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(d[<span class="string">&#x27;a&#x27;</span>])  <span class="comment"># 输出: 1</span></span><br><span class="line"><span class="built_in">print</span>(d[<span class="string">&#x27;b&#x27;</span>])  <span class="comment"># 输出: Key &#x27;b&#x27; is missing!</span></span><br></pre></td></tr></table></figure><p>collections.ChainMap 是 Python 中的一个类，它用于将多个字典或映射对象链接在一起，形成一个逻辑上的单一映射。 ChainMap 提供了一种方便的方式来处理多个字典或映射对象，并将它们作为一个整体来操作。它在逻辑上将这些字典或映射对象链接在一起，形成一个查找链。当我们在 ChainMap 对象上进行键的查找时，它会按照链接顺序依次在各个字典或映射对象中查找。 </p><p>collections.ChainMap的好处是他不会真的合并对象，而只是形成一个链接，因此他不会占用额外的空间。具体可看源码:<a href="https://blog.csdn.net/weixin_37780776/article/details/123777723">https://blog.csdn.net/weixin_37780776/article/details/123777723</a></p><p>collections.Counter 是 Python 中的一个类，它用于计数可哈希对象的出现次数。它是一个无序的集合，其中元素存储为键，其计数存储为值。 Counter 类提供了一些有用的方法，用于对计数器进行操作，如增加、减少元素的计数、获取最常见的元素、计算元素的总数等。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line">counter = Counter(<span class="string">&#x27;abcda&#x27;</span>)</span><br><span class="line">counter</span><br><span class="line">counter.values()</span><br></pre></td></tr></table></figure><p>在 Python 中，创建子类时，可以选择继承内置的 dict 类或 collections.UserDict 类来实现自定义字典类的功能。 尽管 dict 类是 Python 内置的字典类，但在某些情况下，继承 collections.UserDict 类可能更适合。collections.UserDict 是一个可变字典类的包装器，它提供了更简单和安全的方式来创建自定义字典类。 以下是一个示例，展示了如何使用 collections.UserDict 来创建自定义字典类：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> UserDict</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyDict</span>(<span class="title class_ inherited__">UserDict</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setitem__</span>(<span class="params">self, key, value</span>):</span><br><span class="line">        <span class="comment"># 自定义设置键值的行为</span></span><br><span class="line">        <span class="keyword">if</span> key == <span class="string">&#x27;special_key&#x27;</span>:</span><br><span class="line">            value += <span class="number">10</span></span><br><span class="line">        <span class="built_in">super</span>().__setitem__(key, value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="comment"># 自定义获取键值的行为</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().__getitem__(key)</span><br><span class="line"></span><br><span class="line">my_dict = MyDict()</span><br><span class="line">my_dict[<span class="string">&#x27;special_key&#x27;</span>] = <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(my_dict[<span class="string">&#x27;special_key&#x27;</span>])  <span class="comment"># 输出: 15</span></span><br></pre></td></tr></table></figure><p>在上面的示例中，我们创建了一个名为 MyDict 的自定义字典类，并继承了 UserDict 类。通过重写 <code>__setitem__</code> 和 <code>__getitem__</code> 方法，我们可以自定义设置和获取键值的行为。 继承 UserDict 类可以帮助我们避免直接修改 dict 对象的内部结构，从而更安全地创建自定义字典类。 当然，如果你只需要创建一个简单的字典类，而不需要自定义特定的行为，那么继承 dict 类也是可行的。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bytes_data = <span class="string">b&#x27;\xe4\xbd\xa0\xe5\xa5\xbd&#x27;</span></span><br><span class="line">decoded_text = bytes_data.decode(<span class="string">&#x27;utf-8&#x27;</span>)  </span><br><span class="line">decoded_text</span><br></pre></td></tr></table></figure><p>在 Python 中，具名元组（NamedTuple）是一种特殊类型的元组，它允许你给每个元素命名，并通过名称访问元素，而不仅仅是通过索引。 具名元组是通过 collections 模块中的 namedtuple 函数创建的。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建具名元组类</span></span><br><span class="line">Person = namedtuple(<span class="string">&#x27;Person&#x27;</span>, [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建具名元组实例</span></span><br><span class="line">person1 = Person(<span class="string">&#x27;Alice&#x27;</span>, <span class="number">25</span>, <span class="string">&#x27;female&#x27;</span>)</span><br><span class="line">person2 = Person(<span class="string">&#x27;Bob&#x27;</span>, <span class="number">30</span>, <span class="string">&#x27;male&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问元素</span></span><br><span class="line"><span class="built_in">print</span>(person1.name)      <span class="comment"># 输出：Alice</span></span><br><span class="line"><span class="built_in">print</span>(person2.age)       <span class="comment"># 输出：30</span></span><br><span class="line"><span class="built_in">print</span>(person1.gender)    <span class="comment"># 输出：female</span></span><br></pre></td></tr></table></figure><p>@dataclass 是 Python 3.7 引入的一个装饰器，用于简化创建和使用数据类（data class）的过程。数据类是一种用于存储数据的特殊类，它自动为我们生成一些常见的方法，如 <code>__init__</code>、<code>__repr__</code>、<code>__eq__</code> 等，使得我们可以更方便地创建和操作数据对象。 使用 @dataclass 装饰器，我们可以在类定义中省略一些繁琐的代码。以下是一个使用 @dataclass 装饰器创建数据类的示例</p><p>在 Python 中，垃圾回收是自动进行的，它是通过引用计数和循环垃圾收集机制来实现的。下面是对这两种机制的简要说明：</p><ol><li>引用计数（Reference Counting）：Python 使用引用计数来追踪每个对象的引用数。当对象的引用数变为 0 时，说明没有任何引用指向该对象，Python 会立即回收该对象的内存空间。这是一种高效的垃圾回收机制，可以立即回收不再使用的对象。</li></ol><p>然而，引用计数机制无法处理循环引用的情况，即两个或多个对象彼此引用，但没有其他引用指向它们。这种情况下，引用计数无法将对象的引用数降为 0，导致内存泄漏。为了解决这个问题，Python 提供了循环垃圾收集机制。</p><ol><li>循环垃圾收集（Cycle Garbage Collection）：Python 使用循环垃圾收集机制来检测和回收循环引用的对象。循环垃圾收集器会定期运行，它会检查所有对象的引用关系，并标记那些可以被回收的对象。然后，它会释放这些对象所占用的内存空间。</li></ol><p>循环垃圾收集器使用了更复杂的算法，如标记-清除（mark and sweep）和分代回收（generational collection），以提高垃圾回收的效率和性能。</p><p>需要注意的是，Python 的垃圾回收机制是自动的，开发者无需手动管理内存。然而，对于一些特殊情况，如大型数据结构或循环引用的对象，可能需要注意内存的使用和释放，以避免潜在的内存泄漏问题。</p><p>在 Python 中，函数的参数传递方式是通过引用传递（pass-by-reference），也可以称为对象的引用传递。这意味着函数参数在传递过程中，实际上是将对象的引用传递给函数，而不是对象本身的副本。 </p><p>总结起来，当函数参数是引用传递时，函数内部对参数对象的修改会影响到原始对象，但是对参数进行重新赋值则不会影响到原始对象。</p><p>del是一个关键字，常见用法：</p><ol><li>删除对象</li><li>删除对象的属性</li><li>删除列表中的元素</li><li>删除字典中的键值对</li></ol><p>python中函数是一等公民：</p><ol><li>将函数赋值给变量</li><li>函数可以作为参数</li><li>函数作为另一个函数的返回值</li><li>嵌套函数</li></ol><p>在 Python 中，高阶函数（Higher-order functions）是指能够接受函数作为参数，或者返回一个函数的函数。高阶函数是函数式编程的重要概念，它可以让代码更加简洁、灵活和可复用。 以下是一些常见的高阶函数的示例：</p><ul><li>map</li><li>filter</li><li>sorted</li><li>lambda函数：lambda 函数通常只适用于简单的、单行的函数逻辑。如果你需要编写复杂的函数逻辑，还是建议使用常规的函数定义方式。</li></ul><p>用户可以通过自定义类来创建可调用对象。为了使一个类的实例可以像函数一样被调用，需要在类中定义 <code>__call__</code>() 方法</p><p><strong>总结py中星号的用法</strong></p><p>在 Python 中，有一些流行的包和库支持函数式编程范式。以下是其中一些常用的包：</p><ol><li><p>functools：<code>functools</code> 是 Python 内置的一个模块，提供了一些函数式编程的工具函数。它包含了一些用于函数操作的高阶函数，如 <code>map()</code>、<code>filter()</code>、<code>reduce()</code>，以及一些用于函数组合和函数装饰器的工具函数。</p></li><li><p>itertools：<code>itertools</code> 也是 Python 内置的一个模块，提供了一些用于迭代和组合的工具函数。它包含了一些常见的函数式编程模式，如生成无限迭代器、组合迭代器、过滤迭代器等。</p></li><li><p>operator：<code>operator</code> 是 Python 内置的一个模块，提供了一些常见的运算符的函数形式。它提供了一种函数式的方式来执行常见的算术、比较和逻辑运算。</p></li><li><p>toolz：<code>toolz</code> 是一个功能强大的函数式编程工具包，提供了一些高阶函数和工具，用于处理集合、迭代和函数组合。它提供了一些函数式编程的常见模式，如 <code>curry()</code>、<code>compose()</code>、<code>pipe()</code> 等。</p></li><li><p>fn：<code>fn</code> 是一个专注于函数式编程的库，提供了一些函数式编程的工具函数和数据类型。它支持函数组合、柯里化、惰性求值等函数式编程的特性。</p></li></ol><p>这些包和库提供了丰富的工具和函数，帮助开发者更方便地应用函数式编程的思想和模式。无论是在函数组合、迭代操作、惰性求值还是其他函数式编程的场景中，它们都能提供很多便利。</p><p>在 Python 中，类型注解是一种可选的语法，用于提供变量、函数参数、函数返回值等的类型信息。类型注解可以帮助开发者和工具在静态类型检查时发现潜在的类型错误，提高代码的可读性和可维护性。</p><p>以下是一些常用的类型注解，可以在 Python 的注解中使用：</p><ol><li><p>基本类型：int、float、bool、str 等基本数据类型。</p></li><li><p>容器类型：list、tuple、dict、set 等容器类型。可以使用方括号 <code>[]</code> 表示列表，圆括号 <code>()</code> 表示元组，大括号 <code>&#123;&#125;</code> 表示字典和集合。</p></li><li><p>自定义类型：自定义的类、枚举类、命名元组等。</p></li><li><p>Union 类型：使用 <code>Union</code> 或 <code>|</code> 符号表示多个类型中的一个，表示一个变量可以是多种类型之一。</p></li><li><p>Optional 类型：使用 <code>Optional</code> 表示一个变量可以是指定类型或者 <code>None</code>。</p></li><li><p>Callable 类型：使用 <code>Callable</code> 表示一个变量是可调用对象，如函数、方法等。</p></li><li><p>类型变量：使用 <code>TypeVar</code> 表示一个类型变量，用于泛型编程或表示复杂类型。</p></li><li><p>Any 类型：使用 <code>Any</code> 表示任意类型，相当于取消了类型检查。</p></li></ol><p>需要注意的是，类型注解在 Python 中是可选的，不会影响代码的运行。它们只是提供了一种给开发者和工具更多类型信息的方式，以提高代码的可读性和可维护性。Python 解释器在运行时不会对类型注解进行验证，类型检查需要通过静态类型检查工具（如 <code>mypy</code>）进行。</p><p><strong>装饰器和闭包总结和使用装饰器改进策略模式</strong></p><p>实例方法、静态方法、类方法比较</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    cls_var = <span class="string">&#x27;cls_var&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, ins_var</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.ins_var = ins_var</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cls_method</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;This is a cls method&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(cls.cls_var)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">ins_method</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;This is a ins method&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(self.ins_var)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">static_method</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;This is a static method&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(MyClass.cls_var)</span><br><span class="line"></span><br><span class="line">MyClass.static_method()</span><br></pre></td></tr></table></figure><p>在Python中，有两种方式可以限制对类属性的访问：私有属性和受保护的属性。 </p><ol><li>私有属性： 私有属性是以双下划线 __ 开头的属性，它们只能在类的内部访问，无法从外部直接访问。私有属性的目的是防止意外的修改或访问，以保护类的内部实现细节。</li></ol><p>尽管无法直接访问私有属性和方法，但可以通过使用 <code>实例变量._类名__属性名</code>的方式来间接访问私有属性和方法。</p><p>请注意，这种方式只是一个约定，不是真正的访问控制机制。在Python中，没有真正的私有性，它只是一种约定，用于指示这些属性和方法应该被视为私有的。 </p><ol><li>受保护的属性： 受保护的属性是以单下划线 _ 开头的属性，它们建议在类的外部不直接访问，但可以从子类中访问。受保护的属性是一种更宽松的访问限制，用于指示这些属性应该被视为受保护的。</li></ol><p><code>__slots__</code> 是一个特殊的类属性，用于限制类的实例可以拥有的属性。 通过使用 <code>__slots__</code>，你可以告诉Python仅为类的实例分配指定的属性，从而节省了内存空间。当你知道类的实例只需要固定的一组属性时，使用 <code>__slots__</code> 可以提高性能。 下面是一个示例，演示了如何使用 <code>__slots__</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    __slots__ = (<span class="string">&quot;attribute1&quot;</span>, <span class="string">&quot;attribute2&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value1, value2</span>):</span><br><span class="line">        self.attribute1 = value1</span><br><span class="line">        self.attribute2 = value2</span><br><span class="line"></span><br><span class="line">obj = MyClass(<span class="string">&quot;Value 1&quot;</span>, <span class="string">&quot;Value 2&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(obj.attribute1)</span><br><span class="line"><span class="built_in">print</span>(obj.attribute2)</span><br><span class="line"></span><br><span class="line">obj.attribute3 = <span class="string">&quot;Value 3&quot;</span>  <span class="comment"># 无法为属性3分配内存，会引发 AttributeError</span></span><br></pre></td></tr></table></figure><p>在上面的示例中，我们定义了一个名为 MyClass 的类，并使用 <code>__slots__</code> 属性指定了类的实例只能拥有 attribute1 和 attribute2 这两个属性。 在类的 <code>__init__</code>方法中，我们为这两个属性赋予了初始值。 创建 MyClass 的实例 obj 后，我们可以访问这两个属性的值。 然而，当我们尝试为 obj 的 attribute3 属性赋值时，会引发 AttributeError 异常。这是因为 <code>__slots__</code> 属性限制了实例只能拥有 attribute1 和 attribute2 这两个属性，无法为其他属性分配内存。 需要注意的是，<code>__slots__</code> 是一个类属性，而不是实例属性。它仅对类的实例起作用，不对类本身起作用。 使用 <code>__slots__</code> 可以有效地减少实例所占用的内存空间，但需要注意选择适当的属性列表，确保不会限制过多或过少的属性。</p><p>动态存取属性</p><ol><li>点号赋值</li><li>getattr()、 setattr()</li><li>使用字典： <code>obj.__dict__[&#39;name&#39;] = &#39;John&#39;</code></li></ol><p>zip函数 拉链</p><p>鸭子类型是一种动态类型系统的概念，它强调在编程中关注对象的行为而不是具体的类型。根据鸭子类型的原则，只要一个对象具有特定的方法或属性，那么它就可以被视为具有相同的行为，而不需要显式地指定相同的类型。 在Python中，鸭子类型编程可以通过以下方式实现： 1. 不依赖具体的类型：编写代码时，不需要关注对象的具体类型，而是关注对象是否具有所需的方法或属性。例如，如果一个对象具有read()和write()方法，那么它可以被当作文件对象来使用，而不需要是file类型的实例。 2. 使用try-except语句：在使用某个方法或属性之前，可以使用try-except语句来捕获可能的异常。如果对象具有所需的方法或属性，那么代码将正常执行；如果对象没有所需的方法或属性，那么会抛出异常，可以在except块中处理该异常。 以下是一个简单的示例，演示了鸭子类型编程的概念</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">process_data</span>(<span class="params">obj</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        obj.read()</span><br><span class="line">        obj.process()</span><br><span class="line">        obj.write()</span><br><span class="line">    <span class="keyword">except</span> AttributeError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;对象不具有所需的方法或属性&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileObject</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">read</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;读取文件&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;处理数据&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">write</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;写入文件&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DatabaseObject</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">read</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;读取数据库&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;处理数据&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">write</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;写入数据库&quot;</span>)</span><br><span class="line"></span><br><span class="line">file_obj = FileObject()</span><br><span class="line">database_obj = DatabaseObject()</span><br><span class="line"></span><br><span class="line">process_data(file_obj)  <span class="comment"># 输出: 读取文件、处理数据、写入文件</span></span><br><span class="line">process_data(database_obj)  <span class="comment"># 输出: 读取数据库、处理数据、写入数据库</span></span><br><span class="line">process_data(<span class="string">&quot;Hello&quot;</span>)  <span class="comment"># 输出: 对象不具有所需的方法或属性</span></span><br></pre></td></tr></table></figure><p>在Python中，可以通过子类化内置类型来创建自定义的数据类型。内置类型，如list、dict、str等，可以作为基类来定义子类，从而扩展或定制其行为。 以下是一个简单的示例，演示了如何子类化内置类型list：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyList</span>(<span class="title class_ inherited__">list</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, *args</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(*args)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">append</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Appending item:&quot;</span>, item)</span><br><span class="line">        <span class="built_in">super</span>().append(item)</span><br><span class="line"></span><br><span class="line">my_list = MyList([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(my_list)  <span class="comment"># 输出: [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line">my_list.append(<span class="number">4</span>)  <span class="comment"># 输出: Appending item: 4</span></span><br><span class="line"><span class="built_in">print</span>(my_list)  <span class="comment"># 输出: [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><p>需要注意的是，子类化内置类型有一些限制和注意事项。例如，某些内置类型的行为可能是通过C语言实现的，因此无法直接覆盖。此外，一些内置类型具有特殊的方法和行为，需要进行特殊处理。</p><p>多重继承、混入类：略。</p><p>在Python中，TypedDict是一种用于定义具有特定键和值类型的字典的类型提示工具。它是Python 3.8版本中引入的，并且需要使用typing模块进行导入。 TypedDict允许我们为字典的键和值指定类型注解，以提供更严格的类型检查和类型提示。以下是一个示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> TypedDict</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">TypedDict</span>):</span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    age: <span class="built_in">int</span></span><br><span class="line"></span><br><span class="line">person: Person = &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>: <span class="number">30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，我们定义了一个名为Person的TypedDict，它具有两个键：name和age。我们在键后面使用冒号（:）指定了键的类型注解，以及值的类型注解。 然后，我们可以使用Person类型来注解一个字典变量person，并确保该字典的键和值类型与Person类型定义匹配。 TypedDict提供了更强的类型约束，可以在静态类型检查工具（如mypy）或IDE中提供更准确的类型提示。它适用于需要对字典的结构和类型进行严格控制的情况。 需要注意的是，TypedDict只在运行时对字典进行类型检查，而不是在编译时。因此，它不能完全替代编写健壮的输入验证和数据校验代码。</p><p>typing.cast是Python中的一个类型提示工具函数，它用于显式地指定一个对象的类型，并返回该对象的类型转换后的结果。 cast函数的签名如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cast</span>(<span class="params"><span class="built_in">type</span>, value</span>) -&gt; <span class="built_in">type</span>:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>其中，type参数是目标类型，value参数是要进行类型转换的对象。cast函数会将value对象转换为type类型，并返回转换后的结果。 以下是一个示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> cast</span><br><span class="line"></span><br><span class="line">num_str = <span class="string">&quot;123&quot;</span></span><br><span class="line">num_int = cast(<span class="built_in">int</span>, num_str)</span><br><span class="line"><span class="built_in">print</span>(num_int)  <span class="comment"># 输出: 123</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(num_int))  <span class="comment"># 输出: &lt;class &#x27;int&#x27;&gt;</span></span><br></pre></td></tr></table></figure><p>在上面的示例中，我们将字符串num_str通过cast函数转换为整数类型int。尽管num_str的类型是字符串，但我们使用cast函数显式地指定了目标类型为整数，并得到了转换后的结果。 需要注意的是，cast函数并不会进行实际的类型检查或类型转换。它仅仅是一个类型提示工具，用于向静态类型检查器（如mypy）提供额外的信息，以便进行更准确的类型推断和类型检查。 在使用cast函数时，应该谨慎使用，并确保对象的实际类型与指定的目标类型是兼容的，以避免运行时错误。</p><p>在Python中，我们可以使用泛化类（Generic Class）来实现具有通用性的类，以便在不同的类型上使用相同的代码。泛化类可以与类型参数一起使用，这样我们就可以在类定义中使用这些参数来表示不确定的类型。 以下是一个示例，展示如何使用泛化类来实现一个通用的堆栈类：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> TypeVar, <span class="type">Generic</span></span><br><span class="line"></span><br><span class="line">T = TypeVar(<span class="string">&#x27;T&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span>(<span class="type">Generic</span>[T]):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.items = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, item: T</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.items.append(item)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; T:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.is_empty():</span><br><span class="line">            <span class="keyword">return</span> self.items.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> IndexError(<span class="string">&quot;Stack is empty&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.items) == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.items)</span><br></pre></td></tr></table></figure><p>在上面的示例中，我们使用typing模块中的TypeVar来定义一个类型变量T。然后，在类定义中使用Generic[T]来表示这是一个泛化类，并且T是一个类型参数。 在类的方法中，我们可以使用类型参数T来表示不确定的类型。例如，在push方法中，我们接受一个类型为T的参数，并将其添加到堆栈中。在pop方法中，我们使用类型参数T来指定返回值的类型。 使用泛化类时，我们可以在实例化类时指定具体的类型，或者让类型推断机制自动推断类型。以下是一些示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stack = Stack[<span class="built_in">int</span>]()  <span class="comment"># 实例化一个整数类型的堆栈</span></span><br><span class="line">stack.push(<span class="number">1</span>)</span><br><span class="line">stack.push(<span class="number">2</span>)</span><br><span class="line">stack.push(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(stack.pop())  <span class="comment"># 输出: 3</span></span><br><span class="line"><span class="built_in">print</span>(stack.size())  <span class="comment"># 输出: 2</span></span><br><span class="line"></span><br><span class="line">stack2 = Stack[<span class="built_in">str</span>]()  <span class="comment"># 实例化一个字符串类型的堆栈</span></span><br><span class="line">stack2.push(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">stack2.push(<span class="string">&quot;World&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(stack2.pop())  <span class="comment"># 输出: &quot;World&quot;</span></span><br><span class="line"><span class="built_in">print</span>(stack2.size())  <span class="comment"># 输出: 1</span></span><br></pre></td></tr></table></figure><p>通过使用泛化类，我们可以在不同的类型上使用相同的代码逻辑，从而实现更通用、可重用的类。</p><p>在Python中，运算符重载（Operator Overloading）是指通过特殊的方法（也称为魔术方法或双下划线方法）来定义自定义类型的行为，使其支持标准的运算符操作。 以下是一些常用的运算符重载方法及其对应的运算符：</p><p><code>__add__</code>(self, other): 运算符 + 的重载方法，用于实现两个对象相加的操作。</p><p><code>__sub__</code>(self, other): 运算符 - 的重载方法，用于实现两个对象相减的操作。</p><p><code>__mul__</code>(self, other): 运算符 * 的重载方法，用于实现两个对象相乘的操作。</p><p><code>__div__</code>(self, other): 运算符 / 的重载方法，用于实现两个对象相除的操作。</p><p><code>__eq__</code>(self, other): 运算符 == 的重载方法，用于实现两个对象相等比较的操作。</p><p><code>__lt__</code>(self, other): 运算符 &lt; 的重载方法，用于实现两个对象小于比较的操作。</p><p><code>__gt__</code>(self, other): 运算符 &gt; 的重载方法，用于实现两个对象大于比较的操作。 以下是一个示例，展示如何在自定义类中重载运算符：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(other, Point):</span><br><span class="line">            <span class="keyword">return</span> Point(self.x + other.x, self.y + other.y)</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">isinstance</span>(other, <span class="built_in">int</span>) <span class="keyword">or</span> <span class="built_in">isinstance</span>(other, <span class="built_in">float</span>):</span><br><span class="line">            <span class="keyword">return</span> Point(self.x + other, self.y + other)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&quot;Unsupported operand type for +&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(other, Point):</span><br><span class="line">            <span class="keyword">return</span> self.x == other.x <span class="keyword">and</span> self.y == other.y</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;(<span class="subst">&#123;self.x&#125;</span>, <span class="subst">&#123;self.y&#125;</span>)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用运算符重载</span></span><br><span class="line">p1 = Point(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">p2 = Point(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">p3 = p1 + p2</span><br><span class="line"><span class="built_in">print</span>(p3)  <span class="comment"># 输出: (4, 6)</span></span><br><span class="line"></span><br><span class="line">p4 = p1 + <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(p4)  <span class="comment"># 输出: (6, 7)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(p1 == p2)  <span class="comment"># 输出: False</span></span><br><span class="line"><span class="built_in">print</span>(p1 == Point(<span class="number">1</span>, <span class="number">2</span>))  <span class="comment"># 输出: True</span></span><br></pre></td></tr></table></figure><p>在Python中，iter()是一个内置函数，用于返回一个可迭代对象的迭代器。 可迭代对象是指实现了<code>__iter__</code>()方法或<code>__getitem__</code>()方法的对象。迭代器是一个实现了<code>__iter__</code>()方法和<code>__next__</code>()方法的对象。iter()函数接受一个可迭代对象作为参数，并返回该可迭代对象的迭代器。 以下是iter()函数的语法：</p><p>可迭代对象（Iterable）和迭代器（Iterator）是Python中用于迭代操作的两个重要概念，它们之间有一些区别： </p><ol><li><p>可迭代对象（Iterable）：   </p><ul><li>可迭代对象是指实现了<strong>iter</strong>()方法或<strong>getitem</strong>()方法的对象。</li><li>可迭代对象可以使用for循环进行迭代，也可以使用内置函数iter()将其转换为迭代器。   - 可迭代对象每次迭代都会返回一个新的迭代器。 </li></ul></li><li><p>迭代器（Iterator）：   </p><ul><li>迭代器是指实现了<strong>iter</strong>()方法和<strong>next</strong>()方法的对象。   </li><li>迭代器用于从可迭代对象中逐个获取元素，每次调用<strong>next</strong>()方法返回迭代对象中的下一个元素。   </li><li>迭代器具有内部状态，可以记住当前迭代的位置。   </li><li>当迭代器中没有更多的元素可供获取时，调用<strong>next</strong>()方法会引发StopIteration异常。<br>下面是一个示例，展示可迭代对象和迭代器的区别：</li></ul></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SentenceIterator</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, words</span>):</span><br><span class="line">        self.words = words</span><br><span class="line">        self.index = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 有了这个函数才是迭代器</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            word =  self.words[self.index]</span><br><span class="line">        <span class="keyword">except</span> IndexError:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration()</span><br><span class="line">        self.index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> word</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sentence</span>:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;实现一个类，传入一个句子，在使用for迭代的时候，每次返回这个句子的单词（空格划分）&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val:<span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.words = val.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;每次迭代都返回新的返回迭代器，有了这个方法才是可迭代对象&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> SentenceIterator(self.words)</span><br><span class="line">    </span><br><span class="line">sentence = Sentence(<span class="string">&quot;I&#x27;m a Person.&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> sentence:</span><br><span class="line">    <span class="built_in">print</span>(word)</span><br></pre></td></tr></table></figure><p>生成器（Generator）是一种特殊的迭代器，它可以使用函数和yield语句来定义。生成器函数可以逐个产生元素，而不需要一次性生成所有元素。 </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">countdown</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">yield</span> n</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建生成器对象</span></span><br><span class="line">generator = countdown(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用生成器逐个获取元素</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(generator))  <span class="comment"># 输出: 5</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(generator))  <span class="comment"># 输出: 4</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(generator))  <span class="comment"># 输出: 3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(generator))  <span class="comment"># 输出: 2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(generator))  <span class="comment"># 输出: 1</span></span><br><span class="line"><span class="comment"># print(next(generator))  # 引发 StopIteration 异常</span></span><br></pre></td></tr></table></figure><p>在上述示例中，我们定义了一个生成器函数countdown()，它使用while循环和yield语句逐个产生元素。我们通过调用生成器函数来创建一个生成器对象generator。 然后，我们使用next()函数逐个获取生成器中的元素。每次调用next()函数时，生成器函数会从上次暂停的位置继续执行，直到遇到下一个yield语句。 需要注意的是，当生成器中没有更多的元素可供获取时，再次调用next()函数会引发StopIteration异常。 生成器的一个重要特点是它们在迭代过程中保持状态，而不是一次性生成所有元素。这使得生成器非常适合处理大量数据或无限序列，因为它们只在需要时产生元素，从而节省了内存和计算资源。 除了使用生成器函数创建生成器之外，还可以使用生成器表达式来创建生成器。生成器表达式与列表推导式类似，但使用圆括号而不是方括号。 以下是使用生成器表达式创建生成器的示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用生成器表达式创建生成器对象</span></span><br><span class="line">generator = (num <span class="keyword">for</span> num <span class="keyword">in</span> numbers <span class="keyword">if</span> num % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用生成器逐个获取元素</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(generator))  <span class="comment"># 输出: 2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(generator))  <span class="comment"># 输出: 4</span></span><br><span class="line"><span class="comment"># print(next(generator))  # 引发 StopIteration 异常</span></span><br></pre></td></tr></table></figure><p>在上述示例中，我们使用生成器表达式(num for num in numbers if num % 2 == 0)创建了一个生成器对象generator。该生成器对象会逐个产生列表numbers中满足条件的偶数。</p><p>在Python中，上下文管理器（Context Manager）是一种用于管理资源的对象，它定义了在进入和退出特定代码块时要执行的操作。上下文管理器通常用于确保资源的正确分配和释放，例如打开和关闭文件、获取和释放锁等。 上下文管理器可以使用两种方式来实现：通过类实现和通过装饰器实现。 1. 类实现上下文管理器：   - 通过定义一个类，并在类中实现<code>__enter__</code>()和<code>__exit__</code>()方法来创建上下文管理器。   - <code>__enter__</code>()方法在进入代码块前执行，通常用于获取资源或执行必要的准备工作，并将资源返回给调用者。   - <code>__exit__</code>()方法在退出代码块时执行，通常用于释放资源或执行清理操作。   - 如果在代码块中发生异常，异常会被传递给<code>__exit__</code>()方法处理，可以在<code>__exit__</code>()方法中进行异常处理和日志记录等操作。 以下是一个使用类实现上下文管理器的示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 模拟 Python 的打开文件、关闭文件操作</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Filemanager</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, mode</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;calling __init__ method&#x27;</span>)</span><br><span class="line">        self.name = name</span><br><span class="line">        self.mode = mode</span><br><span class="line">        self.file = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;caling __enter__ method&#x27;</span>)</span><br><span class="line">        self.file = <span class="built_in">open</span>(self.name, self.mode)</span><br><span class="line">        <span class="keyword">return</span> self.file</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, exc_type, exc_val, exc_tb</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;caling __exit__ method&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> self.file:</span><br><span class="line">            self.file.close</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Filemanager为上下文管理器</span></span><br><span class="line"><span class="comment"># with Filemanager(&#x27;test.txt&#x27;, &#x27;w&#x27;) as f 是上下文表达式，f为资源对象 </span></span><br><span class="line"><span class="keyword">with</span> Filemanager(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;ready to write to file&#x27;</span>)</span><br><span class="line">    f.write(<span class="string">&#x27;Hello World&#x27;</span>)</span><br></pre></td></tr></table></figure><p>exit方法中的参数exc_type、exc_val、exc_tb分别表示exception type、exception value、traceback。</p><p>装饰器实现上下文管理器：</p><ul><li>通过使用@contextlib.contextmanager装饰器和生成器函数来创建上下文管理器。   </li><li>在生成器函数内部，使用yield语句将控制权暂时交给调用者，并在yield语句前后执行进入和退出代码块的操作。   </li><li>调用者可以使用with语句来使用上下文管理器，而不需要手动调用<strong>enter</strong>()和<strong>exit</strong>()方法。 以下是一个使用装饰器实现上下文管理器的示例：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> contextmanager</span><br><span class="line"></span><br><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">file_manager</span>(<span class="params">name, mode</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        f = <span class="built_in">open</span>(name, mode)</span><br><span class="line">        <span class="keyword">yield</span> f</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        f.close()</span><br><span class="line">        </span><br><span class="line"><span class="keyword">with</span> file_manager(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">&#x27;hello world&#x27;</span>)</span><br></pre></td></tr></table></figure><p>在上述示例中，我们使用@contextmanager装饰器将生成器函数my<em>context<em>manager()转换为上下文管理器。在生成器函数内部，我们使用yield语句将控制权交给调用者，并在yield语句前后执行进入和退出代码块的操作。 然后，我们使用with语句来使用上下文管理器。在with代码块中，我们可以执行需要的操作，而不需要手动调用<strong>enter</strong>()和__exit</em></em>()方法。如果在代码块中发生异常，异常会被传递给生成器函数中的except块处理。 上下文管理器是一种非常有用的编程模式，它可以确保资源的正确分配和释放，提高代码的可读性和健壮性。</p><p>GIL（Global Interpreter Lock）是Python解释器中的一个机制，它是为了保证解释器在多线程环境下的安全性而引入的。GIL的存在导致了Python解释器在同一时间只能执行一个线程的字节码，从而限制了多线程并行执行的能力。</p><p>GIL的作用是在解释器级别上保护Python对象免受并发访问的影响。由于Python的内存管理不是线程安全的，GIL可以确保同一时间只有一个线程能够操作Python对象，从而避免了多线程访问同一对象时可能引发的竞态条件和数据不一致问题。</p><p>由于GIL的存在，Python的多线程并不能真正发挥多核处理器的并行计算能力。在CPU密集型任务中，多线程的性能可能比单线程还要差。然而，在I/O密集型任务中，多线程仍然可以提供一定的性能优势，因为线程可以在等待I/O操作完成时释放GIL，允许其他线程执行。</p><p>需要注意的是，GIL只存在于CPython解释器中，它是Python的参考实现。其他一些Python解释器，如Jython和IronPython，没有GIL，可以实现真正的并行执行。</p><p>为了充分利用多核处理器的并行计算能力，可以考虑使用多进程、异步编程或使用其他语言编写CPU密集型任务的模块。</p><p>下面是几个使用Python实现并发的示例： 1. 多线程并发下载文件：   使用threading模块创建多个线程，每个线程负责下载一个文件。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">download_file</span>(<span class="params">url, filename</span>):</span><br><span class="line">    response = requests.get(url)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        file.write(response.content)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件下载链接列表</span></span><br><span class="line">urls = [</span><br><span class="line">    <span class="string">&#x27;http://example.com/file1.txt&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;http://example.com/file2.txt&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;http://example.com/file3.txt&#x27;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建多个线程进行文件下载</span></span><br><span class="line">threads = []</span><br><span class="line"><span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">    filename = url.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">    thread = threading.Thread(target=download_file, args=(url, filename))</span><br><span class="line">    thread.start()</span><br><span class="line">    threads.append(thread)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待所有线程执行完毕</span></span><br><span class="line"><span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">    thread.join()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>多进程并发处理任务：使用multiprocessing模块创建多个进程，每个进程负责处理一个任务。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_task</span>(<span class="params">task</span>):</span><br><span class="line">    <span class="comment"># 处理任务</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Processing task: <span class="subst">&#123;task&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 任务列表</span></span><br><span class="line">tasks = [<span class="string">&#x27;task1&#x27;</span>, <span class="string">&#x27;task2&#x27;</span>, <span class="string">&#x27;task3&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建多个进程处理任务</span></span><br><span class="line">processes = []</span><br><span class="line"><span class="keyword">for</span> task <span class="keyword">in</span> tasks:</span><br><span class="line">    process = multiprocessing.Process(target=process_task, args=(task,))</span><br><span class="line">    process.start()</span><br><span class="line">    processes.append(process)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待所有进程执行完毕</span></span><br><span class="line"><span class="keyword">for</span> process <span class="keyword">in</span> processes:</span><br><span class="line">    process.join()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>异步并发执行网络请求： 使用asyncio模块和aiohttp库进行异步编程，实现并发执行多个网络请求。     </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">fetch</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> response:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">await</span> response.text()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 网络请求链接列表</span></span><br><span class="line">urls = [</span><br><span class="line">    <span class="string">&#x27;http://example.com/page1&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;http://example.com/page2&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;http://example.com/page3&#x27;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    tasks = [fetch(url) <span class="keyword">for</span> url <span class="keyword">in</span> urls]</span><br><span class="line">    results = <span class="keyword">await</span> asyncio.gather(*tasks)</span><br><span class="line">    <span class="keyword">for</span> result <span class="keyword">in</span> results:</span><br><span class="line">        <span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在Python中，可以使用multiprocessing.Pool类来自建进程池，以实现并发执行多个任务的目的。进程池可以提高任务的执行效率，减少创建和销毁进程的开销。 下面是一个使用multiprocessing.Pool自建进程池的示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_task</span>(<span class="params">task</span>):</span><br><span class="line">    <span class="comment"># 处理任务</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Processing task: <span class="subst">&#123;task&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建进程池，指定进程数量</span></span><br><span class="line">pool = multiprocessing.Pool(processes=<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 任务列表</span></span><br><span class="line">tasks = [<span class="string">&#x27;task1&#x27;</span>, <span class="string">&#x27;task2&#x27;</span>, <span class="string">&#x27;task3&#x27;</span>, <span class="string">&#x27;task4&#x27;</span>, <span class="string">&#x27;task5&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用进程池执行任务</span></span><br><span class="line">pool.<span class="built_in">map</span>(process_task, tasks)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭进程池，阻止新的任务提交</span></span><br><span class="line">pool.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待所有任务执行完毕</span></span><br><span class="line">pool.join()</span><br></pre></td></tr></table></figure><p>在上述示例中，我们首先创建了一个进程池对象pool，通过指定processes参数来设置进程的数量。然后，我们定义了一个任务处理函数process_task，该函数用于处理每个任务。 接着，我们创建了一个任务列表tasks，其中包含了需要处理的多个任务。使用pool.map()方法，我们将任务列表和任务处理函数作为参数传递给进程池，进程池会自动将任务分配给空闲的进程进行处理。 最后，我们关闭进程池并调用pool.join()方法，以等待所有任务执行完毕。 需要注意的是，进程池在执行任务时会自动管理进程的创建和销毁，因此不需要手动创建和销毁进程。进程池内部会维护一个进程队列，根据任务的数量和进程池的大小来动态分配任务给进程</p><p>concurrent.futures是Python标准库中的一个模块，提供了高级的并发编程接口，用于管理并发任务的执行和结果的获取。它建立在threading和multiprocessing模块之上，提供了线程池和进程池的实现。 concurrent.futures模块主要包含以下两个类： 1. ThreadPoolExecutor：线程池执行器，用于管理线程池并发执行任务。 2. ProcessPoolExecutor：进程池执行器，用于管理进程池并发执行任务。 这两个执行器类都实现了Executor接口，提供了一系列方法来提交任务、获取结果、关闭执行器等。 下面是一个使用concurrent.futures模块的示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor, as_completed</span><br><span class="line"><span class="keyword">from</span> concurrent <span class="keyword">import</span> futures </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_task</span>(<span class="params">task</span>):</span><br><span class="line">    <span class="comment"># 处理任务</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Processing task: <span class="subst">&#123;task&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;Result: <span class="subst">&#123;task&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建线程池执行器，指定线程数量</span></span><br><span class="line"><span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">4</span>) <span class="keyword">as</span> executor:</span><br><span class="line">    <span class="comment"># 任务列表</span></span><br><span class="line">    tasks = [<span class="string">&#x27;task1&#x27;</span>, <span class="string">&#x27;task2&#x27;</span>, <span class="string">&#x27;task3&#x27;</span>, <span class="string">&#x27;task4&#x27;</span>, <span class="string">&#x27;task5&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 提交任务到线程池</span></span><br><span class="line">    futures = [executor.submit(process_task, task) <span class="keyword">for</span> task <span class="keyword">in</span> tasks]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取任务结果</span></span><br><span class="line">    <span class="keyword">for</span> future <span class="keyword">in</span> as_completed(futures):</span><br><span class="line">        result = future.result()</span><br><span class="line">        <span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><p>下面是一个使用ThreadPoolExecutor来并发下载文件的示例代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> concurrent.futures</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">download_file</span>(<span class="params">url</span>):</span><br><span class="line">    response = requests.get(url)</span><br><span class="line">    filename = url.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        file.write(response.content)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Downloaded file: <span class="subst">&#123;filename&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件下载链接列表</span></span><br><span class="line">urls = [</span><br><span class="line">    <span class="string">&#x27;http://example.com/file1.txt&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;http://example.com/file2.txt&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;http://example.com/file3.txt&#x27;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建线程池执行器，指定线程数量</span></span><br><span class="line"><span class="keyword">with</span> concurrent.futures.ThreadPoolExecutor() <span class="keyword">as</span> executor:</span><br><span class="line">    <span class="comment"># 提交下载任务到线程池</span></span><br><span class="line">    futures = [executor.submit(download_file, url) <span class="keyword">for</span> url <span class="keyword">in</span> urls]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取任务结果</span></span><br><span class="line">    <span class="keyword">for</span> future <span class="keyword">in</span> concurrent.futures.as_completed(futures):</span><br><span class="line">        result = future.result()</span><br></pre></td></tr></table></figure><p>在上述示例中，我们首先定义了一个download_file函数，用于下载指定URL的文件。该函数使用requests库发送HTTP请求并将响应内容写入本地文件。 然后，我们创建了一个文件下载链接列表urls，其中包含了需要下载的文件的URL。 接下来，我们创建了一个线程池执行器executor，并使用executor.submit()方法将下载任务提交给线程池执行器。submit()方法返回一个Future对象，表示任务的执行结果。 最后，我们使用concurrent.futures.as_completed()函数来迭代Future对象，获取下载任务的结果。as_completed()函数会返回一个迭代器，按照任务的完成顺序返回Future对象。我们通过调用future.result()方法获取每个任务的结果。 需要注意的是，在使用ThreadPoolExecutor时，我们使用了with语句来自动管理执行器的创建和关闭。在with代码块中，我们可以提交任务、获取结果等操作。执行器会在代码块结束时自动关闭，释放资源。</p><p>Python asyncio（异步I/O）是一种基于事件循环的异步编程库，用于编写高效的并发代码。它提供了一种协程（coroutine）的方式，使得编写异步代码更加简洁和可读。 下面是一个简单的示例，展示如何使用asyncio来执行异步任务：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">hello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;World&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(</span><br><span class="line">        hello(),</span><br><span class="line">        hello(),</span><br><span class="line">        hello()</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p>在上述示例中，我们定义了一个hello协程函数，其中包含了一个异步的打印任务和一个异步的等待任务。通过使用await关键字，我们可以在协程中等待其他协程的完成。 然后，我们定义了一个main协程函数，它使用asyncio.gather函数来并发执行多个协程任务。 最后，我们使用asyncio.run函数来运行main协程函数，从而启动整个异步程序。 需要注意的是，asyncio在Python 3.7及以上版本中是一个内置的标准库，可以直接使用。在旧版本的Python中，你可能需要通过pip来安装asyncio库。</p><p>21.2.可异步调用对象<br>在Python中，可以使用asyncio.ensure_future或asyncio.create_task来将可调用对象转换为可异步调用的对象。这样可以在异步程序中并发地执行多个可调用对象。 下面是一个示例代码，展示如何使用asyncio.ensure_future来异步调用可调用对象：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">hello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">world</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;World&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    task1 = asyncio.ensure_future(hello())</span><br><span class="line">    task2 = asyncio.ensure_future(world())</span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(task1, task2)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p>在上述示例中，我们定义了两个异步函数hello和world，它们分别打印”Hello”和”World”。 然后，在main函数中，我们使用asyncio.ensure_future将这两个异步函数转换为可异步调用的对象task1和task2。 最后，我们使用asyncio.gather来并发地执行这两个任务。 另外，从Python 3.7开始，可以使用asyncio.create_task来实现相同的效果：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">hello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">world</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;World&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    task1 = asyncio.create_task(hello())</span><br><span class="line">    task2 = asyncio.create_task(world())</span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(task1, task2)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p>这两种方法都可以将可调用对象转换为可异步调用的对象，以便在异步程序中并发地执行多个任务。</p><p>在Python中，从Python 3.7开始，我们可以使用asyncio库来创建异步上下文管理器。异步上下文管理器是一种特殊的对象，它可以在异步代码中使用async with语法来管理资源的获取和释放。 下面是一个示例代码，展示如何创建和使用异步上下文管理器：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AsyncContextManager</span>:</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">__aenter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Entering async context&quot;</span>)</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Resource&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">__aexit__</span>(<span class="params">self, exc_type, exc_val, exc_tb</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Exiting async context&quot;</span>)</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> AsyncContextManager() <span class="keyword">as</span> resource:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Using resource: <span class="subst">&#123;resource&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p>在上述示例中，我们定义了一个AsyncContextManager类，它实现了<strong>aenter</strong>和<strong>aexit</strong>方法。这两个方法分别在进入和退出异步上下文时被调用。 在<strong>aenter</strong>方法中，我们可以执行一些异步操作来获取资源。在这个示例中，我们使用await asyncio.sleep(1)模拟获取资源的耗时操作，并返回一个表示资源的字符串。 在<strong>aexit</strong>方法中，我们可以执行一些异步操作来释放资源。在这个示例中，我们同样使用await asyncio.sleep(1)模拟释放资源的耗时操作。 然后，在main协程函数中，我们使用async with语法来使用异步上下文管理器。在进入上下文时，会调用<strong>aenter</strong>方法，获取资源并将其赋值给resource变量。然后，在退出上下文时，会调用<strong>aexit</strong>方法，释放资源。 需要注意的是，这个示例使用asyncio.run来运行main协程函数，从而启动整个异步程序。</p><p>在Python中，从Python 3.6开始，我们可以使用<strong>async for</strong>语法来进行异步迭代，以及使用异步可迭代对象来支持异步迭代操作。 异步迭代是指在迭代过程中可以暂停和恢复执行，以便在等待异步操作完成时不阻塞事件循环。 下面是一个示例代码，展示如何进行异步迭代和使用异步可迭代对象：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AsyncIterable</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, data</span>):</span><br><span class="line">        self.data = data</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__aiter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">__anext__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.data:</span><br><span class="line">            <span class="keyword">raise</span> StopAsyncIteration</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)  <span class="comment"># 模拟异步操作</span></span><br><span class="line">        item = self.data.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">for</span> item <span class="keyword">in</span> AsyncIterable([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]):</span><br><span class="line">        <span class="built_in">print</span>(item)</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p>在上述示例中，我们定义了一个AsyncIterable类，它实现了<strong>aiter</strong>和<strong>anext</strong>方法。<strong>aiter</strong>方法返回一个异步迭代器对象，而<strong>anext</strong>方法定义了异步迭代的行为。 在<strong>anext</strong>方法中，我们使用await asyncio.sleep(1)模拟异步操作的等待时间。然后，我们从数据列表中取出一个元素并返回。 然后，在main协程函数中，我们使用async for语法来进行异步迭代。在每次迭代时，会调用<strong>anext</strong>方法来获取下一个元素，并在等待异步操作完成时暂停执行。 需要注意的是，这个示例使用asyncio.run来运行main协程函数，从而启动整个异步程序。</p><p>异步对象的类型提示<br>在Python中，可以使用类型提示来指定异步对象的类型。从Python 3.5开始，引入了typing模块，其中包含了一些用于异步编程的类型提示工具。 下面是一些常用的用于异步对象类型提示的工具： 1. typing.Coroutine: 用于指定协程函数的返回类型。 2. typing.Awaitable: 用于指定一个对象是可等待的，可以使用await关键字来等待其完成。 3. typing.AsyncIterable: 用于指定异步可迭代对象的类型。 4. typing.AsyncIterator: 用于指定异步迭代器的类型。 5. typing.AsyncContextManager: 用于指定异步上下文管理器的类型。 下面是一个示例代码，展示如何使用这些类型提示工具：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Coroutine</span>, Awaitable, AsyncIterable, AsyncIterator, AsyncContextManager</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">foo</span>() -&gt; <span class="type">Coroutine</span>:</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">bar</span>() -&gt; Awaitable[<span class="built_in">int</span>]:</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">baz</span>() -&gt; AsyncIterable[<span class="built_in">int</span>]:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">qux</span>() -&gt; AsyncIterator[<span class="built_in">int</span>]:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">spam</span>() -&gt; AsyncContextManager[<span class="built_in">str</span>]:</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;file.txt&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        content = <span class="keyword">await</span> file.read()</span><br><span class="line">        <span class="keyword">return</span> content</span><br><span class="line"></span><br><span class="line">asyncio.run(foo())</span><br><span class="line">asyncio.run(bar())</span><br><span class="line">asyncio.run(baz())</span><br><span class="line">asyncio.run(qux())</span><br><span class="line">asyncio.run(spam())</span><br></pre></td></tr></table></figure><p>在上述示例中，我们定义了几个异步函数，每个函数使用不同的类型提示来指定返回类型。 在foo函数中，我们使用Coroutine类型提示来指定返回的协程对象的类型。 在bar函数中，我们使用Awaitable类型提示来指定返回的对象是可等待的。 在baz函数中，我们使用AsyncIterable类型提示来指定返回的对象是异步可迭代的。 在qux函数中，我们使用AsyncIterator类型提示来指定返回的对象是异步迭代器。 在spam函数中，我们使用AsyncContextManager类型提示来指定返回的对象是异步上下文管理器。 需要注意的是，这个示例使用asyncio.run来运行每个异步函数，从而启动相应的异步程序。</p><p>使用动态属性访问json数据</p><p>在Python中，可以使用动态属性来访问JSON数据。动态属性允许我们在对象上创建或修改属性，从而实现对JSON数据的灵活访问。 下面是一个示例代码，展示如何使用动态属性访问JSON数据：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JSONData</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, json_str</span>):</span><br><span class="line">        self.data = json.loads(json_str)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">in</span> self.data:</span><br><span class="line">            value = self.data[name]</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(value, <span class="built_in">dict</span>):</span><br><span class="line">                <span class="keyword">return</span> JSONData(json.dumps(value))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(<span class="string">f&quot;&#x27;JSONData&#x27; object has no attribute &#x27;<span class="subst">&#123;name&#125;</span>&#x27;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用动态属性访问JSON数据</span></span><br><span class="line">json_str = <span class="string">&#x27;&#123;&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 30, &quot;address&quot;: &#123;&quot;city&quot;: &quot;New York&quot;, &quot;country&quot;: &quot;USA&quot;&#125;&#125;&#x27;</span></span><br><span class="line">data = JSONData(json_str)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(data.name)                <span class="comment"># 输出: John</span></span><br><span class="line"><span class="built_in">print</span>(data.age)                 <span class="comment"># 输出: 30</span></span><br><span class="line"><span class="built_in">print</span>(data.address)             <span class="comment"># 输出: &lt;__main__.JSONData object at 0x...&gt;</span></span><br><span class="line"><span class="built_in">print</span>(data.address.city)        <span class="comment"># 输出: New York</span></span><br><span class="line"><span class="built_in">print</span>(data.address.country)     <span class="comment"># 输出: USA</span></span><br></pre></td></tr></table></figure><p>后面的略</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;后面几节没整理；没有目录；一些重要章节不是很全，仅仅是介绍。&lt;/p&gt;
&lt;p&gt;Ref：&lt;a href=&quot;https://www.52pojie.cn/thread-1816710-1-1.html&quot;&gt;https://www.52pojie.cn/th</summary>
      
    
    
    
    <category term="Python" scheme="https://guoyujian.github.io/categories/Python/"/>
    
    <category term="基础" scheme="https://guoyujian.github.io/categories/Python/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Python" scheme="https://guoyujian.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python星号用法小结</title>
    <link href="https://guoyujian.github.io/2024/03/06/Python%E6%98%9F%E5%8F%B7%E7%94%A8%E6%B3%95%E5%B0%8F%E7%BB%93/"/>
    <id>https://guoyujian.github.io/2024/03/06/Python%E6%98%9F%E5%8F%B7%E7%94%A8%E6%B3%95%E5%B0%8F%E7%BB%93/</id>
    <published>2024-03-06T09:48:33.000Z</published>
    <updated>2024-03-06T10:20:37.161Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>乘法和乘方</p><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p>用在函数定义的参数时，</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a, *b, **c</span>):</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>在函数的参数中，当以标记一个参数时，表明这个参数是可变参数，具体来讲，用单星号<code>*</code>标记参数，表示其是可变的位置参数，并且以元组的形式将外部的多个位置参数返回给该参数变量，如果用双星号<code>**</code>标记，表示其看是可变的关键词参数，并且会以字典的形式将外部的多组关键词参数和值返回给该参数变量。</p><h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><p>可以用 <code>*</code>运算符把一个可迭代对象拆开作为函数的参数：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">divmod</span>(<span class="number">20</span>, <span class="number">8</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">20</span>, <span class="number">8</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">divmod</span>(*t)</span><br><span class="line">(<span class="number">2</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><h2 id="4"><a href="#4" class="headerlink" title="4"></a>4</h2><p>用星号处理拆包时的部分元素。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b,c,*d=a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="5"><a href="#5" class="headerlink" title="5"></a>5</h2><p>限制关键词参数</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a, *, b</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">func(<span class="number">1</span>, b = <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h2 id="6"><a href="#6" class="headerlink" title="6"></a>6</h2><p>拆包列表或者字典：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">c = [*a, <span class="number">10</span>, * b]  <span class="comment"># [1, 2, 3, 10, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line">d = &#123;<span class="string">&#x27;k1&#x27;</span>: <span class="number">1</span>&#125;</span><br><span class="line">e = &#123;<span class="string">&#x27;k2&#x27;</span>: <span class="number">2</span>&#125;</span><br><span class="line">f = &#123;**d, **e, <span class="string">&#x27;k3&#x27;</span>: <span class="number">3</span>&#125; <span class="comment"># &#123;&#x27;k1&#x27;: 1, &#x27;k2&#x27;: 2, &#x27;k3&#x27;: 3&#125;</span></span><br></pre></td></tr></table></figure><h2 id="More"><a href="#More" class="headerlink" title="More"></a>More</h2><p>…</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1&quot;&gt;&lt;a href=&quot;#1&quot; class=&quot;headerlink&quot; title=&quot;1&quot;&gt;&lt;/a&gt;1&lt;/h2&gt;&lt;p&gt;乘法和乘方&lt;/p&gt;
&lt;h2 id=&quot;2&quot;&gt;&lt;a href=&quot;#2&quot; class=&quot;headerlink&quot; title=&quot;2&quot;&gt;&lt;/a&gt;2&lt;/h2&gt;&lt;</summary>
      
    
    
    
    <category term="Python" scheme="https://guoyujian.github.io/categories/Python/"/>
    
    <category term="基础" scheme="https://guoyujian.github.io/categories/Python/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Python" scheme="https://guoyujian.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python闭包与装饰器总结1</title>
    <link href="https://guoyujian.github.io/2024/03/06/Python%E9%97%AD%E5%8C%85%E4%B8%8E%E8%A3%85%E9%A5%B0%E5%99%A8%E6%80%BB%E7%BB%931/"/>
    <id>https://guoyujian.github.io/2024/03/06/Python%E9%97%AD%E5%8C%85%E4%B8%8E%E8%A3%85%E9%A5%B0%E5%99%A8%E6%80%BB%E7%BB%931/</id>
    <published>2024-03-06T06:49:48.000Z</published>
    <updated>2024-03-06T06:52:58.409Z</updated>
    
    <content type="html"><![CDATA[<h1 id="装饰器基础"><a href="#装饰器基础" class="headerlink" title="装饰器基础"></a>装饰器基础</h1><p>装饰器是可调用的对象，其参数是另一个函数（被装饰的函数）。</p><p>装饰器的一个关键特性是，它们在被装饰的函数定义之后立即运行。这通常是在导入时 （即 Python 加载模块时）</p><p>‍</p><h1 id="变量作用域规则"><a href="#变量作用域规则" class="headerlink" title="变量作用域规则"></a>变量作用域规则</h1><p>对比代码</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">    <span class="built_in">print</span>(b)</span><br><span class="line"></span><br><span class="line">func(<span class="number">3</span>) <span class="comment"># 3 3</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">    <span class="built_in">print</span>(b)</span><br><span class="line">b = <span class="number">9</span></span><br><span class="line"></span><br><span class="line">func(<span class="number">3</span>) <span class="comment"># 3 UnboundLocalError</span></span><br></pre></td></tr></table></figure><p>这不是缺陷，而是设计选择：Python 不要求声明变量，但是假定在函数定义体中赋值的变量是局部变量。</p><p>如果在函数中赋值时想让解释器把 b 当成全局变量，要使用 global 声明:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a</span>):</span><br><span class="line"><span class="keyword">global</span> b</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">    <span class="built_in">print</span>(b)</span><br><span class="line">b = <span class="number">9</span></span><br><span class="line"></span><br><span class="line">func(<span class="number">3</span>) <span class="comment"># 3 3</span></span><br></pre></td></tr></table></figure><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p><strong>闭包指延伸了作用域的函数，其中包含函数定义体中引用、但是不在定义体中定义的非全局变量。</strong></p><p>假如有个名为 avg 的函数，它的作用是计算不断增加的系列值的均值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">10</span>)</span><br><span class="line"><span class="number">10.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">11</span>)</span><br><span class="line"><span class="number">10.5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">12</span>)</span><br><span class="line"><span class="number">11.0</span></span><br></pre></td></tr></table></figure><p>那么它的实现，可以是类的形式：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Average</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.<span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, num:<span class="built_in">int</span></span>) -&gt; <span class="type">Any</span>:</span><br><span class="line">        self.<span class="built_in">sum</span> += num</span><br><span class="line">        self.count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.<span class="built_in">sum</span> / self.count</span><br><span class="line">  </span><br><span class="line">avg = Average()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(avg(<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(avg(<span class="number">11</span>))</span><br><span class="line"><span class="built_in">print</span>(avg(<span class="number">12</span>))</span><br></pre></td></tr></table></figure><p>也可以是高阶函数</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make_averager</span>():</span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">averager</span>(<span class="params">num: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="keyword">nonlocal</span> total, count</span><br><span class="line">        total += num</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> total / count</span><br><span class="line">    <span class="keyword">return</span> averager</span><br><span class="line"></span><br><span class="line">avg = make_averager()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(avg(<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(avg(<span class="number">11</span>))</span><br><span class="line"><span class="built_in">print</span>(avg(<span class="number">12</span>))<span class="keyword">def</span> <span class="title function_">make_averager</span>():</span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">averager</span>(<span class="params">num: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="keyword">nonlocal</span> total, count</span><br><span class="line">        total += num</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> total / count</span><br><span class="line">    <span class="keyword">return</span> averager</span><br><span class="line"></span><br><span class="line">avg = make_averager()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(avg(<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(avg(<span class="number">11</span>))</span><br><span class="line"><span class="built_in">print</span>(avg(<span class="number">12</span>))</span><br></pre></td></tr></table></figure><p>注意<code>nonlocal total, count</code>​：</p><p>因为在Python中并没有要求先声明一个变量，所以Python解释器任务在函数体内，只要对一个变量进行赋值操作，那么这个变量就是局部变量。而 count+=1相当于 count=count+1，对 count 进行了赋值操作，所以Python解释器认为 count 是函数内的局部变量。我们这里需要用nonlocal关键字将局部变量修正为自由变量。</p><p>所谓自由变量就是没有被绑定在局部作用域的变量。</p><p>‍</p><h1 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h1><p>利用闭包实现日志装饰器：对于被装饰函数，每次调用打印调度log</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">logit</span>(<span class="params">func</span>):</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">with_logging</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(func.__name__, <span class="string">&quot;was called&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> with_logging</span><br><span class="line"></span><br><span class="line"><span class="meta">@logit</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">some_func</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;do something&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> x + x</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(some_func(<span class="number">5</span>))</span><br></pre></td></tr></table></figure><p>@符号是一个语法糖，实际的执行是：logit(some_func(x))</p><p>如果装饰器需要带参数，（例如下面的代码实现了将日志保存到指定文件），则需要再加一层：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">logit</span>(<span class="params">log_file = <span class="string">&#x27;out.log&#x27;</span></span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_logit</span>(<span class="params">func</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">with_logging</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">            <span class="built_in">print</span>(func.__name__, <span class="string">&quot;was called&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;save log to <span class="subst">&#123;log_file&#125;</span>&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> with_logging</span><br><span class="line">    <span class="keyword">return</span> _logit</span><br><span class="line"></span><br><span class="line"><span class="meta">@logit(<span class="params">log_file=<span class="string">&#x27;a.log&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">some_func</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;do something&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> x + x</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(some_func(<span class="number">5</span>))</span><br></pre></td></tr></table></figure><h1 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h1><p>《流畅的Python》</p><p>‍</p><h1 id="More"><a href="#More" class="headerlink" title="More"></a>More</h1><p>关于装饰器更多内容还包括：</p><ul><li>[ ] @functools.wraps</li><li>[ ] @lru_cache()和@singledispatch</li><li>[ ] 类装饰器</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;装饰器基础&quot;&gt;&lt;a href=&quot;#装饰器基础&quot; class=&quot;headerlink&quot; title=&quot;装饰器基础&quot;&gt;&lt;/a&gt;装饰器基础&lt;/h1&gt;&lt;p&gt;装饰器是可调用的对象，其参数是另一个函数（被装饰的函数）。&lt;/p&gt;
&lt;p&gt;装饰器的一个关键特性是，它们在被装饰的函数</summary>
      
    
    
    
    <category term="Python" scheme="https://guoyujian.github.io/categories/Python/"/>
    
    <category term="基础" scheme="https://guoyujian.github.io/categories/Python/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Python" scheme="https://guoyujian.github.io/tags/Python/"/>
    
    <category term="闭包" scheme="https://guoyujian.github.io/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>Kruskal算法与力扣1135</title>
    <link href="https://guoyujian.github.io/2024/01/20/Kruskal%E7%AE%97%E6%B3%95%E4%B8%8E%E5%8A%9B%E6%89%A31135/"/>
    <id>https://guoyujian.github.io/2024/01/20/Kruskal%E7%AE%97%E6%B3%95%E4%B8%8E%E5%8A%9B%E6%89%A31135/</id>
    <published>2024-01-20T07:01:01.000Z</published>
    <updated>2024-01-20T07:14:38.602Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍图的最小生成树算法Kruskal 算法。</p><p>阅读之前需要先了解</p><ul><li>图和树数据结构</li><li>加权图、生成树、最小生成树</li><li>Kruskal 算法基本思想</li></ul><p>在Kruskal 算法中，需要保证每次新加入的边不会让树变成图，即不能让树包含环。那么 Union-Find 算法就是帮你干这个事儿的。</p><p>像下面这样添加边会出现环：</p><p><img src="1.png" alt="图片"></p><p>而这样添加边则不会出现环：</p><p><img src="2.png" alt="图片"></p><p>总结一下规律就是：</p><p><strong>对于添加的这条边，如果该边的两个节点本来就在同一连通分量里，那么添加这条边会产生环；反之，如果该边的两个节点不在同一连通分量里，则添加这条边不会产生环</strong>。</p><p>而判断两个节点是否连通（是否在同一个连通分量中）就是 Union-Find 算法的拿手绝活。</p><p>力扣第 1135 题「最低成本联通所有城市」，这是一道标准的最小生成树问题：</p><p><img src="640.png" alt="图片"></p><p>每座城市相当于图中的节点，连通城市的成本相当于边的权重，连通所有城市的最小成本即是最小生成树的权重之和。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"><span class="keyword">from</span> union_find <span class="keyword">import</span> UF  <span class="comment"># 自实现的union-find算法，详略</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minimumCost</span>(<span class="params">self, n: <span class="built_in">int</span>, connections:<span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 城市编号从1开始，所以初始化大小为1+n</span></span><br><span class="line">        uf = UF(n+<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 按权重排序</span></span><br><span class="line">        connections.sort(<span class="keyword">lambda</span> x : x[<span class="number">2</span>])</span><br><span class="line">        mst = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> u, v, weight <span class="keyword">in</span> connections:</span><br><span class="line">            <span class="comment">#如果产生环，则不能加入mst</span></span><br><span class="line">            <span class="keyword">if</span> uf.connected(u, v):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 如果没有产生环，则属于最小生成树</span></span><br><span class="line">            mst += weight</span><br><span class="line">            uf.union(u, v)</span><br><span class="line">        <span class="comment"># 保证所有节点都被连通</span></span><br><span class="line">        <span class="comment"># 按理uf.count() == 1说明所有节点被连通</span></span><br><span class="line">        <span class="comment"># 但因为节点0没有被使用，所以0会额外占用一个连通分量</span></span><br><span class="line">        <span class="keyword">return</span> mst <span class="keyword">if</span> uf.count() == <span class="number">2</span> <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h1><ol><li><a href="https://mp.weixin.qq.com/s/dJ9gqR3RVoeGnATlpMG39w">东哥带你刷图论第五期：Kruskal 最小生成树算法</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文介绍图的最小生成树算法Kruskal 算法。&lt;/p&gt;
&lt;p&gt;阅读之前需要先了解&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;图和树数据结构&lt;/li&gt;
&lt;li&gt;加权图、生成树、最小生成树&lt;/li&gt;
&lt;li&gt;Kruskal 算法基本思想&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在Kruskal 算法中，</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://guoyujian.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="图" scheme="https://guoyujian.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE/"/>
    
    
    <category term="Kruskal 算法" scheme="https://guoyujian.github.io/tags/Kruskal-%E7%AE%97%E6%B3%95/"/>
    
    <category term="力扣1135" scheme="https://guoyujian.github.io/tags/%E5%8A%9B%E6%89%A31135/"/>
    
    <category term="图" scheme="https://guoyujian.github.io/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>Union-Find并查集算法（Python实现）</title>
    <link href="https://guoyujian.github.io/2023/12/24/Union-Find%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%AE%97%E6%B3%95%EF%BC%88Python%E5%AE%9E%E7%8E%B0%EF%BC%89/"/>
    <id>https://guoyujian.github.io/2023/12/24/Union-Find%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%AE%97%E6%B3%95%EF%BC%88Python%E5%AE%9E%E7%8E%B0%EF%BC%89/</id>
    <published>2023-12-24T01:37:00.000Z</published>
    <updated>2023-12-24T01:39:52.705Z</updated>
    
    <content type="html"><![CDATA[<p>这是并查集算法的Python实现：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UF</span>:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    并查集算法</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        初始化数据结构</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 初始化连通分量数量</span></span><br><span class="line">        self._count = n</span><br><span class="line">        <span class="comment"># 初始化双亲节点</span></span><br><span class="line">        self._parent = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="comment"># self.size[x]表示以x为根节点的节点数量</span></span><br><span class="line">        self._size = [<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self, x : <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        find root of x</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">while</span> self._parent[x] != x:</span><br><span class="line">            <span class="comment"># 路经压缩，将当前节点的双亲节点设为其双亲节点的双亲节点</span></span><br><span class="line">            self._parent[x] = self._parent[self._parent[x]]</span><br><span class="line">            x = self._parent[x]</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">union</span>(<span class="params">self, p: <span class="built_in">int</span>, q: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        union p and q</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 找到p和q的根节点</span></span><br><span class="line">        rootP = self.find(p)</span><br><span class="line">        rootQ = self.find(q)</span><br><span class="line">        <span class="keyword">if</span> rootP == rootQ:</span><br><span class="line">            <span class="comment"># 如果根节点相等，则pq本就联通</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 将小集合合并到大集合中，平衡性优化</span></span><br><span class="line">        <span class="keyword">if</span> self._size[rootP] &gt; self._size[rootQ]:</span><br><span class="line"></span><br><span class="line">            self._parent[rootQ] = rootP</span><br><span class="line">            self._size[rootP] += self._size[rootQ]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self._parent[rootP] = rootQ</span><br><span class="line">            self._size[rootQ] += self._size[rootP]</span><br><span class="line">        self._count -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">count</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        返回联通数</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> self._count</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">connected</span>(<span class="params">self, p, q</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        判断pq是否联通</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> self.find(q) == self.find(p)</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>参考：<a href="https://zhuanlan.zhihu.com/p/98406740">https://zhuanlan.zhihu.com/p/98406740</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这是并查集算法的Python实现：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://guoyujian.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="并查集算法" scheme="https://guoyujian.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Python" scheme="https://guoyujian.github.io/tags/Python/"/>
    
    <category term="算法" scheme="https://guoyujian.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="并查集" scheme="https://guoyujian.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
    <category term="UnionFind" scheme="https://guoyujian.github.io/tags/UnionFind/"/>
    
  </entry>
  
  <entry>
    <title>subprocess执行java命令残留进程解决</title>
    <link href="https://guoyujian.github.io/2023/12/07/subprocess%E6%89%A7%E8%A1%8Cjava%E5%91%BD%E4%BB%A4%E6%AE%8B%E7%95%99%E8%BF%9B%E7%A8%8B%E8%A7%A3%E5%86%B3/"/>
    <id>https://guoyujian.github.io/2023/12/07/subprocess%E6%89%A7%E8%A1%8Cjava%E5%91%BD%E4%BB%A4%E6%AE%8B%E7%95%99%E8%BF%9B%E7%A8%8B%E8%A7%A3%E5%86%B3/</id>
    <published>2023-12-07T08:42:12.000Z</published>
    <updated>2023-12-07T08:51:07.103Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题简述"><a href="#问题简述" class="headerlink" title="问题简述"></a>问题简述</h1><blockquote><p>需求是通过Python执行命令java -java springboot-demo.jar</p><p>于是，我使用subprocess.Popen()来启停。但是我发现在关闭子进程后，java进程并没有正确关闭。</p><p>这是由于上面的方法实际原理是另外开启一个cmd命令来运行java -jar命令，后面用popen.terminate()也只能关闭cmd的命令，cmd命令被kill掉后，java进程由系统来托管，从而导致java进程并没有正确关闭。</p></blockquote><h1 id="Bug复现"><a href="#Bug复现" class="headerlink" title="Bug复现"></a>Bug复现</h1><p>执行代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"><span class="comment"># 执行java -jar</span></span><br><span class="line">t = subprocess.Popen([<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;springboot-demo.jar&quot;</span>])</span><br><span class="line"><span class="comment"># Popen是异步的，所以需要等待几秒，再关闭</span></span><br><span class="line">time.sleep(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 关闭子进程</span></span><br><span class="line">t.terminate()</span><br><span class="line"><span class="comment"># 等待关闭结束</span></span><br><span class="line">t.wait()</span><br></pre></td></tr></table></figure><p>发现残留的java进程</p><p><img src="image.png" alt="image"></p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我的解决思路是，稍微修改java代码，在执行java -jar命令后，将java进程id（pid）暴露出来。</p><p>当需要关闭程序时，读取暴露出来的java进程id，使用kill命令，将进程杀死。</p><h2 id="详述"><a href="#详述" class="headerlink" title="详述"></a>详述</h2><p>首先修改java代码，我使用的代码框架是springboot，所以在springboot的启动类上修改如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringbootDemoApplication</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">SpringApplication</span> <span class="variable">application</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpringApplication</span>(SpringbootDemoApplication.class);</span><br><span class="line"><span class="comment">// 获取jar包执行的路径</span></span><br><span class="line"><span class="type">ApplicationHome</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ApplicationHome</span>(SpringbootDemoApplication.class);</span><br><span class="line"><span class="type">File</span> <span class="variable">source</span> <span class="operator">=</span> h.getSource();</span><br><span class="line">System.out.println(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt;&lt; jar 执行目录：&quot;</span> + source.getParentFile().toString() + <span class="string">&quot; &gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">app_pid_file</span> <span class="operator">=</span> source.getParentFile().toString() + <span class="string">&quot;\\app.pid&quot;</span>;</span><br><span class="line">application.addListeners(<span class="keyword">new</span> <span class="title class_">ApplicationPidFileWriter</span>(app_pid_file)); <span class="comment">// 把进程号放到这个文件中</span></span><br><span class="line">application.run();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，</p><ul><li>source.getParentFile().toString()可以获得jar包所在的目录。</li><li>application.addListeners(new ApplicationPidFileWriter(app_pid_file));将在jar包同级目录下生成app.pid的文件，该文件中写入了springboot运行的进程号</li></ul><p>然后修改Python代码</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">JAR_DIR = <span class="string">&#x27;XXX&#x27;</span> <span class="comment"># jar包所在目录</span></span><br><span class="line"><span class="comment"># 执行java -jar</span></span><br><span class="line">t = subprocess.Popen([<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, os.path.join(<span class="string">f&quot;<span class="subst">&#123;JAR_DIR&#125;</span>&quot;</span>, <span class="string">&quot;springboot-demo.jar&quot;</span>])</span><br><span class="line"><span class="comment"># Popen是异步的，所以需要等待几秒，再关闭</span></span><br><span class="line">time.sleep(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 关闭子进程</span></span><br><span class="line">t.terminate()</span><br><span class="line"><span class="comment"># 等待关闭结束</span></span><br><span class="line">t.wait()</span><br><span class="line"><span class="comment"># 关闭java进程</span></span><br><span class="line">app_pid_file_path = os.path.join(JAR_DIR, <span class="string">&quot;app.pid&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> os.path.exists(app_pid_file_path):</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(app_pid_file_path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">pid = f.read()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;正在关闭java 进程, pid： <span class="subst">&#123;<span class="built_in">int</span>(pid)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># 在windows系统下执行杀死进程的命令，其他系统可能命令不同</span></span><br><span class="line">subprocess.run([<span class="string">&quot;cmd&quot;</span>, <span class="string">&quot;/c&quot;</span>, <span class="string">&quot;taskkill&quot;</span>, <span class="string">&quot;/pid&quot;</span>, <span class="string">f&#x27;<span class="subst">&#123;<span class="built_in">int</span>(pid)&#125;</span>&#x27;</span>, <span class="string">&quot;-f&quot;</span>])</span><br><span class="line">os.remove(app_pid_file_path) <span class="comment"># 删除app.pid文件</span></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>无</p><h1 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h1><ol><li><a href="https://blog.csdn.net/skyli114/article/details/127324383">subprocess.Popen执行程序以及关闭进程</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;问题简述&quot;&gt;&lt;a href=&quot;#问题简述&quot; class=&quot;headerlink&quot; title=&quot;问题简述&quot;&gt;&lt;/a&gt;问题简述&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;需求是通过Python执行命令java -java springboot-demo.jar&lt;/p&gt;</summary>
      
    
    
    
    <category term="Python" scheme="https://guoyujian.github.io/categories/Python/"/>
    
    
    <category term="Python" scheme="https://guoyujian.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>CC+Open3d解决大型点云数据加载和计算问题</title>
    <link href="https://guoyujian.github.io/2023/11/29/CC-Open3d%E8%A7%A3%E5%86%B3%E5%A4%A7%E5%9E%8B%E7%82%B9%E4%BA%91%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD%E5%92%8C%E8%AE%A1%E7%AE%97%E9%97%AE%E9%A2%98/"/>
    <id>https://guoyujian.github.io/2023/11/29/CC-Open3d%E8%A7%A3%E5%86%B3%E5%A4%A7%E5%9E%8B%E7%82%B9%E4%BA%91%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD%E5%92%8C%E8%AE%A1%E7%AE%97%E9%97%AE%E9%A2%98/</id>
    <published>2023-11-29T10:28:41.000Z</published>
    <updated>2023-11-29T10:32:24.268Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>雷达扫描的点云数据量往往很大，而其中存在大量不需要的点。</p><p>例如我只需要某个小模型的点云，但雷达将周围的环境也一并扫描进来了，这些环境点云我并不需要。</p><p>现在我需要测量这个小模型的某些属性。（比如长宽）</p><p>此时如果直接在全部点云数据下进行测量，将这些点云加载出来都是一个很大的问题。在我的机器上，使用Cloud Compare载入1.3亿数量级的点云数据直接卡死。</p><p>通常情况下，可以通过体素降采样的方式（例如体素值为2dm）极大缩小点云的数量，但我的需求是希望计算小模型的长宽，其误差不超过5cm。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>因此我的做法如图所示：</p><p><img src="未命名绘图.drawio-20231129175149-u5ss8y9.png" alt="未命名绘图.drawio">​​</p><ol><li>首先为了能够将点云展示出来，我要极大的下采样点云，这里我取参数为0.2（2dm），得到下采样后的点云1</li><li>使用CC加载点云1，并可视化裁剪点云，得到裁剪立方体的参数，包括立方体的中心，长宽高，旋转等</li><li>使用上一步的得到的参数去裁剪原始点云，极大的减少了点云数量</li><li>将裁减后的点云下采样，为了保证精度，这次下采样率为0.01（1cm），得到点云2</li><li>可视化点云2，并进行测量，得到结果。</li></ol><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><h2 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h2><p>编写python脚本并导入到CC，执行该脚本，将点云1加载到CC中</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pycc</span><br><span class="line"><span class="keyword">import</span> cccorelib</span><br><span class="line"></span><br><span class="line">cc = pycc.GetInstance()</span><br><span class="line"><span class="keyword">import</span> open3d <span class="keyword">as</span> o3d</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># open PointCloud with 139032791 points.</span></span><br><span class="line">pcd: o3d.geometry.PointCloud = o3d.io.read_point_cloud(<span class="string">r&quot;origin.pcd&quot;</span>)</span><br><span class="line"><span class="comment"># 调整合适的降采样率</span></span><br><span class="line">pcd = pcd.voxel_down_sample(<span class="number">0.2</span>) <span class="comment">#</span></span><br><span class="line">points = np.asarray(pcd.points)</span><br><span class="line"></span><br><span class="line">xs = points[:, <span class="number">0</span>]</span><br><span class="line">ys = points[:, <span class="number">1</span>]</span><br><span class="line">zs = points[:, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">pc = pycc.ccPointCloud(xs, ys, zs)</span><br><span class="line"><span class="comment"># load</span></span><br><span class="line">cc.addToDB(pc)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h2><p>在CC中对点云进行切片，得到想要的部分点云的裁剪立方体参数。</p><p><img src="image-20231129175946-c305vb2.png" alt="裁剪前"></p><p><img src="image-20231129180213-3vc0ov2.png" alt="裁剪后">​</p><p>如图分别是裁剪前后的效果图，裁剪后的红框里是裁剪立方体的参数。复制下来后面要用到。</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">transformation matrix:</span><br><span class="line">0.987671196461 -0.156546846032 0.000000000000 3.480050563812</span><br><span class="line">0.156546846032 0.987671196461 0.000000000000 -3.573182106018</span><br><span class="line">0.000000000000 0.000000000000 1.000001311302 2.071678161621</span><br><span class="line">0.000000000000 0.000000000000 0.000000000000 1.000000000000</span><br><span class="line"></span><br><span class="line">长宽高：</span><br><span class="line">X: 6.21198273</span><br><span class="line">Y: 13.27857590</span><br><span class="line">Z: 9.57320881</span><br></pre></td></tr></table></figure><h2 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h2><p>由上述的参数可以知道该立方体的中心点是<code>(3.480050563812, -3.573182106018, 2.071678161621)</code>​，旋转矩阵为</p><script type="math/tex; mode=display">\begin{bmatrix}0.987671196461&-0.156546846032&0.000000000000\\0.156546846032&0.987671196461&0.000000000000\\0.000000000000&0.000000000000&1.000001311302\\\end{bmatrix}</script><p>长宽高为<code>(6.21198273, 13.27857590, 9.57320881)</code>​</p><p>因此可以写代码使用open3d来裁剪原始点云：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pcd: o3d.geometry.PointCloud = o3d.io.read_point_cloud(<span class="string">r&quot;origin.pcd&quot;</span>)</span><br><span class="line">   <span class="comment"># 画一个&quot;盒子&quot;，将盒子外的点云去掉，</span></span><br><span class="line">   obx = o3d.geometry.OrientedBoundingBox(</span><br><span class="line">       np.array([<span class="number">3.480050563812</span>, -<span class="number">3.573182106018</span>, <span class="number">2.071678161621</span>]), <span class="comment"># center</span></span><br><span class="line">       np.array([</span><br><span class="line">           [<span class="number">0.987671196461</span>, -<span class="number">0.156546846032</span>, <span class="number">0.000000000000</span>],</span><br><span class="line">           [<span class="number">0.156546846032</span>, <span class="number">0.987671196461</span>, <span class="number">0.000000000000</span>],</span><br><span class="line">           [<span class="number">0.000000000000</span>, <span class="number">0.000000000000</span>, <span class="number">1.000001311302</span>]</span><br><span class="line">       ]), <span class="comment"># rotation</span></span><br><span class="line">       np.array([<span class="number">6.21198273</span>, <span class="number">13.27857590</span>, <span class="number">9.57320881</span>]) <span class="comment"># width, depth, height</span></span><br><span class="line">   )</span><br><span class="line">   pcd_cropped = pcd.crop(obx) <span class="comment"># 裁剪后的点云</span></span><br><span class="line">pcd_cropped = pcd_cropped.voxel_down_sample(<span class="number">0.01</span>) <span class="comment"># 第二次降采样</span></span><br><span class="line">   o3d.io.write_point_cloud(<span class="string">&#x27;cropped.pcd&#x27;</span>, pcd_cropped) <span class="comment"># save </span></span><br></pre></td></tr></table></figure><h2 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h2><p>经过这些步骤后，点云数据量从1.3亿降到了840万。将这个<code>cropped.pcd</code>​拿到CC中打开，并测量。（图略）</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文方法既解决了大规模点云数据加载卡死、操作困难的问题，又能精确得到计算结果。</p><p>不过流程可以再优化，更自动化一些。</p><h1 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h1><p>无</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;雷达扫描的点云数据量往往很大，而其中存在大量不需要的点。&lt;/p&gt;
&lt;p&gt;例如我只需要某个小模型的点云，但雷达将周围的环境也一并扫描进来了，这</summary>
      
    
    
    
    <category term="点云数据处理" scheme="https://guoyujian.github.io/categories/%E7%82%B9%E4%BA%91%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    
    
    <category term="CloudCompare" scheme="https://guoyujian.github.io/tags/CloudCompare/"/>
    
    <category term="Point Cloud" scheme="https://guoyujian.github.io/tags/Point-Cloud/"/>
    
  </entry>
  
  <entry>
    <title>CloudCompare常用操作及Python插件</title>
    <link href="https://guoyujian.github.io/2023/11/28/CloudCompare%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%8F%8APython%E6%8F%92%E4%BB%B6/"/>
    <id>https://guoyujian.github.io/2023/11/28/CloudCompare%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%8F%8APython%E6%8F%92%E4%BB%B6/</id>
    <published>2023-11-28T06:14:52.000Z</published>
    <updated>2023-11-28T06:30:06.169Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>最近在做点云处理相关的工作，这里找到了一个非常好用的开源软件CloudCompare（下称CC）。这里对我的常用操作进行总结，并介绍CC的Python插件，该插件可以实现自定义的点云操作实现，极大地扩展了CC的功能。</p></blockquote><h1 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h1><h2 id="点云按高程赋色"><a href="#点云按高程赋色" class="headerlink" title="点云按高程赋色"></a>点云按高程赋色</h2><p>打开的点云没有颜色，很难看且很难操作，为了让点云更有立体感，可以按高程对点云进行赋色。</p><p><code>Edit -&gt; Colors -&gt; Height Ramp</code></p><p><img src="wps1-20231128113644-3f440qp.jpg" alt="img"></p><p>CC也可以按照其他轴进行赋色</p><p><code>Edit -&gt; Scalar fields -&gt; export coordinate to SF</code>， 选择x/y/z轴</p><p><img src="wps2-20231128113644-ecarnyw.jpg" alt="img"></p><p><img src="wps3-20231128113644-ibdm0ik.jpg" alt="img"></p><h2 id="使用多边形对点云裁剪"><a href="#使用多边形对点云裁剪" class="headerlink" title="使用多边形对点云裁剪"></a>使用多边形对点云裁剪</h2><p><a href="https://blog.csdn.net/qq_32867925/article/details/124187166">https://blog.csdn.net/qq_32867925/article/details/124187166</a></p><h2 id="计算点云中两个点之间的距离"><a href="#计算点云中两个点之间的距离" class="headerlink" title="计算点云中两个点之间的距离"></a>计算点云中两个点之间的距离</h2><p><a href="https://blog.csdn.net/qq_36686437/article/details/122224036">https://blog.csdn.net/qq_36686437/article/details/122224036</a></p><h2 id="下采样"><a href="#下采样" class="headerlink" title="下采样"></a>下采样</h2><p><a href="https://blog.csdn.net/qq_27353621/article/details/124008810">https://blog.csdn.net/qq_27353621/article/details/124008810</a></p><h2 id="统计滤波"><a href="#统计滤波" class="headerlink" title="统计滤波"></a>统计滤波</h2><p><a href="https://blog.csdn.net/qq_36686437/article/details/120011047">https://blog.csdn.net/qq_36686437/article/details/120011047</a></p><p>CC好像没有实现半径滤波，需要自行实现</p><h2 id="计算体积"><a href="#计算体积" class="headerlink" title="计算体积"></a>计算体积</h2><p><a href="https://www.cnblogs.com/codeAndlearn/p/12317673.html">https://www.cnblogs.com/codeAndlearn/p/12317673.html</a></p><p>CC计算的并非是点云的凸包体积，CC好像没有实现凸包体积计算，需要自行实现</p><h2 id="创建球并移动，计算球和球之间的距离"><a href="#创建球并移动，计算球和球之间的距离" class="headerlink" title="创建球并移动，计算球和球之间的距离"></a>创建球并移动，计算球和球之间的距离</h2><p>有时需要计算两点之间的距离，但是这两点虽然代表点云但并不在点云集合中，需要自定义位置。我们可以创建两个球，然后将它们拖动到指定位置，然后再计算距离。</p><p>首先，创建球</p><p><code>File -&gt; Primitive Factory</code>，选择sphere，确定位置和半径</p><p><img src="wps4-20231128113644-n938rmx.jpg?lastModify=1701152207" alt="img"></p><p>然后拖动球：选中球，并点选下图图标。鼠标右键拖动。</p><p><img src="wps5-20231128113644-mbw49ys.jpg" alt="img"></p><p>将两个球拖动到合适的位置，计算距离</p><p><img src="wps6-20231128113644-oc6tpfo.jpg?lastModify=1701152207" alt="img"></p><h2 id="更多操作"><a href="#更多操作" class="headerlink" title="更多操作"></a>更多操作</h2><p>这里有人总结了CC的操作，非常全面。</p><p><a href="https://blog.csdn.net/qq_36686437/article/details/120100839">https://blog.csdn.net/qq_36686437/article/details/120100839</a></p><h1 id="CC-Python插件"><a href="#CC-Python插件" class="headerlink" title="CC-Python插件"></a>CC-Python插件</h1><h2 id="前置条件-Win10"><a href="#前置条件-Win10" class="headerlink" title="前置条件(Win10)"></a>前置条件(Win10)</h2><p>使用该插件需要安装最新版的CC，我安装的版本是2.13</p><p><img src="image-20231128114621-bo1kz5e.png" alt="image"></p><p>在安装时，记得勾选</p><p><img src="image-20231128114706-bwwrkfk.png" alt="image"></p><blockquote><p>Windows是直接带有这个插件的，而MacOS下安装该插件需要自己去编译插件代码并安装。</p><p>这是插件代码的文档：<a href="https://tmontaigu.github.io/CloudCompare-PythonPlugin/">https://tmontaigu.github.io/CloudCompare-PythonPlugin/</a></p><p>包括如何编译源码&amp;Useage</p></blockquote><p>安装完成后，记得更新一下pip：</p><p>进入安装目录下<code>CloudCompare/plugins/Python</code>，执行<code>.\python.exe -m pip install --upgrade pip</code></p><h2 id="使用插件示例"><a href="#使用插件示例" class="headerlink" title="使用插件示例"></a>使用插件示例</h2><p>有些点云文件巨大，加载进来会很慢，我这里先将点云降采样之后才把他加载到CC中。</p><p>为了方便，我需要安装open3d</p><p>打开Python Manager： <code>Plugins -&gt; Python Plugins -&gt; Package Manager</code></p><p><img src="image-20231128120020-x27frq0.png" alt="image">点击install，输入open3d 进行安装。</p><p><img src="image-20231128120130-6obtvph.png" alt="image"></p><p>打开Show REPL： <code>Plugins -&gt; Python Plugins -&gt; Show REPL</code></p><p>红框输入指令</p><p><img src="image-20231128120448-c9cul9e.png" alt="image"></p><p>以下是我输入的指令</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pycc</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> cccorelib</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cc = pycc.GetInstance()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> open3d <span class="keyword">as</span> o3d</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pcd = o3d.io.read_point_cloud(<span class="string">&#x27;C:/Users/Administrator/Desktop/merged_room.pcd&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pcd = pcd.voxel_down_sample(<span class="number">0.5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>points = np.asarray(pcd.points)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>xs = points[:, <span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ys = points[:, <span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>zs = points[:, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pc = pycc.ccPointCloud(xs, ys, zs)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cc.addToDB(pc)</span><br></pre></td></tr></table></figure><p>至此可以看到CC场景中已经加载了点云</p><p><img src="image-20231128120849-90hz4hw.png" alt="image"></p><p>我们可以用插件实现前面CC未实现的诸多功能。更多用法可以参考前文提到的插件的官方文档。</p><h1 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;最近在做点云处理相关的工作，这里找到了一个非常好用的开源软件CloudCompare（下称CC）。这里对我的常用操</summary>
      
    
    
    
    <category term="点云数据处理" scheme="https://guoyujian.github.io/categories/%E7%82%B9%E4%BA%91%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    
    
    <category term="CloudCompare" scheme="https://guoyujian.github.io/tags/CloudCompare/"/>
    
    <category term="Point Cloud" scheme="https://guoyujian.github.io/tags/Point-Cloud/"/>
    
  </entry>
  
  <entry>
    <title>CPU密集型任务的后端实现方法比较总结</title>
    <link href="https://guoyujian.github.io/2023/10/19/CPU%E5%AF%86%E9%9B%86%E5%9E%8B%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%90%8E%E7%AB%AF%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E6%AF%94%E8%BE%83%E6%80%BB%E7%BB%93/"/>
    <id>https://guoyujian.github.io/2023/10/19/CPU%E5%AF%86%E9%9B%86%E5%9E%8B%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%90%8E%E7%AB%AF%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E6%AF%94%E8%BE%83%E6%80%BB%E7%BB%93/</id>
    <published>2023-10-19T14:38:32.000Z</published>
    <updated>2023-10-19T14:49:55.040Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>先介绍下整体系统框架，系统分为前端和后端，二者通过websocket协议进行通信。通过请求数据中的code字段来响应不同的操作。</p><p><img src="前后端通信.png" alt="前后端通信"></p><p><img src="时序图.png" alt="时序图"></p><p><img src="后端处理一次请求的流程图.png" alt="后端处理一次请求的流程图"></p><p>以上介绍整体的软件逻辑。此外，后端使用Python的asyncio来实现异步编程。</p><p>例如，实现将数据插入到数据库并将数据发送到前端：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">insert_data2db(data)</span><br><span class="line">ws_send(websocket, data)</span><br></pre></td></tr></table></figure><p>此时程序是顺序执行的。异步版本如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> insert_data2db(data)</span><br><span class="line"><span class="keyword">await</span> ws_send(websocket, data)</span><br></pre></td></tr></table></figure><p>此时，程序不会等待insert_data2db完成，直接继续执行ws_send方法。两者区别如下草图：</p><p><img src="同步异步.png" alt="同步异步"></p><p>这种异步的方式在IO-Bound Task中好用。但是对于CPU-Bound Task优化效果不大（甚至会有反效果）</p><p>此外，如果后一个操作需要用到前一个操作的结果，这个代码实际是顺序执行的。</p><h1 id="主要代码结构（伪）"><a href="#主要代码结构（伪）" class="headerlink" title="主要代码结构（伪）"></a>主要代码结构（伪）</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">ws_send</span>(<span class="params">websocket, data</span>)</span><br><span class="line"><span class="keyword">await</span> websocket.send(data)</span><br></pre></td></tr></table></figure><p>首先是通过websocket连接将数据发送回前端的通用方法</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">dealPointCloudData</span>(<span class="params">websocket, request_data</span>):</span><br><span class="line">code = request_data[<span class="string">&#x27;code&#x27;</span>]</span><br><span class="line"><span class="keyword">if</span> code == <span class="number">0</span>:</span><br><span class="line"><span class="comment"># 心跳</span></span><br><span class="line"><span class="keyword">await</span> ws_send(websocket, response_heartbeat_data)</span><br><span class="line"><span class="keyword">elif</span> code == <span class="number">1</span>:</span><br><span class="line"><span class="keyword">await</span> func1()</span><br><span class="line"><span class="keyword">elif</span> code == <span class="number">2</span>:</span><br><span class="line"><span class="keyword">await</span> func2(websocket, request_data)</span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure><p>其次，是分发请求的方法dealPointCloudData，它有两个参数，websocket连接和request_data前端发来的数据。</p><p>最后，主程序中会起一个websocket服务器，服务器会将连接发送到dispatch方法，dispatch方法会轮询每一个websocket连接的消息，并交给dealPointCloudData处理。伪代码如下。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">server = websockets.serve(dispatch, ip, port)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">dispatch</span>(<span class="params">websocket_conn</span>):</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">for</span> message <span class="keyword">in</span> websocket:  <span class="comment"># recv message from a websocket client.</span></span><br><span class="line">msg_dict = parse_json(message)</span><br><span class="line"><span class="keyword">await</span> dealPointCloudData(websocket, msg_dict)</span><br></pre></td></tr></table></figure><h1 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h1><p>目前，当code==2时，需要处理一个计算任务。request_data参数中有一个文件夹路径，该计算任务是读取文件夹下的所有文件内容，将文件内容进行merge，最终生成一个完整的文件。流程如下：</p><p><img src="计算流程.png" alt="计算流程"></p><p>伪代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func2</span>(<span class="params">websocket, request_data</span>):</span><br><span class="line">total = init()</span><br><span class="line">file_list = get_file_list(request_data) <span class="comment"># 从request_data中取出文件夹，</span></span><br><span class="line"><span class="keyword">for</span> i, file_path <span class="keyword">in</span> <span class="built_in">enumerate</span>(file_list):</span><br><span class="line">obj = read_file_as_obj(file_path)</span><br><span class="line">total = merge(total, obj)</span><br><span class="line"><span class="keyword">await</span> ws_send(websocket, <span class="string">&#x27;进度：...&#x27;</span>) <span class="comment"># 本次merge结束后向前端发送进度</span></span><br><span class="line">save2file(total)</span><br><span class="line"><span class="keyword">await</span> ws_send(websocket, finish_flag)</span><br></pre></td></tr></table></figure><p>由于func2主要时间花费在一个for循环中， 每次for循环中都有一个耗时的计算任务merge。merge是一个同步方法</p><p>所以func2中虽然使用了await异步编程，但整体来看，还是个同步处理程序。</p><p>这就导致一个严重的问题，就是当单线程执行func2进行长时间计算的时候，新的心跳包请求-响应会被阻塞掉。如图</p><p><img src="心跳响应阻塞.png" alt="心跳响应阻塞"></p><p>如果阻塞的时间过长，前后端就会失去本次连接。</p><p>针对该问题，我尝试了几种解决方法。</p><h1 id="尝试"><a href="#尝试" class="headerlink" title="尝试"></a>尝试</h1><h2 id="1-开启线程执行计算（merge）"><a href="#1-开启线程执行计算（merge）" class="headerlink" title="1 开启线程执行计算（merge）"></a>1 开启线程执行计算（merge）</h2><p>func2函数中开启一个新的线程执行计算，并返回数据。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func2</span>(<span class="params">websocket, request_data</span>):</span><br><span class="line">    t = DealPcdsThread(websocket, other_params)</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure><p>DealPcdsThread线程类的实现如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DealPcdsThread</span>(threading.Thread):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    处理pcd文件夹的线程</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, websocket, request_data</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        file_list = get_file_list(request_data)</span><br><span class="line">        self.websocket = websocket</span><br><span class="line">        self.file_list = file_list </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        asyncio.run(self.merge()) <span class="comment"># 在线程中开启新的事件循环来执行协程函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">self</span>):</span><br><span class="line">        total = init()</span><br><span class="line">file_list = get_file_list(request_data) <span class="comment"># 从request_data中取出文件夹，</span></span><br><span class="line"><span class="keyword">for</span> i, file_path <span class="keyword">in</span> <span class="built_in">enumerate</span>(file_list):</span><br><span class="line">obj = read_file_as_obj(file_path)</span><br><span class="line">total = merge(total, obj)</span><br><span class="line">log.info(<span class="string">f&#x27;...&#x27;</span>)</span><br><span class="line"><span class="keyword">await</span> ws_send(websocket, <span class="string">&#x27;进度：...&#x27;</span>) <span class="comment"># 本次merge结束后向前端发送进度</span></span><br><span class="line">save2file(total)</span><br><span class="line"><span class="keyword">await</span> ws_send(websocket, finish_flag)</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>浏览器控制台日志如图：</p><p><img src="控制台日志.png" alt="控制台日志"></p><p>这说明在处理计算任务时，主线程没有阻塞，心跳包能够正常返回，和预期一致。</p><p>本来问题到这里就解决了，但是在实际测试中又发现了其他问题。</p><h3 id="问题1-前端显示不流畅"><a href="#问题1-前端显示不流畅" class="headerlink" title="问题1: 前端显示不流畅"></a>问题1: 前端显示不流畅</h3><p><img src="合成进度条.gif" alt="合成进度条"></p><p>如图可以看到进度条卡在2.21%后，过了几秒非常迅速的蹦到了40.79%。但是后台的日志打印是“流畅的”，即没有类似的停顿。</p><p>猜测可能是和异步有关，毕竟在<code>await ws_send()</code>​后直接返回了，事件循环选择了某个时间点统一发送这些请求。</p><p>一开始还以为是计算线程失去了CPU的控制权导致的，后来一想可能性不大，一方面占用时间应该在很短的时间，我应该感觉不到，另一方面，后台日志打印流畅。</p><h3 id="问题2-后台报错"><a href="#问题2-后台报错" class="headerlink" title="问题2: 后台报错"></a>问题2: 后台报错</h3><p>在执行计算的过程，出现报错如下图</p><p><img src="报错.png" alt="报错"></p><p>该报错我搜索了很久也没有找到解决方案，在加上该报错不会导致任务失败，也不会有其他影响。所以搁置了。</p><p>该方案是目前最好的解决方案，我也尝试了很多其他解决方案。这里也一并列出。</p><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p>方案2与方案1相同，同样是开启新线程执行合并，只是新的事件循环有主线程创建，而非在新线程中创建。测试这两种方法表现一致。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func2</span>(<span class="params">websocket, request_data</span>):</span><br><span class="line">new_loop: AbstractEventLoop = asyncio.new_event_loop()</span><br><span class="line">    <span class="comment"># 定义</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start_loop</span>(<span class="params">loop: AbstractEventLoop</span>):</span><br><span class="line">        asyncio.set_event_loop(loop)</span><br><span class="line">        loop.run_forever()</span><br><span class="line">    <span class="comment">#通过当前线程开启新的线程启动事件循环</span></span><br><span class="line">    t = threading.Thread(target=start_loop, args= (new_loop,))</span><br><span class="line">    t.start()</span><br><span class="line">    asyncio.run_coroutine_threadsafe(</span><br><span class="line">        DealPcdsThread(websocket, request_data).merge(),</span><br><span class="line">        new_loop</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><p>使用asyncio.run_in_executor将任务放到线程池中运行</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func2</span>(<span class="params">websocket, request_data</span>):</span><br><span class="line"><span class="comment"># 4.4 使用asyncio.run_in_executor将任务放到线程池中运行。效果和4.2一样</span></span><br><span class="line">loop: AbstractEventLoop = asyncio.get_event_loop()</span><br><span class="line"><span class="keyword">await</span> loop.run_in_executor(<span class="literal">None</span>, DealPcdsThread(websocket, request_data).run)</span><br><span class="line"><span class="comment"># await asyncio.to_thread(DealPcdsNoThread.run, loop) # new py3.9</span></span><br></pre></td></tr></table></figure><p>测试说明，这种方法会阻塞主线程，导致心跳包无法及时响应。。</p><h2 id="4"><a href="#4" class="headerlink" title="4"></a>4</h2><p>为了加快计算的速度，想到尝试开启新的进程执行计算。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Process(target=merge, args=(websocket, request_data)).start()</span><br></pre></td></tr></table></figure><p>但是没想到，进程之间传递的Python对象必须可以被序列化（pickle）才可以，而websocket对象不能被序列化，所以这种方法无效。</p><h2 id="5"><a href="#5" class="headerlink" title="5"></a>5</h2><p>最后一种，同样也是开启一个新的线程，不过target传入的是异步计算方法（虽然是异步的，但是内部确是同步的。。。）</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">threading.Thread(target=<span class="keyword">await</span> DealPcdsThread(websocket, request_data).merge()).start()</span><br></pre></td></tr></table></figure><p>这种方法也会阻塞主线程。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>在实验过程中，我发现凡是开启新线程并且新线程中使用新的事件循环来处理发送请求都可以让主线程不阻塞。例如方案1、2</p><p>但是如果只开新线程，而事件循环依然使用主线程loop的话，不能解决主线程阻塞的问题。例如方案3、5</p><h1 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h1><ol><li>用<code>concurrent.futures.ThreadPoolExecutor</code>​替换threading。<code>concurrent.futures.ThreadPoolExecutor</code>​提供了一个高层级接口用来向后台线程推送任务而不会阻塞调用方线程的执行，同时仍然能够在需要时获取任务的结果。</li><li>先读出所有的文件到内存中，放到一个数组里，再开启多进程对这个数组的点云数据进行reduce。利用多核加快合并速度？</li><li>其实我觉得最好的方式是，开启一个线程执行计算任务，线程类中有一个指示进度的变量。在主线程中使用一个协程每隔X秒获取一次进度并将其发送给前端。但是这种方式无法做到实时。</li><li>什么时候Python可以去掉GIL的限制，让这种计算密集型任务能够充分利用多核CPU。。。😢</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;先介绍下整体系统框架，系统分为前端和后端，二者通过websocket协议进行通信。通过请求数据中的code字段来响应不同的操作。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="Python" scheme="https://guoyujian.github.io/categories/Python/"/>
    
    
    <category term="Python" scheme="https://guoyujian.github.io/tags/Python/"/>
    
    <category term="asyncio" scheme="https://guoyujian.github.io/tags/asyncio/"/>
    
    <category term="websocket" scheme="https://guoyujian.github.io/tags/websocket/"/>
    
  </entry>
  
  <entry>
    <title>Python 面试题</title>
    <link href="https://guoyujian.github.io/2023/10/07/Python-%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://guoyujian.github.io/2023/10/07/Python-%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2023-10-07T14:48:30.000Z</published>
    <updated>2023-10-07T14:50:39.894Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记一次Python面试被问到的题</p></blockquote><h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=&#123;<span class="number">1</span>:<span class="number">2</span>,<span class="number">2</span>:<span class="number">3</span>&#125;</span><br><span class="line">b=a</span><br><span class="line">b.pop(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><p>问：a的输出是什么？</p><p>答：<code>&#123;2:3&#125;</code>​</p><h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b=[[]]*<span class="number">2</span>; b[<span class="number">0</span>].append(<span class="number">1</span>); <span class="built_in">print</span>(b)</span><br><span class="line">a=[]; b=[a]*<span class="number">2</span>; b[<span class="number">0</span>].append(<span class="number">1</span>); <span class="built_in">print</span>(b)</span><br><span class="line">a=[]; b=[a, a]; b[<span class="number">0</span>].append(<span class="number">1</span>); <span class="built_in">print</span>(b)</span><br><span class="line">b=[[], []]; b[<span class="number">0</span>].append(<span class="number">1</span>); <span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure><p>问：这四个<code>b</code>​的输出是什么？</p><p>答：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[[1], [1]]</span><br><span class="line">[[1], [1]]</span><br><span class="line">[[1], [1]]</span><br><span class="line">[[1], []]</span><br></pre></td></tr></table></figure><h1 id="3"><a href="#3" class="headerlink" title="3"></a>3</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a=&quot;123&quot;; b=a; b=b[:-1]; </span><br><span class="line">print(a, b)</span><br></pre></td></tr></table></figure><p>问：输出？</p><p>答：<code>123 12</code>​</p><h1 id="4"><a href="#4" class="headerlink" title="4"></a>4</h1><p>比较以下两段代码的执行效率和内存开销</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">res = 1</span><br><span class="line">for num in [1,2,3,4]+[6,7,8,9]:</span><br><span class="line">    res *= num</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import itertools</span><br><span class="line">res = 1</span><br><span class="line">for num in itertools.chain([1,2,3,4], [6,7,8,9]):</span><br><span class="line">    res *= num</span><br></pre></td></tr></table></figure><p><a href="https://docs.python.org/3/library/itertools.html">https://docs.python.org/3/library/itertools.html</a></p><p>答：首先第一个代码需要将两个列表和并为一个列表，而第二段代码是直接遍历两个列表，其次itertools.chain返回的是一个生成器，所以第二个代码的执行效率高，内存开销小。</p><h1 id="5"><a href="#5" class="headerlink" title="5"></a>5</h1><p>What is the difference between tuple() and list[]？loop over tuple and list，which one is more effective？</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if var in [&quot;xxx&quot;, &quot;yyy&quot;]:</span><br><span class="line">if var in (&quot;xxx&quot;, &quot;yyy&quot;):</span><br><span class="line">if var in &#123;&quot;xxx&quot;, &quot;yyy&quot;&#125;:</span><br></pre></td></tr></table></figure><p>Which one above is more efficitive? Note: The value after ‘in’ is a constant.</p><p>时间复杂度：tuple O(?) list O(?) set O(?)</p><p>答：tuple是不可变对象，list是可变对象。由于tuple不可变，所以申请内存为连续定长内存，而list类似于一个链表。</p><p>所以在loop中，tuple is more effective.</p><p><code>if var in &#123;&quot;xxx&quot;, &quot;yyy&quot;&#125;</code>​ is more effective. 因为集合查询时间复杂度为O(1)，tuple和list为O(N)</p><h1 id="6"><a href="#6" class="headerlink" title="6"></a>6</h1><p>Python class中变量名和函数名前缀单下划线和双下划线(后缀没有下划线)分别是什么？For example,</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class A:</span><br><span class="line">   def _method1(): pass   // What&#x27;s the meaning of _</span><br><span class="line">   def __method2(): pass  // What&#x27;s the meaning of __</span><br></pre></td></tr></table></figure><p> What’s the difference among the concepts protected, public, and private?</p><p>答：变量前没有下划线的为public<br>变量前有单下划线为protected，这种变量只能在本类或者其子类中调用（如果你想在其他地方调用也可以，但是会有警告）<br>变量前有双下划线为private，这种变量只能在本类中调用（在其他地方调用会报错）</p><h1 id="7"><a href="#7" class="headerlink" title="7"></a>7</h1><p>在用mongo等非关系型数据库的时候，我们不希望把脏数据、空数据存进数据库，造成后面的混乱。写一个函数(Python3)，删除json dict里面的空数据，包括空dict，空list，空string，None。假设输入的Python dict从合法json读取, 即key必为string, value可以是number/string/list/dict。例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;a&quot;: [1,0,&quot;c&quot;, &#123;&quot;x&quot;:1&#125;]&#125; -&gt; &#123;&quot;a&quot;: [1,0,&quot;c&quot;, &#123;&quot;x&quot;:1&#125;]&#125;</span><br><span class="line">&#123;&quot;a&quot;:[1,None]&#125; -&gt; &#123;&quot;a&quot;: [1]&#125;</span><br><span class="line">&#123;&quot;a&quot;: &#123;&quot;a&quot;:[None, &quot;&quot;, &#123;&#125;,&#123;&quot;x&quot;:None&#125;]&#125;&#125; -&gt; None</span><br></pre></td></tr></table></figure><p>答：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">clean_json</span>(<span class="params">data: (<span class="params"><span class="built_in">dict</span>,<span class="built_in">list</span>,<span class="built_in">int</span>,<span class="built_in">float</span>,<span class="built_in">str</span>,<span class="literal">None</span></span>)</span>):</span><br><span class="line">    <span class="comment"># put your code here</span></span><br><span class="line">    <span class="keyword">if</span> data <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> data == <span class="string">&#x27;&#x27;</span> <span class="keyword">or</span> data == <span class="built_in">dict</span>() <span class="keyword">or</span> data == []:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(data) == <span class="built_in">list</span>:</span><br><span class="line">        data1 = [item <span class="keyword">for</span> item <span class="keyword">in</span> data <span class="keyword">if</span> clean_json(item) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>] <span class="comment"># 复制一份出来</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data1:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> data1</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(data) == <span class="built_in">dict</span>:</span><br><span class="line">        data1 = &#123;k: clean_json(v) <span class="keyword">for</span> k, v <span class="keyword">in</span> data.items() <span class="keyword">if</span> clean_json(v) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>&#125; <span class="comment"># 复制一份出来</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data1:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> data1</span><br><span class="line">    <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure><p>注意：不能直接对原数组or字典作删除操作，会报错！</p><p>例如</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> l:</span><br><span class="line">    <span class="keyword">if</span> l[i] == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">del</span> l[i] <span class="comment"># do not do this</span></span><br></pre></td></tr></table></figure><p>‍</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;记一次Python面试被问到的题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;1&quot;&gt;&lt;a href=&quot;#1&quot; class=&quot;headerlink&quot; title=&quot;1&quot;&gt;&lt;/a&gt;1&lt;/h1&gt;&lt;figure class=&quot;highlight p</summary>
      
    
    
    
    <category term="Python" scheme="https://guoyujian.github.io/categories/Python/"/>
    
    <category term="基础" scheme="https://guoyujian.github.io/categories/Python/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Python" scheme="https://guoyujian.github.io/tags/Python/"/>
    
    <category term="面试" scheme="https://guoyujian.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Python open3d点云相关操作（持续更新）</title>
    <link href="https://guoyujian.github.io/2023/09/16/Python-open3d%E7%82%B9%E4%BA%91%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/"/>
    <id>https://guoyujian.github.io/2023/09/16/Python-open3d%E7%82%B9%E4%BA%91%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/</id>
    <published>2023-09-16T14:26:37.000Z</published>
    <updated>2023-09-16T14:28:04.353Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Prerequisite"><a href="#Prerequisite" class="headerlink" title="Prerequisite"></a>Prerequisite</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">!pip install open3d</span><br><span class="line">!pip install scipy</span><br><span class="line"><span class="keyword">import</span> open3d <span class="keyword">as</span> o3d</span><br><span class="line"><span class="keyword">from</span> scipy.spatial.transform <span class="keyword">import</span> Rotation <span class="keyword">as</span> R</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><h2 id="读和写点云文件"><a href="#读和写点云文件" class="headerlink" title="读和写点云文件"></a>读和写点云文件</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">point_cloud = o3d.io.read_point_cloud(file_path) <span class="comment"># 支持的格式pcd、pts等</span></span><br><span class="line"><span class="comment"># type(point_cloud) == open3d.cpu.pybind.geometry.PointCloud</span></span><br><span class="line"></span><br><span class="line">o3d.io.write_point_cloud(point_cloud, file_path) </span><br></pre></td></tr></table></figure><h2 id="读取点云对象中点的坐标"><a href="#读取点云对象中点的坐标" class="headerlink" title="读取点云对象中点的坐标"></a>读取点云对象中点的坐标</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.asarray(point_cloud.points)</span><br></pre></td></tr></table></figure><h2 id="将点坐标赋值到点云对象"><a href="#将点坐标赋值到点云对象" class="headerlink" title="将点坐标赋值到点云对象"></a>将点坐标赋值到点云对象</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># points = np.array([[...]])</span></span><br><span class="line"></span><br><span class="line">point_cloud.points = o3d.utility.Vector3dVector(points)</span><br></pre></td></tr></table></figure><h2 id="创建点云对象"><a href="#创建点云对象" class="headerlink" title="创建点云对象"></a>创建点云对象</h2><p>创建一个空的点云对象</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pc = o3d.geometry.PointCloud()</span><br></pre></td></tr></table></figure><h2 id="合并点云对象"><a href="#合并点云对象" class="headerlink" title="合并点云对象"></a>合并点云对象</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 直接+</span></span><br><span class="line">pc += point_cloud</span><br></pre></td></tr></table></figure><h2 id="点云平移"><a href="#点云平移" class="headerlink" title="点云平移"></a>点云平移</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">point_cloud.translate(translation)  <span class="comment"># 应用平移,translation 是平移向量</span></span><br></pre></td></tr></table></figure><h2 id="点云旋转"><a href="#点云旋转" class="headerlink" title="点云旋转"></a>点云旋转</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">point_cloud.rotate(rotation_matrix, center = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>))  <span class="comment"># 应用旋转, rotation_matrix是旋转矩阵</span></span><br></pre></td></tr></table></figure><p>这里需要注意第二个参数center是指定旋转中心，如果不传，默认旋转中心是点云的质心。</p><p>而一般来说，旋转中心为原点</p><h2 id="点云上色"><a href="#点云上色" class="headerlink" title="点云上色"></a>点云上色</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">point_cloud.paint_uniform_color([<span class="number">0</span>, <span class="number">0</span>, <span class="number">1.0</span>]) <span class="comment"># 传入的三个值分别是rgb</span></span><br></pre></td></tr></table></figure><h2 id="点云展示"><a href="#点云展示" class="headerlink" title="点云展示"></a>点云展示</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">o3d.visualization.draw_geometries([point_cloud])</span><br></pre></td></tr></table></figure><h2 id="四元数转旋转矩阵"><a href="#四元数转旋转矩阵" class="headerlink" title="四元数转旋转矩阵"></a>四元数转旋转矩阵</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">quaternion = np.array([ori_x, ori_y, ori_z, ori_w])  <span class="comment"># 定义四元数</span></span><br><span class="line">rotation_matrix = R.from_quat(quaternion).as_matrix()</span><br></pre></td></tr></table></figure><p>注意四元数顺序是xyzw，在有些地方顺序是wxyz</p><h2 id="点云下采样"><a href="#点云下采样" class="headerlink" title="点云下采样"></a>点云下采样</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">point_cloud = point_cloud.voxel_down_sample()</span><br></pre></td></tr></table></figure><p>这里需要注意</p><ol><li>需要接收返回值</li><li>下采样是指只保留某一大小立方体内的一个点。voxel_down_sample方法有个默认值参数，为0.05。这个参数就表示立方体的大小，因此这个数越大，下采样的强度越强，保留的点就越少。</li></ol><h2 id="统计滤波"><a href="#统计滤波" class="headerlink" title="统计滤波"></a>统计滤波</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">point_cloud.remove_statistical_outlier(nb_neighbors=<span class="number">20</span>, std_ratio=<span class="number">2.0</span>)</span><br></pre></td></tr></table></figure><p>该方法可以去掉距离点云密集处很远的点。该方法有两个参数</p><ol><li>nb_neighbors允许指定要考虑多少个邻居，以便计算给定点的平均距离。</li><li>std_ratio允许基于跨点云的平均距离的标准偏差来设置阈值级别。此数字越低，过滤器将越具有攻击性。</li></ol><h2 id="筛选点云中的点"><a href="#筛选点云中的点" class="headerlink" title="筛选点云中的点"></a>筛选点云中的点</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># indices_to_keep =[0,1,2...] 点的索引</span></span><br><span class="line">point_cloud = point_cloud.select_by_index(indices_to_keep)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Prerequisite&quot;&gt;&lt;a href=&quot;#Prerequisite&quot; class=&quot;headerlink&quot; title=&quot;Prerequisite&quot;&gt;&lt;/a&gt;Prerequisite&lt;/h2&gt;&lt;figure class=&quot;highlight python&quot;&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Python numpy对三维点的操作汇总（持续更新）</title>
    <link href="https://guoyujian.github.io/2023/09/16/Python-numpy%E5%AF%B9%E4%B8%89%E7%BB%B4%E7%82%B9%E7%9A%84%E6%93%8D%E4%BD%9C%E6%B1%87%E6%80%BB%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/"/>
    <id>https://guoyujian.github.io/2023/09/16/Python-numpy%E5%AF%B9%E4%B8%89%E7%BB%B4%E7%82%B9%E7%9A%84%E6%93%8D%E4%BD%9C%E6%B1%87%E6%80%BB%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/</id>
    <published>2023-09-16T14:04:30.000Z</published>
    <updated>2023-09-16T14:05:50.824Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Prerequisite"><a href="#Prerequisite" class="headerlink" title="Prerequisite"></a>Prerequisite</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><h2 id="将一个列表中的点或者其他对象转换成一个numpy-ndarray对象"><a href="#将一个列表中的点或者其他对象转换成一个numpy-ndarray对象" class="headerlink" title="将一个列表中的点或者其他对象转换成一个numpy.ndarray对象"></a>将一个列表中的点或者其他对象转换成一个numpy.ndarray对象</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">points = np.asarray([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]])</span><br></pre></td></tr></table></figure><h2 id="查看numpy-ndarray的形状"><a href="#查看numpy-ndarray的形状" class="headerlink" title="查看numpy.ndarray的形状"></a>查看numpy.ndarray的形状</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">##  n : numpy.ndarray </span></span><br><span class="line">n.shape </span><br></pre></td></tr></table></figure><h2 id="计算点到原点的欧几里得距离"><a href="#计算点到原点的欧几里得距离" class="headerlink" title="计算点到原点的欧几里得距离"></a>计算点到原点的欧几里得距离</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># points like array([[x1,y1,z1],[x2,y2,z2],[x3,y3,z3]])</span></span><br><span class="line">distances = np.linalg.norm(points, axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><code>np.linalg.norm(x, ord=None, axis=None, keepdims=False)</code>​求范数</p><p>x：是输入的矩阵or向量</p><p>ord：计算的范数类型。ord=2计算L2范数，即欧几里得距离，ord=1计算L1范数。</p><p>axis：轴，axis=0按列计算，axis=1按行计算</p><h2 id="选择欧几里得距离符合一定范围内的点"><a href="#选择欧几里得距离符合一定范围内的点" class="headerlink" title="选择欧几里得距离符合一定范围内的点"></a>选择欧几里得距离符合一定范围内的点</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获得点距离原点的欧几里得距离大于0.1小于70的点索引</span></span><br><span class="line">np.where((distances &gt;= <span class="number">0.01</span>) &amp; (distances &lt;= <span class="number">70</span>))[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#筛选这些点</span></span><br><span class="line">points[np.where((distances &gt;= <span class="number">0.01</span>) &amp; (distances &lt;= <span class="number">70</span>))]</span><br></pre></td></tr></table></figure><p><a href="https://www.delftstack.com/zh/howto/numpy/python-numpy.where-multiple-conditions/#%e5%9c%a8-python-%e4%b8%ad%e4%bd%bf%e7%94%a8-numpylogical_or-%e5%87%bd%e6%95%b0%e5%ae%9e%e7%8e%b0-numpywhere-%e5%a4%9a%e4%b8%aa%e6%9d%a1%e4%bb%b6">https://www.delftstack.com/zh/howto/numpy/python-numpy.where-multiple-conditions/#%e5%9c%a8-python-%e4%b8%ad%e4%bd%bf%e7%94%a8-numpylogical_or-%e5%87%bd%e6%95%b0%e5%ae%9e%e7%8e%b0-numpywhere-%e5%a4%9a%e4%b8%aa%e6%9d%a1%e4%bb%b6</a></p><h2 id="对点进行旋转"><a href="#对点进行旋转" class="headerlink" title="对点进行旋转"></a>对点进行旋转</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 给定一个3*3的旋转矩阵 rotation_matrix， 对点points进行旋转，获得旋转后的点坐标。</span></span><br><span class="line">np.dot(points, rotation_matrix.T)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意这里需要对旋转矩阵做了转置，<strong><em>推导一下</em></strong>​<strong>。</strong></p><p>np.dot矩阵乘法，他的用法是？和np.<code>matmul</code>​的区别？</p><h2 id="对点进行平移"><a href="#对点进行平移" class="headerlink" title="对点进行平移"></a>对点进行平移</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 给定一个平移向量translation_vector， 对点points进行平移，获得旋转后的点坐标。</span></span><br><span class="line">points + translation_vector</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Prerequisite&quot;&gt;&lt;a href=&quot;#Prerequisite&quot; class=&quot;headerlink&quot; title=&quot;Prerequisite&quot;&gt;&lt;/a&gt;Prerequisite&lt;/h2&gt;&lt;figure class=&quot;highlight python&quot;&gt;</summary>
      
    
    
    
    <category term="Python" scheme="https://guoyujian.github.io/categories/Python/"/>
    
    
    <category term="Python" scheme="https://guoyujian.github.io/tags/Python/"/>
    
    <category term="numpy" scheme="https://guoyujian.github.io/tags/numpy/"/>
    
  </entry>
  
  <entry>
    <title>你的项目中有什么亮点？如何回答才能得到面试官的好感</title>
    <link href="https://guoyujian.github.io/2023/09/04/%E4%BD%A0%E7%9A%84%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%9C%89%E4%BB%80%E4%B9%88%E4%BA%AE%E7%82%B9%EF%BC%9F%E5%A6%82%E4%BD%95%E5%9B%9E%E7%AD%94%E6%89%8D%E8%83%BD%E5%BE%97%E5%88%B0%E9%9D%A2%E8%AF%95%E5%AE%98%E7%9A%84%E5%A5%BD%E6%84%9F/"/>
    <id>https://guoyujian.github.io/2023/09/04/%E4%BD%A0%E7%9A%84%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%9C%89%E4%BB%80%E4%B9%88%E4%BA%AE%E7%82%B9%EF%BC%9F%E5%A6%82%E4%BD%95%E5%9B%9E%E7%AD%94%E6%89%8D%E8%83%BD%E5%BE%97%E5%88%B0%E9%9D%A2%E8%AF%95%E5%AE%98%E7%9A%84%E5%A5%BD%E6%84%9F/</id>
    <published>2023-09-04T15:17:53.000Z</published>
    <updated>2023-09-04T15:22:09.604Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>针对本<a href="https://www.bilibili.com/video/BV1DM4y1L7cL/?buvid=9aa5bffff7ad0aee7573c7ed265b7b41&amp;is_story_h5=false&amp;mid=KneIq6dZPkIx5y%2FvWilBwA%3D%3D&amp;p=1&amp;plat_id=116&amp;share_from=ugc&amp;share_medium=iphone&amp;share_plat=ios&amp;share_session_id=B0B2A8E9-DA79-44E5-ADF6-4ECC9B19D812&amp;share_source=WEIXIN&amp;share_tag=s_i&amp;timestamp=1693623913&amp;unique_k=A5vAgCl&amp;up_id=1031543543&amp;vd_source=53d8e50bea64fe70bc50c86af86d28e1">视频</a>做的笔记</p></blockquote><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>请你说一下你项目中的亮点。几乎每个准备去面试的同学都会被这个问题困扰，我羡慕。</p><p>很简单，就是 CRUD 没有亮点怎么办？没有做过分布式的项目，哪有什么亮点，我之前做的都是单体项目，实在想不出有什么亮点，大家对于这个问题的<strong>误解</strong>在于，一定要项目足够好才有亮点。其实面试官在问这个问题的时候是想了解你在项目中的成果和能力，我们可以从几个维度去准备。</p><ol><li>解决复杂问题的能力。你可以描述你在项目中解决过哪一些特别复杂或者有挑战性的问题，可以是技术问题，也可以是业务问题。比如说通过引入 Kafka 这个消息队列，优化了程序的效率，使得我们能够在高峰期处理百万级的消息。</li><li>做了一些提高效率的工作，比如说重构代码，优化数据库查询效率。引入异步线程，优化了代码的效率。开发了一个公共组件，提升了团队的开发效率。比如优化了一个复杂的 MySQL 语句，提高了数据库的查询效率，使得查询效率整体提升了 10 倍。</li><li>突出团队协作和沟通方面的能力。比如说在项目中承担的核心开发或者团队小组长的角色，通过一系列的管理手段，按时完成了项目交付和提高了质量保障等等。比如我带领我的团队完成了这个项目，我负责分配任务，协调团队的成员工作以及解决团队中出现的问题。在我的管理下，我们成功的按时完成了项目，得到了客户的高度评价。</li><li>最后，我们还可以突出学习能力，比如项目里面要用到一个新的技术，这个技术之前没有用过，但是项目交付的时间比较紧，所以我大概花了 3 天时间在网上找了各种资料学习，在实际落地的时候还遇到了一些自己解决不了的问题，后面在 GitHub 的 issue 上找到解决方案，最后按期完成了项目的交付。</li></ol><p>因此，对于项目中的亮点，你们可以从对业务设计的深度思考，问题解决的能力，或者对某个特定技术的深度理解，团队协作沟通等方面去准备，从而让面试官看到你在项目中的思考和总结，而不是一个只会 CRUD的工具人。以上就是我的理解。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;针对本&lt;a href=&quot;https://www.bilibili.com/video/BV1DM4y1L7cL/?buvid=9aa5bffff7ad0aee7573c7ed265b7b41&amp;amp;is_story_h5=false&amp;amp;mi</summary>
      
    
    
    
    
    <category term="面试技巧" scheme="https://guoyujian.github.io/tags/%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>Python asyncio异步编程入门</title>
    <link href="https://guoyujian.github.io/2023/09/03/Python-asyncio%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"/>
    <id>https://guoyujian.github.io/2023/09/03/Python-asyncio%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/</id>
    <published>2023-09-03T09:36:21.000Z</published>
    <updated>2023-09-03T09:40:56.212Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>针对<a href="https://www.bilibili.com/video/BV1oa411b7c9/?spm_id_from=333.337.search-card.all.click&amp;vd_source=53d8e50bea64fe70bc50c86af86d28e1">该视频</a>的一篇笔记</p><p>先决条件：协程、并发</p></blockquote><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>这次讲的是asyncio最新的用法，然后是Python 3. 7 以上才支持的，也是推荐大家学新不学旧。</p><p>asyncio并不能提升你的运算速度，它比较适合处理那些需要等待的任务^（应用场景）^，最典型的就是网络的通讯</p><p>那 asyncio的<strong>运算核心</strong>其实就是一个event loop，它就像一个大脑，它面对着很多可以执行的任务，然后决定执行哪个任务。那在 Python 的asyncio里，同时执行的任务只能有一个，它不存在系统级的上下文切换，它跟线程不一样，它需要每一个任务主动告诉event loop，我这边结束了，你可以让别的任务开始了。因此它有一个<strong>好处</strong>，就是不存在竞争冒险这样的问题，你可以明确的知道我每一个任务什么时候停止运算了。</p><p>那想要使用asyncio第一件事就是理解什么叫coroutine，什么叫task。</p><p>coroutine在 Python 的语境里，我们一般会指两种东西，一个是coroutine function，一个是coroutine object。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>( <span class="string">&#x27;world&#x27;</span>)</span><br><span class="line"></span><br><span class="line">coro = main()</span><br></pre></td></tr></table></figure><p>这个 async def main 就是一个coroutine function。Python 里面所有async def main开头的东西都叫coroutine function，它定义了一个 coroutine 的过程。那 Python 一般的函数，当我们调用它的时候，它返回的是这个函数的返回值，对不对？但是所有的 coroutine function，当你调用的时候，它返回的是一个coroutine object，它的本质跟生成器函数有些像。</p><p>就是当你在调用main的时候，它并不会运行 main 里面的程序，它只会返回一个coroutine object。</p><p>好，那怎么运行coroutine的代码？我们需要<strong>两件事</strong>，第一是进入async的模式，也就是进入这个 event loop，开始控制整个程序的状态。第二就是把coroutine变成task。</p><p>我们先说如何进入 async 模式，那我们正常写Python代码运行的时候，如果我们管它叫 synchronized 模式的话，那么在 synchronize 模式下切换到 asynchronized 模式，切换到让这个 event loop 开始控制一切。基本上我们只用一个入口函数叫做asyncio.run，那 asyncio.run，它的参数是一个coroutine，它会做两件事儿，第一它会建立起这个 event loop，第二它会把这个 coroutine 变成这个 event loop 里面的一个task，那 event loop 建立之后，他就会去找哪个 task 可以执行，那当然只有一个task，所以它就会开始运行 run 给进来的这个coroutine。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>( <span class="string">&#x27;world&#x27;</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p>我们试一下，大家可以看到它先 print 了hello，然后等了 1 秒钟，然后 print 了world，那这个asyncio.run就是我们从 synchronize 模式变到 asynchronize 模式的入口，它的参数是一个coroutine。</p><p>那只有一个 task 是没有什么意思的，对不对？我们刚才也说过， event loop 的核心是它有很多很多个task，然后它来决定哪个 task 要运行。所以我们很重要的一件事情是，当我们已经处于 async 模式下的时候，我们如何增加task？接下来我们就介绍几个把coroutine变成task，让它可以排队执行的方法。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">say_after</span>(<span class="params">delay, what</span>):</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(delay)</span><br><span class="line">    <span class="built_in">print</span>(what)</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;started at <span class="subst">&#123;time.strftime(<span class="string">&#x27;%x&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> say_after(<span class="number">1</span>, <span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> say_after(<span class="number">2</span>,<span class="string">&quot;world&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;finished at <span class="subst">&#123;time.strftime(<span class="string">&#x27;%x&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">        </span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p>大家看，我们有一个 say_after 函数，它显然是一个coroutine，对不对？它前面是async def，那实际上asyncio.sleep，它返回的东西也是一个 core routine，那这里就涉及到了<strong>第一个把coroutine变成 task 的方法</strong>，就是用await。</p><p>那么当你 await 一个<strong>coroutine</strong>的时候（上述代码第8行），发生了如下几件事，第一，这个coroutine被包装成一个task，并且被告诉了 event loop，说这块儿有一个新的task。第二，它会告诉 event loop，我现在这个 task （main）需要等到say_after task 完成之后，我才能继续它，建立了这么一个依赖关系。第三，它会 yield 出去，也就是它会告诉 event loop，我这个 task 现在干不了了，你先让别的 task 干活去吧。最后当 event loop 再次安排它运行的时候，它会把 say after 这个say_after 里面真正的返回值拿出来保存起来。当然现在我们这里await前面没有写，因为我们的 say after 是没有返回值的，好，那我们运行一下这段程序，我们可以看到差不多间隔一秒 print 一个hello，然后在两秒钟之后 print 了一个world。</p><p>我们来还原一下整个过程发生了一个什么事情。首先 asyncio.run把这个main作为一个 task 给放到了 event loop 里。 event loop 寻找task，他发现只有一个 task main，然后他就开始让这个 task main运行。may 你在运行的时候，首先 print 了一个 start at，然后它运行了 say_after 这个coroutine function，得到了一个coroutine object。await 把这个coroutine object变成了一个task，放回了 event loop 里，同时告诉 event loop 我需要等待它，然后把控制权交还给了 event loop。</p><p>现在 event loop 里面有两个task，一个是main，一个是这个 say_after，但是main运行不了， main说我要等这个 say after，那event loop，就让这个say_after先运行。</p><p><code>await asyncio.sleep(delay)</code>​ 这里其实做了一个很相似的事情，也是把它变成了一个task，然后告诉 event loop 说我得等这个 sleep 完成了我才能运行。然后 await 又把这个控制权转回给了 event loop。</p><p>event loop 一看现在有三个 task 对不对？有一个main，有一个 say_after，还有一个sleep，那这个 sleep 会告诉 event loop 说我一秒钟之后我就好了，所以这个 event loop 就等了一秒钟。一秒钟之后这个 sleep 就完成了。然后 event loop 看现在有两个task，一个main，一个 say after，这个 main 要等 say_after，但是这个 say after 等的东西已经完成了，于是 event loop 就说 say_after 你来运行吧，然后 say_after printed 一个what，然后 say_after 也完成了。于是又把控制权交还给 event loop。</p><p>event loop 一看，哎，现在只有一个 task 了，就成 main 了，然后再把控制权给main，这个时候 main就把第一个 say_after 完成了，然后再做第二个 say_after 做同样的事，又等了 2 秒之后它完成，所以整个过程用了 3 秒。</p><p>那在这个过程中，所有控制权的返回都是显式的，就是<strong>​ event loop 并没有办法强行的从一个 task 里边拿回控制权，必须要这个 task 主动把控制权交回去。</strong>交回去的方式有两种，第一个是await，会交回，第二个，当这个函数运行完毕之后，它会交回。所以说如果你有一个 task 里面有一个死循环，你的整个 event loop 就卡死了。</p><p>好，那刚才的运行过程中你可能发现了一个问题，对不对？这个 hello 要等 1 秒，这个 world 要等 2 秒，它俩为啥不能一起等呢？这就应该是我们协程的意义，对不对？在你第一个 hello 等 1 秒的时候，为什么这个 event loop 不能直接让这个 world 运行，然后你俩一起等着， 2 秒之后不就结束了吗？那这个呢？就是我们直接用 await 把一个 cooutine 变成 task 可能遇到的问题，因为 await 需要做的事太多了，它要变成task，它变成 task 之后会主动把控制权交出去，还需要等，这样后面的代码必须要等到它完成之后才能变成一个task。  </p><p>那为了解决这个问题， asyncio给我们提供了 create task 函数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">say_after</span>(<span class="params">delay, what</span>):</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(delay)</span><br><span class="line">    <span class="built_in">print</span>(what)</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    task1 = asyncio.create_task(say_after(<span class="number">1</span>,<span class="string">&quot;hello&quot;</span>))</span><br><span class="line">    task2 = asyncio.create_task(say_after(<span class="number">2</span>,<span class="string">&#x27;world&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;started at <span class="subst">&#123;time.strftime( <span class="string">&#x27;%x&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> task1</span><br><span class="line">    <span class="keyword">await</span> task2</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;finished at <span class="subst">&#123;time.strftime(<span class="string">&#x27;%x&#x27;</span>)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>我们看这里用到的 create_task 函数，这个函数的参数也是一个coroutine。依然记住这个 say_after 调用之后返回的是一个coroutine，它不会运行任何 coroutine 里面的代码，那这个 create_task 函数会把这个coroutine变成一个task，并且把这个 task 注册到 event loop 里面。也就是说它分担了刚才 await 的一部分功能，它把它包装成了一个task，然后告诉 event loop 说OK，这个 task 已经可以开始执行了，但是现在 event loop 并没有办法执行这个task，因为控制权还在 main 的手里，对不对？那这个时候 main 趁着自己有控制权，他就做了第二个task。</p><p>task 2 也是告诉 main 这还有一个新的task，这叫 say_after 2 也可以运行了，那在这儿之后他才开始 await task_1 await task_2 那我们之前说过 await 后面是一个coroutine的时候，它有那么多个功能对不对？把它变成一个task，然后把控制权交出去，等它拿返回值。那当 await 后面是一个 task 而不是一个coroutine 的时候，它就省略了把 coroutine变成 task 这一步，它就只是告诉 event loop 我需要这个 task 完成，我把控制权交还给你，并且在控制权回来的时候，从这个 task 里面提取所需要的返回值。</p><p>好，我们跑一下这个程序试一下。我们看这一次这个程序就只用了 2 秒钟，因为当它 await task 1的时候， event loop 里面实际上已经有了 3 个task，是 main、task 1和 task 2。当 task 1跟 event loop 说完说我要等一秒钟才能完成，之后 event loop 闲来无事就能发现，这有一个 task 2 还可以执行，于是他又执行了 task 2，再跟他说我要两秒钟之后才能结束，这样两个 task 就可以同时进行等待了。</p><p>这也就是为什么asyncio很适合解决一些网络通讯的问题，因为网络通讯很多时间是在等待上的，也就是我们所谓的IO task，就是我真正的运算挺少的，我就是等他的回复，那等待的这个时间就可以其他的任务去干活。那这个函数我们没有涉及coroutine的return，所以我们把这个函数稍微修改一下。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">say_after</span>(<span class="params">delay, what</span>):</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(delay)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;(what) - (delay)&quot;</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    task1 = asyncio.create_task(say_after(<span class="number">1</span>, <span class="string">&quot;he11o&quot;</span>))</span><br><span class="line">    task2 = asyncio.create_task(say_after(<span class="number">2</span>, <span class="string">&quot;world&quot;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;started at <span class="subst">&#123;time.strftime( <span class="string">&#x27;%x&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">    ret1 = <span class="keyword">await</span> task1</span><br><span class="line">    ret2 = <span class="keyword">await</span> task2</span><br><span class="line">    <span class="built_in">print</span>(ret1)</span><br><span class="line">    <span class="built_in">print</span>(ret2)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;finished at <span class="subst">&#123;time.strftime( <span class="string">&#x27;%x&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p>我们看我们把函数修改了一下，主要就是告诉大家怎么拿到coroutine的 return。那当你要拿这个返回值的时候，一定是一个 variable 等于 await task，而不是一个 variable 等于 task。我们之前强调过， await 有一个功能是把这个 task 或者coroutine的这个返回值拿出来，如果你不用 await 是拿不到这个值的。</p><p>那有的人看到这可能说了，那如果我有很多 task 呢？我有，比如说 10 个task，我就写 10 行 await task 吗？这是不是太蠢了？正因如此， asyncio给我们提供了一个函数叫做gather。我们看 gather 这个函数，它不是一个coroutine，但是它会返回一个叫做 future 的东西，这个 future 也是可以用 await 的，那 gather 这个函数作用，首先它的参数是若干个 coroutine或者task，这俩都可以，甚至可以是future，也就是 gather 的 return 值。它还可以接着gather，那如果是coroutine的话，它首先会把它包装成task，并且注册到 event loop 里，然后它会返回一个 future 值。当你 await 这个 future 的时候，你就相当于告诉 event loop，我要等待这里面每一个 task 都完成，我才可以继续，同时会把这些 task 的 return 值放到一个 list 里，然后返回来。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">say_after</span>(<span class="params">delay, what</span>):</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(delay)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;(what) - <span class="subst">&#123;delay&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;started at <span class="subst">&#123;time.strftime( <span class="string">&#x27;%x&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">    ret = <span class="keyword">await</span> asyncio.gather(say_after(<span class="number">1</span>, <span class="string">&#x27;hello&#x27;</span>),</span><br><span class="line">                               say_after(<span class="number">2</span>, <span class="string">&quot;world&quot;</span>))</span><br><span class="line">    <span class="built_in">print</span>(ret)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;finished at <span class="subst">&#123;time.strftime( <span class="string">&#x27;%x&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p>我们看一下这程序的结果，可以看到这次的这个 return value 是一个list，里面分别是 hello和world，<strong>那么这个 list 顺序和里面 task 的顺序是一致的</strong>，这样呢，我们就不用一个个 task await 了。</p><p>那 gather 还有一个好处就是如果你给的是coroutine的话，它会把每一个coroutine首先都变成task，也就是说我们可以不用自己手动先去建立这些 task 了。我们看一下上述代码结果，可以看到这种方式在拿到了正确的返回值的同时，它也只用了 2 秒。因为 gather 首先把这两个 coroutine 都变成了task，然后在 main 做 await 的时候才把控制权交回给了 event loop，这样 event loop 在分配哪一个 task 可以工作的时候，它就有更多的 task 可以分配了。</p><p>尽管asyncio里面还有不少的功能，但是掌握了这几个，基本上你就理解了asyncio的核心理念了。那我再强调一下前面提到过的几个重点。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>要建立一个 event loop 的概念，上面儿有一个 event loop 作为大脑，下面是若干可执行的task。 task 是没有办法控制 event loop 去执行某一个 task 的，它只能告诉 event loop 说我在等这个task。最终是由 event loop 来决定下面要运行哪个task，而 event loop 一旦开始运行task，就必须要 task 显示的把控制权交还给 event loop。交还控制权的方式由 await 和函数运行完毕。所以尽管我们会说这种协程的方式是并发的，但是同时刻实际上只有一段代码在跑，它只是想办法再利用这些代码中间的等待时间。所以如果你的代码里面并没有等待这件事的话，协程对你的代码是没有帮助的。</li><li>务必分清什么是coroutine，什么是task。 coroutine 只有变成了 task 才开始被执行。要能知道什么时候 coroutine 被隐式的变成了task，在你直接await coroutine 的时候，给你放到 gather 里的时候，你放进去的都是coroutine，但是它们会偷偷把它变成 task 执行coroutine，不变成 task 是没有办法执行的。</li><li>最后拿到一个 coroutine 的返回值是需要用 await 的。一个变量等于 await xxx。</li></ol><p>‍</p><p>‍</p><p>‍</p><p>‍</p><p>‍</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;针对&lt;a href=&quot;https://www.bilibili.com/video/BV1oa411b7c9/?spm_id_from=333.337.search-card.all.click&amp;amp;vd_source=53d8e50bea64</summary>
      
    
    
    
    <category term="Python" scheme="https://guoyujian.github.io/categories/Python/"/>
    
    <category term="异步编程" scheme="https://guoyujian.github.io/categories/Python/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Python" scheme="https://guoyujian.github.io/tags/Python/"/>
    
    <category term="asyncio" scheme="https://guoyujian.github.io/tags/asyncio/"/>
    
    <category term="异步编程" scheme="https://guoyujian.github.io/tags/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统学习资料</title>
    <link href="https://guoyujian.github.io/2023/02/28/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"/>
    <id>https://guoyujian.github.io/2023/02/28/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/</id>
    <published>2023-02-28T14:21:37.000Z</published>
    <updated>2023-02-28T14:23:58.466Z</updated>
    
    <content type="html"><![CDATA[<p>source:<a href="https://gist.github.com/ascrutae/7fbc3681ff6e7f68fc908e196eac980e">https://gist.github.com/ascrutae/7fbc3681ff6e7f68fc908e196eac980e</a></p><script src="https://gist.github.com/ascrutae/7fbc3681ff6e7f68fc908e196eac980e.js"></script><p>source2: <a href="https://zhuanlan.zhihu.com/p/372646991">https://zhuanlan.zhihu.com/p/372646991</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;source:&lt;a href=&quot;https://gist.github.com/ascrutae/7fbc3681ff6e7f68fc908e196eac980e&quot;&gt;https://gist.github.com/ascrutae/7fbc3681ff6e7f68fc908</summary>
      
    
    
    
    <category term="分布式" scheme="https://guoyujian.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="学习路线" scheme="https://guoyujian.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
    
    <category term="分布式" scheme="https://guoyujian.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>思源笔记基本使用</title>
    <link href="https://guoyujian.github.io/2023/02/26/%E6%80%9D%E6%BA%90%E7%AC%94%E8%AE%B0%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>https://guoyujian.github.io/2023/02/26/%E6%80%9D%E6%BA%90%E7%AC%94%E8%AE%B0%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</id>
    <published>2023-02-26T09:49:50.000Z</published>
    <updated>2023-02-26T09:52:22.850Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>思源笔记是一款很好的管理知识库的软件。支持本地（免费）和云端（付费）两种模式。</p><p>不仅支持markdown语法，还有更多实用功能。这里进行基本的使用介绍。</p><h1 id="支持markdown语法"><a href="#支持markdown语法" class="headerlink" title="支持markdown语法"></a>支持markdown语法</h1><p>略</p><h1 id="支持新建多级文档"><a href="#支持新建多级文档" class="headerlink" title="支持新建多级文档"></a>支持新建多级文档</h1><p><img src="image-20230226161146934.png" alt="image-20230226161146934"></p><h1 id="设置标签、笔记图标和题头图"><a href="#设置标签、笔记图标和题头图" class="headerlink" title="设置标签、笔记图标和题头图"></a>设置标签、笔记图标和题头图</h1><p>将鼠标放置到笔记开头，出现的三个icon分别对应，添加标签，设置图标和设置题头图。</p><p><img src="image-20230226161241016.png" alt="image-20230226161241016"></p><p>设置之后的效果为：</p><p><img src="image-20230226161340368.png" alt="image-20230226161340368"></p><h1 id="内容块合并"><a href="#内容块合并" class="headerlink" title="内容块合并"></a>内容块合并</h1><p>内容块是思源的基础。块和块之间可以进行合并等操作。</p><p><img src="1.gif" alt="动画"></p><h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><p>思源笔记可以制作模板，导出导入模板。让笔记标准化。</p><h1 id="挂件"><a href="#挂件" class="headerlink" title="挂件"></a>挂件</h1><p>在【设置】-【集市】-【挂件】中进行下载。</p><p>目前看到比较好用的挂件有</p><ul><li>superdraw： 可以让实现随意涂写的挂件</li><li>drawio：实现画流程图的挂件</li><li>思维导图：可以插入思维导图的挂件</li></ul><p>其他的自行研究。这里以drawio为例。他的效果是这样的。</p><p><img src="image-20230226163445070.png" alt="image-20230226163445070"></p><h1 id="导入pdf并进行阅览"><a href="#导入pdf并进行阅览" class="headerlink" title="导入pdf并进行阅览"></a>导入pdf并进行阅览</h1><p>通过拖拽导入pdf，点击进行阅览</p><p><img src="image-20230226163828335.png" alt="image-20230226163828335"></p><p>不仅如此，在pdf中可以进行选中和标注。将标注作为“引用链接”复制回笔记。点击“引用链接”可以直接打开pdf，并跳转到标注的位置。</p><p><img src="image-20230226164254104.png" alt="image-20230226164254104"></p><h1 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h1><p>直接复制粘贴导出的是markdown格式的内容</p><p>也可以直接选择导出模式，导出不同平台的格式。目前支持知乎、微信公众号等。</p><p><img src="2.gif" alt="动画"></p><h1 id="剪藏"><a href="#剪藏" class="headerlink" title="剪藏"></a>剪藏</h1><p>通过chrome插件进行web页面的笔记剪藏</p><p>类似有道云笔记的功能。</p><p>这里需要对token进行配置。token在【设置】【关于】中查看</p><h1 id="网络图片转到本地"><a href="#网络图片转到本地" class="headerlink" title="网络图片转到本地"></a>网络图片转到本地</h1><p><img src="image-20230226164816361.png" alt="image-20230226164816361"></p><h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><p>当前块可以引用其他笔记的内容，输入两个左括号触发。</p><p>继续输入关键词，选中引用的内容即可。</p><p>鼠标悬浮在引用链接上，可以对引用的内容进行预览。</p><p>具体效果如下。</p><p><img src="3.gif" alt="动画"></p><p>链接分为正向链接和反向连接。</p><p>正向链接就是查看链接引用了哪些内容块</p><p>反向链接就是查看哪些内容块被引用了。</p><p>点击右下角的【反向链接】图标查看</p><p><img src="image-20230226165621640.png" alt="image-20230226165621640"></p><p>在连接中你可以右键输入锚文本修改引用链接的文本</p><p><img src="image-20230226165718183.png" alt="image-20230226165718183"></p><h1 id="闪卡"><a href="#闪卡" class="headerlink" title="闪卡"></a>闪卡</h1><h2 id="制作闪卡"><a href="#制作闪卡" class="headerlink" title="制作闪卡"></a>制作闪卡</h2><p>闪卡用于背诵某些内容。制作闪卡的流程如下。</p><p>标记需要背诵的内容，选择块【添加到卡包】，创建卡包并添加。</p><p><img src="image-20230226170647766.png" alt="image-20230226170647766"></p><p><img src="image-20230226170750105.png" alt="image-20230226170750105"></p><p><img src="image-20230226170852763.png" alt="image-20230226170852763"></p><h2 id="复习闪卡"><a href="#复习闪卡" class="headerlink" title="复习闪卡"></a>复习闪卡</h2><p>选择【闪卡】</p><p><img src="image-20230226170933812.png" alt="image-20230226170933812"></p><p>选择卡包就可以看到待复习的闪卡了。</p><p><img src="image-20230226171010071.png" alt="image-20230226171010071"></p><h1 id="图表"><a href="#图表" class="headerlink" title="图表"></a>图表</h1><p>输入<code>/</code>，选择插入Chart</p><p><img src="image-20230226171217053.png" alt="image-20230226171217053"></p><p>这里输入代码即可插入chart，其格式为echarts的json格式代码。</p><p>这里有两种方式</p><ol><li>使用JS编写图表</li><li>使用<a href="https://tushuo.baidu.com/">百度图说</a>，可视化制作图表，然后复制图表代码。</li></ol><p>这里使用第二种方式。</p><p>进入百度图说，创建图表，修改数据，点击【显示代码】</p><p><img src="image-20230226171700714.png" alt="image-20230226171700714"></p><p>复制代码后粘贴到思源的图标代码中，就可以看到图表啦</p><p><img src="image-20230226171753886.png" alt="image-20230226171753886"></p><h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><p>输入<code>/</code>，选择插入flowchart</p><p>这里支持两种语法格式：</p><ol><li>flowchart.js</li><li>plantUML</li></ol><h1 id="Graphviz"><a href="#Graphviz" class="headerlink" title="Graphviz"></a>Graphviz</h1><p>输入<code>/</code>，选择插入Graphviz</p><p>支持的语法格式为dot语法。具体可以参考<a href="">网站</a>进行绘制。在软件工程、数据库和机器学习方面用的多，效果如下。</p><p><img src="image-20230226172409698.png" alt="image-20230226172409698"></p><h1 id="Mermaid"><a href="#Mermaid" class="headerlink" title="Mermaid"></a>Mermaid</h1><p>输入<code>/</code>，选择插入Mermaid</p><p>Mermaid和Graphviz 类似。Mermaid可以绘制流程图等数十种图。</p><p>打开<a href="https://mermaid.js.org/">官网</a>，选择右上角的【live editor】进行实时编辑。</p><p><img src="image-20230226172909167.png" alt="image-20230226172909167"></p><p>复制代码即可在思源笔记中看到效果</p><p><img src="image-20230226172955029.png" alt="image-20230226172955029"></p><h1 id="MindMap"><a href="#MindMap" class="headerlink" title="MindMap"></a>MindMap</h1><p>mindmap是脑图。</p><p>输入<code>/</code>，选择插入MindMap</p><p>之后进行编辑</p><p><img src="image-20230226173129422.png" alt="image-20230226173129422"></p><h1 id="多媒体"><a href="#多媒体" class="headerlink" title="多媒体"></a>多媒体</h1><p>思源支持多媒体数据的插入，包括视频、链接、iframe</p><p>这里插入一个视频为例：</p><p>输入<code>/</code>，选择插入iframe链接，复制视频url链接。效果如下</p><p><img src="image-20230226173429042.png" alt="image-20230226173429042"></p><h1 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h1><ol><li><a href="https://www.bilibili.com/video/BV1bv4y1r7tA/?spm_id_from=333.788&amp;vd_source=53d8e50bea64fe70bc50c86af86d28e1">https://www.bilibili.com/video/BV1bv4y1r7tA/?spm_id_from=333.788&amp;vd_source=53d8e50bea64fe70bc50c86af86d28e1</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;思源笔记是一款很好的管理知识库的软件。支持本地（免费）和云端（付费）两种模式。&lt;/p&gt;
&lt;p&gt;不仅支持markdown语法，还有更多实用功能</summary>
      
    
    
    
    <category term="工具箱" scheme="https://guoyujian.github.io/categories/%E5%B7%A5%E5%85%B7%E7%AE%B1/"/>
    
    
    <category term="siyuan" scheme="https://guoyujian.github.io/tags/siyuan/"/>
    
    <category term="思源" scheme="https://guoyujian.github.io/tags/%E6%80%9D%E6%BA%90/"/>
    
    <category term="教程" scheme="https://guoyujian.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="知识库工具" scheme="https://guoyujian.github.io/tags/%E7%9F%A5%E8%AF%86%E5%BA%93%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>软件行业就业方向调研</title>
    <link href="https://guoyujian.github.io/2023/02/25/%E8%BD%AF%E4%BB%B6%E8%A1%8C%E4%B8%9A%E5%B0%B1%E4%B8%9A%E6%96%B9%E5%90%91%E8%B0%83%E7%A0%94/"/>
    <id>https://guoyujian.github.io/2023/02/25/%E8%BD%AF%E4%BB%B6%E8%A1%8C%E4%B8%9A%E5%B0%B1%E4%B8%9A%E6%96%B9%E5%90%91%E8%B0%83%E7%A0%94/</id>
    <published>2023-02-25T06:44:32.000Z</published>
    <updated>2023-02-25T06:44:32.469Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>本文调研了目前软件行业的就业方向。用于个人选择合适的就业岗位使用。主要调研了软件行业有哪些就业方向，针对这些方向又调研了</p><ol><li>职位岗位</li><li>目前需求：多还是少，为什么</li><li>前景如何：好还是坏，还是不明；从国内和国外两个角度；未来发展评估</li><li>企业：有哪些企业在做，龙头企业有哪些，从国内外两方面</li><li>细分领域：比如自然语言处理有对话领域blabla</li><li>特点：难度，特点</li><li>技术路线：整理该方向的技术路线图，对该方向的技术栈进行简单介绍</li><li>职业规划：方向职业的前进路线，初级-中级，blabla</li><li>是否利于出国：国外的需求是否更旺盛，是否更容易出国</li></ol><h1 id="调研方式"><a href="#调研方式" class="headerlink" title="调研方式"></a>调研方式</h1><p>本文汇总的软件行业就业方向的调研方式是，通过知乎、bilibili、谷歌、YouTube、微信公众号、GitHub等平台，使用以下几组关键词：【就业、职业】【程序员、码农、软件行业】【方向、前景、规划、赛道】，时间选取近两年，进行搜索，总结相关视频、文章、评论等内容。</p><p>先搜集整理可能的软件行业方向，再根据将这些软件行业方向作为关键词，二次搜索。</p><p>PS由于国内广告太多，很多话都不太可信。。</p><h1 id="开发方向-前端"><a href="#开发方向-前端" class="headerlink" title="开发方向-前端"></a>开发方向-前端</h1><h2 id="职位岗位"><a href="#职位岗位" class="headerlink" title="职位岗位"></a>职位岗位</h2><p>无</p><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>和后端差不多。</p><h2 id="前景"><a href="#前景" class="headerlink" title="前景"></a>前景</h2><blockquote><p>Web这种还是挺有生命力的，但是，一切都是在变化，有可能若干年后一个技术变革，Web就丧失优势变得门可罗雀了，所以呢，各位同仁，要有心理准备。</p></blockquote><p>同质化</p><h2 id="企业"><a href="#企业" class="headerlink" title="企业"></a>企业</h2><p>不局限于互联网，但是互联网的技术更新，更有竞争力。</p><h2 id="应用领域"><a href="#应用领域" class="headerlink" title="应用领域"></a>应用领域</h2><p>主要是移动端、PC端的前端开发，还有游戏，后端（NodeJS）以及其他（桌面端）</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li>越来越工具化、工程化</li><li>知识琐碎，门槛低</li><li>出效果快、激励周期短</li></ol><h2 id="技术路线"><a href="#技术路线" class="headerlink" title="技术路线"></a>技术路线</h2><p><img src="png-FrontEnd-by-StuQ.png" alt="png-FrontEnd-by-StuQ.png"></p><p>前端发展经历了三个阶段:</p><ol><li>原生html、js、css</li><li>封装库、jquery</li><li>组件化开发：node</li></ol><h2 id="职业规划"><a href="#职业规划" class="headerlink" title="职业规划"></a>职业规划</h2><div class="table-container"><table><thead><tr><th>职称</th><th>职责</th><th>年限(仅供参考)</th></tr></thead><tbody><tr><td>初级工程师</td><td>能在导师的帮助(详细设计, 关键点实现)下完成简单任务</td><td>0</td></tr><tr><td>中级工程师(开发)</td><td>能在导师的协助(概要设计, 关键点说明)下<strong>独立完成</strong>复杂任务</td><td>1+</td></tr><tr><td>高级工程师(研发)</td><td><strong>能高质量高效率地独立完成任务</strong></td><td>5+</td></tr><tr><td>资深/首席/专家/架构</td><td>全局观, 既有广度又有深度, 在某个专业领域有一席之地</td><td>8+</td></tr></tbody></table></div><h2 id="出国"><a href="#出国" class="headerlink" title="出国"></a>出国</h2><p>无</p><h1 id="开发方向-后端"><a href="#开发方向-后端" class="headerlink" title="开发方向-后端"></a>开发方向-后端</h1><h2 id="职位岗位-1"><a href="#职位岗位-1" class="headerlink" title="职位岗位"></a>职位岗位</h2><p>根据语言不同分为很多，例如，Java、Go等。</p><p>去某公司做后端开发，不一定对他们用到的语言和框架很熟练，会其中一部分就够了，很多都是在工作中学的。</p><h2 id="需求-1"><a href="#需求-1" class="headerlink" title="需求"></a>需求</h2><p>前后端差不多。</p><h2 id="前景-1"><a href="#前景-1" class="headerlink" title="前景"></a>前景</h2><p>随时间变化很大。目前不明。</p><h2 id="企业-1"><a href="#企业-1" class="headerlink" title="企业"></a>企业</h2><p>不局限于互联网，但是互联网的技术更新，更有竞争力。</p><h2 id="应用领域-1"><a href="#应用领域-1" class="headerlink" title="应用领域"></a>应用领域</h2><p>领域广泛。</p><h2 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h2><ol><li>注重功能性和稳定性</li><li>门类分支多：业务、算法、架构。。。</li><li>难以学深，容易瓶颈。这主要是小公司业务量不够&amp;大公司构建技术壁垒，小公司的后端开发容易和大公司拉开差距</li><li>后端的工作范畴很广：设计api、架构、数据库、业务逻辑、高可用等</li><li>非常考验《系统设计》的能力</li></ol><h2 id="RoadMap"><a href="#RoadMap" class="headerlink" title="RoadMap"></a>RoadMap</h2><p>以Java为例</p><p>图片来源：<a href="https://github.com/s4kibs4mi/java-developer-roadmap/blob/master/i18n/zh-CN/ReadMe-zh-CN.md">https://github.com/s4kibs4mi/java-developer-roadmap/blob/master/i18n/zh-CN/ReadMe-zh-CN.md</a></p><p><img src="java-developer-roadmap-zh-CN.png" alt="Roadmap"></p><h2 id="出国-1"><a href="#出国-1" class="headerlink" title="出国"></a>出国</h2><p>无</p><h1 id="小结：前端后端对比"><a href="#小结：前端后端对比" class="headerlink" title="小结：前端后端对比"></a>小结：前端后端对比</h1><h2 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h2><p>需求、工资、前景都差不多</p><p>职业发展规划差不多</p><div class="table-container"><table><thead><tr><th>职称</th><th>职责</th><th>年限(仅供参考)</th></tr></thead><tbody><tr><td>初级工程师</td><td>能在导师的帮助(详细设计, 关键点实现)下完成简单任务</td><td>0</td></tr><tr><td>中级工程师(开发)</td><td>能在导师的协助(概要设计, 关键点说明)下<strong>独立完成</strong>复杂任务</td><td>1+</td></tr><tr><td>高级工程师(研发)</td><td><strong>能高质量高效率地独立完成任务</strong></td><td>5+</td></tr><tr><td>资深/首席/专家/架构</td><td>全局观, 既有广度又有深度, 在某个专业领域有一席之地</td><td>8+</td></tr></tbody></table></div><h2 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h2><blockquote><p><strong>后端要学的技术太多了</strong>，而前端相对来说就少多了，压力自然少很多，而且后端也需要学一些前端技术，有的公司就有这样的需求，考虑到地中海干涸问题，肯定选前端，而且对于后面的发展，比如<strong>转型走管理架构什么的，前端基本没有优势</strong>。但是由于<strong>前端技术难度和学习成本不是太大</strong>，而且随着经验积累，即便到了四十多岁也可以继续开发，而后端再继续撸代码就难多了，因为本来前端逻辑代码不是太多，即便是使用node做前后端分离，前端复杂逻辑也不是太多，而且前端现在有很多脚手架和插件，都可以直接拿来用。而后端就不一样了，性能，并发，算法，各种优化，服务器问题等等，都是后端考虑的，虽然随着各种技术的出现，现在后端也开发没有以前费劲了，但是要知道底层原理和源码你还是要去翻，各种问题还是主要在后端这解决的。</p></blockquote><p>评论：</p><p>前端四十多岁也可以继续开发，存疑。随着前端技术的发展，也可能技术难度up，四十多岁不能继续开发。</p><h2 id="怎么选"><a href="#怎么选" class="headerlink" title="怎么选"></a>怎么选</h2><ul><li>兴趣、现状：你了解哪个多一点就选哪个</li><li>职业背景</li><li>年龄</li></ul><h1 id="开发方向-全栈"><a href="#开发方向-全栈" class="headerlink" title="开发方向-全栈"></a>开发方向-全栈</h1><h2 id="RoadMap-1"><a href="#RoadMap-1" class="headerlink" title="RoadMap"></a>RoadMap</h2><p>来源：<a href="https://github.com/easychen/stack-roadmap">https://github.com/easychen/stack-roadmap</a></p><p><img src="方糖全栈路线图.jpg" alt="img"></p><h2 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h2><p>最大特点就是，<strong>难度高</strong></p><p>特点之二是，美国全栈岗位多，后面再根据个人细分领域。<strong>可能利于出国</strong>。</p><p><strong>不适合应届生</strong></p><p>依据是2019年stack-overflow的调查问卷，程序员岗位分布：</p><p><img src="image-20230223000029-erjot3z.png" alt="image"></p><h1 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h1><p>翻译过来叫质量保证，在国外主要指的是测试，tester。在国内还有另一种不同于测试的质量保证。这点需要注意，招聘时的QA究竟指的是质量保证还是测试工程师。</p><h2 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h2><ol><li>分成两种，手工测试和自动化测试。</li><li>自动化测试需要写代码，需要懂一两门自动化测试语言和框架。</li><li>手工测试，对开发能力和写代码能力没有要求，但是需要有开发的经验。这类岗位基本被淘汰掉了。</li></ol><h2 id="RoadMap-2"><a href="#RoadMap-2" class="headerlink" title="RoadMap"></a>RoadMap</h2><p><a href="https://github.com/yangzige/qa-roadmap/blob/main/roadmap/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF.md">https://github.com/yangzige/qa-roadmap/blob/main/roadmap/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF.md</a></p><h1 id="人工智能-CV方向"><a href="#人工智能-CV方向" class="headerlink" title="人工智能-CV方向"></a>人工智能-CV方向</h1><p>2015-2020是黄金期，找工作比较容易。2020以后赚钱的业务挖掘的差不多了，<strong>对学历和论文的要求高</strong>。</p><p>CV岗位比开发岗<strong>少很多</strong>。</p><h2 id="前景-2"><a href="#前景-2" class="headerlink" title="前景"></a>前景</h2><p>今后会走向“平衡”。人话就是不温不火</p><h2 id="应用领域-2"><a href="#应用领域-2" class="headerlink" title="应用领域"></a>应用领域</h2><p><img src="640.png" alt="图片"></p><ul><li>自动驾驶领域：比较火</li><li>工业视觉领域：应用潜力大</li><li>智慧医疗：有前景但比较困难</li></ul><h2 id="RoadMap-3"><a href="#RoadMap-3" class="headerlink" title="RoadMap"></a>RoadMap</h2><p>没找到比较好的。基本就是Python、PyTorch、数字图象处理，深度学习那一套。。</p><h1 id="人工智能-NLP方向"><a href="#人工智能-NLP方向" class="headerlink" title="人工智能-NLP方向"></a>人工智能-NLP方向</h1><blockquote><p>自然语言处理(<em>NLP</em>)是人工智能技术的王冠，它推动着当代科技的持续发展和重大突破，并越来越多地应用于各行各业；它有着十分重要的实用价值，也有着革命性的理论</p></blockquote><h2 id="前景-3"><a href="#前景-3" class="headerlink" title="前景"></a>前景</h2><p>前景广阔。之前比较卷，现在因为ChatGPT的出现，续了一口气</p><h2 id="应用领域-3"><a href="#应用领域-3" class="headerlink" title="应用领域"></a>应用领域</h2><p>对话、问答。</p><h2 id="RoadMap-4"><a href="#RoadMap-4" class="headerlink" title="RoadMap"></a>RoadMap</h2><p><a href="https://github.com/graykode/nlp-roadmap">https://github.com/graykode/nlp-roadmap</a></p><h1 id="人工智能-其他"><a href="#人工智能-其他" class="headerlink" title="人工智能-其他"></a>人工智能-其他</h1><p>人工智能还包括其他方向，例如推荐算法。</p><h1 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h1><h2 id="职位岗位-2"><a href="#职位岗位-2" class="headerlink" title="职位岗位"></a>职位岗位</h2><p>大数据是一个比较笼统的方向，既可以做大数据开发方向，也可以做数据挖掘等算法方向，也有商业智能BI。。。</p><p>具体方向有以下：</p><ol><li>ETL/数仓工程师：负责数仓建设，偏脚本开发以及SQL开发。</li><li>大数据开发工程师：负责数据计算，偏离线。实时代码开发。</li><li>大数据分析师：负责数据挖掘分析、偏业务分析/SQL</li><li>大数据算法工程师：算法建模、基于人工智能建模。往往是和推荐算法相关。</li><li>大数据BI工程师：偏报表和SQL开发。</li></ol><p>不同方向的学习路线和技能都有所不同。</p><h2 id="需求-2"><a href="#需求-2" class="headerlink" title="需求"></a>需求</h2><p>没有Java那么卷，但是岗位也没有那么多。</p><h2 id="前景-4"><a href="#前景-4" class="headerlink" title="前景"></a>前景</h2><h2 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h2><ol><li>大数据开发需要学习的组件非常多。也比较难。</li><li>ETL/数仓的工作比较基础。</li><li>大数据分析和算法主要偏算法相关。</li></ol><h2 id="RoadMap-5"><a href="#RoadMap-5" class="headerlink" title="RoadMap."></a>RoadMap.</h2><p>学习可以从SQL入手。</p><p><a href="https://github.com/TeamStuQ/skill-map/blob/master/data/map-BigDataEngineer.md">https://github.com/TeamStuQ/skill-map/blob/master/data/map-BigDataEngineer.md</a></p><h2 id="一篇有用的文章"><a href="#一篇有用的文章" class="headerlink" title="一篇有用的文章"></a>一篇有用的文章</h2><p>想学大数据，大数据开发以后的前景怎么样，家里人对这方面了解不深，不太同意转行？ - 云原生研习社的回答 - 知乎 <a href="https://www.zhihu.com/question/509912345/answer/2664371834">https://www.zhihu.com/question/509912345/answer/2664371834</a></p><h1 id="UX-UI"><a href="#UX-UI" class="headerlink" title="UX/UI"></a>UX/UI</h1><p>UX是User Experience（用户体验）的缩写，指的是围绕用户，以用户在使用过程中的主观感受为出发点，力求更简单高效地满足用户需求。 UX设计师的职责简单来说就是为用户设计友好的产品体验，他更关注产品的易用性、实用性、高效性及价值体现。</p><p>UI的全名是User Interface，中文是「使用者介面」的意思。介面指的是APP、網頁等，可以與使用者互動的媒介。如同字面上的意思，UI著重的是使用者介面的呈現，如：視覺美感、設計美學、便利性、風格呈現，細節更包含了字型、字體大小、顏色、標誌、按鍵、動畫效果等。UI的呈現，會影響到使用者的使用感受，以及順暢性。</p><p>其他略。</p><h1 id="数据采集"><a href="#数据采集" class="headerlink" title="数据采集"></a>数据采集</h1><p>爬虫方向。不想说。。</p><h1 id="数据挖掘"><a href="#数据挖掘" class="headerlink" title="数据挖掘"></a>数据挖掘</h1><blockquote><p>广义上说，任何从数据库中挖掘信息的过程都叫做数据挖掘。从这点看来，数据挖掘就是BI（商业智能）。但从技术术语上说，数据挖掘(Data Mining)特指的是：源数据经过清洗和转换等成为适合于挖掘的数据集。数据挖掘在这种具有固定形式的数据集上完成知识的提炼，最后以合适的知识模式用于进一步分析决策工作。从这种狭义的观点上，我们可以定义：数据挖掘是从特定形式的数据集中提炼知识的过程。数据挖掘往往针对特定的数据、特定的问题，选择一种或者多种挖掘算法，找到数据下面隐藏的规律，这些规律往往被用来预测、支持决策。</p></blockquote><p>可以放到大数据的数据挖掘的相关岗位来看。</p><h2 id="应用领域-4"><a href="#应用领域-4" class="headerlink" title="应用领域"></a>应用领域</h2><p>情报检索、数据分析、模式识别</p><h1 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h1><p>可以放到大数据的数据存储的相关岗位来看。</p><p>主要研究各种数据库存储。</p><h2 id="有用的文章"><a href="#有用的文章" class="headerlink" title="有用的文章"></a>有用的文章</h2><p><a href="https://github.com/wx-chevalier/Database-Series">https://github.com/wx-chevalier/Database-Series</a></p><h1 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h1><h2 id="前景-5"><a href="#前景-5" class="headerlink" title="前景"></a>前景</h2><p>前景很好。</p><h2 id="有用的文章-1"><a href="#有用的文章-1" class="headerlink" title="有用的文章"></a>有用的文章</h2><p><a href="https://github.com/LiuBoyu/blockchain">https://github.com/LiuBoyu/blockchain</a></p><p><a href="https://github.com/xianfeng92/Love-Ethereum">https://github.com/xianfeng92/Love-Ethereum</a></p><h2 id="应用领域-5"><a href="#应用领域-5" class="headerlink" title="应用领域"></a>应用领域</h2><p>区块链+物联网</p><h1 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h1><p>略，不感兴趣。但是和区块链息息相关。</p><h1 id="游戏开发"><a href="#游戏开发" class="headerlink" title="游戏开发"></a>游戏开发</h1><h1 id="VR"><a href="#VR" class="headerlink" title="VR"></a>VR</h1><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="素质要求"><a href="#素质要求" class="headerlink" title="素质要求"></a>素质要求</h2><p>这部分是除了细分方向之外的，对软件行业从业者的共同要求：</p><ol><li>涉猎其它领域的专业知识，丰富自己的知识体系、提高自己的综合素质，争取在自己的专业领域有所积累，然后再做扩展。<strong>不要把自己的知识体系局限于自己的岗位上</strong></li><li><strong>终身学习</strong></li><li>技术观：不要排斥其他技术</li><li>产品观：有产品常识</li><li>数据观：对数据敏感</li><li>知其然知其所以然，会使用轮子，也要研究轮子。</li></ol><h2 id="美国硕士博士CS专业分类"><a href="#美国硕士博士CS专业分类" class="headerlink" title="美国硕士博士CS专业分类"></a>美国硕士博士CS专业分类</h2><p><img src="image-20230223090322289.png" alt="image-20230223090322289"></p><p><img src="image-20230223090346670.png" alt="image-20230223090346670"></p><h2 id="计算机科学的主要分支"><a href="#计算机科学的主要分支" class="headerlink" title="计算机科学的主要分支"></a>计算机科学的主要分支</h2><p><img src="815c0d5aed01530b7cf11d0c9061ec70.png" alt="815c0d5aed01530b7cf11d0c9061ec70.png"></p><h1 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h1><p>这篇文章非常浅薄，没有仔细分析各个行业的现状和情况。只是罗列了一些资料。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h1&gt;&lt;p&gt;本文调研了目前软件行业的就业方向。用于个人选择合适的就业岗位使用。主要调研了软件行业有哪些就业方向，针对这些方向又调研了&lt;/p&gt;
&lt;ol&gt;
</summary>
      
    
    
    
    <category term="软件行业" scheme="https://guoyujian.github.io/categories/%E8%BD%AF%E4%BB%B6%E8%A1%8C%E4%B8%9A/"/>
    
    
  </entry>
  
  <entry>
    <title>Visual Attention Network</title>
    <link href="https://guoyujian.github.io/2023/02/04/Visual-Attention-Network/"/>
    <id>https://guoyujian.github.io/2023/02/04/Visual-Attention-Network/</id>
    <published>2023-02-04T03:31:37.000Z</published>
    <updated>2023-02-04T03:55:16.229Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是论文《Visual Attention Network》的学习笔记</p><p>我在该模型上执行一个分类任务，发现该模型的效果要优于我实验的其他模型（包括resnet50、densenet121、efficientNet-b0、swin-tiny）</p><p>所以在此记录一下，笔记大多是抄的，出处在Refs上表明，如有侵权请联系我。</p><p><a href="https://arxiv.org/abs/2202.09741">论文地址</a>   <a href="https://github.com/Visual-Attention-Network">代码地址</a></p></blockquote><p>‍</p><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="自注意力机制"><a href="#自注意力机制" class="headerlink" title="自注意力机制"></a>自注意力机制</h2><p><a href="https://zhuanlan.zhihu.com/p/265108616">Attention注意力机制与self-attention自注意力机制</a></p><p><a href="https://www.jiqizhixin.com/articles/100902">什么是自注意力机制？</a></p><h2 id="空间相关性和通道相关性1"><a href="#空间相关性和通道相关性1" class="headerlink" title="空间相关性和通道相关性1"></a>空间相关性和通道相关性<sup><a href="#fn_1" id="reffn_1">1</a></sup></h2><p>从维度的角度看，卷积核可以看成是一个空间维(宽和高)和通道维的组合，而<strong>卷积操作则可以视为空间相关性和通道相关性的联合映射</strong>。从inception的1x1卷积来看，<strong>卷积中的空间相关性和通道相关性是可以解耦的，将它们分开进行映射，可能会达到更好的效果。</strong></p><p>深度可分离卷积是在1x1卷积基础上的一种创新。主要包括两个部分：深度卷积和1x1卷积。深度卷积的目的在于对输入的每一个通道都单独使用一个卷积核对其进行卷积，也就是通道分离后再组合。1x1卷积的目的则在于加强深度。下面以一个例子来看一下深度可分离卷积。</p><p>假设我们用128个$3 \times3 \times3$的滤波器对一个 $7 \times7 \times3$的输入进行卷积，可得到$5 \times5 \times128$的输出,其计算量为$5 \times5 \times128 \times3 \times3 \times3=86400$。如下图所示：</p><p><img src="image-20230204110644-zz7yeyj.png" alt="image">​</p><p>现在看如何使用深度可分离卷积来实现同样的结果。深度可分离卷积的第一步是深度卷积。这里的深度卷积，就是分别用3个$3 \times3 \times1$的滤波器对输入的3个通道分别做卷积，也就是说要做3次卷积，每次卷积都有一个$5 \times5 \times1$的输出，组合在一起便是$5 \times5 \times3$的输出。现在为了拓展深度达到128，我们需要执行深度可分离卷积的第二步：1x1卷积。现在我们用128个$1 \times1 \times3$的滤波器对$5 \times5 \times3$进行卷积，就可以得到$5 \times5 \times128$的输出。完整过程如下图所示：</p><p><img src="image-20230204111234-3ia5cu3.png" alt="image">​</p><p>那么我们来看一下深度可分离卷积的计算量如何。第一步深度卷积的计算量：$5 \times5 \times1 \times3 \times3 \times1 \times3=675$。第二步1x1卷积的计算量：$5 \times5 \times128 \times1 \times1 \times3=9600$，合计计算量为10275次。可见，相同的卷积计算输出，深度可分离卷积要比常规卷积节省12倍的计算成本。</p><blockquote><p>典型的应用深度可分离卷积的网络模型包括xception和mobilenet等。本质上而言，xception就是应用了深度可分离卷积的inception网络。</p></blockquote><h1 id="正文2"><a href="#正文2" class="headerlink" title="正文2"></a>正文<sup><a href="#fn_2" id="reffn_2">2</a></sup></h1><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>图像的二维性质给在计算机视觉中应用自注意力带来了三个挑战：</p><ol><li>将图像处理为一维序列，忽略了其二维结构。</li><li>二次复杂度对于高分辨率的图像来说太贵了。</li><li>它只捕捉了空间适应性，而忽略了通道适应性</li></ol><p>在本文中，作者提出了一种新的大核注意(LKA)模块，以使自注意的自适应和长程相关，同时避免了上述问题。作者进一步介绍了一种基于LKA的新的神经网络，即视觉注意网络(VAN)。VAN虽然非常简单和高效，但在包括图像分类、目标检测、语义分割、实例分割等广泛的实验中，它以很大的优势优于最先进的transfomer和卷积神经网络。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="LCK"><a href="#LCK" class="headerlink" title="LCK"></a>LCK</h3><p>卷积神经网络(CNNs)利用局部上下文信息和平移不变性，大大提高了神经网络的效率。自AlexNet以来，cnn迅速成为计算机视觉的主要主流框架。为了进一步提高效率，研究人员投入了大量的精力，使cnn成为更深的和更轻的。作者的工作与MobileNet有相似之处，MobileNet将标准卷积解耦为两部分，即深度卷积和逐点卷积(也就是1×1Conv)。作者的方法将卷积分解为三个部分：深度卷积、深度空洞卷积和逐点卷积。得益于这种分解，作者的方法更适合于有效地分解大的核卷积。作者还在该方法中引入了注意机制来获得自适应特性。</p><p><img src="v2-467f001629900492069a79a14d2dc757_720w.webp" alt="img"></p><p>彩色网格表示卷积核的位置，黄色网格表示中心点。从图中可以看出，13×13卷积分解为5×5深度卷积，5×5深度空洞卷积，膨胀速率3和1×1卷积</p><p><img src="v2-d22b7728ed41dd3491530ad8a94fbe19_720w.webp" alt="img"></p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">class AttentionModule(nn.Module):</span><br><span class="line">    def __init__(self, dim):</span><br><span class="line">        super().__init__()</span><br><span class="line">        self.conv0 = nn.Conv2d(dim, dim, 5, padding=2, groups=dim)#深度卷积</span><br><span class="line">        self.conv_spatial = nn.Conv2d(dim, dim, 7, stride=1, padding=9, groups=dim, dilation=3)#深度空洞卷积</span><br><span class="line">        self.conv1 = nn.Conv2d(dim, dim, 1)#逐点卷积</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def forward(self, x):</span><br><span class="line">        u = x.clone()        </span><br><span class="line">        attn = self.conv0(x)</span><br><span class="line">        attn = self.conv_spatial(attn)</span><br><span class="line">        attn = self.conv1(attn)</span><br><span class="line"></span><br><span class="line">        return u * attn   #注意力操作</span><br><span class="line">     </span><br><span class="line">class SpatialAttention(nn.Module):</span><br><span class="line">    def __init__(self, d_model):</span><br><span class="line">        super().__init__()</span><br><span class="line"></span><br><span class="line">        self.proj_1 = nn.Conv2d(d_model, d_model, 1)</span><br><span class="line">        self.activation = nn.GELU()</span><br><span class="line">        self.spatial_gating_unit = AttentionModule(d_model)  #注意力操作</span><br><span class="line">        self.proj_2 = nn.Conv2d(d_model, d_model, 1)</span><br><span class="line"></span><br><span class="line">    def forward(self, x):</span><br><span class="line">        shorcut = x.clone()</span><br><span class="line">        x = self.proj_1(x)</span><br><span class="line">        x = self.activation(x)</span><br><span class="line">        x = self.spatial_gating_unit(x)  #注意力操作</span><br><span class="line">        x = self.proj_2(x)</span><br><span class="line">        x = x + shorcut   #残差连接</span><br><span class="line">        return x</span><br><span class="line"></span><br><span class="line">class Block(nn.Module):</span><br><span class="line">    def __init__(self, dim, mlp_ratio=4., drop=0.,drop_path=0., act_layer=nn.GELU):</span><br><span class="line">        super().__init__()</span><br><span class="line">        self.norm1 = nn.BatchNorm2d(dim)</span><br><span class="line">        self.attn = SpatialAttention(dim)</span><br><span class="line">        self.drop_path = DropPath(drop_path) if drop_path &gt; 0. else nn.Identity()</span><br><span class="line"></span><br><span class="line">        self.norm2 = nn.BatchNorm2d(dim)</span><br><span class="line">        mlp_hidden_dim = int(dim * mlp_ratio)</span><br><span class="line">        self.mlp = Mlp(in_features=dim, hidden_features=mlp_hidden_dim, act_layer=act_layer, drop=drop)</span><br><span class="line">        layer_scale_init_value = 1e-2            </span><br><span class="line">        self.layer_scale_1 = nn.Parameter(</span><br><span class="line">            layer_scale_init_value * torch.ones((dim)), requires_grad=True)</span><br><span class="line">        self.layer_scale_2 = nn.Parameter(</span><br><span class="line">            layer_scale_init_value * torch.ones((dim)), requires_grad=True)</span><br><span class="line"></span><br><span class="line">        self.apply(self._init_weights)</span><br><span class="line"></span><br><span class="line">    def _init_weights(self, m):</span><br><span class="line">        if isinstance(m, nn.Linear):</span><br><span class="line">            trunc_normal_(m.weight, std=.02)</span><br><span class="line">            if isinstance(m, nn.Linear) and m.bias is not None:</span><br><span class="line">                nn.init.constant_(m.bias, 0)</span><br><span class="line">        elif isinstance(m, nn.LayerNorm):</span><br><span class="line">            nn.init.constant_(m.bias, 0)</span><br><span class="line">            nn.init.constant_(m.weight, 1.0)</span><br><span class="line">        elif isinstance(m, nn.Conv2d):</span><br><span class="line">            fan_out = m.kernel_size[0] * m.kernel_size[1] * m.out_channels</span><br><span class="line">            fan_out //= m.groups</span><br><span class="line">            m.weight.data.normal_(0, math.sqrt(2.0 / fan_out))</span><br><span class="line">            if m.bias is not None:</span><br><span class="line">                m.bias.data.zero_()</span><br><span class="line"></span><br><span class="line">    def forward(self, x):</span><br><span class="line">        x = x + self.drop_path(self.layer_scale_1.unsqueeze(-1).unsqueeze(-1) * self.attn(self.norm1(x)))#drop_path分支中，每个batch有概率使样本在self.attn或者mlp不会”执行“，会以0直接传递。</span><br><span class="line">        x = x + self.drop_path(self.layer_scale_2.unsqueeze(-1).unsqueeze(-1) * self.mlp(self.norm2(x)))</span><br><span class="line">        return </span><br></pre></td></tr></table></figure><p>作者提出对大核卷积操作进行分解来捕获长程关系。大核卷积可分为三个部分：空间局部卷积（深度卷积）、空间远程卷积（深度空洞卷积）和通道卷积（1×1卷积）。所以，可以将K×K卷积分解为K/d×K/d的深度空洞卷积，(2d−1)×(2d−1)的深度卷积和1×1卷积。通过上述分解，可以用轻微的计算代价和参数来捕获长程关系。在得到长程关系后，可以估计一个点的重要性并生成注意力图。</p><p><img src="v2-f2a083b057051de4ae3a87fd77138a8e_720w.webp" alt="img"></p><p><img src="v2-6109ccc0466efee70bf7ac2324513a09_720w.webp" alt="img"></p><p>作者提出的LKA结合了卷积和自注意力的优点。它考虑了局部上下文信息、大的感受野和动态过程。此外，LKA不仅实现了空间维度的自适应性，而且还实现了通道维度的自适应性。值得注意的是，在深度神经网络中，不同的通道往往代表不同的对象，而通道维度的适应性对视觉任务也很重要。</p><h3 id="VAN"><a href="#VAN" class="headerlink" title="VAN"></a>VAN</h3><p>VAN具有简单的层次结构，即输出空间分辨率降低的四个阶段序列，分别为H/4×W/4、H/8×W/8、H/16×W/16和H/32×W/32。H和W是输入图像的高度和宽度。随着分辨率的降低，输出通道的数量也在不断增加。输出通道Ci的变化如下表所示。 首先对输入值进行下采样，并使用步幅数来控制下采样率。下采样后，一个stage中的所有层保持相同的输出大小，即空间分辨率和通道数量。然后，批量归一化、GELU激活函数、大核注意和卷积前馈网络依次堆叠，提取特征。最后，在每个阶段结束时应用一个层归一化。根据参数和计算成本，设计了 VAN-Tiny, VAN-Small, VAN-Base and VAN-Large四种结构。</p><p><img src="v2-9c29743630133af223ffb0b9d3c592f0_720w.webp" alt="img"></p><p><img src="v2-f3d5e05ccc5b5d1691c26fc3d8daafcd_720w.webp" alt="img"></p><p>对21×21卷积的不同方式参数的比较。X，Y和our分别提供了标准卷积，mobilenet]和van的分解。输入和输出具有相同大小的H×W×C</p><p><img src="v2-f39da3202b78c90cd02669ff5039e8a9_720w.webp" alt="img"></p><p>默认情况下，本文的LKA采用5×5深度卷积，7×7深度卷积与膨胀率为3的空洞卷积和1×1卷积来近似21×21卷积。在这种设置下，VAN可以有效地获取局部信息和长程联系。作者分别使用7×7和3×3步幅卷积进行4×和2×的降采样。</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>作者在ImageNet-1K图像分类数据集、COCO目标检测数据集和ADE20K语义分割数据集上进行了定量实验。此外，作者通过在ImageNet验证集上使用Grad-CAM来可视化类激活映射(CAM)。</p><h3 id="图像分类"><a href="#图像分类" class="headerlink" title="图像分类"></a>图像分类</h3><p><img src="https://pic2.zhimg.com/80/v2-2fefbe89e8e7da997c3683528fbb2535_720w.webp" alt="img"></p><p>VAN与其他mlp、cnn和ViTs的比较。VAN优于其他参数相似，计算成本相似的cnn(ResNet[29]，ResNeXt[90]，ConvNeXt[53]等)，ViTs(DeiT[74]、PVT[83]、Swin-Transformer[52]等)和MLPs(MLP-Mixer[72]，ResMLP[73]，gMLP[46]等)。作者在每个类别中选择了一个具有代表性的网络进行讨论。ConvNeXt[53]是一种特殊的CNN，它吸收了vit的一些优势，如大的感受野（7×7卷积）和先进的训练策略(300个epoch、数据增强等)。VAN和ConvNeXt[53]相比，VAN-base比CoNvNeXt-t多出0.7%(82.8%vs.82.1%)，因为VAN具有更大的感受域和自适应能力。Swin-Transformer是一种著名的ViT变体，采用局部注意力和移动窗口的方式。由于VAN对二维结构信息非常友好，具有较大的感受野，并在通道维度上实现了自适应性，VAN-Base超过Swin-T1.5%(82.8%vs.81.3%)。对于MLPs，选择gMLP[46]。VAN-Base超过gMLP-S[46]3.2%(82.8%vs.79.6%)。也可以看出，在小型模型上面VAN的表现更加出色。</p><h3 id="目标检测"><a href="#目标检测" class="headerlink" title="目标检测"></a>目标检测</h3><p><img src="v2-c04b7aef7af9212da50e947198ea0179_720w.webp" alt="img"></p><p><img src="v2-ac6fd9136c34fa6ebfce940f20b6a318_720w.webp" alt="img"></p><p><img src="v2-f0a76550ee33afe78ff4d4458f544c25_720w.webp" alt="img"></p><h3 id="语义分割"><a href="#语义分割" class="headerlink" title="语义分割"></a>语义分割</h3><p><img src="v2-5675289d453da40b8f33f28c1966aa44_720w.webp" alt="img"></p><h3 id="消融实验"><a href="#消融实验" class="headerlink" title="消融实验"></a>消融实验</h3><p><img src="v2-1f9970a60d196d053e6433e7bbcca814_720w.webp" alt="img"></p><p>DW-D-Conv提供了深度空洞卷积，这在捕获LKA中的长程依赖性中发挥了作用。</p><p>DW-Conv可以利用图像的局部上下文信息。</p><p>注意力机制的引入可以看作是使网络实现了自适应特性。受益于此，VAN-Tiny实现了约1.1%（74.3%对75.4%）的改善。</p><p>1×1Conv捕获了通道维度中的关系。结合注意机制，引入了通道维度的自适应性。提高了0.8%(74.1%vs.75.4%)，证明了通道维度自适应性的必要性。</p><h3 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h3><p><img src="v2-84a72be357178fade018043de0213190_720w.webp" alt="img"></p><p>可视化结果。所有的图像都来自于ImageNet验证集中的不同类别。CAM采用VAN-Base模型和Grad-CAM产生。左：原始图像，右：类激活图</p><p>结果显示，VAN-Base可以清晰地聚焦于目标对象。因此，可视化直观地证明了VAN的有效性。</p><p>‍</p><h1 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h1><blockquote id="fn_1"><sup>1</sup>. <a href="https://baidinghub.github.io/2020/04/03/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9F%A5%E8%AF%86%E7%B3%BB%E5%88%97%28%E4%BA%8C%29%20%E5%90%84%E7%A7%8D%E5%8D%B7%E7%A7%AF%E5%BD%A2%E5%BC%8F/">深度学习知识系列(二) 各种卷积形式</a><a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a></blockquote><blockquote id="fn_2 "><sup>2 </sup>. <a href="https://zhuanlan.zhihu.com/p/474526444">【ARXIV2202】Visual Attention Network</a><a href="#reffn_2 " title="Jump back to footnote [2 ] in the text."> &#8617;</a></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文是论文《Visual Attention Network》的学习笔记&lt;/p&gt;
&lt;p&gt;我在该模型上执行一个分类任务，发现该模型的效果要优于我实验的其他模型（包括resnet50、densenet121、efficientNet-b0、swin-t</summary>
      
    
    
    
    <category term="深度学习" scheme="https://guoyujian.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="深度学习" scheme="https://guoyujian.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="计算机视觉" scheme="https://guoyujian.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
  </entry>
  
  <entry>
    <title>Spring AOP Demo</title>
    <link href="https://guoyujian.github.io/2022/12/04/Spring-AOP-Demo/"/>
    <id>https://guoyujian.github.io/2022/12/04/Spring-AOP-Demo/</id>
    <published>2022-12-04T07:17:15.000Z</published>
    <updated>2022-12-04T07:21:08.814Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文不涉及Spring AOP原理</p></blockquote><h1 id="Spring-AOP-简介"><a href="#Spring-AOP-简介" class="headerlink" title="Spring AOP 简介"></a>Spring AOP 简介</h1><p>面向切面编程（AOP）是 Spring 最为重要的功能之一了，在数据库事务中切面编程被广泛使用。</p><h2 id="AOP-即-Aspect-Oriented-Program-面向切面编程"><a href="#AOP-即-Aspect-Oriented-Program-面向切面编程" class="headerlink" title="AOP 即 Aspect Oriented Program 面向切面编程"></a>AOP 即 Aspect Oriented Program 面向切面编程</h2><p>首先，在面向切面编程的思想里面，把功能分为核心业务功能，和周边功能。</p><ul><li><strong>所谓的核心业务</strong>​，比如登陆，增加数据，删除数据都叫核心业务</li><li><strong>所谓的周边功能</strong>​，比如性能统计，日志，事务管理等等</li></ul><p>周边功能在 Spring 的面向切面编程AOP思想里，即被定义为切面</p><p>在面向切面编程AOP的思想里面，核心业务功能和切面功能分别独立进行开发，然后把切面功能和核心业务功能 “编织” 在一起，这就叫AOP</p><h2 id="AOP-的目的"><a href="#AOP-的目的" class="headerlink" title="AOP 的目的"></a>AOP 的目的</h2><p>AOP能够将那些与业务无关，​<strong>却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来</strong>​，便于​<strong>减少系统的重复代码</strong>​，​<strong>降低模块间的耦合度</strong>​，并​<strong>有利于未来的可拓展性和可维护性</strong>​。</p><h2 id="AOP-当中的概念："><a href="#AOP-当中的概念：" class="headerlink" title="AOP 当中的概念："></a>AOP 当中的概念：</h2><ul><li>切入点（Pointcut）<br>在哪些类，哪些方法上切入（​<strong>where</strong>​）</li><li>通知（Advice）<br>在方法执行的什么实际（<strong>when:</strong>方法前/方法后/方法前后）做什么（<strong>what:</strong>增强的功能）</li><li>切面（Aspect）<br>切面 = 切入点 + 通知，通俗点就是：<strong>在什么时机，什么地方，做什么增强！</strong></li><li>织入（Weaving）<br>把切面加入到对象，并创建出代理对象的过程。（由 Spring 来完成）</li></ul><h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><h2 id="需求说明"><a href="#需求说明" class="headerlink" title="需求说明"></a>需求说明</h2><p>为了更好的说明 AOP 的概念，我们来举一个实际中的例子来说明：</p><p><img src="image-20221204123653-p1e00ow.png" alt="image">​</p><p>在上面的例子中，包租婆的核心业务就是签合同，收房租，那么这就够了，灰色框起来的部分都是重复且边缘的事，交给中介商就好了，这就是 <strong>AOP 的一个思想：让关注点代码与业务代码分离！</strong></p><h2 id="代码实现（使用注解）"><a href="#代码实现（使用注解）" class="headerlink" title="代码实现（使用注解）"></a>代码实现（使用注解）</h2><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><p>Spring Boot使用AOP需要添加spring-boot-starter-aop依赖，如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>不需要再添加aspectjweaver的依赖了，因为spring-boot-starter-aop包含了aspectjweaver，并且版本是较新的版本，如果在添加老版本（如1.5.4）启动会报错。</p><h3 id="编写核心业务Bean"><a href="#编写核心业务Bean" class="headerlink" title="编写核心业务Bean"></a>编写核心业务Bean</h3><p>也就是连接点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.test_spring.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LandlordService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rent</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;房东：谈合同&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;房东：收房租&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="创建切面"><a href="#创建切面" class="headerlink" title="创建切面"></a>创建切面</h3><p>Spring采用@AspectJ注解对POJO进行标注，该注解表明该类不仅仅是一个POJO，还是一个切面。切面是切点和通知的结合，那么定义一个切面就需要编写切点和通知。在代码中，只需要添加@Aspect注解即可。</p><h3 id="定义切点"><a href="#定义切点" class="headerlink" title="定义切点"></a>定义切点</h3><p>切点是通过<strong>@Pointcut</strong>注解和切点表达式定义的。</p><p>@Pointcut注解可以在一个切面内定义<strong>可重用</strong>的切点。</p><p>由于Spring切面粒度最小是达到方法级别，而execution表达式可以用于明确指定方法返回类型，类名，方法名和参数名等与方法相关的部件，并且实际中，大部分需要使用AOP的业务场景也只需要达到方法级别即可，因而execution表达式的使用是最为广泛的。如图是execution表达式的语法：</p><p>execution表示在方法执行的时候触发。以“​<em>”开头，表明方法返回值类型为任意类型。然后是全限定的类名和方法名，“</em>​”可以表示任意类和任意方法。对于方法参数列表，可以使用“..”表示参数为任意类型。如果需要多个表达式，可以使用“&amp;&amp;”、“||”和“!”完成与、或、非的操作。</p><p><img src="image-20221204150048-bd0mj1f.png" alt="image">​</p><h3 id="定义通知"><a href="#定义通知" class="headerlink" title="定义通知"></a>定义通知</h3><blockquote><p>通知有五种类型，分别是：</p><p>前置通知（@Before）：在目标方法调用之前调用通知</p><p>后置通知（@After）：在目标方法完成之后调用通知</p><p>环绕通知（@Around）：在被通知的方法调用之前和调用之后执行自定义的方法</p><p>返回通知（@AfterReturning）：在目标方法成功执行之后调用通知</p><p>异常通知（@AfterThrowing）：在目标方法抛出异常之后调用通知</p></blockquote><p>本例中，分别使用前置通知实现“看房”和“谈价格”功能，使用后置通知实现“交钥匙”功能。这样一个切面就定义完成，下面是代码</p><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.test_spring.aspect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.After;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Broker</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.example.test_spring.service.LandlordService.rent())&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointCut</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;pointCut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beforeRent</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;中间商：带租客看房&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;中间商：谈价格&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After(&quot;pointCut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterRent</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;中间商：交钥匙&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSpringApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> SpringApplication.run(TestSpringApplication.class, args);</span><br><span class="line">        <span class="type">LandlordService</span> <span class="variable">bean</span> <span class="operator">=</span> context.getBean(LandlordService.class);</span><br><span class="line">        bean.rent();</span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="image-20221204150759-y1b4f1u.png" alt="image">​</p><h2 id="环绕通知"><a href="#环绕通知" class="headerlink" title="环绕通知"></a>环绕通知</h2><p>看到上述的需求也可以使用环绕通知，他会在方法执行前后执行。</p><p>改写<code>Broker.java</code>​代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.test_spring.aspect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.JoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Broker</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.example.test_spring.service.LandlordService.rent())&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointCut</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    @Before(&quot;pointCut()&quot;)</span></span><br><span class="line"><span class="comment">//    public void beforeRent() &#123;</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;中间商：带租客看房&quot;);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;中间商：谈价格&quot;);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    @After(&quot;pointCut()&quot;)</span></span><br><span class="line"><span class="comment">//    public void afterRent() &#123;</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;中间商：交钥匙&quot;);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;pointCut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">aroundRent</span><span class="params">(ProceedingJoinPoint point)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;中间商：带租客看房&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;中间商：谈价格&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            point.proceed();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;中间商：交钥匙&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行测试代码，结果依然正确</p><h1 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h1><ol><li><a href="https://www.jianshu.com/p/994027425b44">Spring(4)——面向切面编程（AOP模块）</a></li><li><a href="https://www.cnblogs.com/sgh1023/p/13363679.html">Spring Boot使用AOP的正确姿势</a>​</li></ol><p>‍</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文不涉及Spring AOP原理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Spring-AOP-简介&quot;&gt;&lt;a href=&quot;#Spring-AOP-简介&quot; class=&quot;headerlink&quot; title=&quot;Spring AOP 简介&quot;</summary>
      
    
    
    
    <category term="Java" scheme="https://guoyujian.github.io/categories/Java/"/>
    
    <category term="Spring" scheme="https://guoyujian.github.io/categories/Java/Spring/"/>
    
    
    <category term="Java" scheme="https://guoyujian.github.io/tags/Java/"/>
    
    <category term="Spring" scheme="https://guoyujian.github.io/tags/Spring/"/>
    
    <category term="面向切面编程" scheme="https://guoyujian.github.io/tags/%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/"/>
    
    <category term="AOP" scheme="https://guoyujian.github.io/tags/AOP/"/>
    
  </entry>
  
</feed>
