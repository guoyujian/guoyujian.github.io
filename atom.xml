<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Gmet&#39;s Blog</title>
  
  <subtitle>Eureka!</subtitle>
  <link href="https://guoyujian.github.io/atom.xml" rel="self"/>
  
  <link href="https://guoyujian.github.io/"/>
  <updated>2025-06-10T11:42:18.411Z</updated>
  <id>https://guoyujian.github.io/</id>
  
  <author>
    <name>Met Guo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>复数的工学应用</title>
    <link href="https://guoyujian.github.io/2025/06/10/%E5%A4%8D%E6%95%B0%E7%9A%84%E5%B7%A5%E5%AD%A6%E5%BA%94%E7%94%A8/"/>
    <id>https://guoyujian.github.io/2025/06/10/%E5%A4%8D%E6%95%B0%E7%9A%84%E5%B7%A5%E5%AD%A6%E5%BA%94%E7%94%A8/</id>
    <published>2025-06-10T11:18:03.000Z</published>
    <updated>2025-06-10T11:42:18.411Z</updated>
    
    <content type="html"><![CDATA[<object data="/pdfs/complex_application.pdf" type="application/pdf" width="100%" height="800px">]]></content>
    
    
      
      
    <summary type="html">&lt;object data=&quot;/pdfs/complex_application.pdf&quot; type=&quot;application/pdf&quot; width=&quot;100%&quot; height=&quot;800px&quot;&gt;



</summary>
      
    
    
    
    <category term="数学" scheme="https://guoyujian.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="数学" scheme="https://guoyujian.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="pdf" scheme="https://guoyujian.github.io/tags/pdf/"/>
    
  </entry>
  
  <entry>
    <title>【摘抄】教科书上有哪些令你触动的话</title>
    <link href="https://guoyujian.github.io/2025/03/28/%E3%80%90%E6%91%98%E6%8A%84%E3%80%91%E6%95%99%E7%A7%91%E4%B9%A6%E4%B8%8A%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BB%A4%E4%BD%A0%E8%A7%A6%E5%8A%A8%E7%9A%84%E8%AF%9D/"/>
    <id>https://guoyujian.github.io/2025/03/28/%E3%80%90%E6%91%98%E6%8A%84%E3%80%91%E6%95%99%E7%A7%91%E4%B9%A6%E4%B8%8A%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BB%A4%E4%BD%A0%E8%A7%A6%E5%8A%A8%E7%9A%84%E8%AF%9D/</id>
    <published>2025-03-28T15:24:39.000Z</published>
    <updated>2025-03-28T15:27:08.299Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>“数学是我国人民所擅长的学科。”</p><p>——华罗庚</p><p>“物理学的殿堂中，没有诡辩者的位置”</p><p>——物理必修一</p><p>“没有学术的民主和思想的自由，科学就不能繁荣。”</p><p>——物理必修一（人教版）</p><p>“现在我要演示世界体系的框架”</p><p>——《自然哲学的数学原理》第三卷前言，牛顿</p><p>“你能认出真理，因为她既美又简单。”</p><p>——费曼</p></blockquote><h2 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h2><p>知乎同名问题回答</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;“数学是我国人民所擅长的学科。”&lt;/p&gt;
&lt;p&gt;——华罗庚&lt;/p&gt;
&lt;p&gt;“物理学的殿堂中，没有诡辩者的位置”&lt;/p&gt;
&lt;p&gt;——物理必修一&lt;/p&gt;
&lt;p&gt;“没有学术的民主和思想的自由，科学就不能繁荣。”&lt;/p&gt;
&lt;p&gt;——物理必修一（人教版）&lt;/</summary>
      
    
    
    
    <category term="其他" scheme="https://guoyujian.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="其他" scheme="https://guoyujian.github.io/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>平面方程的四种表达方式总结</title>
    <link href="https://guoyujian.github.io/2025/03/27/%E5%B9%B3%E9%9D%A2%E6%96%B9%E7%A8%8B%E7%9A%84%E5%9B%9B%E7%A7%8D%E8%A1%A8%E8%BE%BE%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
    <id>https://guoyujian.github.io/2025/03/27/%E5%B9%B3%E9%9D%A2%E6%96%B9%E7%A8%8B%E7%9A%84%E5%9B%9B%E7%A7%8D%E8%A1%A8%E8%BE%BE%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/</id>
    <published>2025-03-27T02:42:16.000Z</published>
    <updated>2025-03-27T02:43:11.461Z</updated>
    
    <content type="html"><![CDATA[<p>平面方程有四种表达方式分别是：截距式，点法式，一般式，法线式。</p><h3 id="点法式"><a href="#点法式" class="headerlink" title="点法式"></a>点法式</h3><script type="math/tex; mode=display">A(x-x_0)+B(y-y_0)+C(z-z_0)=0</script><p>假设$\vec{n}=(A,B,C)$为平面的法向量，$M=(x,y,z)$为平面上任意一点，$M’=(x_0,y_0,z_0)$，则有$\vec{n}·\vec{MM’}=0$，则有</p><script type="math/tex; mode=display">A(x-x_0)+B(y-y_0)+C(z-z_0)=0</script><h3 id="一般式"><a href="#一般式" class="headerlink" title="一般式"></a>一般式</h3><script type="math/tex; mode=display">Ax+By+Cz+D=0</script><p>由点法式推出</p><script type="math/tex; mode=display">Ax + By + Cz - Ax_0 - By_0 - Cz_0 = 0</script><p>令</p><script type="math/tex; mode=display">D =  - Ax_0 - By_0 - Cz_0</script><p>即推导出一般式</p><h3 id="截距式"><a href="#截距式" class="headerlink" title="截距式"></a>截距式</h3><p>设平面方程为</p><script type="math/tex; mode=display">Ax+By+Cz+D=0</script><p>若$D\ne0$，取$a=-\frac{D}{A}$,$b=-\frac{D}{B}$,$c=-\frac{D}{C}$，则得平面的截距式方程</p><script type="math/tex; mode=display">\frac{x}{a} + \frac{y}{b} + \frac{c}{z} = 1</script><p>平面与三个轴的坐标分别为$P(a,0,0)$,$Q(0,b,0)$,$R(0,0,c)$，其中a,b,c依次称为该平面在x,y,z轴上的截距。</p><p>推导过程很简单平面与x轴的交点就是令$y=0$,$z=0$,所以$a=-\frac{D}{A}$，以此类推。</p><h3 id="法线式"><a href="#法线式" class="headerlink" title="法线式"></a>法线式</h3><script type="math/tex; mode=display">x\cos\alpha + y\cos\beta + z\cos\gamma = d</script><p>其中$\cos\alpha$、$\cos\beta$、$\cos\gamma$是平面法向量的方向余弦，$d$为原点到平面的距离。</p><p>其中</p><script type="math/tex; mode=display">\cos^2\alpha+\cos^2\beta+\cos^2\gamma=1</script><p>假设原点到平面的法线为$\vec{on}$，平面上任意一点$p(x,y,z)$，平面上一点$p_0,(x_0,y_0,z_0)$，则有</p><script type="math/tex; mode=display">\vec{on}·\vec{pp_0} = 0</script><p>又$\vec{pp_0} = \vec{op} - \vec{op_0}$，则</p><script type="math/tex; mode=display">\vec{on}·\vec{op}-\vec{on}·\vec{op_0}  = 0</script><p>设$\vec{on_0}$为单位法向量</p><script type="math/tex; mode=display">\vec{on_0}=(\cos\alpha, \cos\beta, \cos\gamma)</script><p>且</p><script type="math/tex; mode=display">\cos^2\alpha+\cos^2\beta+\cos^2\gamma=1</script><p>则</p><script type="math/tex; mode=display">\vec{on}·\vec{op}-\vec{on}·\vec{op_0}  = \vec{on_0}·\vec{op}-\vec{on_0}·\vec{op_0}</script><p>其中</p><script type="math/tex; mode=display">\vec{on_0}·\vec{op_0}=d</script><p>（$\vec{on_0}·\vec{op_0}$相当于$\vec{op_0}$在法线方向上的余弦，即原点到平面距离$d$）</p><p>并且</p><script type="math/tex; mode=display">\vec{on_0}·\vec{op} = x\cos\alpha + y\cos\beta + z\cos\gamma</script><p>所以</p><script type="math/tex; mode=display">x\cos\alpha + y\cos\beta + z\cos\gamma = d</script><p>‍</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;平面方程有四种表达方式分别是：截距式，点法式，一般式，法线式。&lt;/p&gt;
&lt;h3 id=&quot;点法式&quot;&gt;&lt;a href=&quot;#点法式&quot; class=&quot;headerlink&quot; title=&quot;点法式&quot;&gt;&lt;/a&gt;点法式&lt;/h3&gt;&lt;script type=&quot;math/tex; mode=d</summary>
      
    
    
    
    
    <category term="数学" scheme="https://guoyujian.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Python 元类基础</title>
    <link href="https://guoyujian.github.io/2025/03/26/Python-%E5%85%83%E7%B1%BB%E5%9F%BA%E7%A1%80/"/>
    <id>https://guoyujian.github.io/2025/03/26/Python-%E5%85%83%E7%B1%BB%E5%9F%BA%E7%A1%80/</id>
    <published>2025-03-26T03:53:51.000Z</published>
    <updated>2025-03-26T14:39:43.143Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是元类"><a href="#什么是元类" class="headerlink" title="什么是元类"></a>什么是元类</h2><p>在Python中“万物”皆是对象，当然<strong>类</strong>也是对象。</p><p>通过类我们可以创建实例对象：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">a = A()</span><br></pre></td></tr></table></figure><p>那么通过什么我们创建类呢？答案是<strong>元类</strong>。</p><p>即：类是元类的实例</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(A, <span class="built_in">type</span>)) <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">issubclass</span>(A, <span class="built_in">object</span>)) <span class="comment"># True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="元类的作用"><a href="#元类的作用" class="headerlink" title="元类的作用"></a>元类的作用</h2><p>元类可以定制化类的创建过程。例如修改类的属性、方法，添加新的属性、方法，甚至可以拦截类的创建过程。</p><h2 id="使用type创建类"><a href="#使用type创建类" class="headerlink" title="使用type创建类"></a>使用type创建类</h2><p><code>type</code>既可以判断对象的类型</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span>(<span class="number">123</span>) <span class="comment"># &lt;class &#x27;int&#x27;&gt;</span></span><br></pre></td></tr></table></figure><p>也是所有类的顶层元类</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">int</span>))    <span class="comment"># &lt;class &#x27;type&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">str</span>))    <span class="comment"># &lt;class &#x27;type&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">object</span>)) <span class="comment"># &lt;class &#x27;type&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">type</span>))   <span class="comment"># &lt;class &#x27;type&#x27;&gt; （type 也是它自己的实例）</span></span><br></pre></td></tr></table></figure><p>也可以通过<code>type(name, bases, attrs)</code>动态创建类，</p><p>其中，</p><ul><li><code>name</code>：类的名字；</li><li><code>bases</code>：类继承的父类集合</li><li><code>attrs</code>：类的属性、方法字典</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person1</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">    self.name = name</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init</span>(<span class="params">self, name</span>):</span><br><span class="line">  self.name = name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Person2 = <span class="built_in">type</span>(<span class="string">&#x27;Person&#x27;</span>, (), &#123;<span class="string">&#x27;__init__&#x27;</span>: init&#125;)</span><br></pre></td></tr></table></figure><p>在这个例子中，Person2和Person1的效果一模一样，因为Python解释器在读到<code>class Person1</code>的定义时就是调用的type。因此通过Person2创建实例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = Person2(<span class="string">&#x27;John&#x27;</span>)</span><br><span class="line">p.name <span class="comment"># John</span></span><br></pre></td></tr></table></figure><h2 id="自定义元类"><a href="#自定义元类" class="headerlink" title="自定义元类"></a>自定义元类</h2><p>所有类默认情况下，元类是type，当然也可以指定类的元类（当然了，所有类的元类最终都指向了type）</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AMetaClass</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">  <span class="comment">#继承了type的既是元类</span></span><br><span class="line">  <span class="comment">#元类命名最好是MetaClass后缀</span></span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(metaclass = AMetaClass):</span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>这个例子中A的元类是AMetaClass。</p><p>我们知道，创建一个实例对象，会调用类的<code>__new__</code>方法。同样的，创建一个类，会调用其元类的<code>__new__</code>方法。因此在元类中重写<code>__new__</code>方法即可拦截类的生成方式。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AMetaClass</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, name, bases, attrs</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>().__new__(cls, name, bases, attrs)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(metaclass = AMetaClass):</span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>那么这样做的意义是什么？</p><p>通常来讲，对于普通开发者，并不需要元类编程。但凡事总有例外。</p><p>元类编程的最大作用之一，是可以开发框架。</p><h2 id="使用元类创建简单的ORM框架"><a href="#使用元类创建简单的ORM框架" class="headerlink" title="使用元类创建简单的ORM框架"></a>使用元类创建简单的ORM框架</h2><p>这里使用元类创建简单的ORM框架作为案例。</p><p>我希望对于自定义继承自BaseModel的类，其包含一个类变量<code>table_name</code>，变量名为小写的类名。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(User.table_name) <span class="comment"># user</span></span><br></pre></td></tr></table></figure><p>这里就要用到元类，我们要拦截BaseModel类的生成，在生成其子类的时候给它添加属性table_name，因此完整的代码是：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ModelMetaClass</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, name, bases, attrs</span>):</span><br><span class="line">        <span class="keyword">if</span> name != <span class="string">&#x27;BaseModel&#x27;</span>:</span><br><span class="line">            attrs[<span class="string">&#x27;table_name&#x27;</span>] = name.lower()</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().__new__(cls, name, bases, attrs)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseModel</span>(metaclass=ModelMetaClass):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(User.table_name)  <span class="comment"># 输出：user</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是元类&quot;&gt;&lt;a href=&quot;#什么是元类&quot; class=&quot;headerlink&quot; title=&quot;什么是元类&quot;&gt;&lt;/a&gt;什么是元类&lt;/h2&gt;&lt;p&gt;在Python中“万物”皆是对象，当然&lt;strong&gt;类&lt;/strong&gt;也是对象。&lt;/p&gt;
&lt;p&gt;通过类我们可以创</summary>
      
    
    
    
    <category term="Python" scheme="https://guoyujian.github.io/categories/Python/"/>
    
    <category term="基础" scheme="https://guoyujian.github.io/categories/Python/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Python" scheme="https://guoyujian.github.io/tags/Python/"/>
    
    <category term="元类" scheme="https://guoyujian.github.io/tags/%E5%85%83%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>Python单例模式总结</title>
    <link href="https://guoyujian.github.io/2025/03/21/Python%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
    <id>https://guoyujian.github.io/2025/03/21/Python%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/</id>
    <published>2025-03-21T08:06:46.000Z</published>
    <updated>2025-03-21T10:27:17.131Z</updated>
    
    <content type="html"><![CDATA[<p>单例模式的主要目的是保证在系统中，<strong>某个类只能有一个实例存在</strong>。比如保存系统基本配置信息的类，在很多地方都要用到，没有必要频繁创建实例与销毁实例，只需要保存一个全局的实例对象即可，这样可以减少对内存资源的占用。</p><h2 id="Python模块实现单例"><a href="#Python模块实现单例" class="headerlink" title="Python模块实现单例"></a>Python模块实现单例</h2><p><strong>Python 的模块就是天然的单例模式</strong>，因为模块在第一次导入时，会生成 <code>.pyc</code> 文件，当第二次导入时，就会直接加载 <code>.pyc</code> 文件，而不会再次执行模块代码。因此，我们只需把相关的函数和数据定义在一个模块中，就可以获得一个单例对象了。如果我们真的想要一个单例类，可以考虑这样做：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">singleton = Singleton()</span><br></pre></td></tr></table></figure><p>将上面的代码保存在文件 <code>mysingleton.py</code> 中，要使用时，直接在其他文件中导入此文件中的对象，这个对象即是单例模式的对象</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mysingleton <span class="keyword">import</span> singleton</span><br></pre></td></tr></table></figure><h2 id="使用装饰器实现单例"><a href="#使用装饰器实现单例" class="headerlink" title="使用装饰器实现单例"></a>使用装饰器实现单例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def singleton(cls):</span><br><span class="line">    _instance = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    def _singleton(*args, **kwargs):</span><br><span class="line">        if cls not in _instance:</span><br><span class="line">            _instance[cls] = cls(*args, **kwargs)</span><br><span class="line">        return _instance[cls]</span><br><span class="line">    return _singleton</span><br><span class="line"></span><br><span class="line">@singleton</span><br><span class="line">class A(object):</span><br><span class="line">    a = 1</span><br><span class="line">    def __init__(self, x = 0):</span><br><span class="line">        self.x = x</span><br><span class="line"></span><br><span class="line">a1 = A(1)</span><br><span class="line">a2 = A(2)</span><br><span class="line">print(a1 == a2)</span><br></pre></td></tr></table></figure><blockquote><p>使用装饰器实现的单例模式在<strong>多线程环境</strong>下可能会引发竞争条件（race condition），导致创建多个实例。因此，在<strong>并发访问的场景</strong>下，<strong>需要加锁</strong>来保证线程安全。</p><hr><p><strong>为什么需要加锁？</strong></p><p>假设多个线程同时执行 _singleton() 方法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if cls not in _instance:</span><br><span class="line">    _instance[cls] = cls(*args, **kwargs)</span><br></pre></td></tr></table></figure><ul><li><strong>线程 A</strong> 判断 _instance 中没有 cls，但此时 <strong>线程 B</strong> 可能也执行到此处。</li><li>两个线程可能同时创建 cls()，最终 _instance 可能存储多个实例。</li></ul><p>这种竞争条件会导致<strong>单例模式失效</strong>。</p><hr><p><strong>如何加锁？</strong></p><p>可以使用 threading.Lock() 来确保只有一个线程能创建实例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">singleton</span>(<span class="params">cls</span>):</span><br><span class="line">    _instance = &#123;&#125;</span><br><span class="line">    _lock = threading.Lock()  <span class="comment"># 线程锁</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @wraps(<span class="params">cls</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> _instance:  <span class="comment"># 第一次判断（非严格保证）</span></span><br><span class="line">            <span class="keyword">with</span> _lock:  <span class="comment"># 进入锁定区间</span></span><br><span class="line">                <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> _instance:  <span class="comment"># 再次判断，避免多个线程重复创建</span></span><br><span class="line">                    _instance[cls] = cls(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> _instance[cls]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="meta">@singleton</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cls</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value=<span class="number">0</span></span>):</span><br><span class="line">        self.value = value</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试多线程环境</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_singleton</span>():</span><br><span class="line">    obj = Cls()</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">id</span>(obj))</span><br><span class="line"></span><br><span class="line">threads = [threading.Thread(target=test_singleton) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">    t.start()</span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">    t.join()</span><br></pre></td></tr></table></figure><p><strong>要点</strong></p><ol><li><em>双重检查*</em>（Double-Checked Locking）：<ol><li>先检查 _instance 是否存在（不加锁）。</li><li><strong>进入锁定区间</strong>后，<strong>再次检查</strong> _instance 是否已创建。</li><li>这样可避免多个线程重复创建实例。</li></ol></li><li><strong>使用 with _lock 语法</strong>确保锁在作用域结束后自动释放。</li></ol></blockquote><h2 id="使用类实现单例"><a href="#使用类实现单例" class="headerlink" title="使用类实现单例"></a>使用类实现单例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">instance</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(Singleton, <span class="string">&quot;_instance&quot;</span>):</span><br><span class="line">            Singleton._instance = Singleton(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> Singleton._instance</span><br></pre></td></tr></table></figure><p>和使用装饰器的方法一样，使用类的单例模式在多线程环境下会失效。</p><p>解决方法也和“使用装饰器的方法”一样，加锁。</p><h2 id="【推荐】-new-实现单例"><a href="#【推荐】-new-实现单例" class="headerlink" title="【推荐】__new__实现单例"></a>【推荐】<code>__new__</code>实现单例</h2><p><code>__new__</code>方法在实例创建前被调用，可确保只创建一个实例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>:</span><br><span class="line">    _instance = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">if</span> cls._instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            cls._instance = <span class="built_in">super</span>().__new__(cls)</span><br><span class="line">        <span class="keyword">return</span> cls._instance</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">a = Singleton()</span><br><span class="line">b = Singleton()</span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">is</span> b)  <span class="comment"># True</span></span><br></pre></td></tr></table></figure><p>和使用装饰器的方法一样，使用<strong>new</strong>的单例模式在多线程环境下会失效。</p><p>解决方法也和“使用装饰器的方法”一样。（加锁，Double-Check）</p><h2 id="【推荐】metaclass实现单例"><a href="#【推荐】metaclass实现单例" class="headerlink" title="【推荐】metaclass实现单例"></a>【推荐】metaclass实现单例</h2><blockquote><p>在Python中，对象是类的实例，而类是元类的实例。在没有指定的情况下，type是所有类的元类。</p><p>自定义类的元类，可以拦截类的创建过程，这是metaclass实现单例模式的基础。</p><p>这里不懂的话，需要仔细看一下Python元类的知识～</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingletonMeta</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    _instances = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> cls._instances:</span><br><span class="line">            cls._instances[cls] = <span class="built_in">super</span>().__call__(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> cls._instances[cls]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>(metaclass=SingletonMeta):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">obj1 = Singleton()</span><br><span class="line">obj2 = Singleton()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(obj1 <span class="keyword">is</span> obj2)  <span class="comment"># True，说明 obj1 和 obj2 是同一个实例</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>难点解释：</p><ol><li>当调用 <code>Singleton()</code> 时，实际上调用的是 <code>SingletonMeta</code> 的 <code>__call__</code> 方法。</li><li><code>cls</code> 是 <code>Singleton</code> 类，而不是 <code>SingletonMeta</code> 元类</li><li>元类属性会自动成为类的属性，所以<code>cls._instances</code>指向了SingletonMeta._instances</li><li><code>super().__call__(*args, **kwargs)</code>的等价操作<code>type.__call__(cls, *args, **kwargs)</code></li><li>而<code>type.__call__</code>会调用类的<code>__new__</code>和<code>__init__</code>方法，从而创建Singleton的实例对象。</li></ol><h2 id="使用-functools-lru-cache"><a href="#使用-functools-lru-cache" class="headerlink" title="使用 functools.lru_cache"></a>使用 <code>functools.lru_cache</code></h2><p><code>lru_cache</code> 可以缓存实例，从而实现单例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> lru_cache</span><br><span class="line"></span><br><span class="line"><span class="meta">@lru_cache(<span class="params">maxsize=<span class="number">1</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_instance</span>():</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Singleton</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">return</span> Singleton()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">a = get_instance()</span><br><span class="line">b = get_instance()</span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">is</span> b)  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;单例模式的主要目的是保证在系统中，&lt;strong&gt;某个类只能有一个实例存在&lt;/strong&gt;。比如保存系统基本配置信息的类，在很多地方都要用到，没有必要频繁创建实例与销毁实例，只需要保存一个全局的实例对象即可，这样可以减少对内存资源的占用。&lt;/p&gt;
&lt;h2 id=&quot;Pyth</summary>
      
    
    
    
    <category term="Python" scheme="https://guoyujian.github.io/categories/Python/"/>
    
    <category term="基础" scheme="https://guoyujian.github.io/categories/Python/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Python" scheme="https://guoyujian.github.io/tags/Python/"/>
    
    <category term="设计模式" scheme="https://guoyujian.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>比较PCL使用CPU和Nvidia GPU计算效率问题</title>
    <link href="https://guoyujian.github.io/2024/06/20/%E6%AF%94%E8%BE%83PCL%E4%BD%BF%E7%94%A8CPU%E5%92%8CNvidia-GPU%E8%AE%A1%E7%AE%97%E6%95%88%E7%8E%87%E9%97%AE%E9%A2%98/"/>
    <id>https://guoyujian.github.io/2024/06/20/%E6%AF%94%E8%BE%83PCL%E4%BD%BF%E7%94%A8CPU%E5%92%8CNvidia-GPU%E8%AE%A1%E7%AE%97%E6%95%88%E7%8E%87%E9%97%AE%E9%A2%98/</id>
    <published>2024-06-20T10:11:19.000Z</published>
    <updated>2024-06-24T10:00:49.973Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前篇文章提到，对比PCL使用CPU和Nvidia GPU进行欧式聚类发现，尴尬发现使用CPU的计算效率反而更高。</p><p>本篇文章探讨一下原因。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>观察<a href="https://github.com/PointCloudLibrary/pcl/blob/master/gpu/examples/segmentation/src/seg.cpp">代码</a>可以发现，代码中使用CPU欧式聚类的搜索方法选用的是kdtree，使用GPU欧式聚类的搜索方法选用的是octree。感觉有可能是这里的原因导致CPU计算效率更高。于是尝试将CPU的搜索方法也改为octree。</p><p>但是编译确保错了，细看官方文档发现</p><p><img src="image-20240620154924-1r4baou.png" alt="image">​</p><p><img src="image-20240620154931-xs2ku8t.png" alt="image">​</p><p>pcl::search::octree的构造方法中有一个resolution的参数，而在pcl::gpu::octree的构造方法中并没有提供带有resolution参数的构造方法。</p><p>尴尬。这样一来就没有保证cpu和gpu计算时同时使用octree。</p><p>于是我转头去实现<strong>法线估计的cpu和gpu比较。</strong> 发现还是同样的问题：同样的方法，其参数在CPU和GPU上的实现不能保持一致。</p><p><img src="image-20240620155643-sp9v2fk.png" alt="image">​</p><p><img src="image-20240620155701-b0q1yif.png" alt="image">​</p><p>在法线估计的参数上，我设置radius=0.03f, max_results=1000</p><p>得到结果使用gpu消耗的时间&lt;&lt;cpu消耗的时间，但是我对比了两者结果，发现计算结果的法线向量完全不一样。</p><p>如果参数不一样、结果不一样，那么即使计算效率gpu更高，也不能说明什么问题。</p><p>后来又发现了在pcl/gpu之外，还有一个pcl/cuda，这下面有一个voxelgrid，结果代码中说does not work…</p><p><img src="image-20240620170456-9u3gr2y.png" alt="image">​</p><p>总结一下前述：</p><ol><li>对于欧式聚类，修改参数resolution不会导致结果发生改变；</li><li>对于欧式聚类，gpu和cpu计算结果一致；</li><li>对于欧式聚类，cpu计算效率略高于gpu；</li><li>对于法线估计，修改参数会导致计算结果改变；</li><li>对于欧式聚类，gpu和cpu计算结果不一致；</li><li>对于欧式聚类，cpu计算效率远低于GPU；</li><li>无论是欧式聚类还是法线估计，cpu和gpu提供的接口都有差异，以至于找不到完全一致的参数进行比较。</li><li>除pcl/gpu外，还有pcl/cuda，但是也没什么用。</li></ol><hr><p>后来我找到了Nvidia官方提供的PCL cpu和gpu计算比较代码：</p><p><a href="https://github.com/NVIDIA-AI-IOT/cuPCL/tree/main">https://github.com/NVIDIA-AI-IOT/cuPCL/tree/main</a></p><p>其中提供了聚类、滤波、ICP、NDT、Octree和segmentation的演示代码</p><p><img src="image-20240620170650-m33j5l9.png" alt="image">​</p><p>clone和自己硬件环境对应的代码分支</p><p>根据官方的说明，配置好依赖环境，直接进到子目录下make，就可以。但是我尝试死活编译不通。</p><p><img src="WX20240624-175840@2x.png" alt="WX20240624-175840@2x"></p><p>检查PCL各项环境配置的都没问题，于是创建CMakeLists，通过cmake生成makefile，再make。成功了…</p><p>最后编译执行了cuFilter，得到结果如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GPU has cuda devices: 1</span><br><span class="line">----device id: 0 info----</span><br><span class="line">  GPU : Orin </span><br><span class="line">  Capbility: 8.7</span><br><span class="line">  Global memory: 15420MB</span><br><span class="line">  Const memory: 64KB</span><br><span class="line">  SM in a block: 48KB</span><br><span class="line">  warp size: 32</span><br><span class="line">  threads in a block: 1024</span><br><span class="line">  block dim: (1024,1024,64)</span><br><span class="line">  grid dim: (2147483647,65535,65535)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------checking CUDA ---------------- </span><br><span class="line">CUDA Loaded 119978 data points from PCD file with the following fields: x y z</span><br><span class="line"></span><br><span class="line">------------checking CUDA PassThrough ---------------- </span><br><span class="line">CUDA PassThrough by Time: 0.999257 ms.</span><br><span class="line">CUDA PassThrough before filtering: 119978</span><br><span class="line">CUDA PassThrough after filtering: 5110</span><br><span class="line"></span><br><span class="line">------------checking CUDA VoxelGrid---------------- </span><br><span class="line">CUDA VoxelGrid by Time: 6.46314 ms.</span><br><span class="line">CUDA VoxelGrid before filtering: 119978</span><br><span class="line">CUDA VoxelGrid after filtering: 3440</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------checking PCL ---------------- </span><br><span class="line">PCL(CPU) Loaded 119978 data points from PCD file with the following fields: x y z</span><br><span class="line"></span><br><span class="line">------------checking PCL(CPU) PassThrough ---------------- </span><br><span class="line">PCL(CPU) PassThrough by Time: 3.08542 ms.</span><br><span class="line">PointCloud before filtering: 119978 data points (x y z).</span><br><span class="line">PointCloud after filtering: 5110 data points (x y z).</span><br><span class="line"></span><br><span class="line">------------checking PCL VoxelGrid---------------- </span><br><span class="line">PCL VoxelGrid by Time: 11.5708 ms.</span><br><span class="line">PointCloud before filtering: 119978 data points (x y z).</span><br><span class="line">PointCloud after filtering: 3440 data points (x y z).</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>目前该项目源码尚未开源，但是从结果和部分调用的代码来看，参数一致、结果一致，🈶可比较性。</p><p>测试结果可以发现使用CUDA可以加速PCL对点云的滤波计算。</p><p>补充CMakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.16</span>)</span><br><span class="line"><span class="keyword">project</span>(cupcl)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将资源文件复制到build目录中</span></span><br><span class="line"><span class="comment"># configure_file($&#123;CMAKE_SOURCE_DIR&#125;/cuFilter/lib  $&#123;CMAKE_BINARY_DIR&#125;/  COPYONLY)</span></span><br><span class="line"><span class="comment"># configure_file($&#123;CMAKE_SOURCE_DIR&#125;/table_scene_lms400.pcd  $&#123;CMAKE_BINARY_DIR&#125;/table_scene_lms400.pcd  COPYONLY)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(PCL <span class="number">1.14</span> REQUIRED)</span><br><span class="line"><span class="keyword">find_package</span>(CUDA  REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;PCL INCLUDE DIRS : $&#123;PCL_INCLUDE_DIRS&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>(</span><br><span class="line">    <span class="variable">$&#123;PCL_INCLUDE_DIRS&#125;</span></span><br><span class="line">    <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/cuFilter/lib   </span><br><span class="line">)</span><br><span class="line"><span class="keyword">link_directories</span>(</span><br><span class="line">    <span class="variable">$&#123;PCL_LIBRARY_DIRS&#125;</span></span><br><span class="line">    <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/cuFilter/lib    </span><br><span class="line">)</span><br><span class="line"><span class="keyword">add_definitions</span>(<span class="variable">$&#123;PCL_DEFINITIONS&#125;</span>)</span><br><span class="line"><span class="keyword">add_executable</span>(cupcl </span><br><span class="line">    <span class="comment"># seg1.cpp</span></span><br><span class="line">    cuFilter/main.cpp</span><br><span class="line">)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(cupcl <span class="variable">$&#123;PCL_LIBRARIES&#125;</span> cudafilter <span class="variable">$&#123;CUDA_LIBRARIES&#125;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前篇文章提到，对比PCL使用CPU和Nvidia GPU进行欧式聚类发现，尴尬发现使用CPU的计算效率反而更高。&lt;/p&gt;
&lt;p&gt;本篇文章探讨</summary>
      
    
    
    
    <category term="点云处理" scheme="https://guoyujian.github.io/categories/%E7%82%B9%E4%BA%91%E5%A4%84%E7%90%86/"/>
    
    
    <category term="PCL" scheme="https://guoyujian.github.io/tags/PCL/"/>
    
    <category term="点云处理" scheme="https://guoyujian.github.io/tags/%E7%82%B9%E4%BA%91%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>PCL-CUDA版本编译安装</title>
    <link href="https://guoyujian.github.io/2024/06/20/PCL-CUDA%E7%89%88%E6%9C%AC%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85/"/>
    <id>https://guoyujian.github.io/2024/06/20/PCL-CUDA%E7%89%88%E6%9C%AC%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85/</id>
    <published>2024-06-20T10:05:16.000Z</published>
    <updated>2024-06-20T10:10:27.827Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>pcl是一个c++编写的点云数据处理库。</p><p>大量点云数据处理通常需要消耗CPU大量时间，而使用cuda可以加速计算。</p><p>目前pcl最新版本（1.14）支持cuda计算加速（尽管还不完善），但是需要额外的步骤进行编译安装。</p><p>如果要编译安装的是PCL普通版本（即只使用CPU进行计算的版本）比较简单，在此略过。</p><p>本文介绍PCL-CUDA的编译安装。‍</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>我的OS是Ubuntu，详细硬件环境如下图，通过jtop命令获得</p><p><img src="image-20240620114138-83b047k.png" alt="image">​</p><p>我的软件环境：</p><div class="table-container"><table><thead><tr><th>software</th><th><br /></th><th>cmd</th></tr></thead><tbody><tr><td>cuda</td><td>11.4</td><td>nvcc —version</td></tr><tr><td>gcc</td><td>9</td><td>gcc -dumpversion</td></tr><tr><td>clang</td><td>10</td><td>clang —version</td></tr><tr><td>Eigen</td><td>3.3.7</td><td>dpkg -s libeigen3-dev \</td><td>grep Version</td></tr><tr><td>cmake vtk qt</td><td></td></tr></tbody></table></div><p>安装命令自己找，大部分都是apt install，这里找到一个比较全的</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install git build-essential linux-libc-dev</span><br><span class="line">sudo apt-get install cmake cmake-gui</span><br><span class="line">sudo apt-get install libusb-1.0-0-dev libusb-dev libudev-dev</span><br><span class="line">sudo apt-get install mpi-default-dev openmpi-bin openmpi-common</span><br><span class="line">sudo apt-get install libflann1.9 libflann-dev # ubuntu20.4对应1.9</span><br><span class="line">sudo apt-get install libeigen3-dev</span><br><span class="line">sudo apt-get install libboost-all-dev</span><br><span class="line">sudo apt-get install libqhull* libgtest-dev</span><br><span class="line">sudo apt-get install freeglut3-dev pkg-config</span><br><span class="line">sudo apt-get install libxmu-dev libxi-dev</span><br><span class="line">sudo apt-get install mono-complete</span><br><span class="line">sudo apt-get install libopenni-dev</span><br><span class="line">sudo apt-get install libopenni2-dev</span><br></pre></td></tr></table></figure><h2 id="编译安装PCL"><a href="#编译安装PCL" class="headerlink" title="编译安装PCL"></a>编译安装PCL</h2><p>下载PCL源码，我的是pcl-1.14。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/PointCloudLibrary/pcl.git</span><br><span class="line">cd pcl &amp;&amp; mkdir build &amp;&amp; cd build</span><br><span class="line">cmake -DBUILD_GPU=ON -DBUILD_CUDA=ON -DBUILD_apps=ON -DBUILD_examples=ON ..</span><br><span class="line">make -j2</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>这里注意<code>-DBUILD_GPU=ON -DBUILD_CUDA=ON</code>​</p><p>在make的时候 -j2指定使用2个线程make，如果机器好，可以把2改大一点，加速编译。</p><hr><p>或者打开cmake-gui图形化界面，选择source和build目录，</p><p>把BUILD下和gpu or cuda有关的勾选上，点按configue和generate，</p><p>如果缺什么cmake会飘红，补全后再次点按configue和generate即可。</p><p>以下是我的勾选</p><p><img src="image-20240620142315-h54igmb.png" alt="image">​</p><h2 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h2><p>在<code>make</code>​的时候报错，报错内容和原因忘记了，但是我修改了pcl的源码。</p><p>一个是修改了源码中的头文件，并删除了一部分代码，详见下两图</p><p><img src="image-20240620143054-3kgru5v.png" alt="image">​</p><p><img src="image-20240620143604-hb6fnpc.png" alt="image">​</p><p>一个是增加了对应的头文件sse2neon.h，该文件下载地址：</p><p><a href="https://github.com/DLTcollab/sse2neon/blob/master/sse2neon.h">https://github.com/DLTcollab/sse2neon/blob/master/sse2neon.h</a></p><p><img src="image-20240620143135-mor11yo.png" alt="image">​</p><p>这么改的具体报错忘记了……</p><p>现在看来，这部分代码也不是必须的，只要在cmake的时候指定<code>cmake -DBUILD_gpu_people=OFF ..</code>​就行。</p><h2 id="验证编译是否成功"><a href="#验证编译是否成功" class="headerlink" title="验证编译是否成功"></a>验证编译是否成功</h2><p>在源码中，找到gpu/examples/segmentation/src/seg.cpp，这是一个比较cpu和gpu对点云进行欧式聚类的该代码引入了pcl/gpu的头文件</p><p>如果能编译运行seg.cpp成功，说明pcl-gpu版本安装成功。</p><p><img src="assets/image-20240620153624-0klfssb.png" alt="image">​</p><p>不过我在执行代码得到的结果发现，使用CPU的效率反而会更高。</p><p>检查代码发现，在使用CPU进行聚类的时候使用的searchMethon是kdtree，而使用GPU进行聚类的时候使用的searchMethon是octree。后续文章细说。</p><h2 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h2><ol><li><a href="https://pcl.readthedocs.io/projects/tutorials/en/pcl-1.12.0/gpu_install.html">https://pcl.readthedocs.io/projects/tutorials/en/pcl-1.12.0/gpu_install.html</a></li><li><a href="https://blog.csdn.net/qq_64006507/article/details/135824915">https://blog.csdn.net/qq_64006507/article/details/135824915</a></li><li><a href="https://github.com/PointCloudLibrary/pcl">https://github.com/PointCloudLibrary/pcl</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;pcl是一个c++编写的点云数据处理库。&lt;/p&gt;
&lt;p&gt;大量点云数据处理通常需要消耗CPU大量时间，而使用cuda可以加速计算。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="点云处理" scheme="https://guoyujian.github.io/categories/%E7%82%B9%E4%BA%91%E5%A4%84%E7%90%86/"/>
    
    
    <category term="PCL" scheme="https://guoyujian.github.io/tags/PCL/"/>
    
    <category term="点云" scheme="https://guoyujian.github.io/tags/%E7%82%B9%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>协程，从yield说起</title>
    <link href="https://guoyujian.github.io/2024/03/14/%E5%8D%8F%E7%A8%8B%EF%BC%8C%E4%BB%8Eyield%E8%AF%B4%E8%B5%B7/"/>
    <id>https://guoyujian.github.io/2024/03/14/%E5%8D%8F%E7%A8%8B%EF%BC%8C%E4%BB%8Eyield%E8%AF%B4%E8%B5%B7/</id>
    <published>2024-03-14T02:52:33.000Z</published>
    <updated>2024-03-14T02:58:39.795Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Ref: 《Fluent Python》 第16章 协程</p></blockquote><p>协程是指一个过程，这个过程与调用方协作，产出由调用方提供的值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">simple_coroutine</span>(<span class="params">a</span>): <span class="comment"># 协程用生成器函数定义，里面有yield</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;-&gt; Started: a = <span class="subst">&#123;a&#125;</span>&#x27;</span>)</span><br><span class="line">    b = <span class="keyword">yield</span> a <span class="comment"># yield左边是接收值，右边是产出值</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;-&gt; Received:&#x27;</span>, b)</span><br><span class="line"></span><br><span class="line">my_coro = simple_coroutine(<span class="number">14</span>)</span><br><span class="line">my_coro <span class="comment"># 调用得到协程</span></span><br></pre></td></tr></table></figure><pre><code>&lt;generator object simple_coroutine at 0x1069e5230&gt;</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">next</span>(my_coro) <span class="comment"># 预激活协程，让协程向前执行到第一个yield</span></span><br></pre></td></tr></table></figure><pre><code>-&gt; Started: a = 14</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_coro.send(<span class="number">42</span>) <span class="comment"># 控制权流动到协程末尾，抛出StopIteration</span></span><br></pre></td></tr></table></figure><pre><code>-&gt; Received: 42---------------------------------------------------------------------------StopIteration                             Traceback (most recent call last)Cell In[3], line 1----&gt; 1 my_coro.send(42) # 控制权流动到协程末尾，抛出StopIteration</code></pre><p>可以通过<code>inspect.getgeneratorstate()</code>确定协程的状态：</p><ul><li>GEN_CREATED</li><li>GEN_RUNNING</li><li>GEN_SUSPENDED</li><li>GEN_CLOSED</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> inspect <span class="keyword">import</span> getgeneratorstate</span><br><span class="line">getgeneratorstate(my_coro)</span><br></pre></td></tr></table></figure><pre><code>&#39;GEN_CLOSED&#39;</code></pre><p><strong>使用协程计算移动平均值</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">averager</span>():</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    向协程不断传入值，计算结束，协程再传出</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    average = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        term = <span class="keyword">yield</span> average</span><br><span class="line">        total += term</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        average = total / count</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">avg = averager()</span><br><span class="line"><span class="built_in">next</span>(avg) <span class="comment"># 预激活</span></span><br><span class="line">avg.send(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><pre><code>10.0</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">avg.send(<span class="number">11</span>)</span><br></pre></td></tr></table></figure><pre><code>10.5</code></pre><p>下面解决两个问题：</p><ol><li>用装饰器解决每次都要先预激活协程的问题（略）</li><li>如何结束协程的问题</li></ol><p>第一个问题的代码忽略，预激协程装饰器</p><p><strong>终止协程和异常处理</strong></p><p>客户代码可以在生成器对象上调用两个方法，显式地把异常发给协程。这两个方法是 throw 和 close。</p><p><code>generator.throw(exc_type[, exc_value[, traceback]])</code></p><p>致使生成器在暂停的 yield 表达式处抛出指定的异常。如果生成器处理了抛出的异常，代码会向前执行到下一个 yield 表达式，而产出的值会成为调用 generator.throw 方法得到的返回值。如果生成器没有处理抛出的异常，异常会向上冒泡，传到调用方的上下文中。</p><p><code>generator.close()</code></p><p>致使生成器在暂停的 yield 表达式处抛出 GeneratorExit 异常。如果生成器没有处理这个异常，或者抛出了 StopIteration 异常（通常是指运行到结尾），调用方不会报错。如果收到 GeneratorExit 异常，生成器一定不能产出值，否则解释器会抛出RuntimeError 异常。生成器抛出的其他异常会向上冒泡，传给调用方。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DemoException</span>(<span class="title class_ inherited__">Exception</span>):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">demo_exc_handling</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;started&#x27;</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>: </span><br><span class="line">            x = <span class="keyword">yield</span></span><br><span class="line">        <span class="keyword">except</span> DemoException:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;DemoException Handled, Continuing...&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;received: <span class="subst">&#123;x&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">exe_coro = demo_exc_handling()</span><br><span class="line"><span class="built_in">next</span>(exe_coro)</span><br><span class="line">exe_coro.send(<span class="number">11</span>)</span><br><span class="line">exe_coro.send(<span class="number">11</span>)</span><br><span class="line"><span class="comment"># 传入DemoException不会导致协程终止</span></span><br><span class="line">exe_coro.throw(DemoException())</span><br><span class="line"><span class="comment"># 传入其他未处理的异常，协程会终止</span></span><br><span class="line">exe_coro.close()</span><br></pre></td></tr></table></figure><pre><code>startedreceived: 11received: 11DemoException Handled, Continuing...</code></pre><p><strong>使用yield from</strong></p><p>首先yield from 可以简化for循环中的yield表达式，</p><p>yield from x 表达式对 x 对象所做的第一件事是，调用 iter(x)，从中获取迭代器。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">gen</span>():</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">&#x27;AB&#x27;</span>:</span><br><span class="line">        <span class="keyword">yield</span> c</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>(gen())</span><br></pre></td></tr></table></figure><pre><code>[&#39;A&#39;, &#39;B&#39;, 0, 1, 2]</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">gen</span>():</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;use yield from&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> <span class="string">&#x27;AB&#x27;</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> <span class="built_in">range</span>(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>(gen())</span><br></pre></td></tr></table></figure><pre><code>[&#39;A&#39;, &#39;B&#39;, 0, 1, 2]</code></pre><p><strong>但yield from 的主要功能是打开双向通道，把最外层的调用方与最内层的子生成器连接起来，这样二者可以直接发送和产出值，还可以直接传入异常，而不用在位于中间的协程中添加大量处理异常的样板代码。有了这个结构，协程可以通过以前不可能的方式委托职责。</strong>用脚本例子说明：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">脚本从一个字典中读取虚构的七年级男女学生的体重和身高。例如，&#x27;boys;m&#x27; 键对应于 9 个男学生的身高（单位是米）， &#x27;girls;kg&#x27; 键对应于 10 个女学生的体重（单位是千克）。这个脚本把各组数据传给前面定义的 averager 协程，然后生成一个报告</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line">Result = namedtuple(<span class="string">&#x27;Result&#x27;</span>, <span class="string">&#x27;count average&#x27;</span>)</span><br><span class="line"><span class="comment"># 子生成器</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">averager</span>():</span><br><span class="line">    total = <span class="number">0.0</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    average = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        term = <span class="keyword">yield</span> </span><br><span class="line">        <span class="keyword">if</span> term <span class="keyword">is</span> <span class="literal">None</span>: </span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        total += term</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        average = total/count</span><br><span class="line">    <span class="keyword">return</span> Result(count, average) <span class="comment"># 返回的result会成为grouper函数中yield from表达式的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 委派生成器</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">grouper</span>(<span class="params">results, key</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>: <span class="comment"># 每次循环新建一个average实例</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        grouper 发 送 的 每 个 值 都 会 经 由 yield from 处 理， 通 过 管 道 传 给 averager 实 例。</span></span><br><span class="line"><span class="string">        grouper 会在 yield from 表达式处暂停，等待 averager 实例处理客户端发来的值。</span></span><br><span class="line"><span class="string">        averager 实例运行完毕后，返回的值绑定到 results[key] 上。 while 循环会不断创建</span></span><br><span class="line"><span class="string">        averager 实例，处理更多的值。</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        results[key] = <span class="keyword">yield</span> <span class="keyword">from</span> averager() <span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端代码，即调用方</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">data</span>):</span><br><span class="line">    results = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> key, values <span class="keyword">in</span> data.items():</span><br><span class="line">        group = grouper(results, key)</span><br><span class="line">        <span class="built_in">next</span>(group)</span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> values:</span><br><span class="line">            group.send(value) <span class="comment"># 把各个 value 传给 grouper。传入的值最终到达 averager 函数中 term = yield 那一行；grouper 永远不知道传入的值是什么。</span></span><br><span class="line">        group.send(<span class="literal">None</span>) <span class="comment"># 重要！ 把 None 传入 grouper，导致当前的 averager 实例终止，也让 grouper 继续运行，再创建一个 averager 实例，处理下一组值</span></span><br><span class="line">    <span class="comment"># print(results) # 如果要调试，去掉注释</span></span><br><span class="line">    report(results)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出报告</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">report</span>(<span class="params">results</span>):</span><br><span class="line">    <span class="keyword">for</span> key, result <span class="keyword">in</span> <span class="built_in">sorted</span>(results.items()):</span><br><span class="line">        group, unit = key.split(<span class="string">&#x27;;&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&#123;:2&#125; &#123;:5&#125; averaging &#123;:.2f&#125;&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">            result.count, group, result.average, unit))</span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;girls;kg&#x27;</span>:</span><br><span class="line">        [<span class="number">40.9</span>, <span class="number">38.5</span>, <span class="number">44.3</span>, <span class="number">42.2</span>, <span class="number">45.2</span>, <span class="number">41.7</span>, <span class="number">44.5</span>, <span class="number">38.0</span>, <span class="number">40.6</span>, <span class="number">44.5</span>],</span><br><span class="line">    <span class="string">&#x27;girls;m&#x27;</span>:</span><br><span class="line">        [<span class="number">1.6</span>, <span class="number">1.51</span>, <span class="number">1.4</span>, <span class="number">1.3</span>, <span class="number">1.41</span>, <span class="number">1.39</span>, <span class="number">1.33</span>, <span class="number">1.46</span>, <span class="number">1.45</span>, <span class="number">1.43</span>],</span><br><span class="line">    <span class="string">&#x27;boys;kg&#x27;</span>:</span><br><span class="line">        [<span class="number">39.0</span>, <span class="number">40.8</span>, <span class="number">43.2</span>, <span class="number">40.8</span>, <span class="number">43.1</span>, <span class="number">38.6</span>, <span class="number">41.4</span>, <span class="number">40.6</span>, <span class="number">36.3</span>],</span><br><span class="line">    <span class="string">&#x27;boys;m&#x27;</span>:</span><br><span class="line">        [<span class="number">1.38</span>, <span class="number">1.5</span>, <span class="number">1.32</span>, <span class="number">1.25</span>, <span class="number">1.37</span>, <span class="number">1.48</span>, <span class="number">1.25</span>, <span class="number">1.49</span>, <span class="number">1.46</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main(data)</span><br></pre></td></tr></table></figure><pre><code> 9 boys  averaging 40.42kg 9 boys  averaging 1.39m10 girls averaging 42.04kg10 girls averaging 1.43m</code></pre><p>解释一下上面代码发生了什么：<br><img src="image.png" alt="image.png"></p><ul><li>外层for循环每次迭代会新建一个grouper实例，赋值给group变量； group是委派生成器。</li><li>调用 next(group)，预激委派生成器 grouper，此时进入 while True 循环，调用子生成器 averager 后，在 yield from 表达式处暂停。</li><li>内层 for 循环调用 group.send(value)，直接把值传给子生成器 averager。同时，当前的 grouper 实例（group）在 yield from 表达式处暂停。</li><li>内层循环结束后， group 实例依旧在 yield from 表达式处暂停，因此， grouper 函数定义体中为 results[key] 赋值的语句还没有执行。</li><li>如果外层 for 循环的末尾没有 group.send(None)，那么 averager 子生成器永远不会终止，委派生成器 group 永远不会再次激活，因此永远不会为 results[key] 赋值。</li><li>外层 for 循环重新迭代时会新建一个 grouper 实例，然后绑定到 group 变量上。前一个grouper 实例（以及它创建的尚未终止的 averager 子生成器实例）被垃圾回收程序回收。</li></ul><p>yield from 意义</p><ul><li>子生成器产出的值都直接传给委派生成器的调用方（即客户端代码）。</li><li>使用 send() 方法发给委派生成器的值都直接传给子生成器。如果发送的值是 None，那么会调用子生成器的 <strong>next</strong>() 方法。如果发送的值不是 None，那么会调用子生成器的 send() 方法。如果调用的方法抛出 StopIteration 异常，那么委派生成器恢复运行。任何其他异常都会向上冒泡，传给委派生成器。</li><li>生成器退出时，生成器（或子生成器）中的 return expr 表达式会触发 StopIteration(expr)异常抛出。</li><li>yield from 表达式的值是子生成器终止时传给 StopIteration 异常的第一个参数</li></ul><p>对于<code>RESULT = yield from EXPR</code>的伪代码：(这块看看就行了)</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">_i = <span class="built_in">iter</span>(EXPR) <span class="comment"># EXPR是任何可迭代的对象</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    _y = <span class="built_in">next</span>(_i) <span class="comment"># 预激子生成器，结果保存在_y作为产出的第一个值</span></span><br><span class="line"><span class="keyword">except</span> StopIteration <span class="keyword">as</span> _e:</span><br><span class="line">    _r = _e.value <span class="comment">#如果抛出 StopIteration 异常，获取异常对象的 value 属性，赋值给 _r</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>: <span class="comment"># 运行这个循环时，委派生成器会阻塞，只作为调用方和子生成器之间的通道。</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            _s = <span class="keyword">yield</span> _y <span class="comment"># 产出子生成器当前产出的元素；等待调用方发送 _s 中保存的值。</span></span><br><span class="line">        <span class="keyword">except</span> GeneratorExit <span class="keyword">as</span> _e: <span class="comment"># 这一部分用于关闭委派生成器和子生成器。因为子生成器可以是任何可迭代的对象，所以可能没有 close 方法。</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                _m = _i.close</span><br><span class="line">            <span class="keyword">except</span> AttributeError:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                _m()</span><br><span class="line">            <span class="keyword">raise</span> _e</span><br><span class="line">        <span class="keyword">except</span> BaseException <span class="keyword">as</span> _e: <span class="comment"># 这一部分处理调用方通过 .throw(...) 方法传入的异常。</span></span><br><span class="line">            _x = sys.exc_info()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                _m = _i.throw</span><br><span class="line">            <span class="keyword">except</span> AttributeError:</span><br><span class="line">                <span class="keyword">raise</span> _e</span><br><span class="line">            <span class="keyword">else</span>: <span class="comment"># 如果子生成器有 throw 方法，调用它并传入调用方发来的异常。</span></span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    _y = _m(*_x)</span><br><span class="line">                <span class="keyword">except</span> StopIteration <span class="keyword">as</span> _e:</span><br><span class="line">                    _r = _e.value</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># 如果产出值时没有异常</span></span><br><span class="line">            <span class="keyword">try</span>: <span class="comment"># 尝试让子生成器向前执行</span></span><br><span class="line">                <span class="keyword">if</span> _s <span class="keyword">is</span> <span class="literal">None</span>: <span class="comment"># 如果调用方最后发送的值是 None，在子生成器上调用 next 函数，否则调用 send 方法</span></span><br><span class="line">                    _y = <span class="built_in">next</span>(_i)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    _y = _i.send(_s)</span><br><span class="line">            <span class="keyword">except</span> StopIteration <span class="keyword">as</span> _e: <span class="comment"># 如果子生成器抛出 StopIteration 异常，获取 value 属性的值，赋值给 _r，然后退出循环，让委派生成器恢复运行</span></span><br><span class="line">                    _r = _e.value</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">RESULT = _r <span class="comment"># 返回的结果（RESULT）是 _r，即整个 yield from 表达式的值。</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Ref: 《Fluent Python》 第16章 协程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;协程是指一个过程，这个过程与调用方协作，产出由调用方提供的值。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;tabl</summary>
      
    
    
    
    <category term="Python" scheme="https://guoyujian.github.io/categories/Python/"/>
    
    <category term="基础" scheme="https://guoyujian.github.io/categories/Python/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Python" scheme="https://guoyujian.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python 并发编程小结1</title>
    <link href="https://guoyujian.github.io/2024/03/08/Python-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%B0%8F%E7%BB%931/"/>
    <id>https://guoyujian.github.io/2024/03/08/Python-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%B0%8F%E7%BB%931/</id>
    <published>2024-03-08T07:23:02.000Z</published>
    <updated>2024-03-08T07:40:53.849Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>KeyWords:</p><ul><li>threading.Thread</li><li>threading.Event</li><li>使用队列queue.Queue，task_down()、join()实现线程通信</li><li>Lock的上下文管理、RLock、信号量Semaphore</li><li>死锁</li><li>创建对其他线程不可见的线程状态：threading.local()</li><li>线程池: concurrent.futures.ThreadPoolExecutor</li><li>并行编程：concurrent.futures.ProcessPoolExecutor、multiprocessing</li><li>GIL全局解释器的影响和解决方案</li><li>Actor模式</li><li>（本文未提到的）生成器、协程与asyncio</li><li>（本文未提到的）消息发布/订阅模型、多线程轮询</li></ul></blockquote><h1 id="启动和停止线程"><a href="#启动和停止线程" class="headerlink" title="启动和停止线程"></a>启动和停止线程</h1><p><code>threading</code>​ 库可以在单独的线程中执行任何的在 Python 中可以调用的对象。你可以创建一个 <code>Thread</code>​ 对象并将你要执行的对象以 target 参数的形式提供给该对象。 下面是一个简单的例子：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Code to execute in an independent thread</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">countdown</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;T-minus&#x27;</span>, n)</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line">        time.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create and launch a thread</span></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line">t = Thread(target=countdown, args=(<span class="number">10</span>,))</span><br><span class="line">t.start()</span><br></pre></td></tr></table></figure><p>当你创建好一个线程对象后，该对象并不会立即执行，除非你调用它的 <code>&lt;span class=&quot;pre&quot;&gt;start()&lt;/span&gt;</code>​ 方法（当你调用 <code>&lt;span class=&quot;pre&quot;&gt;start()&lt;/span&gt;</code>​ 方法时，它会调用你传递进来的函数，并把你传递进来的参数传递给该函数）。Python中的线程会在一个单独的系统级线程中执行（比如说一个 POSIX 线程或者一个 Windows 线程），这些线程将由操作系统来全权管理。线程一旦启动，将独立执行直到目标函数返回。你可以查询一个线程对象的状态，看它是否还在执行：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if t.is_alive():</span><br><span class="line">    print(&#x27;Still running&#x27;)</span><br><span class="line">else:</span><br><span class="line">    print(&#x27;Completed&#x27;)</span><br></pre></td></tr></table></figure><p>你也可以将一个线程加入到当前线程，并等待它终止：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">t.join()</span><br></pre></td></tr></table></figure><p>Python解释器直到所有线程都终止前仍保持运行。对于需要长时间运行的线程或者需要一直运行的后台任务，你应当考虑使用后台线程。 例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">t = Thread(target=countdown, args=(10,), daemon=True)</span><br><span class="line">t.start()</span><br></pre></td></tr></table></figure><p>后台线程无法等待，不过，这些线程会在主线程终止时自动销毁。 除了如上所示的两个操作，并没有太多可以对线程做的事情。你无法结束一个线程，无法给它发送信号，无法调整它的调度，也无法执行其他高级操作。如果需要这些特性，你需要自己添加。比如说，如果你需要终止线程，那么这个线程必须通过编程在某个特定点轮询来退出。你可以像下边这样把线程放入一个类中：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CountdownTask</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._running = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">terminate</span>(<span class="params">self</span>):</span><br><span class="line">        self._running = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self, n</span>):</span><br><span class="line">        <span class="keyword">while</span> self._running <span class="keyword">and</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;T-minus&#x27;</span>, n)</span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line">            time.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">c = CountdownTask()</span><br><span class="line">t = Thread(target=c.run, args=(<span class="number">10</span>,))</span><br><span class="line">t.start()</span><br><span class="line">c.terminate() <span class="comment"># Signal termination</span></span><br><span class="line">t.join()      <span class="comment"># Wait for actual termination (if needed)</span></span><br></pre></td></tr></table></figure><p>如果线程执行一些像I/O这样的阻塞操作，那么通过轮询来终止线程将使得线程之间的协调变得非常棘手。比如，如果一个线程一直阻塞在一个I/O操作上，它就永远无法返回，也就无法检查自己是否已经被结束了。要正确处理这些问题，你需要利用超时循环来小心操作线程。 例子如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IOTask</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">terminate</span>(<span class="params">self</span>):</span><br><span class="line">        self._running = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self, sock</span>):</span><br><span class="line">        <span class="comment"># sock is a socket</span></span><br><span class="line">        sock.settimeout(<span class="number">5</span>)        <span class="comment"># Set timeout period</span></span><br><span class="line">        <span class="keyword">while</span> self._running:</span><br><span class="line">            <span class="comment"># Perform a blocking I/O operation w/ timeout</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                data = sock.recv(<span class="number">8192</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">except</span> socket.timeout:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># Continued processing</span></span><br><span class="line">            ...</span><br><span class="line">        <span class="comment"># Terminated</span></span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure><h2 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h2><p>由于全局解释锁（GIL）的原因，Python 的线程被限制到同一时刻只允许一个线程执行这样一个执行模型。所以，Python 的线程更适用于处理I/O和其他需要并发执行的阻塞操作（比如等待I/O、等待从数据库获取数据等等），而不是需要多处理器并行的计算密集型任务。</p><p>有时你会看到下边这种通过继承 <code>Thread</code>​ 类来实现的线程：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from threading import Thread</span><br><span class="line"></span><br><span class="line">class CountdownThread(Thread):</span><br><span class="line">    def __init__(self, n):</span><br><span class="line">        super().__init__()</span><br><span class="line">        self.n = n</span><br><span class="line">    def run(self):</span><br><span class="line">        while self.n &gt; 0:</span><br><span class="line"></span><br><span class="line">            print(&#x27;T-minus&#x27;, self.n)</span><br><span class="line">            self.n -= 1</span><br><span class="line">            time.sleep(5)</span><br><span class="line"></span><br><span class="line">c = CountdownThread(5)</span><br><span class="line">c.start()</span><br></pre></td></tr></table></figure><p>尽管这样也可以工作，但这使得你的代码依赖于 <code>threading</code>​ 库，所以你的这些代码只能在线程上下文中使用。上文所写的那些代码、函数都是与 <code>threading</code>​ 库无关的，这样就使得这些代码可以被用在其他的上下文中，可能与线程有关，也可能与线程无关。比如，你可以通过 <code>multiprocessing</code>​ 模块在一个单独的进程中执行你的代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import multiprocessing</span><br><span class="line">c = CountdownTask(5)</span><br><span class="line">p = multiprocessing.Process(target=c.run)</span><br><span class="line">p.start()</span><br></pre></td></tr></table></figure><p>再次重申，这段代码仅适用于 CountdownTask 类是以独立于实际的并发手段（多线程、多进程等等）实现的情况。</p><h1 id="判断线程是否启动"><a href="#判断线程是否启动" class="headerlink" title="判断线程是否启动"></a>判断线程是否启动</h1><p>你已经启动了一个线程，但是你想知道它是不是真的已经开始运行了。</p><p>线程的一个关键特性是每个线程都是独立运行且状态不可预测。如果程序中的其他线程需要通过判断某个线程的状态来确定自己下一步的操作，这时线程同步问题就会变得非常棘手。为了解决这些问题，我们需要使用 <code>threading</code>​ 库中的 <code>Event</code>​ 对象。 <code>Event</code>​ 对象包含一个可由线程设置的信号标志，它允许线程等待某些事件的发生。在初始情况下，event 对象中的信号标志被设置为假。如果有线程等待一个 event 对象，而这个 event 对象的标志为假，那么这个线程将会被一直阻塞直至该标志为真。一个线程如果将一个 event 对象的信号标志设置为真，它将唤醒所有等待这个 event 对象的线程。如果一个线程等待一个已经被设置为真的 event 对象，那么它将忽略这个事件，继续执行。 下边的代码展示了如何使用 <code>Event</code>​ 来协调线程的启动：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Event</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># Code to execute in an independent thread</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">countdown</span>(<span class="params">n, started_evt</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;countdown starting&#x27;</span>)</span><br><span class="line">    started_evt.<span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;T-minus&#x27;</span>, n)</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line">        time.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create the event object that will be used to signal startup</span></span><br><span class="line">started_evt = Event()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Launch the thread and pass the startup event</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Launching countdown&#x27;</span>)</span><br><span class="line">t = Thread(target=countdown, args=(<span class="number">10</span>,started_evt))</span><br><span class="line">t.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Wait for the thread to start</span></span><br><span class="line">started_evt.wait()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;countdown is running&#x27;</span>)</span><br></pre></td></tr></table></figure><p>当你执行这段代码，“countdown is running” 总是显示在 “countdown starting” 之后显示。这是由于使用 event 来协调线程，使得主线程要等到 <code>countdown()</code>​ 函数输出启动信息后，才能继续执行。</p><h2 id="讨论-1"><a href="#讨论-1" class="headerlink" title="讨论"></a>讨论</h2><p>event 对象最好单次使用，就是说，你创建一个 event 对象，让某个线程等待这个对象，一旦这个对象被设置为真，你就应该丢弃它。尽管可以通过 <code>clear()</code>​ 方法来重置 event 对象，但是很难确保安全地清理 event 对象并对它重新赋值。很可能会发生错过事件、死锁或者其他问题（特别是，你无法保证重置 event 对象的代码会在线程再次等待这个 event 对象之前执行）。如果一个线程需要不停地重复使用 event 对象，你最好使用 <code>Condition</code>​ 对象来代替。下面的代码使用 <code>Condition</code>​ 对象实现了一个周期定时器，每当定时器超时的时候，其他线程都可以监测到：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PeriodicTimer</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, interval</span>):</span><br><span class="line">        self._interval = interval</span><br><span class="line">        self._flag = <span class="number">0</span></span><br><span class="line">        self._cv = threading.Condition()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start</span>(<span class="params">self</span>):</span><br><span class="line">        t = threading.Thread(target=self.run)</span><br><span class="line">        t.daemon = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        Run the timer and notify waiting threads after each interval</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            time.sleep(self._interval)</span><br><span class="line">            <span class="keyword">with</span> self._cv:</span><br><span class="line">                 self._flag ^= <span class="number">1</span></span><br><span class="line">                 self._cv.notify_all()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wait_for_tick</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        Wait for the next tick of the timer</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">with</span> self._cv:</span><br><span class="line">            last_flag = self._flag</span><br><span class="line">            <span class="keyword">while</span> last_flag == self._flag:</span><br><span class="line">                self._cv.wait()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example use of the timer</span></span><br><span class="line">ptimer = PeriodicTimer(<span class="number">5</span>)</span><br><span class="line">ptimer.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Two threads that synchronize on the timer</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">countdown</span>(<span class="params">nticks</span>):</span><br><span class="line">    <span class="keyword">while</span> nticks &gt; <span class="number">0</span>:</span><br><span class="line">        ptimer.wait_for_tick()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;T-minus&#x27;</span>, nticks)</span><br><span class="line">        nticks -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">countup</span>(<span class="params">last</span>):</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; last:</span><br><span class="line">        ptimer.wait_for_tick()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Counting&#x27;</span>, n)</span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">threading.Thread(target=countdown, args=(<span class="number">10</span>,)).start()</span><br><span class="line">threading.Thread(target=countup, args=(<span class="number">5</span>,)).start()</span><br></pre></td></tr></table></figure><p>event对象的一个重要特点是当它被设置为真时会唤醒所有等待它的线程。如果你只想唤醒单个线程，最好是使用信号量或者 <code>Condition</code>​ 对象来替代。考虑一下这段使用信号量实现的代码：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Worker thread</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">worker</span>(<span class="params">n, sema</span>):</span><br><span class="line">    <span class="comment"># Wait to be signaled</span></span><br><span class="line">    sema.acquire()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Do some work</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Working&#x27;</span>, n)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create some threads</span></span><br><span class="line">sema = threading.Semaphore(<span class="number">0</span>)</span><br><span class="line">nworkers = <span class="number">10</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(nworkers):</span><br><span class="line">    t = threading.Thread(target=worker, args=(n, sema,))</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure><p>运行上边的代码将会启动一个线程池，但是并没有什么事情发生。这是因为所有的线程都在等待获取信号量。每次信号量被释放，只有一个线程会被唤醒并执行，示例如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; sema.release()</span><br><span class="line">Working 0</span><br><span class="line">&gt;&gt;&gt; sema.release()</span><br><span class="line">Working 1</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>编写涉及到大量的线程间同步问题的代码会让你痛不欲生。比较合适的方式是使用队列来进行线程间通信或者每个把线程当作一个Actor，利用Actor模型来控制并发。下一节将会介绍到队列，而Actor模型将在12.10节介绍。</p><h1 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h1><p>从一个线程向另一个线程发送数据最安全的方式可能就是使用 <code>queue</code>​ 库中的队列了。创建一个被多个线程共享的 <code>Queue</code>​ 对象，这些线程通过使用 <code>put()</code>​ 和 <code>get()</code>​ 操作来向队列中添加或者删除元素。 例如：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="comment"># A thread that produces data</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">producer</span>(<span class="params">out_q</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># Produce some data</span></span><br><span class="line">        ...</span><br><span class="line">        out_q.put(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># A thread that consumes data</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">consumer</span>(<span class="params">in_q</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="comment"># Get some data</span></span><br><span class="line">        data = in_q.get()</span><br><span class="line">        <span class="comment"># Process the data</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create the shared queue and launch both threads</span></span><br><span class="line">q = Queue()</span><br><span class="line">t1 = Thread(target=consumer, args=(q,))</span><br><span class="line">t2 = Thread(target=producer, args=(q,))</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br></pre></td></tr></table></figure><p><code>Queue</code>​ 对象已经包含了必要的锁，所以你可以通过它在多个线程间多安全地共享数据。 当使用队列时，协调生产者和消费者的关闭问题可能会有一些麻烦。一个通用的解决方法是在队列中放置一个特殊的值，当消费者读到这个值的时候，终止执行。</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="comment"># Object that signals shutdown</span></span><br><span class="line">_sentinel = <span class="built_in">object</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># A thread that produces data</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">producer</span>(<span class="params">out_q</span>):</span><br><span class="line">    <span class="keyword">while</span> running:</span><br><span class="line">        <span class="comment"># Produce some data</span></span><br><span class="line">        ...</span><br><span class="line">        out_q.put(data)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Put the sentinel on the queue to indicate completion</span></span><br><span class="line">    out_q.put(_sentinel)</span><br><span class="line"></span><br><span class="line"><span class="comment"># A thread that consumes data</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">consumer</span>(<span class="params">in_q</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># Get some data</span></span><br><span class="line">        data = in_q.get()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Check for termination</span></span><br><span class="line">        <span class="keyword">if</span> data <span class="keyword">is</span> _sentinel:</span><br><span class="line">            in_q.put(_sentinel)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Process the data</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>本例中有一个特殊的地方：消费者在读到这个特殊值之后立即又把它放回到队列中，将之传递下去。这样，所有监听这个队列的消费者线程就可以全部关闭了。 尽管队列是最常见的线程间通信机制，但是仍然可以自己通过创建自己的数据结构并添加所需的锁和同步机制来实现线程间通信。最常见的方法是使用 <code>Condition</code>​ 变量来包装你的数据结构。下边这个例子演示了如何创建一个线程安全的优先级队列，如同1.5节中介绍的那样。</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PriorityQueue</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._queue = []</span><br><span class="line">        self._count = <span class="number">0</span></span><br><span class="line">        self._cv = threading.Condition()</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">put</span>(<span class="params">self, item, priority</span>):</span><br><span class="line">        <span class="keyword">with</span> self._cv:</span><br><span class="line">            heapq.heappush(self._queue, (-priority, self._count, item))</span><br><span class="line">            self._count += <span class="number">1</span></span><br><span class="line">            self._cv.notify()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">with</span> self._cv:</span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(self._queue) == <span class="number">0</span>:</span><br><span class="line">                self._cv.wait()</span><br><span class="line">            <span class="keyword">return</span> heapq.heappop(self._queue)[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>使用队列来进行线程间通信是一个单向、不确定的过程。通常情况下，你没有办法知道接收数据的线程是什么时候接收到的数据并开始工作的。不过队列对象提供一些基本完成的特性，比如下边这个例子中的 <code>**task_done()**</code> ​ 和 <code>**join()**</code> ​ ：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from queue import Queue</span><br><span class="line">from threading import Thread</span><br><span class="line"></span><br><span class="line"># A thread that produces data</span><br><span class="line">def producer(out_q):</span><br><span class="line">    while running:</span><br><span class="line">        # Produce some data</span><br><span class="line">        ...</span><br><span class="line">        out_q.put(data)</span><br><span class="line"></span><br><span class="line"># A thread that consumes data</span><br><span class="line">def consumer(in_q):</span><br><span class="line">    while True:</span><br><span class="line">        # Get some data</span><br><span class="line">        data = in_q.get()</span><br><span class="line"></span><br><span class="line">        # Process the data</span><br><span class="line">        ...</span><br><span class="line">        # Indicate completion</span><br><span class="line">        in_q.task_done()</span><br><span class="line"></span><br><span class="line"># Create the shared queue and launch both threads</span><br><span class="line">q = Queue()</span><br><span class="line">t1 = Thread(target=consumer, args=(q,))</span><br><span class="line">t2 = Thread(target=producer, args=(q,))</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line"></span><br><span class="line"># Wait for all produced items to be consumed</span><br><span class="line">q.join()</span><br></pre></td></tr></table></figure><p>如果一个线程需要在一个“消费者”线程处理完特定的数据项时立即得到通知，你可以把要发送的数据和一个 <code>Event</code>​ 放到一起使用，这样“生产者”就可以通过这个Event对象来监测处理的过程了。示例如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from queue import Queue</span><br><span class="line">from threading import Thread, Event</span><br><span class="line"></span><br><span class="line"># A thread that produces data</span><br><span class="line">def producer(out_q):</span><br><span class="line">    while running:</span><br><span class="line">        # Produce some data</span><br><span class="line">        ...</span><br><span class="line">        # Make an (data, event) pair and hand it to the consumer</span><br><span class="line">        evt = Event()</span><br><span class="line">        out_q.put((data, evt))</span><br><span class="line">        ...</span><br><span class="line">        # Wait for the consumer to process the item</span><br><span class="line">        evt.wait()</span><br><span class="line"></span><br><span class="line"># A thread that consumes data</span><br><span class="line">def consumer(in_q):</span><br><span class="line">    while True:</span><br><span class="line">        # Get some data</span><br><span class="line">        data, evt = in_q.get()</span><br><span class="line">        # Process the data</span><br><span class="line">        ...</span><br><span class="line">        # Indicate completion</span><br><span class="line">        evt.set()</span><br></pre></td></tr></table></figure><h2 id="讨论-2"><a href="#讨论-2" class="headerlink" title="讨论"></a>讨论</h2><p>基于简单队列编写多线程程序在多数情况下是一个比较明智的选择。从线程安全队列的底层实现来看，你无需在你的代码中使用锁和其他底层的同步机制，这些只会把你的程序弄得乱七八糟。此外，使用队列这种基于消息的通信机制可以被扩展到更大的应用范畴，比如，你可以把你的程序放入多个进程甚至是分布式系统而无需改变底层的队列结构。 使用线程队列有一个要注意的问题是，向队列中添加数据项时并不会复制此数据项，线程间通信实际上是在线程间传递对象引用。如果你担心对象的共享状态，那你最好只传递不可修改的数据结构（如：整型、字符串或者元组）或者一个对象的深拷贝。例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from queue import Queue</span><br><span class="line">from threading import Thread</span><br><span class="line">import copy</span><br><span class="line"></span><br><span class="line"># A thread that produces data</span><br><span class="line">def producer(out_q):</span><br><span class="line">    while True:</span><br><span class="line">        # Produce some data</span><br><span class="line">        ...</span><br><span class="line">        out_q.put(copy.deepcopy(data))</span><br><span class="line"></span><br><span class="line"># A thread that consumes data</span><br><span class="line">def consumer(in_q):</span><br><span class="line">    while True:</span><br><span class="line">        # Get some data</span><br><span class="line">        data = in_q.get()</span><br><span class="line">        # Process the data</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p><code>Queue</code>​ 对象提供一些在当前上下文很有用的附加特性。比如在创建 Queue 对象时提供可选的 <code>size</code>​ 参数来限制可以添加到队列中的元素数量。对于“生产者”与“消费者”速度有差异的情况，为队列中的元素数量添加上限是有意义的。比如，一个“生产者”产生项目的速度比“消费者” “消费”的速度快，那么使用固定大小的队列就可以在队列已满的时候阻塞队列，以免未预期的连锁效应扩散整个程序造成死锁或者程序运行失常。在通信的线程之间进行“流量控制”是一个看起来容易实现起来困难的问题。如果你发现自己曾经试图通过摆弄队列大小来解决一个问题，这也许就标志着你的程序可能存在脆弱设计或者固有的可伸缩问题。 <code>get()</code>​ 和 <code>put()</code>​ 方法都支持非阻塞方式和设定超时，例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import queue</span><br><span class="line">q = queue.Queue()</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    data = q.get(block=False)</span><br><span class="line">except queue.Empty:</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    q.put(item, block=False)</span><br><span class="line">except queue.Full:</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    data = q.get(timeout=5.0)</span><br><span class="line">except queue.Empty:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>这些操作都可以用来避免当执行某些特定队列操作时发生无限阻塞的情况，比如，一个非阻塞的 <code>put()</code>​ 方法和一个固定大小的队列一起使用，这样当队列已满时就可以执行不同的代码。比如输出一条日志信息并丢弃。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def producer(q):</span><br><span class="line">    ...</span><br><span class="line">    try:</span><br><span class="line">        q.put(item, block=False)</span><br><span class="line">    except queue.Full:</span><br><span class="line">        log.warning(&#x27;queued item %r discarded!&#x27;, item)</span><br></pre></td></tr></table></figure><p>如果你试图让消费者线程在执行像 <code>q.get()</code>​ 这样的操作时，超时自动终止以便检查终止标志，你应该使用 <code>q.get()</code>​ 的可选参数 <code>timeout</code>​ ，如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_running = True</span><br><span class="line"></span><br><span class="line">def consumer(q):</span><br><span class="line">    while _running:</span><br><span class="line">        try:</span><br><span class="line">            item = q.get(timeout=5.0)</span><br><span class="line">            # Process item</span><br><span class="line">            ...</span><br><span class="line">        except queue.Empty:</span><br><span class="line">            pass</span><br></pre></td></tr></table></figure><p>最后，有 <code>q.qsize()</code>​ ， <code>q.full()</code>​ ， <code>q.empty()</code>​ 等实用方法可以获取一个队列的当前大小和状态。但要注意，这些方法都不是线程安全的。可能你对一个队列使用 <code>empty()</code>​ 判断出这个队列为空，但同时另外一个线程可能已经向这个队列中插入一个数据项。所以，你最好不要在你的代码中使用这些方法。</p><h1 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h1><p>要在多线程程序中安全使用可变对象，你需要使用 threading 库中的 <code>&lt;span class=&quot;pre&quot;&gt;Lock&lt;/span&gt;</code>​ 对象，就像下边这个例子这样：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line"></span><br><span class="line">class SharedCounter:</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    A counter object that can be shared by multiple threads.</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    def __init__(self, initial_value = 0):</span><br><span class="line">        self._value = initial_value</span><br><span class="line">        self._value_lock = threading.Lock()</span><br><span class="line"></span><br><span class="line">    def incr(self,delta=1):</span><br><span class="line">        &#x27;&#x27;&#x27;</span><br><span class="line">        Increment the counter with locking</span><br><span class="line">        &#x27;&#x27;&#x27;</span><br><span class="line">        with self._value_lock:</span><br><span class="line">             self._value += delta</span><br><span class="line"></span><br><span class="line">    def decr(self,delta=1):</span><br><span class="line">        &#x27;&#x27;&#x27;</span><br><span class="line">        Decrement the counter with locking</span><br><span class="line">        &#x27;&#x27;&#x27;</span><br><span class="line">        with self._value_lock:</span><br><span class="line">             self._value -= delta</span><br></pre></td></tr></table></figure><p><code>&lt;span class=&quot;pre&quot;&gt;Lock&lt;/span&gt;</code>​ 对象和 <code>&lt;span class=&quot;pre&quot;&gt;with&lt;/span&gt;</code>​ 语句块一起使用可以保证互斥执行，就是每次只有一个线程可以执行 with 语句包含的代码块。with 语句会在这个代码块执行前自动获取锁，在执行结束后自动释放锁。</p><h2 id="讨论-3"><a href="#讨论-3" class="headerlink" title="讨论"></a>讨论</h2><p>线程调度本质上是不确定的，因此，在多线程程序中错误地使用锁机制可能会导致随机数据损坏或者其他的异常行为，我们称之为竞争条件。为了避免竞争条件，最好只在临界区（对临界资源进行操作的那部分代码）使用锁。 在一些“老的” Python 代码中，显式获取和释放锁是很常见的。下边是一个上一个例子的变种：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line"></span><br><span class="line">class SharedCounter:</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    A counter object that can be shared by multiple threads.</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    def __init__(self, initial_value = 0):</span><br><span class="line">        self._value = initial_value</span><br><span class="line">        self._value_lock = threading.Lock()</span><br><span class="line"></span><br><span class="line">    def incr(self,delta=1):</span><br><span class="line">        &#x27;&#x27;&#x27;</span><br><span class="line">        Increment the counter with locking</span><br><span class="line">        &#x27;&#x27;&#x27;</span><br><span class="line">        self._value_lock.acquire()</span><br><span class="line">        self._value += delta</span><br><span class="line">        self._value_lock.release()</span><br><span class="line"></span><br><span class="line">    def decr(self,delta=1):</span><br><span class="line">        &#x27;&#x27;&#x27;</span><br><span class="line">        Decrement the counter with locking</span><br><span class="line">        &#x27;&#x27;&#x27;</span><br><span class="line">        self._value_lock.acquire()</span><br><span class="line">        self._value -= delta</span><br><span class="line">        self._value_lock.release()</span><br></pre></td></tr></table></figure><p><strong>相比于这种显式调用的方法，with 语句更加优雅，也更不容易出错</strong>，特别是程序员可能会忘记调用 release() 方法或者程序在获得锁之后产生异常这两种情况（使用 with 语句可以保证在这两种情况下仍能正确释放锁）。 为了避免出现死锁的情况，使用锁机制的程序应该设定为每个线程一次只允许获取一个锁。如果不能这样做的话，你就需要更高级的死锁避免机制，我们将在12.5节介绍。 在 <code>threading</code>​ 库中还提供了其他的同步原语，比如 <code>RLock</code>​ 和 <code>Semaphore</code>​ 对象。但是根据以往经验，这些原语是用于一些特殊的情况，如果你只是需要简单地对可变对象进行锁定，那就不应该使用它们。一个 <code>RLock</code>​ （可重入锁）可以被同一个线程多次获取，主要用来实现基于监测对象模式的锁定和同步。在使用这种锁的情况下，当锁被持有时，只有一个线程可以使用完整的函数或者类中的方法。比如，你可以实现一个这样的 SharedCounter 类：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line"></span><br><span class="line">class SharedCounter:</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    A counter object that can be shared by multiple threads.</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    _lock = threading.RLock()</span><br><span class="line">    def __init__(self, initial_value = 0):</span><br><span class="line">        self._value = initial_value</span><br><span class="line"></span><br><span class="line">    def incr(self,delta=1):</span><br><span class="line">        &#x27;&#x27;&#x27;</span><br><span class="line">        Increment the counter with locking</span><br><span class="line">        &#x27;&#x27;&#x27;</span><br><span class="line">        with SharedCounter._lock:</span><br><span class="line">            self._value += delta</span><br><span class="line"></span><br><span class="line">    def decr(self,delta=1):</span><br><span class="line">        &#x27;&#x27;&#x27;</span><br><span class="line">        Decrement the counter with locking</span><br><span class="line">        &#x27;&#x27;&#x27;</span><br><span class="line">        with SharedCounter._lock:</span><br><span class="line">             self.incr(-delta)</span><br></pre></td></tr></table></figure><p>在上边这个例子中，没有对每一个实例中的可变对象加锁，取而代之的是一个被所有实例共享的类级锁。这个锁用来同步类方法，具体来说就是，这个锁可以保证一次只有一个线程可以调用这个类方法。不过，与一个标准的锁不同的是，已经持有这个锁的方法在调用同样使用这个锁的方法时，无需再次获取锁。比如 decr 方法。 这种实现方式的一个特点是，无论这个类有多少个实例都只用一个锁。因此在需要大量使用计数器的情况下内存效率更高。不过这样做也有缺点，就是在程序中使用大量线程并频繁更新计数器时会有争用锁的问题。 信号量对象是一个建立在共享计数器基础上的同步原语。如果计数器不为0，with 语句将计数器减1，线程被允许执行。with 语句执行结束后，计数器加１。如果计数器为0，线程将被阻塞，直到其他线程结束将计数器加1。尽管你可以在程序中像标准锁一样使用信号量来做线程同步，但是这种方式并不被推荐，<strong>因为使用信号量为程序增加的复杂性会影响程序性能。</strong> 相对于简单地作为锁使用，信号量更适用于那些需要在线程之间引入信号或者限制的程序。比如，你需要限制一段代码的并发访问量，你就可以像下面这样使用信号量完成：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from threading import Semaphore</span><br><span class="line">import urllib.request</span><br><span class="line"></span><br><span class="line"># At most, five threads allowed to run at once</span><br><span class="line">_fetch_url_sema = Semaphore(5)</span><br><span class="line"></span><br><span class="line">def fetch_url(url):</span><br><span class="line">    with _fetch_url_sema:</span><br><span class="line">        return urllib.request.urlopen(url)</span><br></pre></td></tr></table></figure><p>如果你对线程同步原语的底层理论和实现感兴趣，可以参考操作系统相关书籍，绝大多数都有提及。</p><h1 id="防止死锁的加锁机制"><a href="#防止死锁的加锁机制" class="headerlink" title="防止死锁的加锁机制"></a>防止死锁的加锁机制</h1><p>（这一章节我没看）</p><p>在多线程程序中，死锁问题很大一部分是由于线程同时获取多个锁造成的。举个例子：一个线程获取了第一个锁，然后在获取第二个锁的 时候发生阻塞，那么这个线程就可能阻塞其他线程的执行，从而导致整个程序假死。 解决死锁问题的一种方案是为程序中的每一个锁分配一个唯一的id，然后只允许按照升序规则来使用多个锁，这个规则使用上下文管理器 是非常容易实现的，示例如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line">from contextlib import contextmanager</span><br><span class="line"></span><br><span class="line"># Thread-local state to stored information on locks already acquired</span><br><span class="line">_local = threading.local()</span><br><span class="line"></span><br><span class="line">@contextmanager</span><br><span class="line">def acquire(*locks):</span><br><span class="line">    # Sort locks by object identifier</span><br><span class="line">    locks = sorted(locks, key=lambda x: id(x))</span><br><span class="line"></span><br><span class="line">    # Make sure lock order of previously acquired locks is not violated</span><br><span class="line">    acquired = getattr(_local,&#x27;acquired&#x27;,[])</span><br><span class="line">    if acquired and max(id(lock) for lock in acquired) &gt;= id(locks[0]):</span><br><span class="line">        raise RuntimeError(&#x27;Lock Order Violation&#x27;)</span><br><span class="line"></span><br><span class="line">    # Acquire all of the locks</span><br><span class="line">    acquired.extend(locks)</span><br><span class="line">    _local.acquired = acquired</span><br><span class="line"></span><br><span class="line">    try:</span><br><span class="line">        for lock in locks:</span><br><span class="line">            lock.acquire()</span><br><span class="line">        yield</span><br><span class="line">    finally:</span><br><span class="line">        # Release locks in reverse order of acquisition</span><br><span class="line">        for lock in reversed(locks):</span><br><span class="line">            lock.release()</span><br><span class="line">        del acquired[-len(locks):]</span><br></pre></td></tr></table></figure><p>如何使用这个上下文管理器呢？你可以按照正常途径创建一个锁对象，但不论是单个锁还是多个锁中都使用 <code>&lt;span class=&quot;pre&quot;&gt;acquire()&lt;/span&gt;</code>​ 函数来申请锁， 示例如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line">x_lock = threading.Lock()</span><br><span class="line">y_lock = threading.Lock()</span><br><span class="line"></span><br><span class="line">def thread_1():</span><br><span class="line">    while True:</span><br><span class="line">        with acquire(x_lock, y_lock):</span><br><span class="line">            print(&#x27;Thread-1&#x27;)</span><br><span class="line"></span><br><span class="line">def thread_2():</span><br><span class="line">    while True:</span><br><span class="line">        with acquire(y_lock, x_lock):</span><br><span class="line">            print(&#x27;Thread-2&#x27;)</span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target=thread_1)</span><br><span class="line">t1.daemon = True</span><br><span class="line">t1.start()</span><br><span class="line"></span><br><span class="line">t2 = threading.Thread(target=thread_2)</span><br><span class="line">t2.daemon = True</span><br><span class="line">t2.start()</span><br></pre></td></tr></table></figure><p>如果你执行这段代码，你会发现它即使在不同的函数中以不同的顺序获取锁也没有发生死锁。 其关键在于，在第一段代码中，我们对这些锁进行了排序。通过排序，使得不管用户以什么样的顺序来请求锁，这些锁都会按照固定的顺序被获取。 如果有多个 <code>&lt;span class=&quot;pre&quot;&gt;acquire()&lt;/span&gt;</code>​ 操作被嵌套调用，可以通过线程本地存储（TLS）来检测潜在的死锁问题。 假设你的代码是这样写的：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line">x_lock = threading.Lock()</span><br><span class="line">y_lock = threading.Lock()</span><br><span class="line"></span><br><span class="line">def thread_1():</span><br><span class="line"></span><br><span class="line">    while True:</span><br><span class="line">        with acquire(x_lock):</span><br><span class="line">            with acquire(y_lock):</span><br><span class="line">                print(&#x27;Thread-1&#x27;)</span><br><span class="line"></span><br><span class="line">def thread_2():</span><br><span class="line">    while True:</span><br><span class="line">        with acquire(y_lock):</span><br><span class="line">            with acquire(x_lock):</span><br><span class="line">                print(&#x27;Thread-2&#x27;)</span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target=thread_1)</span><br><span class="line">t1.daemon = True</span><br><span class="line">t1.start()</span><br><span class="line"></span><br><span class="line">t2 = threading.Thread(target=thread_2)</span><br><span class="line">t2.daemon = True</span><br><span class="line">t2.start()</span><br></pre></td></tr></table></figure><p>如果你运行这个版本的代码，必定会有一个线程发生崩溃，异常信息可能像这样：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Exception in thread Thread-1:</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/usr/local/lib/python3.3/threading.py&quot;, line 639, in _bootstrap_inner</span><br><span class="line">    self.run()</span><br><span class="line">  File &quot;/usr/local/lib/python3.3/threading.py&quot;, line 596, in run</span><br><span class="line">    self._target(*self._args, **self._kwargs)</span><br><span class="line">  File &quot;deadlock.py&quot;, line 49, in thread_1</span><br><span class="line">    with acquire(y_lock):</span><br><span class="line">  File &quot;/usr/local/lib/python3.3/contextlib.py&quot;, line 48, in __enter__</span><br><span class="line">    return next(self.gen)</span><br><span class="line">  File &quot;deadlock.py&quot;, line 15, in acquire</span><br><span class="line">    raise RuntimeError(&quot;Lock Order Violation&quot;)</span><br><span class="line">RuntimeError: Lock Order Violation</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>发生崩溃的原因在于，每个线程都记录着自己已经获取到的锁。 <code>&lt;span class=&quot;pre&quot;&gt;acquire()&lt;/span&gt;</code>​ 函数会检查之前已经获取的锁列表， 由于锁是按照升序排列获取的，所以函数会认为之前已获取的锁的id必定小于新申请到的锁，这时就会触发异常。</p><h2 id="讨论-4"><a href="#讨论-4" class="headerlink" title="讨论"></a>讨论</h2><p>死锁是每一个多线程程序都会面临的一个问题（就像它是每一本操作系统课本的共同话题一样）。根据经验来讲，尽可能保证每一个 线程只能同时保持一个锁，这样程序就不会被死锁问题所困扰。一旦有线程同时申请多个锁，一切就不可预料了。</p><p>死锁的检测与恢复是一个几乎没有优雅的解决方案的扩展话题。一个比较常用的死锁检测与恢复的方案是引入看门狗计数器。当线程正常 运行的时候会每隔一段时间重置计数器，在没有发生死锁的情况下，一切都正常进行。一旦发生死锁，由于无法重置计数器导致定时器 超时，这时程序会通过重启自身恢复到正常状态。</p><p>避免死锁是另外一种解决死锁问题的方式，在进程获取锁的时候会严格按照对象id升序排列获取，经过数学证明，这样保证程序不会进入 死锁状态。证明就留给读者作为练习了。避免死锁的主要思想是，单纯地按照对象id递增的顺序加锁不会产生循环依赖，而循环依赖是 死锁的一个必要条件，从而避免程序进入死锁状态。</p><p>下面以一个关于线程死锁的经典问题：“哲学家就餐问题”，作为本节最后一个例子。题目是这样的：五位哲学家围坐在一张桌子前，每个人 面前有一碗饭和一只筷子。在这里每个哲学家可以看做是一个独立的线程，而每只筷子可以看做是一个锁。每个哲学家可以处在静坐、 思考、吃饭三种状态中的一个。需要注意的是，每个哲学家吃饭是需要两只筷子的，这样问题就来了：如果每个哲学家都拿起自己左边的筷子， 那么他们五个都只能拿着一只筷子坐在那儿，直到饿死。此时他们就进入了死锁状态。 下面是一个简单的使用死锁避免机制解决“哲学家就餐问题”的实现：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line"></span><br><span class="line"># The philosopher thread</span><br><span class="line">def philosopher(left, right):</span><br><span class="line">    while True:</span><br><span class="line">        with acquire(left,right):</span><br><span class="line">             print(threading.currentThread(), &#x27;eating&#x27;)</span><br><span class="line"></span><br><span class="line"># The chopsticks (represented by locks)</span><br><span class="line">NSTICKS = 5</span><br><span class="line">chopsticks = [threading.Lock() for n in range(NSTICKS)]</span><br><span class="line"></span><br><span class="line"># Create all of the philosophers</span><br><span class="line">for n in range(NSTICKS):</span><br><span class="line">    t = threading.Thread(target=philosopher,</span><br><span class="line">                         args=(chopsticks[n],chopsticks[(n+1) % NSTICKS]))</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure><p>最后，要特别注意到，为了避免死锁，所有的加锁操作必须使用 <code>&lt;span class=&quot;pre&quot;&gt;acquire()&lt;/span&gt;</code>​ 函数。如果代码中的某部分绕过acquire 函数直接申请锁，那么整个死锁避免机制就不起作用了。</p><p>‍</p><h1 id="保存线程的状态信息"><a href="#保存线程的状态信息" class="headerlink" title="保存线程的状态信息"></a>保存线程的状态信息</h1><blockquote><p>和Java ThreadLocal类似，介绍了怎么用</p></blockquote><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>你需要保存正在运行线程的状态，这个状态对于其他的线程是不可见的。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>有时在多线程编程中，你需要只保存当前运行线程的状态。 要这么做，可使用 <code>&lt;span class=&quot;pre&quot;&gt;thread.local()&lt;/span&gt;</code>​ 创建一个本地线程存储对象。 对这个对象的属性的保存和读取操作都只会对执行线程可见，而其他线程并不可见。</p><p>作为使用本地存储的一个有趣的实际例子， 考虑在8.3小节定义过的 <code>&lt;span class=&quot;pre&quot;&gt;LazyConnection&lt;/span&gt;</code>​ 上下文管理器类。 下面我们对它进行一些小的修改使得它可以适用于多线程：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from socket import socket, AF_INET, SOCK_STREAM</span><br><span class="line">import threading</span><br><span class="line"></span><br><span class="line">class LazyConnection:</span><br><span class="line">    def __init__(self, address, family=AF_INET, type=SOCK_STREAM):</span><br><span class="line">        self.address = address</span><br><span class="line">        self.family = AF_INET</span><br><span class="line">        self.type = SOCK_STREAM</span><br><span class="line">        self.local = threading.local()</span><br><span class="line"></span><br><span class="line">    def __enter__(self):</span><br><span class="line">        if hasattr(self.local, &#x27;sock&#x27;):</span><br><span class="line">            raise RuntimeError(&#x27;Already connected&#x27;)</span><br><span class="line">        self.local.sock = socket(self.family, self.type)</span><br><span class="line">        self.local.sock.connect(self.address)</span><br><span class="line">        return self.local.sock</span><br><span class="line"></span><br><span class="line">    def __exit__(self, exc_ty, exc_val, tb):</span><br><span class="line">        self.local.sock.close()</span><br><span class="line">        del self.local.sock</span><br></pre></td></tr></table></figure><p>代码中，自己观察对于 <code>&lt;span class=&quot;pre&quot;&gt;self.local&lt;/span&gt;</code>​ 属性的使用。 它被初始化为一个 <code>&lt;span class=&quot;pre&quot;&gt;threading.local()&lt;/span&gt;</code>​ 实例。 其他方法操作被存储为 <code>&lt;span class=&quot;pre&quot;&gt;self.local.sock&lt;/span&gt;</code>​ 的套接字对象。 有了这些就可以在多线程中安全的使用 <code>&lt;span class=&quot;pre&quot;&gt;LazyConnection&lt;/span&gt;</code>​ 实例了。例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from functools import partial</span><br><span class="line">def test(conn):</span><br><span class="line">    with conn as s:</span><br><span class="line">        s.send(b&#x27;GET /index.html HTTP/1.0\r\n&#x27;)</span><br><span class="line">        s.send(b&#x27;Host: www.python.org\r\n&#x27;)</span><br><span class="line"></span><br><span class="line">        s.send(b&#x27;\r\n&#x27;)</span><br><span class="line">        resp = b&#x27;&#x27;.join(iter(partial(s.recv, 8192), b&#x27;&#x27;))</span><br><span class="line"></span><br><span class="line">    print(&#x27;Got &#123;&#125; bytes&#x27;.format(len(resp)))</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    conn = LazyConnection((&#x27;www.python.org&#x27;, 80))</span><br><span class="line"></span><br><span class="line">    t1 = threading.Thread(target=test, args=(conn,))</span><br><span class="line">    t2 = threading.Thread(target=test, args=(conn,))</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    t1.join()</span><br><span class="line">    t2.join()</span><br></pre></td></tr></table></figure><p>它之所以行得通的原因是每个线程会创建一个自己专属的套接字连接（存储为self.local.sock）。 因此，当不同的线程执行套接字操作时，由于操作的是不同的套接字，因此它们不会相互影响。</p><h2 id="讨论-5"><a href="#讨论-5" class="headerlink" title="讨论"></a>讨论</h2><p>在大部分程序中创建和操作线程特定状态并不会有什么问题。 不过，当出了问题的时候，通常是因为某个对象被多个线程使用到，用来操作一些专用的系统资源， 比如一个套接字或文件。你不能让所有线程共享一个单独对象， 因为多个线程同时读和写的时候会产生混乱。 本地线程存储通过让这些资源只能在被使用的线程中可见来解决这个问题。</p><p>本节中，使用 <code>&lt;span class=&quot;pre&quot;&gt;thread.local()&lt;/span&gt;</code>​ 可以让 <code>&lt;span class=&quot;pre&quot;&gt;LazyConnection&lt;/span&gt;</code>​ 类支持一个线程一个连接， 而不是对于所有的进程都只有一个连接。</p><p>其原理是，每个 <code>&lt;span class=&quot;pre&quot;&gt;threading.local()&lt;/span&gt;</code>​ 实例为每个线程维护着一个单独的实例字典。 所有普通实例操作比如获取、修改和删除值仅仅操作这个字典。 每个线程使用一个独立的字典就可以保证数据的隔离了。</p><p>‍</p><h1 id="创建线程池"><a href="#创建线程池" class="headerlink" title="创建线程池"></a>创建线程池</h1><p><code>concurrent.futures</code>​ 函数库有一个 <code>ThreadPoolExecutor</code>​ 类可以被用来完成这个任务。 下面是一个简单的TCP服务器，使用了一个线程池来响应客户端：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from socket import AF_INET, SOCK_STREAM, socket</span><br><span class="line">from concurrent.futures import ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line">def echo_client(sock, client_addr):</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    Handle a client connection</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    print(&#x27;Got connection from&#x27;, client_addr)</span><br><span class="line">    while True:</span><br><span class="line">        msg = sock.recv(65536)</span><br><span class="line">        if not msg:</span><br><span class="line">            break</span><br><span class="line">        sock.sendall(msg)</span><br><span class="line">    print(&#x27;Client closed connection&#x27;)</span><br><span class="line">    sock.close()</span><br><span class="line"></span><br><span class="line">def echo_server(addr):</span><br><span class="line">    pool = ThreadPoolExecutor(128)</span><br><span class="line">    sock = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">    sock.bind(addr)</span><br><span class="line">    sock.listen(5)</span><br><span class="line">    while True:</span><br><span class="line">        client_sock, client_addr = sock.accept()</span><br><span class="line">        pool.submit(echo_client, client_sock, client_addr)</span><br><span class="line"></span><br><span class="line">echo_server((&#x27;&#x27;,15000))</span><br></pre></td></tr></table></figure><p>如果你想手动创建你自己的线程池， 通常可以使用一个Queue来轻松实现。下面是一个稍微不同但是手动实现的例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from socket import socket, AF_INET, SOCK_STREAM</span><br><span class="line">from threading import Thread</span><br><span class="line">from queue import Queue</span><br><span class="line"></span><br><span class="line">def echo_client(q):</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    Handle a client connection</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    sock, client_addr = q.get()</span><br><span class="line">    print(&#x27;Got connection from&#x27;, client_addr)</span><br><span class="line">    while True:</span><br><span class="line">        msg = sock.recv(65536)</span><br><span class="line">        if not msg:</span><br><span class="line">            break</span><br><span class="line">        sock.sendall(msg)</span><br><span class="line">    print(&#x27;Client closed connection&#x27;)</span><br><span class="line"></span><br><span class="line">    sock.close()</span><br><span class="line"></span><br><span class="line">def echo_server(addr, nworkers):</span><br><span class="line">    # Launch the client workers</span><br><span class="line">    q = Queue()</span><br><span class="line">    for n in range(nworkers):</span><br><span class="line">        t = Thread(target=echo_client, args=(q,))</span><br><span class="line">        t.daemon = True</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line">    # Run the server</span><br><span class="line">    sock = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">    sock.bind(addr)</span><br><span class="line">    sock.listen(5)</span><br><span class="line">    while True:</span><br><span class="line">        client_sock, client_addr = sock.accept()</span><br><span class="line">        q.put((client_sock, client_addr))</span><br><span class="line"></span><br><span class="line">echo_server((&#x27;&#x27;,15000), 128)</span><br></pre></td></tr></table></figure><p>使用 <code>&lt;span class=&quot;pre&quot;&gt;ThreadPoolExecutor&lt;/span&gt;</code>​ 相对于手动实现的一个好处在于它使得 任务提交者更方便的从被调用函数中获取返回值。例如，你可能会像下面这样写：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from concurrent.futures import ThreadPoolExecutor</span><br><span class="line">import urllib.request</span><br><span class="line"></span><br><span class="line">def fetch_url(url):</span><br><span class="line">    u = urllib.request.urlopen(url)</span><br><span class="line">    data = u.read()</span><br><span class="line">    return data</span><br><span class="line"></span><br><span class="line">pool = ThreadPoolExecutor(10)</span><br><span class="line"># Submit work to the pool</span><br><span class="line">a = pool.submit(fetch_url, &#x27;http://www.python.org&#x27;)</span><br><span class="line">b = pool.submit(fetch_url, &#x27;http://www.pypy.org&#x27;)</span><br><span class="line"></span><br><span class="line"># Get the results back</span><br><span class="line">x = a.result()</span><br><span class="line">y = b.result()</span><br></pre></td></tr></table></figure><p>例子中返回的handle对象会帮你处理所有的阻塞与协作，然后从工作线程中返回数据给你。 特别的，<code>&lt;span class=&quot;pre&quot;&gt;a.result()&lt;/span&gt;</code>​ 操作会阻塞进程直到对应的函数执行完成并返回一个结果。</p><h2 id="讨论-6"><a href="#讨论-6" class="headerlink" title="讨论"></a>讨论</h2><p>通常来讲，你应该避免编写线程数量可以无限制增长的程序。例如，看看下面这个服务器：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from threading import Thread</span><br><span class="line">from socket import socket, AF_INET, SOCK_STREAM</span><br><span class="line"></span><br><span class="line">def echo_client(sock, client_addr):</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    Handle a client connection</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    print(&#x27;Got connection from&#x27;, client_addr)</span><br><span class="line">    while True:</span><br><span class="line">        msg = sock.recv(65536)</span><br><span class="line">        if not msg:</span><br><span class="line">            break</span><br><span class="line">        sock.sendall(msg)</span><br><span class="line">    print(&#x27;Client closed connection&#x27;)</span><br><span class="line">    sock.close()</span><br><span class="line"></span><br><span class="line">def echo_server(addr, nworkers):</span><br><span class="line">    # Run the server</span><br><span class="line">    sock = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">    sock.bind(addr)</span><br><span class="line">    sock.listen(5)</span><br><span class="line">    while True:</span><br><span class="line">        client_sock, client_addr = sock.accept()</span><br><span class="line">        t = Thread(target=echo_client, args=(client_sock, client_addr))</span><br><span class="line">        t.daemon = True</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line">echo_server((&#x27;&#x27;,15000))</span><br></pre></td></tr></table></figure><p>尽管这个也可以工作， 但是它不能抵御有人试图通过创建大量线程让你服务器资源枯竭而崩溃的攻击行为。 通过使用预先初始化的线程池，你可以设置同时运行线程的上限数量。</p><p>你可能会关心创建大量线程会有什么后果。 现代操作系统可以很轻松的创建几千个线程的线程池。 甚至，同时几千个线程等待工作并不会对其他代码产生性能影响。 当然了，如果所有线程同时被唤醒并立即在CPU上执行，那就不同了——特别是有了全局解释器锁GIL。 通常，你应该只在I/O处理相关代码中使用线程池。</p><p>创建大的线程池的一个可能需要关注的问题是内存的使用。 例如，如果你在OS X系统上面创建2000个线程，系统显示Python进程使用了超过9GB的虚拟内存。 不过，这个计算通常是有误差的。当创建一个线程时，操作系统会预留一个虚拟内存区域来 放置线程的执行栈（通常是8MB大小）。但是这个内存只有一小片段被实际映射到真实内存中。 因此，Python进程使用到的真实内存其实很小 （比如，对于2000个线程来讲，只使用到了70MB的真实内存，而不是9GB）。 如果你担心虚拟内存大小，可以使用 <code>&lt;span class=&quot;pre&quot;&gt;threading.stack_size()&lt;/span&gt;</code>​ 函数来降低它。例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line">threading.stack_size(65536)</span><br></pre></td></tr></table></figure><p>如果你加上这条语句并再次运行前面的创建2000个线程试验， 你会发现Python进程只使用到了大概210MB的虚拟内存，而真实内存使用量没有变。 注意线程栈大小必须至少为32768字节，通常是系统内存页大小（4096、8192等）的整数倍。</p><p>‍</p><h1 id="简单并行编程"><a href="#简单并行编程" class="headerlink" title="简单并行编程"></a>简单并行编程</h1><p>你有个程序要执行CPU密集型工作，你想让他利用多核CPU的优势来运行的快一点。</p><h2 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h2><p><code>concurrent.futures</code>​ 库提供了一个 <code>ProcessPoolExecutor</code>​ 类， 可被用来在一个单独的Python解释器中执行计算密集型函数。 不过，要使用它，你首先要有一些计算密集型的任务。 我们通过一个简单而实际的例子来演示它。假定你有个Apache web服务器日志目录的gzip压缩包：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">logs/</span><br><span class="line">   20120701.log.gz</span><br><span class="line">   20120702.log.gz</span><br><span class="line">   20120703.log.gz</span><br><span class="line">   20120704.log.gz</span><br><span class="line">   20120705.log.gz</span><br><span class="line">   20120706.log.gz</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure><p>进一步假设每个日志文件内容类似下面这样：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">124.115.6.12 - - [10/Jul/2012:00:18:50 -0500] &quot;GET /robots.txt ...&quot; 200 71</span><br><span class="line">210.212.209.67 - - [10/Jul/2012:00:18:51 -0500] &quot;GET /ply/ ...&quot; 200 11875</span><br><span class="line">210.212.209.67 - - [10/Jul/2012:00:18:51 -0500] &quot;GET /favicon.ico ...&quot; 404 369</span><br><span class="line">61.135.216.105 - - [10/Jul/2012:00:20:04 -0500] &quot;GET /blog/atom.xml ...&quot; 304 -</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面是一个脚本，在这些日志文件中查找出所有访问过robots.txt文件的主机：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># findrobots.py</span><br><span class="line"></span><br><span class="line">import gzip</span><br><span class="line">import io</span><br><span class="line">import glob</span><br><span class="line"></span><br><span class="line">def find_robots(filename):</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    Find all of the hosts that access robots.txt in a single log file</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    robots = set()</span><br><span class="line">    with gzip.open(filename) as f:</span><br><span class="line">        for line in io.TextIOWrapper(f,encoding=&#x27;ascii&#x27;):</span><br><span class="line">            fields = line.split()</span><br><span class="line">            if fields[6] == &#x27;/robots.txt&#x27;:</span><br><span class="line">                robots.add(fields[0])</span><br><span class="line">    return robots</span><br><span class="line"></span><br><span class="line">def find_all_robots(logdir):</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    Find all hosts across and entire sequence of files</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    files = glob.glob(logdir+&#x27;/*.log.gz&#x27;)</span><br><span class="line">    all_robots = set()</span><br><span class="line">    for robots in map(find_robots, files):</span><br><span class="line">        all_robots.update(robots)</span><br><span class="line">    return all_robots</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    robots = find_all_robots(&#x27;logs&#x27;)</span><br><span class="line">    for ipaddr in robots:</span><br><span class="line">        print(ipaddr)</span><br></pre></td></tr></table></figure><p>前面的程序使用了通常的map-reduce风格来编写。 函数 <code>&lt;span class=&quot;pre&quot;&gt;find_robots()&lt;/span&gt;</code>​ 在一个文件名集合上做map操作，并将结果汇总为一个单独的结果， 也就是 <code>&lt;span class=&quot;pre&quot;&gt;find_all_robots()&lt;/span&gt;</code>​ 函数中的 <code>&lt;span class=&quot;pre&quot;&gt;all_robots&lt;/span&gt;</code>​ 集合。 现在，假设你想要修改这个程序让它使用多核CPU。 很简单——只需要将map()操作替换为一个 <code>&lt;span class=&quot;pre&quot;&gt;concurrent.futures&lt;/span&gt;</code>​ 库中生成的类似操作即可。 下面是一个简单修改版本：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># findrobots.py</span><br><span class="line"></span><br><span class="line">import gzip</span><br><span class="line">import io</span><br><span class="line">import glob</span><br><span class="line">from concurrent import futures</span><br><span class="line"></span><br><span class="line">def find_robots(filename):</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    Find all of the hosts that access robots.txt in a single log file</span><br><span class="line"></span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    robots = set()</span><br><span class="line">    with gzip.open(filename) as f:</span><br><span class="line">        for line in io.TextIOWrapper(f,encoding=&#x27;ascii&#x27;):</span><br><span class="line">            fields = line.split()</span><br><span class="line">            if fields[6] == &#x27;/robots.txt&#x27;:</span><br><span class="line">                robots.add(fields[0])</span><br><span class="line">    return robots</span><br><span class="line"></span><br><span class="line">def find_all_robots(logdir):</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    Find all hosts across and entire sequence of files</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    files = glob.glob(logdir+&#x27;/*.log.gz&#x27;)</span><br><span class="line">    all_robots = set()</span><br><span class="line">    with futures.ProcessPoolExecutor() as pool:</span><br><span class="line">        for robots in pool.map(find_robots, files):</span><br><span class="line">            all_robots.update(robots)</span><br><span class="line">    return all_robots</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    robots = find_all_robots(&#x27;logs&#x27;)</span><br><span class="line">    for ipaddr in robots:</span><br><span class="line">        print(ipaddr)</span><br></pre></td></tr></table></figure><p>通过这个修改后，运行这个脚本产生同样的结果，但是在四核机器上面比之前快了3.5倍。 实际的性能优化效果根据你的机器CPU数量的不同而不同。</p><h2 id="讨论-7"><a href="#讨论-7" class="headerlink" title="讨论"></a>讨论</h2><p><code>&lt;span class=&quot;pre&quot;&gt;ProcessPoolExecutor&lt;/span&gt;</code>​ 的典型用法如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from concurrent.futures import ProcessPoolExecutor</span><br><span class="line"></span><br><span class="line">with ProcessPoolExecutor() as pool:</span><br><span class="line">    ...</span><br><span class="line">    do work in parallel using pool</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>其原理是，一个 <code>&lt;span class=&quot;pre&quot;&gt;ProcessPoolExecutor&lt;/span&gt;</code>​ 创建N个独立的Python解释器， N是系统上面可用CPU的个数。你可以通过提供可选参数给 <code>&lt;span class=&quot;pre&quot;&gt;ProcessPoolExecutor(N)&lt;/span&gt;</code>​ 来修改 处理器数量。这个处理池会一直运行到with块中最后一个语句执行完成， 然后处理池被关闭。不过，程序会一直等待直到所有提交的工作被处理完成。</p><p>被提交到池中的工作必须被定义为一个函数。有两种方法去提交。 如果你想让一个列表推导或一个 <code>&lt;span class=&quot;pre&quot;&gt;map()&lt;/span&gt;</code>​ 操作并行执行的话，可使用 <code>&lt;span class=&quot;pre&quot;&gt;pool.map()&lt;/span&gt;</code>​ :</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># A function that performs a lot of work</span><br><span class="line">def work(x):</span><br><span class="line">    ...</span><br><span class="line">    return result</span><br><span class="line"></span><br><span class="line"># Nonparallel code</span><br><span class="line">results = map(work, data)</span><br><span class="line"></span><br><span class="line"># Parallel implementation</span><br><span class="line">with ProcessPoolExecutor() as pool:</span><br><span class="line">    results = pool.map(work, data)</span><br></pre></td></tr></table></figure><p>另外，你可以使用 <code>&lt;span class=&quot;pre&quot;&gt;pool.submit()&lt;/span&gt;</code>​ 来手动的提交单个任务：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Some function</span><br><span class="line">def work(x):</span><br><span class="line">    ...</span><br><span class="line">    return result</span><br><span class="line"></span><br><span class="line">with ProcessPoolExecutor() as pool:</span><br><span class="line">    ...</span><br><span class="line">    # Example of submitting work to the pool</span><br><span class="line">    future_result = pool.submit(work, arg)</span><br><span class="line"></span><br><span class="line">    # Obtaining the result (blocks until done)</span><br><span class="line">    r = future_result.result()</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>如果你手动提交一个任务，结果是一个 <code>&lt;span class=&quot;pre&quot;&gt;Future&lt;/span&gt;</code>​ 实例。 要获取最终结果，你需要调用它的 <code>&lt;span class=&quot;pre&quot;&gt;result()&lt;/span&gt;</code>​ 方法。 它会阻塞进程直到结果被返回来。</p><p>如果不想阻塞，你还可以使用一个回调函数，例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def when_done(r):</span><br><span class="line">    print(&#x27;Got:&#x27;, r.result())</span><br><span class="line"></span><br><span class="line">with ProcessPoolExecutor() as pool:</span><br><span class="line">     future_result = pool.submit(work, arg)</span><br><span class="line">     future_result.add_done_callback(when_done)</span><br></pre></td></tr></table></figure><p>回调函数接受一个 <code>&lt;span class=&quot;pre&quot;&gt;Future&lt;/span&gt;</code>​ 实例，被用来获取最终的结果（比如通过调用它的result()方法）。 尽管处理池很容易使用，在设计大程序的时候还是有很多需要注意的地方，如下几点：</p><ul><li>这种并行处理技术只适用于那些可以被分解为互相独立部分的问题。</li><li>被提交的任务必须是简单函数形式。对于方法、闭包和其他类型的并行执行还不支持。</li><li>函数参数和返回值必须兼容pickle，因为要使用到进程间的通信，所有解释器之间的交换数据必须被序列化</li><li>被提交的任务函数不应保留状态或有副作用。除了打印日志之类简单的事情，</li></ul><p>一旦启动你不能控制子进程的任何行为，因此最好保持简单和纯洁——函数不要去修改环境。</p><ul><li>在Unix上进程池通过调用 <code>&lt;span class=&quot;pre&quot;&gt;fork()&lt;/span&gt;</code>​ 系统调用被创建，</li></ul><p>它会克隆Python解释器，包括fork时的所有程序状态。 而在Windows上，克隆解释器时不会克隆状态。 实际的fork操作会在第一次调用 <code>&lt;span class=&quot;pre&quot;&gt;pool.map()&lt;/span&gt;</code>​ 或 <code>&lt;span class=&quot;pre&quot;&gt;pool.submit()&lt;/span&gt;</code>​ 后发生。</p><ul><li>当你混合使用进程池和多线程的时候要特别小心。</li></ul><p>你应该在创建任何线程之前先创建并激活进程池（比如在程序启动的main线程中创建进程池）。</p><h1 id="Py的全局锁问题"><a href="#Py的全局锁问题" class="headerlink" title="Py的全局锁问题"></a>Py的全局锁问题</h1><p>尽管Python完全支持多线程编程， 但是解释器的C语言实现部分在完全并行执行时并不是线程安全的。 实际上，解释器被一个全局解释器锁保护着，它确保任何时候都只有一个Python线程执行。 GIL最大的问题就是Python的多线程程序并不能利用多核CPU的优势 （比如一个使用了多个线程的计算密集型程序只会在一个单CPU上面运行）。</p><p>在讨论普通的GIL之前，<strong>有一点要强调的是GIL只会影响到那些严重依赖CPU的程序</strong>（比如计算型的）。 如果你的程序大部分只会涉及到I/O，比如网络交互，那么使用多线程就很合适， 因为它们大部分时间都在等待。实际上，你完全可以放心的创建几千个Python线程， 现代操作系统运行这么多线程没有任何压力，没啥可担心的。</p><p>而对于依赖CPU的程序，你需要弄清楚执行的计算的特点。 例如，优化底层算法要比使用多线程运行快得多。 类似的，由于Python是解释执行的，如果你将那些性能瓶颈代码移到一个C语言扩展模块中， 速度也会提升的很快。如果你要操作数组，那么使用NumPy这样的扩展会非常的高效。 最后，你还可以考虑下其他可选实现方案，比如PyPy，它通过一个JIT编译器来优化执行效率 （不过在写这本书的时候它还不能支持Python 3）。</p><p>还有一点要注意的是，线程不是专门用来优化性能的。 一个CPU依赖型程序可能会使用线程来管理一个图形用户界面、一个网络连接或其他服务。 这时候，GIL会产生一些问题，因为如果一个线程长期持有GIL的话会导致其他非CPU型线程一直等待。 事实上，一个写的不好的C语言扩展会导致这个问题更加严重， 尽管代码的计算部分会比之前运行的更快些。</p><p>说了这么多，现在想说的是我们有两种策略来解决GIL的缺点。 首先，如果你完全工作于Python环境中，你可以使用 <code>&lt;span class=&quot;pre&quot;&gt;multiprocessing&lt;/span&gt;</code>​ 模块来创建一个进程池， 并像协同处理器一样的使用它。例如，假如你有如下的线程代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Performs a large calculation (CPU bound)</span><br><span class="line">def some_work(args):</span><br><span class="line">    ...</span><br><span class="line">    return result</span><br><span class="line"></span><br><span class="line"># A thread that calls the above function</span><br><span class="line">def some_thread():</span><br><span class="line">    while True:</span><br><span class="line">        ...</span><br><span class="line">        r = some_work(args)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>修改代码，使用进程池：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Processing pool (see below for initiazation)</span><br><span class="line">pool = None</span><br><span class="line"></span><br><span class="line"># Performs a large calculation (CPU bound)</span><br><span class="line">def some_work(args):</span><br><span class="line">    ...</span><br><span class="line">    return result</span><br><span class="line"></span><br><span class="line"># A thread that calls the above function</span><br><span class="line">def some_thread():</span><br><span class="line">    while True:</span><br><span class="line">        ...</span><br><span class="line">        r = pool.apply(some_work, (args))</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line"># Initiaze the pool</span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    import multiprocessing</span><br><span class="line">    pool = multiprocessing.Pool()</span><br></pre></td></tr></table></figure><p>这个通过使用一个技巧利用进程池解决了GIL的问题。 当一个线程想要执行CPU密集型工作时，会将任务发给进程池。 然后进程池会在另外一个进程中启动一个单独的Python解释器来工作。 当线程等待结果的时候会释放GIL。 并且，由于计算任务在单独解释器中执行，那么就不会受限于GIL了。 在一个多核系统上面，你会发现这个技术可以让你很好的利用多CPU的优势。</p><p>另外一个解决GIL的策略是使用<strong>C扩展编程技术</strong>。 主要思想是将计算密集型任务转移给C，跟Python独立，在工作的时候在C代码中释放GIL。 这可以通过在C代码中插入下面这样的特殊宏来完成：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;Python.h&quot;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">PyObject *pyfunc(PyObject *self, PyObject *args) &#123;</span><br><span class="line">   ...</span><br><span class="line">   Py_BEGIN_ALLOW_THREADS</span><br><span class="line">   // Threaded C code</span><br><span class="line">   ...</span><br><span class="line">   Py_END_ALLOW_THREADS</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你使用其他工具访问C语言，比如对于Cython的ctypes库，你不需要做任何事。 例如，ctypes在调用C时会自动释放GIL。</p><h2 id="讨论-8"><a href="#讨论-8" class="headerlink" title="讨论"></a>讨论</h2><p>许多程序员在面对线程性能问题的时候，马上就会怪罪GIL，什么都是它的问题。 其实这样子太不厚道也太天真了点。 作为一个真实的例子，在多线程的网络编程中神秘的 <code>&lt;span class=&quot;pre&quot;&gt;stalls&lt;/span&gt;</code>​ 可能是因为其他原因比如一个DNS查找延时，而跟GIL毫无关系。 最后你真的需要先去搞懂你的代码是否真的被GIL影响到。 同时还要明白GIL大部分都应该只关注CPU的处理而不是I/O.</p><p>如果你准备使用一个处理器池，注意的是这样做涉及到数据序列化和在不同Python解释器通信。 被执行的操作需要放在一个通过def语句定义的Python函数中，不能是lambda、闭包可调用实例等， 并且函数参数和返回值必须要兼容pickle。 同样，要执行的任务量必须足够大以弥补额外的通信开销。</p><p>另外一个难点是当混合使用线程和进程池的时候会让你很头疼。 如果你要同时使用两者，最好在程序启动时，创建任何线程之前先创建一个单例的进程池。 然后线程使用同样的进程池来进行它们的计算密集型工作。</p><p>C扩展最重要的特征是它们和Python解释器是保持独立的。 也就是说，如果你准备将Python中的任务分配到C中去执行， 你需要确保C代码的操作跟Python保持独立， 这就意味着不要使用Python数据结构以及不要调用Python的C API。 另外一个就是你要确保C扩展所做的工作是足够的，值得你这样做。 也就是说C扩展担负起了大量的计算任务，而不是少数几个计算。</p><p>这些解决GIL的方案并不能适用于所有问题。 例如，某些类型的应用程序如果被分解为多个进程处理的话并不能很好的工作， 也不能将它的部分代码改成C语言执行。 对于这些应用程序，你就要自己需求解决方案了 （比如多进程访问共享内存区，多解析器运行于同一个进程等）。 或者，你还可以考虑下其他的解释器实现，比如PyPy。</p><p>了解更多关于在C扩展中释放GIL，请参考15.7和15.10小节。</p><p>‍</p><h1 id="Actor模式"><a href="#Actor模式" class="headerlink" title="Actor模式"></a>Actor模式</h1><p><strong>actor模式是一种最古老的也是最简单的并行和分布式计算解决方案。</strong>  事实上，它天生的简单性是它如此受欢迎的重要原因之一。 简单来讲，一个actor就是一个并发执行的任务，只是简单的执行发送给它的消息任务。 响应这些消息时，它可能还会给其他actor发送更进一步的消息。 actor之间的通信是单向和异步的。因此，消息发送者不知道消息是什么时候被发送， 也不会接收到一个消息已被处理的回应或通知。</p><p>结合使用一个线程和一个队列可以很容易的定义actor，例如：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Event</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sentinel used for shutdown</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ActorExit</span>(<span class="title class_ inherited__">Exception</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Actor</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._mailbox = Queue()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">send</span>(<span class="params">self, msg</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        Send a message to the actor</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        self._mailbox.put(msg)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recv</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        Receive an incoming message</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        msg = self._mailbox.get()</span><br><span class="line">        <span class="keyword">if</span> msg <span class="keyword">is</span> ActorExit:</span><br><span class="line">            <span class="keyword">raise</span> ActorExit()</span><br><span class="line">        <span class="keyword">return</span> msg</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">close</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        Close the actor, thus shutting it down</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        self.send(ActorExit)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        Start concurrent execution</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        self._terminated = Event()</span><br><span class="line">        t = Thread(target=self._bootstrap)</span><br><span class="line"></span><br><span class="line">        t.daemon = <span class="literal">True</span></span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_bootstrap</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.run()</span><br><span class="line">        <span class="keyword">except</span> ActorExit:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            self._terminated.<span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">join</span>(<span class="params">self</span>):</span><br><span class="line">        self._terminated.wait()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        Run method to be implemented by the user</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            msg = self.recv()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sample ActorTask</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PrintActor</span>(<span class="title class_ inherited__">Actor</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            msg = self.recv()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Got:&#x27;</span>, msg)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sample use</span></span><br><span class="line">p = PrintActor()</span><br><span class="line">p.start()</span><br><span class="line">p.send(<span class="string">&#x27;Hello&#x27;</span>)</span><br><span class="line">p.send(<span class="string">&#x27;World&#x27;</span>)</span><br><span class="line">p.close()</span><br><span class="line">p.join()</span><br></pre></td></tr></table></figure><p>这个例子中，你使用actor实例的 <code>&lt;span class=&quot;pre&quot;&gt;send()&lt;/span&gt;</code>​ 方法发送消息给它们。 其机制是，这个方法会将消息放入一个队里中， 然后将其转交给处理被接受消息的一个内部线程。 <code>&lt;span class=&quot;pre&quot;&gt;close()&lt;/span&gt;</code>​ 方法通过在队列中放入一个特殊的哨兵值（ActorExit）来关闭这个actor。 用户可以通过继承Actor并定义实现自己处理逻辑run()方法来定义新的actor。 <code>&lt;span class=&quot;pre&quot;&gt;ActorExit&lt;/span&gt;</code>​ 异常的使用就是用户自定义代码可以在需要的时候来捕获终止请求 （异常被get()方法抛出并传播出去）。</p><p>如果你放宽对于同步和异步消息发送的要求， 类actor对象还可以通过生成器来简化定义。例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def print_actor():</span><br><span class="line">    while True:</span><br><span class="line"></span><br><span class="line">        try:</span><br><span class="line">            msg = yield      # Get a message</span><br><span class="line">            print(&#x27;Got:&#x27;, msg)</span><br><span class="line">        except GeneratorExit:</span><br><span class="line">            print(&#x27;Actor terminating&#x27;)</span><br><span class="line"></span><br><span class="line"># Sample use</span><br><span class="line">p = print_actor()</span><br><span class="line">next(p)     # Advance to the yield (ready to receive)</span><br><span class="line">p.send(&#x27;Hello&#x27;)</span><br><span class="line">p.send(&#x27;World&#x27;)</span><br><span class="line">p.close()</span><br></pre></td></tr></table></figure><h2 id="讨论-9"><a href="#讨论-9" class="headerlink" title="讨论"></a>讨论</h2><p>actor模式的魅力就在于它的简单性。 实际上，这里仅仅只有一个核心操作 <code>&lt;span class=&quot;pre&quot;&gt;send()&lt;/span&gt;</code>​ . 甚至，对于在基于actor系统中的“消息”的泛化概念可以已多种方式被扩展。 例如，你可以以元组形式传递标签消息，让actor执行不同的操作，如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class TaggedActor(Actor):</span><br><span class="line">    def run(self):</span><br><span class="line">        while True:</span><br><span class="line">             tag, *payload = self.recv()</span><br><span class="line">             getattr(self,&#x27;do_&#x27;+tag)(*payload)</span><br><span class="line"></span><br><span class="line">    # Methods correponding to different message tags</span><br><span class="line">    def do_A(self, x):</span><br><span class="line">        print(&#x27;Running A&#x27;, x)</span><br><span class="line"></span><br><span class="line">    def do_B(self, x, y):</span><br><span class="line">        print(&#x27;Running B&#x27;, x, y)</span><br><span class="line"></span><br><span class="line"># Example</span><br><span class="line">a = TaggedActor()</span><br><span class="line">a.start()</span><br><span class="line">a.send((&#x27;A&#x27;, 1))      # Invokes do_A(1)</span><br><span class="line">a.send((&#x27;B&#x27;, 2, 3))   # Invokes do_B(2,3)</span><br><span class="line">a.close()</span><br><span class="line">a.join()</span><br></pre></td></tr></table></figure><p>作为另外一个例子，下面的actor允许在一个工作者中运行任意的函数， 并且通过一个特殊的Result对象返回结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from threading import Event</span><br><span class="line">class Result:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self._evt = Event()</span><br><span class="line">        self._result = None</span><br><span class="line"></span><br><span class="line">    def set_result(self, value):</span><br><span class="line">        self._result = value</span><br><span class="line"></span><br><span class="line">        self._evt.set()</span><br><span class="line"></span><br><span class="line">    def result(self):</span><br><span class="line">        self._evt.wait()</span><br><span class="line">        return self._result</span><br><span class="line"></span><br><span class="line">class Worker(Actor):</span><br><span class="line">    def submit(self, func, *args, **kwargs):</span><br><span class="line">        r = Result()</span><br><span class="line">        self.send((func, args, kwargs, r))</span><br><span class="line">        return r</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        while True:</span><br><span class="line">            func, args, kwargs, r = self.recv()</span><br><span class="line">            r.set_result(func(*args, **kwargs))</span><br><span class="line"></span><br><span class="line"># Example use</span><br><span class="line">worker = Worker()</span><br><span class="line">worker.start()</span><br><span class="line">r = worker.submit(pow, 2, 3)</span><br><span class="line">worker.close()</span><br><span class="line">worker.join()</span><br><span class="line">print(r.result())</span><br></pre></td></tr></table></figure><p>最后，“发送”一个任务消息的概念可以被扩展到多进程甚至是大型分布式系统中去。 例如，一个类actor对象的 <code>send()</code>​ 方法可以被编程让它能在一个套接字连接上传输数据 或通过某些消息中间件（比如AMQP、ZMQ等）来发送。</p><h1 id="实现消息发布-订阅模型"><a href="#实现消息发布-订阅模型" class="headerlink" title="实现消息发布/订阅模型"></a>实现消息发布/订阅模型</h1><p>TODO</p><h1 id="使用生成器代替线程"><a href="#使用生成器代替线程" class="headerlink" title="使用生成器代替线程"></a>使用生成器代替线程</h1><p>TODO</p><h1 id="多个线程队列轮询"><a href="#多个线程队列轮询" class="headerlink" title="多个线程队列轮询"></a>多个线程队列轮询</h1><p>TODO</p><h1 id="在Unix系统上面启动守护线程"><a href="#在Unix系统上面启动守护线程" class="headerlink" title="在Unix系统上面启动守护线程"></a>在Unix系统上面启动守护线程</h1><p>TODO</p><h1 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h1><p><a href="https://python3-cookbook.readthedocs.io/zh-cn/latest/chapters/p12_concurrency.html">Python CookBook</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;KeyWords:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;threading.Thread&lt;/li&gt;
&lt;li&gt;threading.Event&lt;/li&gt;
&lt;li&gt;使用队列queue.Queue，task_down()、join()实现线程通信&lt;/li&gt;
&lt;li&gt;</summary>
      
    
    
    
    <category term="Python" scheme="https://guoyujian.github.io/categories/Python/"/>
    
    <category term="并发" scheme="https://guoyujian.github.io/categories/Python/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="Python" scheme="https://guoyujian.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Fluent Python笔记持续整理</title>
    <link href="https://guoyujian.github.io/2024/03/08/Fluent-Python%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%95%B4%E7%90%86/"/>
    <id>https://guoyujian.github.io/2024/03/08/Fluent-Python%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%95%B4%E7%90%86/</id>
    <published>2024-03-08T07:22:30.000Z</published>
    <updated>2024-03-14T03:00:25.978Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>后面几节没整理；没有目录；一些重要章节不是很全，仅仅是介绍。<br>待拆分<br>Ref：<a href="https://www.52pojie.cn/thread-1816710-1-1.html">https://www.52pojie.cn/thread-1816710-1-1.html</a></p></blockquote><p>在Python中，如果一个类定义了<code>__getitem__</code>方法，那么该类的对象可以像序列（如列表、字符串等）一样使用索引运算符[]来访问其元素。 </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Seq</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.data = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, index</span>):</span><br><span class="line">        <span class="keyword">return</span> self.data[index]</span><br><span class="line">    </span><br><span class="line">seq = Seq()</span><br><span class="line">seq[<span class="number">0</span>:<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>这类方法称为魔术方法，类似的还有<code>__len__</code>, <code>__setitem__</code>, <code>__str__</code>, <code>__repr__</code>, <code>__add__</code>, <code>__eq__</code>等</p><p><code>__str__</code>和<code>__repr__</code>用于定义对象的字符串表示形式。<code>__str__</code>方法用于返回对象的人类可读的字符串表示形式，通常用于打印输出或显示给用户。 <code>__repr__</code>方法用于返回对象的官方字符串表示形式，通常用于调试和开发过程中。 下面是一个示例，展示了如何在自定义类中使用<code>__str__</code>和<code>__repr__</code>方法：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x, y</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;print..Point(<span class="subst">&#123;self.x&#125;</span>, <span class="subst">&#123;self.y&#125;</span>)&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;Point(<span class="subst">&#123;self.x&#125;</span>, <span class="subst">&#123;self.y&#125;</span>)&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">p = Point(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(p)</span><br><span class="line"><span class="built_in">repr</span>(p)</span><br></pre></td></tr></table></figure><p>总结魔术方法 TODO</p><hr><p>列表推导式： [expression for item in iterable if condition]<br>在处理大型数据集时，列表推导式可能会影响性能，这时应考虑使用生成器表达式或其他更适合的方法。</p><p>在Python中，map()和filter()是两个内置函数，用于对可迭代对象进行映射和过滤操作。 1. map()函数：   map()函数接受一个函数和一个或多个可迭代对象作为参数，将函数应用于每个可迭代对象中的元素，并返回一个新的迭代器（在Python 3中返回迭代器，在Python 2中返回列表）。    map()函数的语法如下：<br>map(function, iterable, …)  </p><p>filter()函数：   filter()函数接受一个函数和一个可迭代对象作为参数，根据函数的返回值（True或False）来过滤可迭代对象中的元素，并返回一个新的迭代器（在Python 3中返回迭代器，在Python 2中返回列表）。    filter()函数的语法如下：   </p><p>filter(function, iterable)</p><p>使用map()和filter()函数可以简化对列表的处理，使代码更简洁、可读性更高。然而，请注意在处理大型数据集时，这些函数可能会影响性能，这时应考虑使用列表推导式或其他更适合的方法。</p><p>生成器表达式与列表推导式的语法非常相似，只是将[]替换为()，从而创建一个生成器对象而不是列表对象。以下是生成器表达式的一般语法格式</p><p>(expression for item in iterable if condition)</p><p>与列表推导式不同，生成器表达式生成的是一个迭代器，而不是立即生成一个完整的列表。这种延迟计算的特性使得生成器表达式非常适合处理大数据集或无限序列。</p><p>拆包：拆包（Unpacking）是一种将序列（如元组或列表）中的元素分配给变量的操作。它可以方便地将序列中的元素解包并赋值给多个变量。 拆包可以应用于任何可迭代对象，例如元组、列表、集合等。要进行拆包，只需将可迭代对象放在赋值语句的左侧，并使用与元素数量相同的变量进行赋值。</p><p>使用拆包可以简化代码，并使其更易读。它允许一次性访问和操作序列中的多个元素，而不需要使用索引来逐个访问。 需要注意的是，如果拆包的变量数量与序列中的元素数量不匹配，将会引发ValueError异常。如果只想拆包序列中的一部分元素，可以使用占位符（如_）来表示不需要的元素。</p><p>在Python中，* 可以用于拆包操作，它可以将可迭代对象中的剩余元素打包成一个列表。这种用法通常称为“可变长参数”或“可变长参数列表”。 使用号拆包可以处理可变长度的参数列表，无需事先知道可迭代对象中的元素个数。 </p><p>Python支持嵌套拆包</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">a, *rest, b = lst</span><br><span class="line">rest</span><br></pre></td></tr></table></figure><p>序列模式匹配</p><p>从 Python 3.10 版本开始，引入了 match 表达式，以提供更强大的模式匹配功能。match 表达式可以用于匹配和解构各种数据类型，包括序列类型。 以下是一个示例，展示了如何在 Python 3.10 中使用 match 表达式进行模式匹配：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">process_data</span>(<span class="params">data</span>):</span><br><span class="line">    match data:</span><br><span class="line">        case [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;匹配到 [1, 2, 3]&quot;</span>)</span><br><span class="line">        case [<span class="number">4</span>, x, y]:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;匹配到 [4, <span class="subst">&#123;x&#125;</span>, <span class="subst">&#123;y&#125;</span>]&quot;</span>)</span><br><span class="line">        case [a, b, c]:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;匹配到 [<span class="subst">&#123;a&#125;</span>, <span class="subst">&#123;b&#125;</span>, <span class="subst">&#123;c&#125;</span>]&quot;</span>)</span><br><span class="line">        case _:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;未匹配到任何模式&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试示例</span></span><br><span class="line">process_data([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])  <span class="comment"># 输出: 匹配到 [1, 2, 3]</span></span><br><span class="line">process_data([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])  <span class="comment"># 输出: 匹配到 [4, 5, 6]</span></span><br><span class="line">process_data([<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])  <span class="comment"># 输出: 匹配到 [7, 8, 9]</span></span><br><span class="line">process_data([<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>])  <span class="comment"># 输出: 未匹配到任何模式</span></span><br></pre></td></tr></table></figure><p>字典推导式：它类似于列表推导式，但是生成的结果是字典而不是列表。</p><p>{key_expression: value_expression for item in iterable}</p><p>在Python中，defaultdict 是 collections 模块中的一个类，它是 dict 类的一个子类，用于创建具有默认值的字典。 与普通的字典不同，defaultdict 在创建时需要指定一个默认值的类型，当访问一个不存在的键时，它会自动返回默认值，而不会抛出 KeyError 异常。 以下是一个示例，展示了如何使用 defaultdict 创建具有默认值的字典：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line">d = defaultdict(<span class="built_in">int</span>)</span><br><span class="line"></span><br><span class="line">d[<span class="string">&#x27;a&#x27;</span>] = <span class="number">1</span></span><br><span class="line">d[<span class="string">&#x27;b&#x27;</span>]  <span class="comment"># 0 </span></span><br></pre></td></tr></table></figure><p>当我们使用一个字典访问一个不存在的键时，如果字典类中定义了 <code>__missing__</code> 方法，那么在访问不存在的键时，Python 会自动调用该方法，并将所访问的键作为参数传递给它。 以下是一个示例，展示了如何使用 <code>__missing__</code> 方法自定义字典中访问不存在的键的行为：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyDict</span>(<span class="title class_ inherited__">dict</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__missing__</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;Key &#x27;<span class="subst">&#123;key&#125;</span>&#x27; is missing!&quot;</span></span><br><span class="line"></span><br><span class="line">d = MyDict()</span><br><span class="line">d[<span class="string">&#x27;a&#x27;</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(d[<span class="string">&#x27;a&#x27;</span>])  <span class="comment"># 输出: 1</span></span><br><span class="line"><span class="built_in">print</span>(d[<span class="string">&#x27;b&#x27;</span>])  <span class="comment"># 输出: Key &#x27;b&#x27; is missing!</span></span><br></pre></td></tr></table></figure><p>collections.ChainMap 是 Python 中的一个类，它用于将多个字典或映射对象链接在一起，形成一个逻辑上的单一映射。 ChainMap 提供了一种方便的方式来处理多个字典或映射对象，并将它们作为一个整体来操作。它在逻辑上将这些字典或映射对象链接在一起，形成一个查找链。当我们在 ChainMap 对象上进行键的查找时，它会按照链接顺序依次在各个字典或映射对象中查找。 </p><p>collections.ChainMap的好处是他不会真的合并对象，而只是形成一个链接，因此他不会占用额外的空间。具体可看源码:<a href="https://blog.csdn.net/weixin_37780776/article/details/123777723">https://blog.csdn.net/weixin_37780776/article/details/123777723</a></p><p>collections.Counter 是 Python 中的一个类，它用于计数可哈希对象的出现次数。它是一个无序的集合，其中元素存储为键，其计数存储为值。 Counter 类提供了一些有用的方法，用于对计数器进行操作，如增加、减少元素的计数、获取最常见的元素、计算元素的总数等。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line">counter = Counter(<span class="string">&#x27;abcda&#x27;</span>)</span><br><span class="line">counter</span><br><span class="line">counter.values()</span><br></pre></td></tr></table></figure><p>在 Python 中，创建子类时，可以选择继承内置的 dict 类或 collections.UserDict 类来实现自定义字典类的功能。 尽管 dict 类是 Python 内置的字典类，但在某些情况下，继承 collections.UserDict 类可能更适合。collections.UserDict 是一个可变字典类的包装器，它提供了更简单和安全的方式来创建自定义字典类。 以下是一个示例，展示了如何使用 collections.UserDict 来创建自定义字典类：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> UserDict</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyDict</span>(<span class="title class_ inherited__">UserDict</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setitem__</span>(<span class="params">self, key, value</span>):</span><br><span class="line">        <span class="comment"># 自定义设置键值的行为</span></span><br><span class="line">        <span class="keyword">if</span> key == <span class="string">&#x27;special_key&#x27;</span>:</span><br><span class="line">            value += <span class="number">10</span></span><br><span class="line">        <span class="built_in">super</span>().__setitem__(key, value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="comment"># 自定义获取键值的行为</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().__getitem__(key)</span><br><span class="line"></span><br><span class="line">my_dict = MyDict()</span><br><span class="line">my_dict[<span class="string">&#x27;special_key&#x27;</span>] = <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(my_dict[<span class="string">&#x27;special_key&#x27;</span>])  <span class="comment"># 输出: 15</span></span><br></pre></td></tr></table></figure><p>在上面的示例中，我们创建了一个名为 MyDict 的自定义字典类，并继承了 UserDict 类。通过重写 <code>__setitem__</code> 和 <code>__getitem__</code> 方法，我们可以自定义设置和获取键值的行为。 继承 UserDict 类可以帮助我们避免直接修改 dict 对象的内部结构，从而更安全地创建自定义字典类。 当然，如果你只需要创建一个简单的字典类，而不需要自定义特定的行为，那么继承 dict 类也是可行的。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bytes_data = <span class="string">b&#x27;\xe4\xbd\xa0\xe5\xa5\xbd&#x27;</span></span><br><span class="line">decoded_text = bytes_data.decode(<span class="string">&#x27;utf-8&#x27;</span>)  </span><br><span class="line">decoded_text</span><br></pre></td></tr></table></figure><p>在 Python 中，具名元组（NamedTuple）是一种特殊类型的元组，它允许你给每个元素命名，并通过名称访问元素，而不仅仅是通过索引。 具名元组是通过 collections 模块中的 namedtuple 函数创建的。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建具名元组类</span></span><br><span class="line">Person = namedtuple(<span class="string">&#x27;Person&#x27;</span>, [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建具名元组实例</span></span><br><span class="line">person1 = Person(<span class="string">&#x27;Alice&#x27;</span>, <span class="number">25</span>, <span class="string">&#x27;female&#x27;</span>)</span><br><span class="line">person2 = Person(<span class="string">&#x27;Bob&#x27;</span>, <span class="number">30</span>, <span class="string">&#x27;male&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问元素</span></span><br><span class="line"><span class="built_in">print</span>(person1.name)      <span class="comment"># 输出：Alice</span></span><br><span class="line"><span class="built_in">print</span>(person2.age)       <span class="comment"># 输出：30</span></span><br><span class="line"><span class="built_in">print</span>(person1.gender)    <span class="comment"># 输出：female</span></span><br></pre></td></tr></table></figure><p>@dataclass 是 Python 3.7 引入的一个装饰器，用于简化创建和使用数据类（data class）的过程。数据类是一种用于存储数据的特殊类，它自动为我们生成一些常见的方法，如 <code>__init__</code>、<code>__repr__</code>、<code>__eq__</code> 等，使得我们可以更方便地创建和操作数据对象。 使用 @dataclass 装饰器，我们可以在类定义中省略一些繁琐的代码。以下是一个使用 @dataclass 装饰器创建数据类的示例</p><p>在 Python 中，垃圾回收是自动进行的，它是通过引用计数和循环垃圾收集机制来实现的。下面是对这两种机制的简要说明：</p><ol><li>引用计数（Reference Counting）：Python 使用引用计数来追踪每个对象的引用数。当对象的引用数变为 0 时，说明没有任何引用指向该对象，Python 会立即回收该对象的内存空间。这是一种高效的垃圾回收机制，可以立即回收不再使用的对象。</li></ol><p>然而，引用计数机制无法处理循环引用的情况，即两个或多个对象彼此引用，但没有其他引用指向它们。这种情况下，引用计数无法将对象的引用数降为 0，导致内存泄漏。为了解决这个问题，Python 提供了循环垃圾收集机制。</p><ol><li>循环垃圾收集（Cycle Garbage Collection）：Python 使用循环垃圾收集机制来检测和回收循环引用的对象。循环垃圾收集器会定期运行，它会检查所有对象的引用关系，并标记那些可以被回收的对象。然后，它会释放这些对象所占用的内存空间。</li></ol><p>循环垃圾收集器使用了更复杂的算法，如标记-清除（mark and sweep）和分代回收（generational collection），以提高垃圾回收的效率和性能。</p><p>需要注意的是，Python 的垃圾回收机制是自动的，开发者无需手动管理内存。然而，对于一些特殊情况，如大型数据结构或循环引用的对象，可能需要注意内存的使用和释放，以避免潜在的内存泄漏问题。</p><p>在 Python 中，函数的参数传递方式是通过引用传递（pass-by-reference），也可以称为对象的引用传递。这意味着函数参数在传递过程中，实际上是将对象的引用传递给函数，而不是对象本身的副本。 </p><p>总结起来，当函数参数是引用传递时，函数内部对参数对象的修改会影响到原始对象，但是对参数进行重新赋值则不会影响到原始对象。</p><p>del是一个关键字，常见用法：</p><ol><li>删除对象</li><li>删除对象的属性</li><li>删除列表中的元素</li><li>删除字典中的键值对</li></ol><p>python中函数是一等公民：</p><ol><li>将函数赋值给变量</li><li>函数可以作为参数</li><li>函数作为另一个函数的返回值</li><li>嵌套函数</li></ol><p>在 Python 中，高阶函数（Higher-order functions）是指能够接受函数作为参数，或者返回一个函数的函数。高阶函数是函数式编程的重要概念，它可以让代码更加简洁、灵活和可复用。 以下是一些常见的高阶函数的示例：</p><ul><li>map</li><li>filter</li><li>sorted</li><li>lambda函数：lambda 函数通常只适用于简单的、单行的函数逻辑。如果你需要编写复杂的函数逻辑，还是建议使用常规的函数定义方式。</li></ul><p>用户可以通过自定义类来创建可调用对象。为了使一个类的实例可以像函数一样被调用，需要在类中定义 <code>__call__</code>() 方法</p><p><strong>总结py中星号的用法</strong></p><p>在 Python 中，有一些流行的包和库支持函数式编程范式。以下是其中一些常用的包：</p><ol><li><p>functools：<code>functools</code> 是 Python 内置的一个模块，提供了一些函数式编程的工具函数。它包含了一些用于函数操作的高阶函数，如 <code>map()</code>、<code>filter()</code>、<code>reduce()</code>，以及一些用于函数组合和函数装饰器的工具函数。</p></li><li><p>itertools：<code>itertools</code> 也是 Python 内置的一个模块，提供了一些用于迭代和组合的工具函数。它包含了一些常见的函数式编程模式，如生成无限迭代器、组合迭代器、过滤迭代器等。</p></li><li><p>operator：<code>operator</code> 是 Python 内置的一个模块，提供了一些常见的运算符的函数形式。它提供了一种函数式的方式来执行常见的算术、比较和逻辑运算。</p></li><li><p>toolz：<code>toolz</code> 是一个功能强大的函数式编程工具包，提供了一些高阶函数和工具，用于处理集合、迭代和函数组合。它提供了一些函数式编程的常见模式，如 <code>curry()</code>、<code>compose()</code>、<code>pipe()</code> 等。</p></li><li><p>fn：<code>fn</code> 是一个专注于函数式编程的库，提供了一些函数式编程的工具函数和数据类型。它支持函数组合、柯里化、惰性求值等函数式编程的特性。</p></li></ol><p>这些包和库提供了丰富的工具和函数，帮助开发者更方便地应用函数式编程的思想和模式。无论是在函数组合、迭代操作、惰性求值还是其他函数式编程的场景中，它们都能提供很多便利。</p><p>在 Python 中，类型注解是一种可选的语法，用于提供变量、函数参数、函数返回值等的类型信息。类型注解可以帮助开发者和工具在静态类型检查时发现潜在的类型错误，提高代码的可读性和可维护性。</p><p>以下是一些常用的类型注解，可以在 Python 的注解中使用：</p><ol><li><p>基本类型：int、float、bool、str 等基本数据类型。</p></li><li><p>容器类型：list、tuple、dict、set 等容器类型。可以使用方括号 <code>[]</code> 表示列表，圆括号 <code>()</code> 表示元组，大括号 <code>&#123;&#125;</code> 表示字典和集合。</p></li><li><p>自定义类型：自定义的类、枚举类、命名元组等。</p></li><li><p>Union 类型：使用 <code>Union</code> 或 <code>|</code> 符号表示多个类型中的一个，表示一个变量可以是多种类型之一。</p></li><li><p>Optional 类型：使用 <code>Optional</code> 表示一个变量可以是指定类型或者 <code>None</code>。</p></li><li><p>Callable 类型：使用 <code>Callable</code> 表示一个变量是可调用对象，如函数、方法等。</p></li><li><p>类型变量：使用 <code>TypeVar</code> 表示一个类型变量，用于泛型编程或表示复杂类型。</p></li><li><p>Any 类型：使用 <code>Any</code> 表示任意类型，相当于取消了类型检查。</p></li></ol><p>需要注意的是，类型注解在 Python 中是可选的，不会影响代码的运行。它们只是提供了一种给开发者和工具更多类型信息的方式，以提高代码的可读性和可维护性。Python 解释器在运行时不会对类型注解进行验证，类型检查需要通过静态类型检查工具（如 <code>mypy</code>）进行。</p><p><strong>装饰器和闭包总结和使用装饰器改进策略模式</strong></p><p>实例方法、静态方法、类方法比较</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    cls_var = <span class="string">&#x27;cls_var&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, ins_var</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.ins_var = ins_var</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cls_method</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;This is a cls method&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(cls.cls_var)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">ins_method</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;This is a ins method&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(self.ins_var)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">static_method</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;This is a static method&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(MyClass.cls_var)</span><br><span class="line"></span><br><span class="line">MyClass.static_method()</span><br></pre></td></tr></table></figure><p>在Python中，有两种方式可以限制对类属性的访问：私有属性和受保护的属性。 </p><ol><li>私有属性： 私有属性是以双下划线 __ 开头的属性，它们只能在类的内部访问，无法从外部直接访问。私有属性的目的是防止意外的修改或访问，以保护类的内部实现细节。</li></ol><p>尽管无法直接访问私有属性和方法，但可以通过使用 <code>实例变量._类名__属性名</code>的方式来间接访问私有属性和方法。</p><p>请注意，这种方式只是一个约定，不是真正的访问控制机制。在Python中，没有真正的私有性，它只是一种约定，用于指示这些属性和方法应该被视为私有的。 </p><ol><li>受保护的属性： 受保护的属性是以单下划线 _ 开头的属性，它们建议在类的外部不直接访问，但可以从子类中访问。受保护的属性是一种更宽松的访问限制，用于指示这些属性应该被视为受保护的。</li></ol><p><code>__slots__</code> 是一个特殊的类属性，用于限制类的实例可以拥有的属性。 通过使用 <code>__slots__</code>，你可以告诉Python仅为类的实例分配指定的属性，从而节省了内存空间。当你知道类的实例只需要固定的一组属性时，使用 <code>__slots__</code> 可以提高性能。 下面是一个示例，演示了如何使用 <code>__slots__</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    __slots__ = (<span class="string">&quot;attribute1&quot;</span>, <span class="string">&quot;attribute2&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value1, value2</span>):</span><br><span class="line">        self.attribute1 = value1</span><br><span class="line">        self.attribute2 = value2</span><br><span class="line"></span><br><span class="line">obj = MyClass(<span class="string">&quot;Value 1&quot;</span>, <span class="string">&quot;Value 2&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(obj.attribute1)</span><br><span class="line"><span class="built_in">print</span>(obj.attribute2)</span><br><span class="line"></span><br><span class="line">obj.attribute3 = <span class="string">&quot;Value 3&quot;</span>  <span class="comment"># 无法为属性3分配内存，会引发 AttributeError</span></span><br></pre></td></tr></table></figure><p>在上面的示例中，我们定义了一个名为 MyClass 的类，并使用 <code>__slots__</code> 属性指定了类的实例只能拥有 attribute1 和 attribute2 这两个属性。 在类的 <code>__init__</code>方法中，我们为这两个属性赋予了初始值。 创建 MyClass 的实例 obj 后，我们可以访问这两个属性的值。 然而，当我们尝试为 obj 的 attribute3 属性赋值时，会引发 AttributeError 异常。这是因为 <code>__slots__</code> 属性限制了实例只能拥有 attribute1 和 attribute2 这两个属性，无法为其他属性分配内存。 需要注意的是，<code>__slots__</code> 是一个类属性，而不是实例属性。它仅对类的实例起作用，不对类本身起作用。 使用 <code>__slots__</code> 可以有效地减少实例所占用的内存空间，但需要注意选择适当的属性列表，确保不会限制过多或过少的属性。</p><p>动态存取属性</p><ol><li>点号赋值</li><li>getattr()、 setattr()</li><li>使用字典： <code>obj.__dict__[&#39;name&#39;] = &#39;John&#39;</code></li></ol><p>zip函数 拉链</p><p>鸭子类型是一种动态类型系统的概念，它强调在编程中关注对象的行为而不是具体的类型。根据鸭子类型的原则，只要一个对象具有特定的方法或属性，那么它就可以被视为具有相同的行为，而不需要显式地指定相同的类型。 在Python中，鸭子类型编程可以通过以下方式实现： 1. 不依赖具体的类型：编写代码时，不需要关注对象的具体类型，而是关注对象是否具有所需的方法或属性。例如，如果一个对象具有read()和write()方法，那么它可以被当作文件对象来使用，而不需要是file类型的实例。 2. 使用try-except语句：在使用某个方法或属性之前，可以使用try-except语句来捕获可能的异常。如果对象具有所需的方法或属性，那么代码将正常执行；如果对象没有所需的方法或属性，那么会抛出异常，可以在except块中处理该异常。 以下是一个简单的示例，演示了鸭子类型编程的概念</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">process_data</span>(<span class="params">obj</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        obj.read()</span><br><span class="line">        obj.process()</span><br><span class="line">        obj.write()</span><br><span class="line">    <span class="keyword">except</span> AttributeError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;对象不具有所需的方法或属性&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileObject</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">read</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;读取文件&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;处理数据&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">write</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;写入文件&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DatabaseObject</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">read</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;读取数据库&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;处理数据&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">write</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;写入数据库&quot;</span>)</span><br><span class="line"></span><br><span class="line">file_obj = FileObject()</span><br><span class="line">database_obj = DatabaseObject()</span><br><span class="line"></span><br><span class="line">process_data(file_obj)  <span class="comment"># 输出: 读取文件、处理数据、写入文件</span></span><br><span class="line">process_data(database_obj)  <span class="comment"># 输出: 读取数据库、处理数据、写入数据库</span></span><br><span class="line">process_data(<span class="string">&quot;Hello&quot;</span>)  <span class="comment"># 输出: 对象不具有所需的方法或属性</span></span><br></pre></td></tr></table></figure><p>在Python中，可以通过子类化内置类型来创建自定义的数据类型。内置类型，如list、dict、str等，可以作为基类来定义子类，从而扩展或定制其行为。 以下是一个简单的示例，演示了如何子类化内置类型list：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyList</span>(<span class="title class_ inherited__">list</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, *args</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(*args)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">append</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Appending item:&quot;</span>, item)</span><br><span class="line">        <span class="built_in">super</span>().append(item)</span><br><span class="line"></span><br><span class="line">my_list = MyList([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(my_list)  <span class="comment"># 输出: [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line">my_list.append(<span class="number">4</span>)  <span class="comment"># 输出: Appending item: 4</span></span><br><span class="line"><span class="built_in">print</span>(my_list)  <span class="comment"># 输出: [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><p>需要注意的是，子类化内置类型有一些限制和注意事项。例如，某些内置类型的行为可能是通过C语言实现的，因此无法直接覆盖。此外，一些内置类型具有特殊的方法和行为，需要进行特殊处理。</p><p>多重继承、混入类：略。</p><p>在Python中，TypedDict是一种用于定义具有特定键和值类型的字典的类型提示工具。它是Python 3.8版本中引入的，并且需要使用typing模块进行导入。 TypedDict允许我们为字典的键和值指定类型注解，以提供更严格的类型检查和类型提示。以下是一个示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> TypedDict</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">TypedDict</span>):</span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    age: <span class="built_in">int</span></span><br><span class="line"></span><br><span class="line">person: Person = &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>: <span class="number">30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，我们定义了一个名为Person的TypedDict，它具有两个键：name和age。我们在键后面使用冒号（:）指定了键的类型注解，以及值的类型注解。 然后，我们可以使用Person类型来注解一个字典变量person，并确保该字典的键和值类型与Person类型定义匹配。 TypedDict提供了更强的类型约束，可以在静态类型检查工具（如mypy）或IDE中提供更准确的类型提示。它适用于需要对字典的结构和类型进行严格控制的情况。 需要注意的是，TypedDict只在运行时对字典进行类型检查，而不是在编译时。因此，它不能完全替代编写健壮的输入验证和数据校验代码。</p><p>typing.cast是Python中的一个类型提示工具函数，它用于显式地指定一个对象的类型，并返回该对象的类型转换后的结果。 cast函数的签名如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cast</span>(<span class="params"><span class="built_in">type</span>, value</span>) -&gt; <span class="built_in">type</span>:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>其中，type参数是目标类型，value参数是要进行类型转换的对象。cast函数会将value对象转换为type类型，并返回转换后的结果。 以下是一个示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> cast</span><br><span class="line"></span><br><span class="line">num_str = <span class="string">&quot;123&quot;</span></span><br><span class="line">num_int = cast(<span class="built_in">int</span>, num_str)</span><br><span class="line"><span class="built_in">print</span>(num_int)  <span class="comment"># 输出: 123</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(num_int))  <span class="comment"># 输出: &lt;class &#x27;int&#x27;&gt;</span></span><br></pre></td></tr></table></figure><p>在上面的示例中，我们将字符串num_str通过cast函数转换为整数类型int。尽管num_str的类型是字符串，但我们使用cast函数显式地指定了目标类型为整数，并得到了转换后的结果。 需要注意的是，cast函数并不会进行实际的类型检查或类型转换。它仅仅是一个类型提示工具，用于向静态类型检查器（如mypy）提供额外的信息，以便进行更准确的类型推断和类型检查。 在使用cast函数时，应该谨慎使用，并确保对象的实际类型与指定的目标类型是兼容的，以避免运行时错误。</p><p>在Python中，我们可以使用泛化类（Generic Class）来实现具有通用性的类，以便在不同的类型上使用相同的代码。泛化类可以与类型参数一起使用，这样我们就可以在类定义中使用这些参数来表示不确定的类型。 以下是一个示例，展示如何使用泛化类来实现一个通用的堆栈类：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> TypeVar, <span class="type">Generic</span></span><br><span class="line"></span><br><span class="line">T = TypeVar(<span class="string">&#x27;T&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span>(<span class="type">Generic</span>[T]):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.items = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, item: T</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.items.append(item)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; T:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.is_empty():</span><br><span class="line">            <span class="keyword">return</span> self.items.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> IndexError(<span class="string">&quot;Stack is empty&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.items) == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.items)</span><br></pre></td></tr></table></figure><p>在上面的示例中，我们使用typing模块中的TypeVar来定义一个类型变量T。然后，在类定义中使用Generic[T]来表示这是一个泛化类，并且T是一个类型参数。 在类的方法中，我们可以使用类型参数T来表示不确定的类型。例如，在push方法中，我们接受一个类型为T的参数，并将其添加到堆栈中。在pop方法中，我们使用类型参数T来指定返回值的类型。 使用泛化类时，我们可以在实例化类时指定具体的类型，或者让类型推断机制自动推断类型。以下是一些示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stack = Stack[<span class="built_in">int</span>]()  <span class="comment"># 实例化一个整数类型的堆栈</span></span><br><span class="line">stack.push(<span class="number">1</span>)</span><br><span class="line">stack.push(<span class="number">2</span>)</span><br><span class="line">stack.push(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(stack.pop())  <span class="comment"># 输出: 3</span></span><br><span class="line"><span class="built_in">print</span>(stack.size())  <span class="comment"># 输出: 2</span></span><br><span class="line"></span><br><span class="line">stack2 = Stack[<span class="built_in">str</span>]()  <span class="comment"># 实例化一个字符串类型的堆栈</span></span><br><span class="line">stack2.push(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">stack2.push(<span class="string">&quot;World&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(stack2.pop())  <span class="comment"># 输出: &quot;World&quot;</span></span><br><span class="line"><span class="built_in">print</span>(stack2.size())  <span class="comment"># 输出: 1</span></span><br></pre></td></tr></table></figure><p>通过使用泛化类，我们可以在不同的类型上使用相同的代码逻辑，从而实现更通用、可重用的类。</p><p>在Python中，运算符重载（Operator Overloading）是指通过特殊的方法（也称为魔术方法或双下划线方法）来定义自定义类型的行为，使其支持标准的运算符操作。 以下是一些常用的运算符重载方法及其对应的运算符：</p><p><code>__add__</code>(self, other): 运算符 + 的重载方法，用于实现两个对象相加的操作。</p><p><code>__sub__</code>(self, other): 运算符 - 的重载方法，用于实现两个对象相减的操作。</p><p><code>__mul__</code>(self, other): 运算符 * 的重载方法，用于实现两个对象相乘的操作。</p><p><code>__div__</code>(self, other): 运算符 / 的重载方法，用于实现两个对象相除的操作。</p><p><code>__eq__</code>(self, other): 运算符 == 的重载方法，用于实现两个对象相等比较的操作。</p><p><code>__lt__</code>(self, other): 运算符 &lt; 的重载方法，用于实现两个对象小于比较的操作。</p><p><code>__gt__</code>(self, other): 运算符 &gt; 的重载方法，用于实现两个对象大于比较的操作。 以下是一个示例，展示如何在自定义类中重载运算符：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(other, Point):</span><br><span class="line">            <span class="keyword">return</span> Point(self.x + other.x, self.y + other.y)</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">isinstance</span>(other, <span class="built_in">int</span>) <span class="keyword">or</span> <span class="built_in">isinstance</span>(other, <span class="built_in">float</span>):</span><br><span class="line">            <span class="keyword">return</span> Point(self.x + other, self.y + other)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&quot;Unsupported operand type for +&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(other, Point):</span><br><span class="line">            <span class="keyword">return</span> self.x == other.x <span class="keyword">and</span> self.y == other.y</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;(<span class="subst">&#123;self.x&#125;</span>, <span class="subst">&#123;self.y&#125;</span>)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用运算符重载</span></span><br><span class="line">p1 = Point(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">p2 = Point(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">p3 = p1 + p2</span><br><span class="line"><span class="built_in">print</span>(p3)  <span class="comment"># 输出: (4, 6)</span></span><br><span class="line"></span><br><span class="line">p4 = p1 + <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(p4)  <span class="comment"># 输出: (6, 7)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(p1 == p2)  <span class="comment"># 输出: False</span></span><br><span class="line"><span class="built_in">print</span>(p1 == Point(<span class="number">1</span>, <span class="number">2</span>))  <span class="comment"># 输出: True</span></span><br></pre></td></tr></table></figure><p>在Python中，iter()是一个内置函数，用于返回一个可迭代对象的迭代器。 可迭代对象是指实现了<code>__iter__</code>()方法或<code>__getitem__</code>()方法的对象。迭代器是一个实现了<code>__iter__</code>()方法和<code>__next__</code>()方法的对象。iter()函数接受一个可迭代对象作为参数，并返回该可迭代对象的迭代器。 以下是iter()函数的语法：</p><p>可迭代对象（Iterable）和迭代器（Iterator）是Python中用于迭代操作的两个重要概念，它们之间有一些区别： </p><ol><li><p>可迭代对象（Iterable）：   </p><ul><li>可迭代对象是指实现了<strong>iter</strong>()方法或<strong>getitem</strong>()方法的对象。</li><li>可迭代对象可以使用for循环进行迭代，也可以使用内置函数iter()将其转换为迭代器。   - 可迭代对象每次迭代都会返回一个新的迭代器。 </li></ul></li><li><p>迭代器（Iterator）：   </p><ul><li>迭代器是指实现了<strong>iter</strong>()方法和<strong>next</strong>()方法的对象。   </li><li>迭代器用于从可迭代对象中逐个获取元素，每次调用<strong>next</strong>()方法返回迭代对象中的下一个元素。   </li><li>迭代器具有内部状态，可以记住当前迭代的位置。   </li><li>当迭代器中没有更多的元素可供获取时，调用<strong>next</strong>()方法会引发StopIteration异常。<br>下面是一个示例，展示可迭代对象和迭代器的区别：</li></ul></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SentenceIterator</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, words</span>):</span><br><span class="line">        self.words = words</span><br><span class="line">        self.index = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 有了这个函数才是迭代器</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            word =  self.words[self.index]</span><br><span class="line">        <span class="keyword">except</span> IndexError:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration()</span><br><span class="line">        self.index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> word</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sentence</span>:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;实现一个类，传入一个句子，在使用for迭代的时候，每次返回这个句子的单词（空格划分）&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val:<span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.words = val.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;每次迭代都返回新的返回迭代器，有了这个方法才是可迭代对象&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> SentenceIterator(self.words)</span><br><span class="line">    </span><br><span class="line">sentence = Sentence(<span class="string">&quot;I&#x27;m a Person.&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> sentence:</span><br><span class="line">    <span class="built_in">print</span>(word)</span><br></pre></td></tr></table></figure><p>生成器（Generator）是一种特殊的迭代器，它可以使用函数和yield语句来定义。生成器函数可以逐个产生元素，而不需要一次性生成所有元素。 </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">countdown</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">yield</span> n</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建生成器对象</span></span><br><span class="line">generator = countdown(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用生成器逐个获取元素</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(generator))  <span class="comment"># 输出: 5</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(generator))  <span class="comment"># 输出: 4</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(generator))  <span class="comment"># 输出: 3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(generator))  <span class="comment"># 输出: 2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(generator))  <span class="comment"># 输出: 1</span></span><br><span class="line"><span class="comment"># print(next(generator))  # 引发 StopIteration 异常</span></span><br></pre></td></tr></table></figure><p>在上述示例中，我们定义了一个生成器函数countdown()，它使用while循环和yield语句逐个产生元素。我们通过调用生成器函数来创建一个生成器对象generator。 然后，我们使用next()函数逐个获取生成器中的元素。每次调用next()函数时，生成器函数会从上次暂停的位置继续执行，直到遇到下一个yield语句。 需要注意的是，当生成器中没有更多的元素可供获取时，再次调用next()函数会引发StopIteration异常。 生成器的一个重要特点是它们在迭代过程中保持状态，而不是一次性生成所有元素。这使得生成器非常适合处理大量数据或无限序列，因为它们只在需要时产生元素，从而节省了内存和计算资源。 除了使用生成器函数创建生成器之外，还可以使用生成器表达式来创建生成器。生成器表达式与列表推导式类似，但使用圆括号而不是方括号。 以下是使用生成器表达式创建生成器的示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用生成器表达式创建生成器对象</span></span><br><span class="line">generator = (num <span class="keyword">for</span> num <span class="keyword">in</span> numbers <span class="keyword">if</span> num % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用生成器逐个获取元素</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(generator))  <span class="comment"># 输出: 2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(generator))  <span class="comment"># 输出: 4</span></span><br><span class="line"><span class="comment"># print(next(generator))  # 引发 StopIteration 异常</span></span><br></pre></td></tr></table></figure><p>在上述示例中，我们使用生成器表达式(num for num in numbers if num % 2 == 0)创建了一个生成器对象generator。该生成器对象会逐个产生列表numbers中满足条件的偶数。</p><p>在Python中，上下文管理器（Context Manager）是一种用于管理资源的对象，它定义了在进入和退出特定代码块时要执行的操作。上下文管理器通常用于确保资源的正确分配和释放，例如打开和关闭文件、获取和释放锁等。 上下文管理器可以使用两种方式来实现：通过类实现和通过装饰器实现。 1. 类实现上下文管理器：   - 通过定义一个类，并在类中实现<code>__enter__</code>()和<code>__exit__</code>()方法来创建上下文管理器。   - <code>__enter__</code>()方法在进入代码块前执行，通常用于获取资源或执行必要的准备工作，并将资源返回给调用者。   - <code>__exit__</code>()方法在退出代码块时执行，通常用于释放资源或执行清理操作。   - 如果在代码块中发生异常，异常会被传递给<code>__exit__</code>()方法处理，可以在<code>__exit__</code>()方法中进行异常处理和日志记录等操作。 以下是一个使用类实现上下文管理器的示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 模拟 Python 的打开文件、关闭文件操作</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Filemanager</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, mode</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;calling __init__ method&#x27;</span>)</span><br><span class="line">        self.name = name</span><br><span class="line">        self.mode = mode</span><br><span class="line">        self.file = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;caling __enter__ method&#x27;</span>)</span><br><span class="line">        self.file = <span class="built_in">open</span>(self.name, self.mode)</span><br><span class="line">        <span class="keyword">return</span> self.file</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, exc_type, exc_val, exc_tb</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;caling __exit__ method&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> self.file:</span><br><span class="line">            self.file.close</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Filemanager为上下文管理器</span></span><br><span class="line"><span class="comment"># with Filemanager(&#x27;test.txt&#x27;, &#x27;w&#x27;) as f 是上下文表达式，f为资源对象 </span></span><br><span class="line"><span class="keyword">with</span> Filemanager(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;ready to write to file&#x27;</span>)</span><br><span class="line">    f.write(<span class="string">&#x27;Hello World&#x27;</span>)</span><br></pre></td></tr></table></figure><p>exit方法中的参数exc_type、exc_val、exc_tb分别表示exception type、exception value、traceback。</p><p>装饰器实现上下文管理器：</p><ul><li>通过使用@contextlib.contextmanager装饰器和生成器函数来创建上下文管理器。   </li><li>在生成器函数内部，使用yield语句将控制权暂时交给调用者，并在yield语句前后执行进入和退出代码块的操作。   </li><li>调用者可以使用with语句来使用上下文管理器，而不需要手动调用<strong>enter</strong>()和<strong>exit</strong>()方法。 以下是一个使用装饰器实现上下文管理器的示例：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> contextmanager</span><br><span class="line"></span><br><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">file_manager</span>(<span class="params">name, mode</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        f = <span class="built_in">open</span>(name, mode)</span><br><span class="line">        <span class="keyword">yield</span> f</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        f.close()</span><br><span class="line">        </span><br><span class="line"><span class="keyword">with</span> file_manager(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">&#x27;hello world&#x27;</span>)</span><br></pre></td></tr></table></figure><p>在上述示例中，我们使用@contextmanager装饰器将生成器函数my<em>context<em>manager()转换为上下文管理器。在生成器函数内部，我们使用yield语句将控制权交给调用者，并在yield语句前后执行进入和退出代码块的操作。 然后，我们使用with语句来使用上下文管理器。在with代码块中，我们可以执行需要的操作，而不需要手动调用<strong>enter</strong>()和__exit</em></em>()方法。如果在代码块中发生异常，异常会被传递给生成器函数中的except块处理。 上下文管理器是一种非常有用的编程模式，它可以确保资源的正确分配和释放，提高代码的可读性和健壮性。</p><p>GIL（Global Interpreter Lock）是Python解释器中的一个机制，它是为了保证解释器在多线程环境下的安全性而引入的。GIL的存在导致了Python解释器在同一时间只能执行一个线程的字节码，从而限制了多线程并行执行的能力。</p><p>GIL的作用是在解释器级别上保护Python对象免受并发访问的影响。由于Python的内存管理不是线程安全的，GIL可以确保同一时间只有一个线程能够操作Python对象，从而避免了多线程访问同一对象时可能引发的竞态条件和数据不一致问题。</p><p>由于GIL的存在，Python的多线程并不能真正发挥多核处理器的并行计算能力。在CPU密集型任务中，多线程的性能可能比单线程还要差。然而，在I/O密集型任务中，多线程仍然可以提供一定的性能优势，因为线程可以在等待I/O操作完成时释放GIL，允许其他线程执行。</p><p>需要注意的是，GIL只存在于CPython解释器中，它是Python的参考实现。其他一些Python解释器，如Jython和IronPython，没有GIL，可以实现真正的并行执行。</p><p>为了充分利用多核处理器的并行计算能力，可以考虑使用多进程、异步编程或使用其他语言编写CPU密集型任务的模块。</p><p>下面是几个使用Python实现并发的示例： 1. 多线程并发下载文件：   使用threading模块创建多个线程，每个线程负责下载一个文件。  </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">download_file</span>(<span class="params">url, filename</span>):</span><br><span class="line">    response = requests.get(url)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        file.write(response.content)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件下载链接列表</span></span><br><span class="line">urls = [</span><br><span class="line">    <span class="string">&#x27;http://example.com/file1.txt&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;http://example.com/file2.txt&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;http://example.com/file3.txt&#x27;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建多个线程进行文件下载</span></span><br><span class="line">threads = []</span><br><span class="line"><span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">    filename = url.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">    thread = threading.Thread(target=download_file, args=(url, filename))</span><br><span class="line">    thread.start()</span><br><span class="line">    threads.append(thread)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待所有线程执行完毕</span></span><br><span class="line"><span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">    thread.join()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>多进程并发处理任务：使用multiprocessing模块创建多个进程，每个进程负责处理一个任务。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_task</span>(<span class="params">task</span>):</span><br><span class="line">    <span class="comment"># 处理任务</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Processing task: <span class="subst">&#123;task&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 任务列表</span></span><br><span class="line">tasks = [<span class="string">&#x27;task1&#x27;</span>, <span class="string">&#x27;task2&#x27;</span>, <span class="string">&#x27;task3&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建多个进程处理任务</span></span><br><span class="line">processes = []</span><br><span class="line"><span class="keyword">for</span> task <span class="keyword">in</span> tasks:</span><br><span class="line">    process = multiprocessing.Process(target=process_task, args=(task,))</span><br><span class="line">    process.start()</span><br><span class="line">    processes.append(process)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待所有进程执行完毕</span></span><br><span class="line"><span class="keyword">for</span> process <span class="keyword">in</span> processes:</span><br><span class="line">    process.join()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>异步并发执行网络请求： 使用asyncio模块和aiohttp库进行异步编程，实现并发执行多个网络请求。     </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">fetch</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> response:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">await</span> response.text()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 网络请求链接列表</span></span><br><span class="line">urls = [</span><br><span class="line">    <span class="string">&#x27;http://example.com/page1&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;http://example.com/page2&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;http://example.com/page3&#x27;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    tasks = [fetch(url) <span class="keyword">for</span> url <span class="keyword">in</span> urls]</span><br><span class="line">    results = <span class="keyword">await</span> asyncio.gather(*tasks)</span><br><span class="line">    <span class="keyword">for</span> result <span class="keyword">in</span> results:</span><br><span class="line">        <span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在Python中，可以使用multiprocessing.Pool类来自建进程池，以实现并发执行多个任务的目的。进程池可以提高任务的执行效率，减少创建和销毁进程的开销。 下面是一个使用multiprocessing.Pool自建进程池的示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_task</span>(<span class="params">task</span>):</span><br><span class="line">    <span class="comment"># 处理任务</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Processing task: <span class="subst">&#123;task&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建进程池，指定进程数量</span></span><br><span class="line">pool = multiprocessing.Pool(processes=<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 任务列表</span></span><br><span class="line">tasks = [<span class="string">&#x27;task1&#x27;</span>, <span class="string">&#x27;task2&#x27;</span>, <span class="string">&#x27;task3&#x27;</span>, <span class="string">&#x27;task4&#x27;</span>, <span class="string">&#x27;task5&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用进程池执行任务</span></span><br><span class="line">pool.<span class="built_in">map</span>(process_task, tasks)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭进程池，阻止新的任务提交</span></span><br><span class="line">pool.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待所有任务执行完毕</span></span><br><span class="line">pool.join()</span><br></pre></td></tr></table></figure><p>在上述示例中，我们首先创建了一个进程池对象pool，通过指定processes参数来设置进程的数量。然后，我们定义了一个任务处理函数process_task，该函数用于处理每个任务。 接着，我们创建了一个任务列表tasks，其中包含了需要处理的多个任务。使用pool.map()方法，我们将任务列表和任务处理函数作为参数传递给进程池，进程池会自动将任务分配给空闲的进程进行处理。 最后，我们关闭进程池并调用pool.join()方法，以等待所有任务执行完毕。 需要注意的是，进程池在执行任务时会自动管理进程的创建和销毁，因此不需要手动创建和销毁进程。进程池内部会维护一个进程队列，根据任务的数量和进程池的大小来动态分配任务给进程</p><p>concurrent.futures是Python标准库中的一个模块，提供了高级的并发编程接口，用于管理并发任务的执行和结果的获取。它建立在threading和multiprocessing模块之上，提供了线程池和进程池的实现。 concurrent.futures模块主要包含以下两个类： 1. ThreadPoolExecutor：线程池执行器，用于管理线程池并发执行任务。 2. ProcessPoolExecutor：进程池执行器，用于管理进程池并发执行任务。 这两个执行器类都实现了Executor接口，提供了一系列方法来提交任务、获取结果、关闭执行器等。 下面是一个使用concurrent.futures模块的示例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor, as_completed</span><br><span class="line"><span class="keyword">from</span> concurrent <span class="keyword">import</span> futures </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_task</span>(<span class="params">task</span>):</span><br><span class="line">    <span class="comment"># 处理任务</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Processing task: <span class="subst">&#123;task&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;Result: <span class="subst">&#123;task&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建线程池执行器，指定线程数量</span></span><br><span class="line"><span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">4</span>) <span class="keyword">as</span> executor:</span><br><span class="line">    <span class="comment"># 任务列表</span></span><br><span class="line">    tasks = [<span class="string">&#x27;task1&#x27;</span>, <span class="string">&#x27;task2&#x27;</span>, <span class="string">&#x27;task3&#x27;</span>, <span class="string">&#x27;task4&#x27;</span>, <span class="string">&#x27;task5&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 提交任务到线程池</span></span><br><span class="line">    futures = [executor.submit(process_task, task) <span class="keyword">for</span> task <span class="keyword">in</span> tasks]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取任务结果</span></span><br><span class="line">    <span class="keyword">for</span> future <span class="keyword">in</span> as_completed(futures):</span><br><span class="line">        result = future.result()</span><br><span class="line">        <span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><p>下面是一个使用ThreadPoolExecutor来并发下载文件的示例代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> concurrent.futures</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">download_file</span>(<span class="params">url</span>):</span><br><span class="line">    response = requests.get(url)</span><br><span class="line">    filename = url.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        file.write(response.content)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Downloaded file: <span class="subst">&#123;filename&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件下载链接列表</span></span><br><span class="line">urls = [</span><br><span class="line">    <span class="string">&#x27;http://example.com/file1.txt&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;http://example.com/file2.txt&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;http://example.com/file3.txt&#x27;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建线程池执行器，指定线程数量</span></span><br><span class="line"><span class="keyword">with</span> concurrent.futures.ThreadPoolExecutor() <span class="keyword">as</span> executor:</span><br><span class="line">    <span class="comment"># 提交下载任务到线程池</span></span><br><span class="line">    futures = [executor.submit(download_file, url) <span class="keyword">for</span> url <span class="keyword">in</span> urls]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取任务结果</span></span><br><span class="line">    <span class="keyword">for</span> future <span class="keyword">in</span> concurrent.futures.as_completed(futures):</span><br><span class="line">        result = future.result()</span><br></pre></td></tr></table></figure><p>在上述示例中，我们首先定义了一个download_file函数，用于下载指定URL的文件。该函数使用requests库发送HTTP请求并将响应内容写入本地文件。 然后，我们创建了一个文件下载链接列表urls，其中包含了需要下载的文件的URL。 接下来，我们创建了一个线程池执行器executor，并使用executor.submit()方法将下载任务提交给线程池执行器。submit()方法返回一个Future对象，表示任务的执行结果。 最后，我们使用concurrent.futures.as_completed()函数来迭代Future对象，获取下载任务的结果。as_completed()函数会返回一个迭代器，按照任务的完成顺序返回Future对象。我们通过调用future.result()方法获取每个任务的结果。 需要注意的是，在使用ThreadPoolExecutor时，我们使用了with语句来自动管理执行器的创建和关闭。在with代码块中，我们可以提交任务、获取结果等操作。执行器会在代码块结束时自动关闭，释放资源。</p><p>Python asyncio（异步I/O）是一种基于事件循环的异步编程库，用于编写高效的并发代码。它提供了一种协程（coroutine）的方式，使得编写异步代码更加简洁和可读。 下面是一个简单的示例，展示如何使用asyncio来执行异步任务：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">hello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;World&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(</span><br><span class="line">        hello(),</span><br><span class="line">        hello(),</span><br><span class="line">        hello()</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p>在上述示例中，我们定义了一个hello协程函数，其中包含了一个异步的打印任务和一个异步的等待任务。通过使用await关键字，我们可以在协程中等待其他协程的完成。 然后，我们定义了一个main协程函数，它使用asyncio.gather函数来并发执行多个协程任务。 最后，我们使用asyncio.run函数来运行main协程函数，从而启动整个异步程序。 需要注意的是，asyncio在Python 3.7及以上版本中是一个内置的标准库，可以直接使用。在旧版本的Python中，你可能需要通过pip来安装asyncio库。</p><p>21.2.可异步调用对象<br>在Python中，可以使用asyncio.ensure_future或asyncio.create_task来将可调用对象转换为可异步调用的对象。这样可以在异步程序中并发地执行多个可调用对象。 下面是一个示例代码，展示如何使用asyncio.ensure_future来异步调用可调用对象：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">hello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">world</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;World&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    task1 = asyncio.ensure_future(hello())</span><br><span class="line">    task2 = asyncio.ensure_future(world())</span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(task1, task2)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p>在上述示例中，我们定义了两个异步函数hello和world，它们分别打印”Hello”和”World”。 然后，在main函数中，我们使用asyncio.ensure_future将这两个异步函数转换为可异步调用的对象task1和task2。 最后，我们使用asyncio.gather来并发地执行这两个任务。 另外，从Python 3.7开始，可以使用asyncio.create_task来实现相同的效果：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">hello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">world</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;World&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    task1 = asyncio.create_task(hello())</span><br><span class="line">    task2 = asyncio.create_task(world())</span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(task1, task2)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p>这两种方法都可以将可调用对象转换为可异步调用的对象，以便在异步程序中并发地执行多个任务。</p><p>在Python中，从Python 3.7开始，我们可以使用asyncio库来创建异步上下文管理器。异步上下文管理器是一种特殊的对象，它可以在异步代码中使用async with语法来管理资源的获取和释放。 下面是一个示例代码，展示如何创建和使用异步上下文管理器：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AsyncContextManager</span>:</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">__aenter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Entering async context&quot;</span>)</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Resource&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">__aexit__</span>(<span class="params">self, exc_type, exc_val, exc_tb</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Exiting async context&quot;</span>)</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> AsyncContextManager() <span class="keyword">as</span> resource:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Using resource: <span class="subst">&#123;resource&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p>在上述示例中，我们定义了一个AsyncContextManager类，它实现了<strong>aenter</strong>和<strong>aexit</strong>方法。这两个方法分别在进入和退出异步上下文时被调用。 在<strong>aenter</strong>方法中，我们可以执行一些异步操作来获取资源。在这个示例中，我们使用await asyncio.sleep(1)模拟获取资源的耗时操作，并返回一个表示资源的字符串。 在<strong>aexit</strong>方法中，我们可以执行一些异步操作来释放资源。在这个示例中，我们同样使用await asyncio.sleep(1)模拟释放资源的耗时操作。 然后，在main协程函数中，我们使用async with语法来使用异步上下文管理器。在进入上下文时，会调用<strong>aenter</strong>方法，获取资源并将其赋值给resource变量。然后，在退出上下文时，会调用<strong>aexit</strong>方法，释放资源。 需要注意的是，这个示例使用asyncio.run来运行main协程函数，从而启动整个异步程序。</p><p>在Python中，从Python 3.6开始，我们可以使用<strong>async for</strong>语法来进行异步迭代，以及使用异步可迭代对象来支持异步迭代操作。 异步迭代是指在迭代过程中可以暂停和恢复执行，以便在等待异步操作完成时不阻塞事件循环。 下面是一个示例代码，展示如何进行异步迭代和使用异步可迭代对象：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AsyncIterable</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, data</span>):</span><br><span class="line">        self.data = data</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__aiter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">__anext__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.data:</span><br><span class="line">            <span class="keyword">raise</span> StopAsyncIteration</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)  <span class="comment"># 模拟异步操作</span></span><br><span class="line">        item = self.data.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">for</span> item <span class="keyword">in</span> AsyncIterable([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]):</span><br><span class="line">        <span class="built_in">print</span>(item)</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p>在上述示例中，我们定义了一个AsyncIterable类，它实现了<strong>aiter</strong>和<strong>anext</strong>方法。<strong>aiter</strong>方法返回一个异步迭代器对象，而<strong>anext</strong>方法定义了异步迭代的行为。 在<strong>anext</strong>方法中，我们使用await asyncio.sleep(1)模拟异步操作的等待时间。然后，我们从数据列表中取出一个元素并返回。 然后，在main协程函数中，我们使用async for语法来进行异步迭代。在每次迭代时，会调用<strong>anext</strong>方法来获取下一个元素，并在等待异步操作完成时暂停执行。 需要注意的是，这个示例使用asyncio.run来运行main协程函数，从而启动整个异步程序。</p><p>异步对象的类型提示<br>在Python中，可以使用类型提示来指定异步对象的类型。从Python 3.5开始，引入了typing模块，其中包含了一些用于异步编程的类型提示工具。 下面是一些常用的用于异步对象类型提示的工具： 1. typing.Coroutine: 用于指定协程函数的返回类型。 2. typing.Awaitable: 用于指定一个对象是可等待的，可以使用await关键字来等待其完成。 3. typing.AsyncIterable: 用于指定异步可迭代对象的类型。 4. typing.AsyncIterator: 用于指定异步迭代器的类型。 5. typing.AsyncContextManager: 用于指定异步上下文管理器的类型。 下面是一个示例代码，展示如何使用这些类型提示工具：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Coroutine</span>, Awaitable, AsyncIterable, AsyncIterator, AsyncContextManager</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">foo</span>() -&gt; <span class="type">Coroutine</span>:</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">bar</span>() -&gt; Awaitable[<span class="built_in">int</span>]:</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">baz</span>() -&gt; AsyncIterable[<span class="built_in">int</span>]:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">qux</span>() -&gt; AsyncIterator[<span class="built_in">int</span>]:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">spam</span>() -&gt; AsyncContextManager[<span class="built_in">str</span>]:</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;file.txt&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        content = <span class="keyword">await</span> file.read()</span><br><span class="line">        <span class="keyword">return</span> content</span><br><span class="line"></span><br><span class="line">asyncio.run(foo())</span><br><span class="line">asyncio.run(bar())</span><br><span class="line">asyncio.run(baz())</span><br><span class="line">asyncio.run(qux())</span><br><span class="line">asyncio.run(spam())</span><br></pre></td></tr></table></figure><p>在上述示例中，我们定义了几个异步函数，每个函数使用不同的类型提示来指定返回类型。 在foo函数中，我们使用Coroutine类型提示来指定返回的协程对象的类型。 在bar函数中，我们使用Awaitable类型提示来指定返回的对象是可等待的。 在baz函数中，我们使用AsyncIterable类型提示来指定返回的对象是异步可迭代的。 在qux函数中，我们使用AsyncIterator类型提示来指定返回的对象是异步迭代器。 在spam函数中，我们使用AsyncContextManager类型提示来指定返回的对象是异步上下文管理器。 需要注意的是，这个示例使用asyncio.run来运行每个异步函数，从而启动相应的异步程序。</p><p>使用动态属性访问json数据</p><p>在Python中，可以使用动态属性来访问JSON数据。动态属性允许我们在对象上创建或修改属性，从而实现对JSON数据的灵活访问。 下面是一个示例代码，展示如何使用动态属性访问JSON数据：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JSONData</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, json_str</span>):</span><br><span class="line">        self.data = json.loads(json_str)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">in</span> self.data:</span><br><span class="line">            value = self.data[name]</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(value, <span class="built_in">dict</span>):</span><br><span class="line">                <span class="keyword">return</span> JSONData(json.dumps(value))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(<span class="string">f&quot;&#x27;JSONData&#x27; object has no attribute &#x27;<span class="subst">&#123;name&#125;</span>&#x27;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用动态属性访问JSON数据</span></span><br><span class="line">json_str = <span class="string">&#x27;&#123;&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 30, &quot;address&quot;: &#123;&quot;city&quot;: &quot;New York&quot;, &quot;country&quot;: &quot;USA&quot;&#125;&#125;&#x27;</span></span><br><span class="line">data = JSONData(json_str)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(data.name)                <span class="comment"># 输出: John</span></span><br><span class="line"><span class="built_in">print</span>(data.age)                 <span class="comment"># 输出: 30</span></span><br><span class="line"><span class="built_in">print</span>(data.address)             <span class="comment"># 输出: &lt;__main__.JSONData object at 0x...&gt;</span></span><br><span class="line"><span class="built_in">print</span>(data.address.city)        <span class="comment"># 输出: New York</span></span><br><span class="line"><span class="built_in">print</span>(data.address.country)     <span class="comment"># 输出: USA</span></span><br></pre></td></tr></table></figure><p>后面的略</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;后面几节没整理；没有目录；一些重要章节不是很全，仅仅是介绍。&lt;br&gt;待拆分&lt;br&gt;Ref：&lt;a href=&quot;https://www.52pojie.cn/thread-1816710-1-1.html&quot;&gt;https://www.52pojie.cn</summary>
      
    
    
    
    <category term="Python" scheme="https://guoyujian.github.io/categories/Python/"/>
    
    <category term="基础" scheme="https://guoyujian.github.io/categories/Python/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Python" scheme="https://guoyujian.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python星号用法小结</title>
    <link href="https://guoyujian.github.io/2024/03/06/Python%E6%98%9F%E5%8F%B7%E7%94%A8%E6%B3%95%E5%B0%8F%E7%BB%93/"/>
    <id>https://guoyujian.github.io/2024/03/06/Python%E6%98%9F%E5%8F%B7%E7%94%A8%E6%B3%95%E5%B0%8F%E7%BB%93/</id>
    <published>2024-03-06T09:48:33.000Z</published>
    <updated>2024-03-06T10:20:37.161Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>乘法和乘方</p><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p>用在函数定义的参数时，</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a, *b, **c</span>):</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>在函数的参数中，当以标记一个参数时，表明这个参数是可变参数，具体来讲，用单星号<code>*</code>标记参数，表示其是可变的位置参数，并且以元组的形式将外部的多个位置参数返回给该参数变量，如果用双星号<code>**</code>标记，表示其看是可变的关键词参数，并且会以字典的形式将外部的多组关键词参数和值返回给该参数变量。</p><h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><p>可以用 <code>*</code>运算符把一个可迭代对象拆开作为函数的参数：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">divmod</span>(<span class="number">20</span>, <span class="number">8</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">20</span>, <span class="number">8</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">divmod</span>(*t)</span><br><span class="line">(<span class="number">2</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><h2 id="4"><a href="#4" class="headerlink" title="4"></a>4</h2><p>用星号处理拆包时的部分元素。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b,c,*d=a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="5"><a href="#5" class="headerlink" title="5"></a>5</h2><p>限制关键词参数</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a, *, b</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">func(<span class="number">1</span>, b = <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h2 id="6"><a href="#6" class="headerlink" title="6"></a>6</h2><p>拆包列表或者字典：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">c = [*a, <span class="number">10</span>, * b]  <span class="comment"># [1, 2, 3, 10, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line">d = &#123;<span class="string">&#x27;k1&#x27;</span>: <span class="number">1</span>&#125;</span><br><span class="line">e = &#123;<span class="string">&#x27;k2&#x27;</span>: <span class="number">2</span>&#125;</span><br><span class="line">f = &#123;**d, **e, <span class="string">&#x27;k3&#x27;</span>: <span class="number">3</span>&#125; <span class="comment"># &#123;&#x27;k1&#x27;: 1, &#x27;k2&#x27;: 2, &#x27;k3&#x27;: 3&#125;</span></span><br></pre></td></tr></table></figure><h2 id="More"><a href="#More" class="headerlink" title="More"></a>More</h2><p>…</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1&quot;&gt;&lt;a href=&quot;#1&quot; class=&quot;headerlink&quot; title=&quot;1&quot;&gt;&lt;/a&gt;1&lt;/h2&gt;&lt;p&gt;乘法和乘方&lt;/p&gt;
&lt;h2 id=&quot;2&quot;&gt;&lt;a href=&quot;#2&quot; class=&quot;headerlink&quot; title=&quot;2&quot;&gt;&lt;/a&gt;2&lt;/h2&gt;&lt;</summary>
      
    
    
    
    <category term="Python" scheme="https://guoyujian.github.io/categories/Python/"/>
    
    <category term="基础" scheme="https://guoyujian.github.io/categories/Python/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Python" scheme="https://guoyujian.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python闭包与装饰器总结1</title>
    <link href="https://guoyujian.github.io/2024/03/06/Python%E9%97%AD%E5%8C%85%E4%B8%8E%E8%A3%85%E9%A5%B0%E5%99%A8%E6%80%BB%E7%BB%931/"/>
    <id>https://guoyujian.github.io/2024/03/06/Python%E9%97%AD%E5%8C%85%E4%B8%8E%E8%A3%85%E9%A5%B0%E5%99%A8%E6%80%BB%E7%BB%931/</id>
    <published>2024-03-06T06:49:48.000Z</published>
    <updated>2024-03-06T06:52:58.409Z</updated>
    
    <content type="html"><![CDATA[<h1 id="装饰器基础"><a href="#装饰器基础" class="headerlink" title="装饰器基础"></a>装饰器基础</h1><p>装饰器是可调用的对象，其参数是另一个函数（被装饰的函数）。</p><p>装饰器的一个关键特性是，它们在被装饰的函数定义之后立即运行。这通常是在导入时 （即 Python 加载模块时）</p><p>‍</p><h1 id="变量作用域规则"><a href="#变量作用域规则" class="headerlink" title="变量作用域规则"></a>变量作用域规则</h1><p>对比代码</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">    <span class="built_in">print</span>(b)</span><br><span class="line"></span><br><span class="line">func(<span class="number">3</span>) <span class="comment"># 3 3</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">    <span class="built_in">print</span>(b)</span><br><span class="line">b = <span class="number">9</span></span><br><span class="line"></span><br><span class="line">func(<span class="number">3</span>) <span class="comment"># 3 UnboundLocalError</span></span><br></pre></td></tr></table></figure><p>这不是缺陷，而是设计选择：Python 不要求声明变量，但是假定在函数定义体中赋值的变量是局部变量。</p><p>如果在函数中赋值时想让解释器把 b 当成全局变量，要使用 global 声明:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a</span>):</span><br><span class="line"><span class="keyword">global</span> b</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">    <span class="built_in">print</span>(b)</span><br><span class="line">b = <span class="number">9</span></span><br><span class="line"></span><br><span class="line">func(<span class="number">3</span>) <span class="comment"># 3 3</span></span><br></pre></td></tr></table></figure><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p><strong>闭包指延伸了作用域的函数，其中包含函数定义体中引用、但是不在定义体中定义的非全局变量。</strong></p><p>假如有个名为 avg 的函数，它的作用是计算不断增加的系列值的均值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">10</span>)</span><br><span class="line"><span class="number">10.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">11</span>)</span><br><span class="line"><span class="number">10.5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">12</span>)</span><br><span class="line"><span class="number">11.0</span></span><br></pre></td></tr></table></figure><p>那么它的实现，可以是类的形式：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Average</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.<span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, num:<span class="built_in">int</span></span>) -&gt; <span class="type">Any</span>:</span><br><span class="line">        self.<span class="built_in">sum</span> += num</span><br><span class="line">        self.count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.<span class="built_in">sum</span> / self.count</span><br><span class="line">  </span><br><span class="line">avg = Average()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(avg(<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(avg(<span class="number">11</span>))</span><br><span class="line"><span class="built_in">print</span>(avg(<span class="number">12</span>))</span><br></pre></td></tr></table></figure><p>也可以是高阶函数</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make_averager</span>():</span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">averager</span>(<span class="params">num: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="keyword">nonlocal</span> total, count</span><br><span class="line">        total += num</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> total / count</span><br><span class="line">    <span class="keyword">return</span> averager</span><br><span class="line"></span><br><span class="line">avg = make_averager()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(avg(<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(avg(<span class="number">11</span>))</span><br><span class="line"><span class="built_in">print</span>(avg(<span class="number">12</span>))<span class="keyword">def</span> <span class="title function_">make_averager</span>():</span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">averager</span>(<span class="params">num: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="keyword">nonlocal</span> total, count</span><br><span class="line">        total += num</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> total / count</span><br><span class="line">    <span class="keyword">return</span> averager</span><br><span class="line"></span><br><span class="line">avg = make_averager()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(avg(<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(avg(<span class="number">11</span>))</span><br><span class="line"><span class="built_in">print</span>(avg(<span class="number">12</span>))</span><br></pre></td></tr></table></figure><p>注意<code>nonlocal total, count</code>​：</p><p>因为在Python中并没有要求先声明一个变量，所以Python解释器任务在函数体内，只要对一个变量进行赋值操作，那么这个变量就是局部变量。而 count+=1相当于 count=count+1，对 count 进行了赋值操作，所以Python解释器认为 count 是函数内的局部变量。我们这里需要用nonlocal关键字将局部变量修正为自由变量。</p><p>所谓自由变量就是没有被绑定在局部作用域的变量。</p><p>‍</p><h1 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h1><p>利用闭包实现日志装饰器：对于被装饰函数，每次调用打印调度log</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">logit</span>(<span class="params">func</span>):</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">with_logging</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(func.__name__, <span class="string">&quot;was called&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> with_logging</span><br><span class="line"></span><br><span class="line"><span class="meta">@logit</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">some_func</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;do something&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> x + x</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(some_func(<span class="number">5</span>))</span><br></pre></td></tr></table></figure><p>@符号是一个语法糖，实际的执行是：logit(some_func(x))</p><p>如果装饰器需要带参数，（例如下面的代码实现了将日志保存到指定文件），则需要再加一层：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">logit</span>(<span class="params">log_file = <span class="string">&#x27;out.log&#x27;</span></span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_logit</span>(<span class="params">func</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">with_logging</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">            <span class="built_in">print</span>(func.__name__, <span class="string">&quot;was called&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;save log to <span class="subst">&#123;log_file&#125;</span>&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> with_logging</span><br><span class="line">    <span class="keyword">return</span> _logit</span><br><span class="line"></span><br><span class="line"><span class="meta">@logit(<span class="params">log_file=<span class="string">&#x27;a.log&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">some_func</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;do something&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> x + x</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(some_func(<span class="number">5</span>))</span><br></pre></td></tr></table></figure><h1 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h1><p>《流畅的Python》</p><p>‍</p><h1 id="More"><a href="#More" class="headerlink" title="More"></a>More</h1><p>关于装饰器更多内容还包括：</p><ul><li>[ ] @functools.wraps</li><li>[ ] @lru_cache()和@singledispatch</li><li>[ ] 类装饰器</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;装饰器基础&quot;&gt;&lt;a href=&quot;#装饰器基础&quot; class=&quot;headerlink&quot; title=&quot;装饰器基础&quot;&gt;&lt;/a&gt;装饰器基础&lt;/h1&gt;&lt;p&gt;装饰器是可调用的对象，其参数是另一个函数（被装饰的函数）。&lt;/p&gt;
&lt;p&gt;装饰器的一个关键特性是，它们在被装饰的函数</summary>
      
    
    
    
    <category term="Python" scheme="https://guoyujian.github.io/categories/Python/"/>
    
    <category term="基础" scheme="https://guoyujian.github.io/categories/Python/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Python" scheme="https://guoyujian.github.io/tags/Python/"/>
    
    <category term="闭包" scheme="https://guoyujian.github.io/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>Kruskal算法与力扣1135</title>
    <link href="https://guoyujian.github.io/2024/01/20/Kruskal%E7%AE%97%E6%B3%95%E4%B8%8E%E5%8A%9B%E6%89%A31135/"/>
    <id>https://guoyujian.github.io/2024/01/20/Kruskal%E7%AE%97%E6%B3%95%E4%B8%8E%E5%8A%9B%E6%89%A31135/</id>
    <published>2024-01-20T07:01:01.000Z</published>
    <updated>2024-01-20T07:14:38.602Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍图的最小生成树算法Kruskal 算法。</p><p>阅读之前需要先了解</p><ul><li>图和树数据结构</li><li>加权图、生成树、最小生成树</li><li>Kruskal 算法基本思想</li></ul><p>在Kruskal 算法中，需要保证每次新加入的边不会让树变成图，即不能让树包含环。那么 Union-Find 算法就是帮你干这个事儿的。</p><p>像下面这样添加边会出现环：</p><p><img src="1.png" alt="图片"></p><p>而这样添加边则不会出现环：</p><p><img src="2.png" alt="图片"></p><p>总结一下规律就是：</p><p><strong>对于添加的这条边，如果该边的两个节点本来就在同一连通分量里，那么添加这条边会产生环；反之，如果该边的两个节点不在同一连通分量里，则添加这条边不会产生环</strong>。</p><p>而判断两个节点是否连通（是否在同一个连通分量中）就是 Union-Find 算法的拿手绝活。</p><p>力扣第 1135 题「最低成本联通所有城市」，这是一道标准的最小生成树问题：</p><p><img src="640.png" alt="图片"></p><p>每座城市相当于图中的节点，连通城市的成本相当于边的权重，连通所有城市的最小成本即是最小生成树的权重之和。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"><span class="keyword">from</span> union_find <span class="keyword">import</span> UF  <span class="comment"># 自实现的union-find算法，详略</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minimumCost</span>(<span class="params">self, n: <span class="built_in">int</span>, connections:<span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 城市编号从1开始，所以初始化大小为1+n</span></span><br><span class="line">        uf = UF(n+<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 按权重排序</span></span><br><span class="line">        connections.sort(<span class="keyword">lambda</span> x : x[<span class="number">2</span>])</span><br><span class="line">        mst = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> u, v, weight <span class="keyword">in</span> connections:</span><br><span class="line">            <span class="comment">#如果产生环，则不能加入mst</span></span><br><span class="line">            <span class="keyword">if</span> uf.connected(u, v):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 如果没有产生环，则属于最小生成树</span></span><br><span class="line">            mst += weight</span><br><span class="line">            uf.union(u, v)</span><br><span class="line">        <span class="comment"># 保证所有节点都被连通</span></span><br><span class="line">        <span class="comment"># 按理uf.count() == 1说明所有节点被连通</span></span><br><span class="line">        <span class="comment"># 但因为节点0没有被使用，所以0会额外占用一个连通分量</span></span><br><span class="line">        <span class="keyword">return</span> mst <span class="keyword">if</span> uf.count() == <span class="number">2</span> <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h1><ol><li><a href="https://mp.weixin.qq.com/s/dJ9gqR3RVoeGnATlpMG39w">东哥带你刷图论第五期：Kruskal 最小生成树算法</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文介绍图的最小生成树算法Kruskal 算法。&lt;/p&gt;
&lt;p&gt;阅读之前需要先了解&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;图和树数据结构&lt;/li&gt;
&lt;li&gt;加权图、生成树、最小生成树&lt;/li&gt;
&lt;li&gt;Kruskal 算法基本思想&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在Kruskal 算法中，</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://guoyujian.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="图" scheme="https://guoyujian.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE/"/>
    
    
    <category term="Kruskal 算法" scheme="https://guoyujian.github.io/tags/Kruskal-%E7%AE%97%E6%B3%95/"/>
    
    <category term="力扣1135" scheme="https://guoyujian.github.io/tags/%E5%8A%9B%E6%89%A31135/"/>
    
    <category term="图" scheme="https://guoyujian.github.io/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>Union-Find并查集算法（Python实现）</title>
    <link href="https://guoyujian.github.io/2023/12/24/Union-Find%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%AE%97%E6%B3%95%EF%BC%88Python%E5%AE%9E%E7%8E%B0%EF%BC%89/"/>
    <id>https://guoyujian.github.io/2023/12/24/Union-Find%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%AE%97%E6%B3%95%EF%BC%88Python%E5%AE%9E%E7%8E%B0%EF%BC%89/</id>
    <published>2023-12-24T01:37:00.000Z</published>
    <updated>2023-12-24T01:39:52.705Z</updated>
    
    <content type="html"><![CDATA[<p>这是并查集算法的Python实现：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UF</span>:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    并查集算法</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        初始化数据结构</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 初始化连通分量数量</span></span><br><span class="line">        self._count = n</span><br><span class="line">        <span class="comment"># 初始化双亲节点</span></span><br><span class="line">        self._parent = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="comment"># self.size[x]表示以x为根节点的节点数量</span></span><br><span class="line">        self._size = [<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self, x : <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        find root of x</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">while</span> self._parent[x] != x:</span><br><span class="line">            <span class="comment"># 路经压缩，将当前节点的双亲节点设为其双亲节点的双亲节点</span></span><br><span class="line">            self._parent[x] = self._parent[self._parent[x]]</span><br><span class="line">            x = self._parent[x]</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">union</span>(<span class="params">self, p: <span class="built_in">int</span>, q: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        union p and q</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 找到p和q的根节点</span></span><br><span class="line">        rootP = self.find(p)</span><br><span class="line">        rootQ = self.find(q)</span><br><span class="line">        <span class="keyword">if</span> rootP == rootQ:</span><br><span class="line">            <span class="comment"># 如果根节点相等，则pq本就联通</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 将小集合合并到大集合中，平衡性优化</span></span><br><span class="line">        <span class="keyword">if</span> self._size[rootP] &gt; self._size[rootQ]:</span><br><span class="line"></span><br><span class="line">            self._parent[rootQ] = rootP</span><br><span class="line">            self._size[rootP] += self._size[rootQ]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self._parent[rootP] = rootQ</span><br><span class="line">            self._size[rootQ] += self._size[rootP]</span><br><span class="line">        self._count -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">count</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        返回联通数</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> self._count</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">connected</span>(<span class="params">self, p, q</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        判断pq是否联通</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> self.find(q) == self.find(p)</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>参考：<a href="https://zhuanlan.zhihu.com/p/98406740">https://zhuanlan.zhihu.com/p/98406740</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这是并查集算法的Python实现：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://guoyujian.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="并查集算法" scheme="https://guoyujian.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Python" scheme="https://guoyujian.github.io/tags/Python/"/>
    
    <category term="算法" scheme="https://guoyujian.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="并查集" scheme="https://guoyujian.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
    <category term="UnionFind" scheme="https://guoyujian.github.io/tags/UnionFind/"/>
    
  </entry>
  
  <entry>
    <title>subprocess执行java命令残留进程解决</title>
    <link href="https://guoyujian.github.io/2023/12/07/subprocess%E6%89%A7%E8%A1%8Cjava%E5%91%BD%E4%BB%A4%E6%AE%8B%E7%95%99%E8%BF%9B%E7%A8%8B%E8%A7%A3%E5%86%B3/"/>
    <id>https://guoyujian.github.io/2023/12/07/subprocess%E6%89%A7%E8%A1%8Cjava%E5%91%BD%E4%BB%A4%E6%AE%8B%E7%95%99%E8%BF%9B%E7%A8%8B%E8%A7%A3%E5%86%B3/</id>
    <published>2023-12-07T08:42:12.000Z</published>
    <updated>2023-12-07T08:51:07.103Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题简述"><a href="#问题简述" class="headerlink" title="问题简述"></a>问题简述</h1><blockquote><p>需求是通过Python执行命令java -java springboot-demo.jar</p><p>于是，我使用subprocess.Popen()来启停。但是我发现在关闭子进程后，java进程并没有正确关闭。</p><p>这是由于上面的方法实际原理是另外开启一个cmd命令来运行java -jar命令，后面用popen.terminate()也只能关闭cmd的命令，cmd命令被kill掉后，java进程由系统来托管，从而导致java进程并没有正确关闭。</p></blockquote><h1 id="Bug复现"><a href="#Bug复现" class="headerlink" title="Bug复现"></a>Bug复现</h1><p>执行代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"><span class="comment"># 执行java -jar</span></span><br><span class="line">t = subprocess.Popen([<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;springboot-demo.jar&quot;</span>])</span><br><span class="line"><span class="comment"># Popen是异步的，所以需要等待几秒，再关闭</span></span><br><span class="line">time.sleep(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 关闭子进程</span></span><br><span class="line">t.terminate()</span><br><span class="line"><span class="comment"># 等待关闭结束</span></span><br><span class="line">t.wait()</span><br></pre></td></tr></table></figure><p>发现残留的java进程</p><p><img src="image.png" alt="image"></p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我的解决思路是，稍微修改java代码，在执行java -jar命令后，将java进程id（pid）暴露出来。</p><p>当需要关闭程序时，读取暴露出来的java进程id，使用kill命令，将进程杀死。</p><h2 id="详述"><a href="#详述" class="headerlink" title="详述"></a>详述</h2><p>首先修改java代码，我使用的代码框架是springboot，所以在springboot的启动类上修改如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringbootDemoApplication</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">SpringApplication</span> <span class="variable">application</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpringApplication</span>(SpringbootDemoApplication.class);</span><br><span class="line"><span class="comment">// 获取jar包执行的路径</span></span><br><span class="line"><span class="type">ApplicationHome</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ApplicationHome</span>(SpringbootDemoApplication.class);</span><br><span class="line"><span class="type">File</span> <span class="variable">source</span> <span class="operator">=</span> h.getSource();</span><br><span class="line">System.out.println(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt;&lt; jar 执行目录：&quot;</span> + source.getParentFile().toString() + <span class="string">&quot; &gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">app_pid_file</span> <span class="operator">=</span> source.getParentFile().toString() + <span class="string">&quot;\\app.pid&quot;</span>;</span><br><span class="line">application.addListeners(<span class="keyword">new</span> <span class="title class_">ApplicationPidFileWriter</span>(app_pid_file)); <span class="comment">// 把进程号放到这个文件中</span></span><br><span class="line">application.run();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，</p><ul><li>source.getParentFile().toString()可以获得jar包所在的目录。</li><li>application.addListeners(new ApplicationPidFileWriter(app_pid_file));将在jar包同级目录下生成app.pid的文件，该文件中写入了springboot运行的进程号</li></ul><p>然后修改Python代码</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">JAR_DIR = <span class="string">&#x27;XXX&#x27;</span> <span class="comment"># jar包所在目录</span></span><br><span class="line"><span class="comment"># 执行java -jar</span></span><br><span class="line">t = subprocess.Popen([<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, os.path.join(<span class="string">f&quot;<span class="subst">&#123;JAR_DIR&#125;</span>&quot;</span>, <span class="string">&quot;springboot-demo.jar&quot;</span>])</span><br><span class="line"><span class="comment"># Popen是异步的，所以需要等待几秒，再关闭</span></span><br><span class="line">time.sleep(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 关闭子进程</span></span><br><span class="line">t.terminate()</span><br><span class="line"><span class="comment"># 等待关闭结束</span></span><br><span class="line">t.wait()</span><br><span class="line"><span class="comment"># 关闭java进程</span></span><br><span class="line">app_pid_file_path = os.path.join(JAR_DIR, <span class="string">&quot;app.pid&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> os.path.exists(app_pid_file_path):</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(app_pid_file_path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">pid = f.read()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;正在关闭java 进程, pid： <span class="subst">&#123;<span class="built_in">int</span>(pid)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># 在windows系统下执行杀死进程的命令，其他系统可能命令不同</span></span><br><span class="line">subprocess.run([<span class="string">&quot;cmd&quot;</span>, <span class="string">&quot;/c&quot;</span>, <span class="string">&quot;taskkill&quot;</span>, <span class="string">&quot;/pid&quot;</span>, <span class="string">f&#x27;<span class="subst">&#123;<span class="built_in">int</span>(pid)&#125;</span>&#x27;</span>, <span class="string">&quot;-f&quot;</span>])</span><br><span class="line">os.remove(app_pid_file_path) <span class="comment"># 删除app.pid文件</span></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>无</p><h1 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h1><ol><li><a href="https://blog.csdn.net/skyli114/article/details/127324383">subprocess.Popen执行程序以及关闭进程</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;问题简述&quot;&gt;&lt;a href=&quot;#问题简述&quot; class=&quot;headerlink&quot; title=&quot;问题简述&quot;&gt;&lt;/a&gt;问题简述&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;需求是通过Python执行命令java -java springboot-demo.jar&lt;/p&gt;</summary>
      
    
    
    
    <category term="Python" scheme="https://guoyujian.github.io/categories/Python/"/>
    
    
    <category term="Python" scheme="https://guoyujian.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>CC+Open3d解决大型点云数据加载和计算问题</title>
    <link href="https://guoyujian.github.io/2023/11/29/CC-Open3d%E8%A7%A3%E5%86%B3%E5%A4%A7%E5%9E%8B%E7%82%B9%E4%BA%91%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD%E5%92%8C%E8%AE%A1%E7%AE%97%E9%97%AE%E9%A2%98/"/>
    <id>https://guoyujian.github.io/2023/11/29/CC-Open3d%E8%A7%A3%E5%86%B3%E5%A4%A7%E5%9E%8B%E7%82%B9%E4%BA%91%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD%E5%92%8C%E8%AE%A1%E7%AE%97%E9%97%AE%E9%A2%98/</id>
    <published>2023-11-29T10:28:41.000Z</published>
    <updated>2023-11-29T10:32:24.268Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>雷达扫描的点云数据量往往很大，而其中存在大量不需要的点。</p><p>例如我只需要某个小模型的点云，但雷达将周围的环境也一并扫描进来了，这些环境点云我并不需要。</p><p>现在我需要测量这个小模型的某些属性。（比如长宽）</p><p>此时如果直接在全部点云数据下进行测量，将这些点云加载出来都是一个很大的问题。在我的机器上，使用Cloud Compare载入1.3亿数量级的点云数据直接卡死。</p><p>通常情况下，可以通过体素降采样的方式（例如体素值为2dm）极大缩小点云的数量，但我的需求是希望计算小模型的长宽，其误差不超过5cm。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>因此我的做法如图所示：</p><p><img src="未命名绘图.drawio-20231129175149-u5ss8y9.png" alt="未命名绘图.drawio">​​</p><ol><li>首先为了能够将点云展示出来，我要极大的下采样点云，这里我取参数为0.2（2dm），得到下采样后的点云1</li><li>使用CC加载点云1，并可视化裁剪点云，得到裁剪立方体的参数，包括立方体的中心，长宽高，旋转等</li><li>使用上一步的得到的参数去裁剪原始点云，极大的减少了点云数量</li><li>将裁减后的点云下采样，为了保证精度，这次下采样率为0.01（1cm），得到点云2</li><li>可视化点云2，并进行测量，得到结果。</li></ol><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><h2 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h2><p>编写python脚本并导入到CC，执行该脚本，将点云1加载到CC中</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pycc</span><br><span class="line"><span class="keyword">import</span> cccorelib</span><br><span class="line"></span><br><span class="line">cc = pycc.GetInstance()</span><br><span class="line"><span class="keyword">import</span> open3d <span class="keyword">as</span> o3d</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># open PointCloud with 139032791 points.</span></span><br><span class="line">pcd: o3d.geometry.PointCloud = o3d.io.read_point_cloud(<span class="string">r&quot;origin.pcd&quot;</span>)</span><br><span class="line"><span class="comment"># 调整合适的降采样率</span></span><br><span class="line">pcd = pcd.voxel_down_sample(<span class="number">0.2</span>) <span class="comment">#</span></span><br><span class="line">points = np.asarray(pcd.points)</span><br><span class="line"></span><br><span class="line">xs = points[:, <span class="number">0</span>]</span><br><span class="line">ys = points[:, <span class="number">1</span>]</span><br><span class="line">zs = points[:, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">pc = pycc.ccPointCloud(xs, ys, zs)</span><br><span class="line"><span class="comment"># load</span></span><br><span class="line">cc.addToDB(pc)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h2><p>在CC中对点云进行切片，得到想要的部分点云的裁剪立方体参数。</p><p><img src="image-20231129175946-c305vb2.png" alt="裁剪前"></p><p><img src="image-20231129180213-3vc0ov2.png" alt="裁剪后">​</p><p>如图分别是裁剪前后的效果图，裁剪后的红框里是裁剪立方体的参数。复制下来后面要用到。</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">transformation matrix:</span><br><span class="line">0.987671196461 -0.156546846032 0.000000000000 3.480050563812</span><br><span class="line">0.156546846032 0.987671196461 0.000000000000 -3.573182106018</span><br><span class="line">0.000000000000 0.000000000000 1.000001311302 2.071678161621</span><br><span class="line">0.000000000000 0.000000000000 0.000000000000 1.000000000000</span><br><span class="line"></span><br><span class="line">长宽高：</span><br><span class="line">X: 6.21198273</span><br><span class="line">Y: 13.27857590</span><br><span class="line">Z: 9.57320881</span><br></pre></td></tr></table></figure><h2 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h2><p>由上述的参数可以知道该立方体的中心点是<code>(3.480050563812, -3.573182106018, 2.071678161621)</code>​，旋转矩阵为</p><script type="math/tex; mode=display">\begin{bmatrix}0.987671196461&-0.156546846032&0.000000000000\\0.156546846032&0.987671196461&0.000000000000\\0.000000000000&0.000000000000&1.000001311302\\\end{bmatrix}</script><p>长宽高为<code>(6.21198273, 13.27857590, 9.57320881)</code>​</p><p>因此可以写代码使用open3d来裁剪原始点云：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pcd: o3d.geometry.PointCloud = o3d.io.read_point_cloud(<span class="string">r&quot;origin.pcd&quot;</span>)</span><br><span class="line">   <span class="comment"># 画一个&quot;盒子&quot;，将盒子外的点云去掉，</span></span><br><span class="line">   obx = o3d.geometry.OrientedBoundingBox(</span><br><span class="line">       np.array([<span class="number">3.480050563812</span>, -<span class="number">3.573182106018</span>, <span class="number">2.071678161621</span>]), <span class="comment"># center</span></span><br><span class="line">       np.array([</span><br><span class="line">           [<span class="number">0.987671196461</span>, -<span class="number">0.156546846032</span>, <span class="number">0.000000000000</span>],</span><br><span class="line">           [<span class="number">0.156546846032</span>, <span class="number">0.987671196461</span>, <span class="number">0.000000000000</span>],</span><br><span class="line">           [<span class="number">0.000000000000</span>, <span class="number">0.000000000000</span>, <span class="number">1.000001311302</span>]</span><br><span class="line">       ]), <span class="comment"># rotation</span></span><br><span class="line">       np.array([<span class="number">6.21198273</span>, <span class="number">13.27857590</span>, <span class="number">9.57320881</span>]) <span class="comment"># width, depth, height</span></span><br><span class="line">   )</span><br><span class="line">   pcd_cropped = pcd.crop(obx) <span class="comment"># 裁剪后的点云</span></span><br><span class="line">pcd_cropped = pcd_cropped.voxel_down_sample(<span class="number">0.01</span>) <span class="comment"># 第二次降采样</span></span><br><span class="line">   o3d.io.write_point_cloud(<span class="string">&#x27;cropped.pcd&#x27;</span>, pcd_cropped) <span class="comment"># save </span></span><br></pre></td></tr></table></figure><h2 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h2><p>经过这些步骤后，点云数据量从1.3亿降到了840万。将这个<code>cropped.pcd</code>​拿到CC中打开，并测量。（图略）</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文方法既解决了大规模点云数据加载卡死、操作困难的问题，又能精确得到计算结果。</p><p>不过流程可以再优化，更自动化一些。</p><h1 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h1><p>无</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;雷达扫描的点云数据量往往很大，而其中存在大量不需要的点。&lt;/p&gt;
&lt;p&gt;例如我只需要某个小模型的点云，但雷达将周围的环境也一并扫描进来了，这</summary>
      
    
    
    
    <category term="点云数据处理" scheme="https://guoyujian.github.io/categories/%E7%82%B9%E4%BA%91%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    
    
    <category term="CloudCompare" scheme="https://guoyujian.github.io/tags/CloudCompare/"/>
    
    <category term="Point Cloud" scheme="https://guoyujian.github.io/tags/Point-Cloud/"/>
    
  </entry>
  
  <entry>
    <title>CloudCompare常用操作及Python插件</title>
    <link href="https://guoyujian.github.io/2023/11/28/CloudCompare%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%8F%8APython%E6%8F%92%E4%BB%B6/"/>
    <id>https://guoyujian.github.io/2023/11/28/CloudCompare%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%8F%8APython%E6%8F%92%E4%BB%B6/</id>
    <published>2023-11-28T06:14:52.000Z</published>
    <updated>2023-11-28T06:30:06.169Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>最近在做点云处理相关的工作，这里找到了一个非常好用的开源软件CloudCompare（下称CC）。这里对我的常用操作进行总结，并介绍CC的Python插件，该插件可以实现自定义的点云操作实现，极大地扩展了CC的功能。</p></blockquote><h1 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h1><h2 id="点云按高程赋色"><a href="#点云按高程赋色" class="headerlink" title="点云按高程赋色"></a>点云按高程赋色</h2><p>打开的点云没有颜色，很难看且很难操作，为了让点云更有立体感，可以按高程对点云进行赋色。</p><p><code>Edit -&gt; Colors -&gt; Height Ramp</code></p><p><img src="wps1-20231128113644-3f440qp.jpg" alt="img"></p><p>CC也可以按照其他轴进行赋色</p><p><code>Edit -&gt; Scalar fields -&gt; export coordinate to SF</code>， 选择x/y/z轴</p><p><img src="wps2-20231128113644-ecarnyw.jpg" alt="img"></p><p><img src="wps3-20231128113644-ibdm0ik.jpg" alt="img"></p><h2 id="使用多边形对点云裁剪"><a href="#使用多边形对点云裁剪" class="headerlink" title="使用多边形对点云裁剪"></a>使用多边形对点云裁剪</h2><p><a href="https://blog.csdn.net/qq_32867925/article/details/124187166">https://blog.csdn.net/qq_32867925/article/details/124187166</a></p><h2 id="计算点云中两个点之间的距离"><a href="#计算点云中两个点之间的距离" class="headerlink" title="计算点云中两个点之间的距离"></a>计算点云中两个点之间的距离</h2><p><a href="https://blog.csdn.net/qq_36686437/article/details/122224036">https://blog.csdn.net/qq_36686437/article/details/122224036</a></p><h2 id="下采样"><a href="#下采样" class="headerlink" title="下采样"></a>下采样</h2><p><a href="https://blog.csdn.net/qq_27353621/article/details/124008810">https://blog.csdn.net/qq_27353621/article/details/124008810</a></p><h2 id="统计滤波"><a href="#统计滤波" class="headerlink" title="统计滤波"></a>统计滤波</h2><p><a href="https://blog.csdn.net/qq_36686437/article/details/120011047">https://blog.csdn.net/qq_36686437/article/details/120011047</a></p><p>CC好像没有实现半径滤波，需要自行实现</p><h2 id="计算体积"><a href="#计算体积" class="headerlink" title="计算体积"></a>计算体积</h2><p><a href="https://www.cnblogs.com/codeAndlearn/p/12317673.html">https://www.cnblogs.com/codeAndlearn/p/12317673.html</a></p><p>CC计算的并非是点云的凸包体积，CC好像没有实现凸包体积计算，需要自行实现</p><h2 id="创建球并移动，计算球和球之间的距离"><a href="#创建球并移动，计算球和球之间的距离" class="headerlink" title="创建球并移动，计算球和球之间的距离"></a>创建球并移动，计算球和球之间的距离</h2><p>有时需要计算两点之间的距离，但是这两点虽然代表点云但并不在点云集合中，需要自定义位置。我们可以创建两个球，然后将它们拖动到指定位置，然后再计算距离。</p><p>首先，创建球</p><p><code>File -&gt; Primitive Factory</code>，选择sphere，确定位置和半径</p><p><img src="wps4-20231128113644-n938rmx.jpg?lastModify=1701152207" alt="img"></p><p>然后拖动球：选中球，并点选下图图标。鼠标右键拖动。</p><p><img src="wps5-20231128113644-mbw49ys.jpg" alt="img"></p><p>将两个球拖动到合适的位置，计算距离</p><p><img src="wps6-20231128113644-oc6tpfo.jpg?lastModify=1701152207" alt="img"></p><h2 id="更多操作"><a href="#更多操作" class="headerlink" title="更多操作"></a>更多操作</h2><p>这里有人总结了CC的操作，非常全面。</p><p><a href="https://blog.csdn.net/qq_36686437/article/details/120100839">https://blog.csdn.net/qq_36686437/article/details/120100839</a></p><h1 id="CC-Python插件"><a href="#CC-Python插件" class="headerlink" title="CC-Python插件"></a>CC-Python插件</h1><h2 id="前置条件-Win10"><a href="#前置条件-Win10" class="headerlink" title="前置条件(Win10)"></a>前置条件(Win10)</h2><p>使用该插件需要安装最新版的CC，我安装的版本是2.13</p><p><img src="image-20231128114621-bo1kz5e.png" alt="image"></p><p>在安装时，记得勾选</p><p><img src="image-20231128114706-bwwrkfk.png" alt="image"></p><blockquote><p>Windows是直接带有这个插件的，而MacOS下安装该插件需要自己去编译插件代码并安装。</p><p>这是插件代码的文档：<a href="https://tmontaigu.github.io/CloudCompare-PythonPlugin/">https://tmontaigu.github.io/CloudCompare-PythonPlugin/</a></p><p>包括如何编译源码&amp;Useage</p></blockquote><p>安装完成后，记得更新一下pip：</p><p>进入安装目录下<code>CloudCompare/plugins/Python</code>，执行<code>.\python.exe -m pip install --upgrade pip</code></p><h2 id="使用插件示例"><a href="#使用插件示例" class="headerlink" title="使用插件示例"></a>使用插件示例</h2><p>有些点云文件巨大，加载进来会很慢，我这里先将点云降采样之后才把他加载到CC中。</p><p>为了方便，我需要安装open3d</p><p>打开Python Manager： <code>Plugins -&gt; Python Plugins -&gt; Package Manager</code></p><p><img src="image-20231128120020-x27frq0.png" alt="image">点击install，输入open3d 进行安装。</p><p><img src="image-20231128120130-6obtvph.png" alt="image"></p><p>打开Show REPL： <code>Plugins -&gt; Python Plugins -&gt; Show REPL</code></p><p>红框输入指令</p><p><img src="image-20231128120448-c9cul9e.png" alt="image"></p><p>以下是我输入的指令</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pycc</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> cccorelib</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cc = pycc.GetInstance()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> open3d <span class="keyword">as</span> o3d</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pcd = o3d.io.read_point_cloud(<span class="string">&#x27;C:/Users/Administrator/Desktop/merged_room.pcd&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pcd = pcd.voxel_down_sample(<span class="number">0.5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>points = np.asarray(pcd.points)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>xs = points[:, <span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ys = points[:, <span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>zs = points[:, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pc = pycc.ccPointCloud(xs, ys, zs)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cc.addToDB(pc)</span><br></pre></td></tr></table></figure><p>至此可以看到CC场景中已经加载了点云</p><p><img src="image-20231128120849-90hz4hw.png" alt="image"></p><p>我们可以用插件实现前面CC未实现的诸多功能。更多用法可以参考前文提到的插件的官方文档。</p><h1 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;最近在做点云处理相关的工作，这里找到了一个非常好用的开源软件CloudCompare（下称CC）。这里对我的常用操</summary>
      
    
    
    
    <category term="点云数据处理" scheme="https://guoyujian.github.io/categories/%E7%82%B9%E4%BA%91%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    
    
    <category term="CloudCompare" scheme="https://guoyujian.github.io/tags/CloudCompare/"/>
    
    <category term="Point Cloud" scheme="https://guoyujian.github.io/tags/Point-Cloud/"/>
    
  </entry>
  
  <entry>
    <title>CPU密集型任务的后端实现方法比较总结</title>
    <link href="https://guoyujian.github.io/2023/10/19/CPU%E5%AF%86%E9%9B%86%E5%9E%8B%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%90%8E%E7%AB%AF%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E6%AF%94%E8%BE%83%E6%80%BB%E7%BB%93/"/>
    <id>https://guoyujian.github.io/2023/10/19/CPU%E5%AF%86%E9%9B%86%E5%9E%8B%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%90%8E%E7%AB%AF%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E6%AF%94%E8%BE%83%E6%80%BB%E7%BB%93/</id>
    <published>2023-10-19T14:38:32.000Z</published>
    <updated>2023-10-19T14:49:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>先介绍下整体系统框架，系统分为前端和后端，二者通过websocket协议进行通信。通过请求数据中的code字段来响应不同的操作。</p><p><img src="前后端通信.png" alt="前后端通信"></p><p><img src="时序图.png" alt="时序图"></p><p><img src="后端处理一次请求的流程图.png" alt="后端处理一次请求的流程图"></p><p>以上介绍整体的软件逻辑。此外，后端使用Python的asyncio来实现异步编程。</p><p>例如，实现将数据插入到数据库并将数据发送到前端：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">insert_data2db(data)</span><br><span class="line">ws_send(websocket, data)</span><br></pre></td></tr></table></figure><p>此时程序是顺序执行的。异步版本如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> insert_data2db(data)</span><br><span class="line"><span class="keyword">await</span> ws_send(websocket, data)</span><br></pre></td></tr></table></figure><p>此时，程序不会等待insert_data2db完成，直接继续执行ws_send方法。两者区别如下草图：</p><p><img src="同步异步.png" alt="同步异步"></p><p>这种异步的方式在IO-Bound Task中好用。但是对于CPU-Bound Task优化效果不大（甚至会有反效果）</p><p>此外，如果后一个操作需要用到前一个操作的结果，这个代码实际是顺序执行的。</p><h1 id="主要代码结构（伪）"><a href="#主要代码结构（伪）" class="headerlink" title="主要代码结构（伪）"></a>主要代码结构（伪）</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">ws_send</span>(<span class="params">websocket, data</span>)</span><br><span class="line"><span class="keyword">await</span> websocket.send(data)</span><br></pre></td></tr></table></figure><p>首先是通过websocket连接将数据发送回前端的通用方法</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">dealPointCloudData</span>(<span class="params">websocket, request_data</span>):</span><br><span class="line">code = request_data[<span class="string">&#x27;code&#x27;</span>]</span><br><span class="line"><span class="keyword">if</span> code == <span class="number">0</span>:</span><br><span class="line"><span class="comment"># 心跳</span></span><br><span class="line"><span class="keyword">await</span> ws_send(websocket, response_heartbeat_data)</span><br><span class="line"><span class="keyword">elif</span> code == <span class="number">1</span>:</span><br><span class="line"><span class="keyword">await</span> func1()</span><br><span class="line"><span class="keyword">elif</span> code == <span class="number">2</span>:</span><br><span class="line"><span class="keyword">await</span> func2(websocket, request_data)</span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure><p>其次，是分发请求的方法dealPointCloudData，它有两个参数，websocket连接和request_data前端发来的数据。</p><p>最后，主程序中会起一个websocket服务器，服务器会将连接发送到dispatch方法，dispatch方法会轮询每一个websocket连接的消息，并交给dealPointCloudData处理。伪代码如下。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">server = websockets.serve(dispatch, ip, port)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">dispatch</span>(<span class="params">websocket_conn</span>):</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">for</span> message <span class="keyword">in</span> websocket:  <span class="comment"># recv message from a websocket client.</span></span><br><span class="line">msg_dict = parse_json(message)</span><br><span class="line"><span class="keyword">await</span> dealPointCloudData(websocket, msg_dict)</span><br></pre></td></tr></table></figure><h1 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h1><p>目前，当code==2时，需要处理一个计算任务。request_data参数中有一个文件夹路径，该计算任务是读取文件夹下的所有文件内容，将文件内容进行merge，最终生成一个完整的文件。流程如下：</p><p><img src="计算流程.png" alt="计算流程"></p><p>伪代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func2</span>(<span class="params">websocket, request_data</span>):</span><br><span class="line">total = init()</span><br><span class="line">file_list = get_file_list(request_data) <span class="comment"># 从request_data中取出文件夹，</span></span><br><span class="line"><span class="keyword">for</span> i, file_path <span class="keyword">in</span> <span class="built_in">enumerate</span>(file_list):</span><br><span class="line">obj = read_file_as_obj(file_path)</span><br><span class="line">total = merge(total, obj)</span><br><span class="line"><span class="keyword">await</span> ws_send(websocket, <span class="string">&#x27;进度：...&#x27;</span>) <span class="comment"># 本次merge结束后向前端发送进度</span></span><br><span class="line">save2file(total)</span><br><span class="line"><span class="keyword">await</span> ws_send(websocket, finish_flag)</span><br></pre></td></tr></table></figure><p>由于func2主要时间花费在一个for循环中， 每次for循环中都有一个耗时的计算任务merge。merge是一个同步方法</p><p>所以func2中虽然使用了await异步编程，但整体来看，还是个同步处理程序。</p><p>这就导致一个严重的问题，就是当单线程执行func2进行长时间计算的时候，新的心跳包请求-响应会被阻塞掉。如图</p><p><img src="心跳响应阻塞.png" alt="心跳响应阻塞"></p><p>如果阻塞的时间过长，前后端就会失去本次连接。</p><p>针对该问题，我尝试了几种解决方法。</p><h1 id="尝试"><a href="#尝试" class="headerlink" title="尝试"></a>尝试</h1><h2 id="1-开启线程执行计算（merge）"><a href="#1-开启线程执行计算（merge）" class="headerlink" title="1 开启线程执行计算（merge）"></a>1 开启线程执行计算（merge）</h2><p>func2函数中开启一个新的线程执行计算，并返回数据。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func2</span>(<span class="params">websocket, request_data</span>):</span><br><span class="line">    t = DealPcdsThread(websocket, other_params)</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure><p>DealPcdsThread线程类的实现如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DealPcdsThread</span>(threading.Thread):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    处理pcd文件夹的线程</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, websocket, request_data</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        file_list = get_file_list(request_data)</span><br><span class="line">        self.websocket = websocket</span><br><span class="line">        self.file_list = file_list </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        asyncio.run(self.merge()) <span class="comment"># 在线程中开启新的事件循环来执行协程函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">self</span>):</span><br><span class="line">        total = init()</span><br><span class="line">file_list = get_file_list(request_data) <span class="comment"># 从request_data中取出文件夹，</span></span><br><span class="line"><span class="keyword">for</span> i, file_path <span class="keyword">in</span> <span class="built_in">enumerate</span>(file_list):</span><br><span class="line">obj = read_file_as_obj(file_path)</span><br><span class="line">total = merge(total, obj)</span><br><span class="line">log.info(<span class="string">f&#x27;...&#x27;</span>)</span><br><span class="line"><span class="keyword">await</span> ws_send(websocket, <span class="string">&#x27;进度：...&#x27;</span>) <span class="comment"># 本次merge结束后向前端发送进度</span></span><br><span class="line">save2file(total)</span><br><span class="line"><span class="keyword">await</span> ws_send(websocket, finish_flag)</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>浏览器控制台日志如图：</p><p><img src="控制台日志.png" alt="控制台日志"></p><p>这说明在处理计算任务时，主线程没有阻塞，心跳包能够正常返回，和预期一致。</p><p>本来问题到这里就解决了，但是在实际测试中又发现了其他问题。</p><h3 id="问题1-前端显示不流畅"><a href="#问题1-前端显示不流畅" class="headerlink" title="问题1: 前端显示不流畅"></a>问题1: 前端显示不流畅</h3><p><img src="合成进度条.gif" alt="合成进度条"></p><p>如图可以看到进度条卡在2.21%后，过了几秒非常迅速的蹦到了40.79%。但是后台的日志打印是“流畅的”，即没有类似的停顿。</p><p>猜测可能是和异步有关，毕竟在<code>await ws_send()</code>​后直接返回了，事件循环选择了某个时间点统一发送这些请求。</p><p>一开始还以为是计算线程失去了CPU的控制权导致的，后来一想可能性不大，一方面占用时间应该在很短的时间，我应该感觉不到，另一方面，后台日志打印流畅。</p><h3 id="问题2-后台报错"><a href="#问题2-后台报错" class="headerlink" title="问题2: 后台报错"></a>问题2: 后台报错</h3><p>在执行计算的过程，出现报错如下图</p><p><img src="报错.png" alt="报错"></p><p>该报错我搜索了很久也没有找到解决方案，在加上该报错不会导致任务失败，也不会有其他影响。所以搁置了。</p><p>该方案是目前最好的解决方案，我也尝试了很多其他解决方案。这里也一并列出。</p><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p>方案2与方案1相同，同样是开启新线程执行合并，只是新的事件循环有主线程创建，而非在新线程中创建。测试这两种方法表现一致。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func2</span>(<span class="params">websocket, request_data</span>):</span><br><span class="line">new_loop: AbstractEventLoop = asyncio.new_event_loop()</span><br><span class="line">    <span class="comment"># 定义</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start_loop</span>(<span class="params">loop: AbstractEventLoop</span>):</span><br><span class="line">        asyncio.set_event_loop(loop)</span><br><span class="line">        loop.run_forever()</span><br><span class="line">    <span class="comment">#通过当前线程开启新的线程启动事件循环</span></span><br><span class="line">    t = threading.Thread(target=start_loop, args= (new_loop,))</span><br><span class="line">    t.start()</span><br><span class="line">    asyncio.run_coroutine_threadsafe(</span><br><span class="line">        DealPcdsThread(websocket, request_data).merge(),</span><br><span class="line">        new_loop</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><p>使用asyncio.run_in_executor将任务放到线程池中运行</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func2</span>(<span class="params">websocket, request_data</span>):</span><br><span class="line"><span class="comment"># 4.4 使用asyncio.run_in_executor将任务放到线程池中运行。效果和4.2一样</span></span><br><span class="line">loop: AbstractEventLoop = asyncio.get_event_loop()</span><br><span class="line"><span class="keyword">await</span> loop.run_in_executor(<span class="literal">None</span>, DealPcdsThread(websocket, request_data).run)</span><br><span class="line"><span class="comment"># await asyncio.to_thread(DealPcdsNoThread.run, loop) # new py3.9</span></span><br></pre></td></tr></table></figure><p>测试说明，这种方法会阻塞主线程，导致心跳包无法及时响应。。</p><h2 id="4"><a href="#4" class="headerlink" title="4"></a>4</h2><p>为了加快计算的速度，想到尝试开启新的进程执行计算。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Process(target=merge, args=(websocket, request_data)).start()</span><br></pre></td></tr></table></figure><p>但是没想到，进程之间传递的Python对象必须可以被序列化（pickle）才可以，而websocket对象不能被序列化，所以这种方法无效。</p><h2 id="5"><a href="#5" class="headerlink" title="5"></a>5</h2><p>最后一种，同样也是开启一个新的线程，不过target传入的是异步计算方法（虽然是异步的，但是内部确是同步的。。。）</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">threading.Thread(target=<span class="keyword">await</span> DealPcdsThread(websocket, request_data).merge()).start()</span><br></pre></td></tr></table></figure><p>这种方法也会阻塞主线程。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>在实验过程中，我发现凡是开启新线程并且新线程中使用新的事件循环来处理发送请求都可以让主线程不阻塞。例如方案1、2</p><p>但是如果只开新线程，而事件循环依然使用主线程loop的话，不能解决主线程阻塞的问题。例如方案3、5</p><h1 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h1><ol><li>用<code>concurrent.futures.ThreadPoolExecutor</code>​替换threading。<code>concurrent.futures.ThreadPoolExecutor</code>​提供了一个高层级接口用来向后台线程推送任务而不会阻塞调用方线程的执行，同时仍然能够在需要时获取任务的结果。</li><li>先读出所有的文件到内存中，放到一个数组里，再开启多进程对这个数组的点云数据进行reduce。利用多核加快合并速度？</li><li>其实我觉得最好的方式是，开启一个线程执行计算任务，线程类中有一个指示进度的变量。在主线程中使用一个协程每隔X秒获取一次进度并将其发送给前端。但是这种方式无法做到实时。</li><li>什么时候Python可以去掉GIL的限制，让这种计算密集型任务能够充分利用多核CPU。。。😢</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;先介绍下整体系统框架，系统分为前端和后端，二者通过websocket协议进行通信。通过请求数据中的code字段来响应不同的操作。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="Python" scheme="https://guoyujian.github.io/categories/Python/"/>
    
    
    <category term="Python" scheme="https://guoyujian.github.io/tags/Python/"/>
    
    <category term="websocket" scheme="https://guoyujian.github.io/tags/websocket/"/>
    
    <category term="asyncio" scheme="https://guoyujian.github.io/tags/asyncio/"/>
    
  </entry>
  
  <entry>
    <title>Python 面试题</title>
    <link href="https://guoyujian.github.io/2023/10/07/Python-%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://guoyujian.github.io/2023/10/07/Python-%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2023-10-07T14:48:30.000Z</published>
    <updated>2023-10-07T14:50:40.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记一次Python面试被问到的题</p></blockquote><h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=&#123;<span class="number">1</span>:<span class="number">2</span>,<span class="number">2</span>:<span class="number">3</span>&#125;</span><br><span class="line">b=a</span><br><span class="line">b.pop(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><p>问：a的输出是什么？</p><p>答：<code>&#123;2:3&#125;</code>​</p><h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b=[[]]*<span class="number">2</span>; b[<span class="number">0</span>].append(<span class="number">1</span>); <span class="built_in">print</span>(b)</span><br><span class="line">a=[]; b=[a]*<span class="number">2</span>; b[<span class="number">0</span>].append(<span class="number">1</span>); <span class="built_in">print</span>(b)</span><br><span class="line">a=[]; b=[a, a]; b[<span class="number">0</span>].append(<span class="number">1</span>); <span class="built_in">print</span>(b)</span><br><span class="line">b=[[], []]; b[<span class="number">0</span>].append(<span class="number">1</span>); <span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure><p>问：这四个<code>b</code>​的输出是什么？</p><p>答：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[[1], [1]]</span><br><span class="line">[[1], [1]]</span><br><span class="line">[[1], [1]]</span><br><span class="line">[[1], []]</span><br></pre></td></tr></table></figure><h1 id="3"><a href="#3" class="headerlink" title="3"></a>3</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a=&quot;123&quot;; b=a; b=b[:-1]; </span><br><span class="line">print(a, b)</span><br></pre></td></tr></table></figure><p>问：输出？</p><p>答：<code>123 12</code>​</p><h1 id="4"><a href="#4" class="headerlink" title="4"></a>4</h1><p>比较以下两段代码的执行效率和内存开销</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">res = 1</span><br><span class="line">for num in [1,2,3,4]+[6,7,8,9]:</span><br><span class="line">    res *= num</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import itertools</span><br><span class="line">res = 1</span><br><span class="line">for num in itertools.chain([1,2,3,4], [6,7,8,9]):</span><br><span class="line">    res *= num</span><br></pre></td></tr></table></figure><p><a href="https://docs.python.org/3/library/itertools.html">https://docs.python.org/3/library/itertools.html</a></p><p>答：首先第一个代码需要将两个列表和并为一个列表，而第二段代码是直接遍历两个列表，其次itertools.chain返回的是一个生成器，所以第二个代码的执行效率高，内存开销小。</p><h1 id="5"><a href="#5" class="headerlink" title="5"></a>5</h1><p>What is the difference between tuple() and list[]？loop over tuple and list，which one is more effective？</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if var in [&quot;xxx&quot;, &quot;yyy&quot;]:</span><br><span class="line">if var in (&quot;xxx&quot;, &quot;yyy&quot;):</span><br><span class="line">if var in &#123;&quot;xxx&quot;, &quot;yyy&quot;&#125;:</span><br></pre></td></tr></table></figure><p>Which one above is more efficitive? Note: The value after ‘in’ is a constant.</p><p>时间复杂度：tuple O(?) list O(?) set O(?)</p><p>答：tuple是不可变对象，list是可变对象。由于tuple不可变，所以申请内存为连续定长内存，而list类似于一个链表。</p><p>所以在loop中，tuple is more effective.</p><p><code>if var in &#123;&quot;xxx&quot;, &quot;yyy&quot;&#125;</code>​ is more effective. 因为集合查询时间复杂度为O(1)，tuple和list为O(N)</p><h1 id="6"><a href="#6" class="headerlink" title="6"></a>6</h1><p>Python class中变量名和函数名前缀单下划线和双下划线(后缀没有下划线)分别是什么？For example,</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class A:</span><br><span class="line">   def _method1(): pass   // What&#x27;s the meaning of _</span><br><span class="line">   def __method2(): pass  // What&#x27;s the meaning of __</span><br></pre></td></tr></table></figure><p> What’s the difference among the concepts protected, public, and private?</p><p>答：变量前没有下划线的为public<br>变量前有单下划线为protected，这种变量只能在本类或者其子类中调用（如果你想在其他地方调用也可以，但是会有警告）<br>变量前有双下划线为private，这种变量只能在本类中调用（在其他地方调用会报错）</p><h1 id="7"><a href="#7" class="headerlink" title="7"></a>7</h1><p>在用mongo等非关系型数据库的时候，我们不希望把脏数据、空数据存进数据库，造成后面的混乱。写一个函数(Python3)，删除json dict里面的空数据，包括空dict，空list，空string，None。假设输入的Python dict从合法json读取, 即key必为string, value可以是number/string/list/dict。例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;a&quot;: [1,0,&quot;c&quot;, &#123;&quot;x&quot;:1&#125;]&#125; -&gt; &#123;&quot;a&quot;: [1,0,&quot;c&quot;, &#123;&quot;x&quot;:1&#125;]&#125;</span><br><span class="line">&#123;&quot;a&quot;:[1,None]&#125; -&gt; &#123;&quot;a&quot;: [1]&#125;</span><br><span class="line">&#123;&quot;a&quot;: &#123;&quot;a&quot;:[None, &quot;&quot;, &#123;&#125;,&#123;&quot;x&quot;:None&#125;]&#125;&#125; -&gt; None</span><br></pre></td></tr></table></figure><p>答：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">clean_json</span>(<span class="params">data: (<span class="params"><span class="built_in">dict</span>,<span class="built_in">list</span>,<span class="built_in">int</span>,<span class="built_in">float</span>,<span class="built_in">str</span>,<span class="literal">None</span></span>)</span>):</span><br><span class="line">    <span class="comment"># put your code here</span></span><br><span class="line">    <span class="keyword">if</span> data <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> data == <span class="string">&#x27;&#x27;</span> <span class="keyword">or</span> data == <span class="built_in">dict</span>() <span class="keyword">or</span> data == []:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(data) == <span class="built_in">list</span>:</span><br><span class="line">        data1 = [item <span class="keyword">for</span> item <span class="keyword">in</span> data <span class="keyword">if</span> clean_json(item) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>] <span class="comment"># 复制一份出来</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data1:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> data1</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(data) == <span class="built_in">dict</span>:</span><br><span class="line">        data1 = &#123;k: clean_json(v) <span class="keyword">for</span> k, v <span class="keyword">in</span> data.items() <span class="keyword">if</span> clean_json(v) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>&#125; <span class="comment"># 复制一份出来</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data1:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> data1</span><br><span class="line">    <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure><p>注意：不能直接对原数组or字典作删除操作，会报错！</p><p>例如</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> l:</span><br><span class="line">    <span class="keyword">if</span> l[i] == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">del</span> l[i] <span class="comment"># do not do this</span></span><br></pre></td></tr></table></figure><p>‍</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;记一次Python面试被问到的题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;1&quot;&gt;&lt;a href=&quot;#1&quot; class=&quot;headerlink&quot; title=&quot;1&quot;&gt;&lt;/a&gt;1&lt;/h1&gt;&lt;figure class=&quot;highlight p</summary>
      
    
    
    
    <category term="Python" scheme="https://guoyujian.github.io/categories/Python/"/>
    
    <category term="基础" scheme="https://guoyujian.github.io/categories/Python/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Python" scheme="https://guoyujian.github.io/tags/Python/"/>
    
    <category term="面试" scheme="https://guoyujian.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Python open3d点云相关操作（持续更新）</title>
    <link href="https://guoyujian.github.io/2023/09/16/Python-open3d%E7%82%B9%E4%BA%91%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/"/>
    <id>https://guoyujian.github.io/2023/09/16/Python-open3d%E7%82%B9%E4%BA%91%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/</id>
    <published>2023-09-16T14:26:37.000Z</published>
    <updated>2023-09-16T14:28:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Prerequisite"><a href="#Prerequisite" class="headerlink" title="Prerequisite"></a>Prerequisite</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">!pip install open3d</span><br><span class="line">!pip install scipy</span><br><span class="line"><span class="keyword">import</span> open3d <span class="keyword">as</span> o3d</span><br><span class="line"><span class="keyword">from</span> scipy.spatial.transform <span class="keyword">import</span> Rotation <span class="keyword">as</span> R</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><h2 id="读和写点云文件"><a href="#读和写点云文件" class="headerlink" title="读和写点云文件"></a>读和写点云文件</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">point_cloud = o3d.io.read_point_cloud(file_path) <span class="comment"># 支持的格式pcd、pts等</span></span><br><span class="line"><span class="comment"># type(point_cloud) == open3d.cpu.pybind.geometry.PointCloud</span></span><br><span class="line"></span><br><span class="line">o3d.io.write_point_cloud(point_cloud, file_path) </span><br></pre></td></tr></table></figure><h2 id="读取点云对象中点的坐标"><a href="#读取点云对象中点的坐标" class="headerlink" title="读取点云对象中点的坐标"></a>读取点云对象中点的坐标</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.asarray(point_cloud.points)</span><br></pre></td></tr></table></figure><h2 id="将点坐标赋值到点云对象"><a href="#将点坐标赋值到点云对象" class="headerlink" title="将点坐标赋值到点云对象"></a>将点坐标赋值到点云对象</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># points = np.array([[...]])</span></span><br><span class="line"></span><br><span class="line">point_cloud.points = o3d.utility.Vector3dVector(points)</span><br></pre></td></tr></table></figure><h2 id="创建点云对象"><a href="#创建点云对象" class="headerlink" title="创建点云对象"></a>创建点云对象</h2><p>创建一个空的点云对象</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pc = o3d.geometry.PointCloud()</span><br></pre></td></tr></table></figure><h2 id="合并点云对象"><a href="#合并点云对象" class="headerlink" title="合并点云对象"></a>合并点云对象</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 直接+</span></span><br><span class="line">pc += point_cloud</span><br></pre></td></tr></table></figure><h2 id="点云平移"><a href="#点云平移" class="headerlink" title="点云平移"></a>点云平移</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">point_cloud.translate(translation)  <span class="comment"># 应用平移,translation 是平移向量</span></span><br></pre></td></tr></table></figure><h2 id="点云旋转"><a href="#点云旋转" class="headerlink" title="点云旋转"></a>点云旋转</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">point_cloud.rotate(rotation_matrix, center = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>))  <span class="comment"># 应用旋转, rotation_matrix是旋转矩阵</span></span><br></pre></td></tr></table></figure><p>这里需要注意第二个参数center是指定旋转中心，如果不传，默认旋转中心是点云的质心。</p><p>而一般来说，旋转中心为原点</p><h2 id="点云上色"><a href="#点云上色" class="headerlink" title="点云上色"></a>点云上色</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">point_cloud.paint_uniform_color([<span class="number">0</span>, <span class="number">0</span>, <span class="number">1.0</span>]) <span class="comment"># 传入的三个值分别是rgb</span></span><br></pre></td></tr></table></figure><h2 id="点云展示"><a href="#点云展示" class="headerlink" title="点云展示"></a>点云展示</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">o3d.visualization.draw_geometries([point_cloud])</span><br></pre></td></tr></table></figure><h2 id="四元数转旋转矩阵"><a href="#四元数转旋转矩阵" class="headerlink" title="四元数转旋转矩阵"></a>四元数转旋转矩阵</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">quaternion = np.array([ori_x, ori_y, ori_z, ori_w])  <span class="comment"># 定义四元数</span></span><br><span class="line">rotation_matrix = R.from_quat(quaternion).as_matrix()</span><br></pre></td></tr></table></figure><p>注意四元数顺序是xyzw，在有些地方顺序是wxyz</p><h2 id="点云下采样"><a href="#点云下采样" class="headerlink" title="点云下采样"></a>点云下采样</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">point_cloud = point_cloud.voxel_down_sample()</span><br></pre></td></tr></table></figure><p>这里需要注意</p><ol><li>需要接收返回值</li><li>下采样是指只保留某一大小立方体内的一个点。voxel_down_sample方法有个默认值参数，为0.05。这个参数就表示立方体的大小，因此这个数越大，下采样的强度越强，保留的点就越少。</li></ol><h2 id="统计滤波"><a href="#统计滤波" class="headerlink" title="统计滤波"></a>统计滤波</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">point_cloud.remove_statistical_outlier(nb_neighbors=<span class="number">20</span>, std_ratio=<span class="number">2.0</span>)</span><br></pre></td></tr></table></figure><p>该方法可以去掉距离点云密集处很远的点。该方法有两个参数</p><ol><li>nb_neighbors允许指定要考虑多少个邻居，以便计算给定点的平均距离。</li><li>std_ratio允许基于跨点云的平均距离的标准偏差来设置阈值级别。此数字越低，过滤器将越具有攻击性。</li></ol><h2 id="筛选点云中的点"><a href="#筛选点云中的点" class="headerlink" title="筛选点云中的点"></a>筛选点云中的点</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># indices_to_keep =[0,1,2...] 点的索引</span></span><br><span class="line">point_cloud = point_cloud.select_by_index(indices_to_keep)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Prerequisite&quot;&gt;&lt;a href=&quot;#Prerequisite&quot; class=&quot;headerlink&quot; title=&quot;Prerequisite&quot;&gt;&lt;/a&gt;Prerequisite&lt;/h2&gt;&lt;figure class=&quot;highlight python&quot;&gt;</summary>
      
    
    
    
    
  </entry>
  
</feed>
