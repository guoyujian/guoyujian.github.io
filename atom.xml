<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Gmet&#39;s Blog</title>
  
  <subtitle>Eureka!</subtitle>
  <link href="https://guoyujian.github.io/atom.xml" rel="self"/>
  
  <link href="https://guoyujian.github.io/"/>
  <updated>2022-09-23T16:32:47.718Z</updated>
  <id>https://guoyujian.github.io/</id>
  
  <author>
    <name>Met Guo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HTTP缓存</title>
    <link href="https://guoyujian.github.io/2022/09/24/HTTP%E7%BC%93%E5%AD%98/"/>
    <id>https://guoyujian.github.io/2022/09/24/HTTP%E7%BC%93%E5%AD%98/</id>
    <published>2022-09-23T16:26:34.000Z</published>
    <updated>2022-09-23T16:32:47.718Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前端缓存知识点"><a href="#前端缓存知识点" class="headerlink" title="前端缓存知识点"></a>前端缓存知识点</h1><p><img src="前端缓存一览.png" alt="前端缓存一览">​</p><h1 id="什么是HTTP缓存"><a href="#什么是HTTP缓存" class="headerlink" title="什么是HTTP缓存"></a>什么是HTTP缓存</h1><p>http缓存指的是: 当客户端向服务器请求资源时，会先抵达浏览器缓存，如果浏览器有“要请求资源”的副本，就可以直接从浏览器缓存中提取而不是从原始服务器中提取这个资源。</p><p>常见的http缓存只能缓存get请求响应的资源，对于其他类型的响应则无能为力，所以后续说的请求缓存都是指GET请求。</p><p>http缓存都是从第二次请求开始的。第一次请求资源时，服务器返回资源，并在respone header头中回传资源的缓存参数；第二次请求时，浏览器判断这些请求参数，命中强缓存就直接200，否则就把请求参数加到request header头中传给服务器，看是否命中协商缓存，命中则返回304，否则服务器会返回新的资源。</p><h1 id="为什么要使用HTTP缓存-？"><a href="#为什么要使用HTTP缓存-？" class="headerlink" title="为什么要使用HTTP缓存 ？"></a>为什么要使用HTTP缓存 ？</h1><ol><li>减少了冗余的数据传输，节省了网费。</li><li>缓解了服务器的压力， 大大提高了网站的性能</li><li>加快了客户端加载网页的速度</li></ol><h1 id="如何使用HTTP缓存-？"><a href="#如何使用HTTP缓存-？" class="headerlink" title="如何使用HTTP缓存 ？"></a>如何使用HTTP缓存 ？</h1><p>一般需要缓存的资源有html页面和其他静态资源：</p><blockquote><p>1、 <strong>html页面缓存的设置主要是在<code>&lt;head&gt;</code>标签中嵌入<code>&lt;meta&gt;</code>标签，这种方式只对页面有效，对页面上的资源无效</strong></p></blockquote><p>1.1 html页面禁用缓存的设置如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;cache-control&quot; content=&quot;no-cache&quot; \&gt;</span><br></pre></td></tr></table></figure><p>1.2 html设置缓存如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;max-age=7200&quot; /&gt;</span><br></pre></td></tr></table></figure><blockquote><p>2、 <strong>静态资源的缓存一般是在web服务器上配置的，常用的web服务器有：nginx、apache。具体的配置这里不做详细介绍，大家自行查阅。</strong></p><p><strong>3、不想使用缓存的几种方式</strong></p></blockquote><ul><li>Ctrl + F5强制刷新，都会直接向服务器提取数据。</li><li>按F5刷新或浏览器的刷新按钮，默认加上Cache-Control：max-age=0，即会走协商缓存。</li><li>还有就是上面1、2中禁用缓存的做法</li></ul><h1 id="HTTP缓存的几个注意点"><a href="#HTTP缓存的几个注意点" class="headerlink" title="HTTP缓存的几个注意点"></a>HTTP缓存的几个注意点</h1><p>1、强缓存情况下，只要缓存还没过期，就会直接从缓存中取数据，就算服务器端有数据变化，也不会从服务器端获取了，这样就无法获取到修改后的数据。解决的办法有：在修改后的资源加上随机数，确保不会从缓存中取。</p><p>例如：<code>http://www.kimshare.club/kim/common.css?v=22324432</code></p><p>2、尽量减少304的请求，因为我们知道，协商缓存每次都会与后台服务器进行交互，所以性能上不是很好。从性能上来看尽量多使用强缓存。</p><p>3、与缓存相关的几个header属性有：Vary、Date/Age。</p><h1 id="HTTP缓存的分类"><a href="#HTTP缓存的分类" class="headerlink" title="HTTP缓存的分类"></a><strong>HTTP缓存的分类</strong></h1><ul><li>根据是否需要重新向服务器发起请求来分类，可分为强制缓存，协商缓存</li><li>根据是否可以被单个或者多个用户使用来分类，可分为私有缓存，共享缓存（不care）</li></ul><p>强制缓存如果生效，不需要再和服务器发生交互，而协商缓存不管是否生效，都需要与服务端发生交互。下面是强制缓存和协商缓存的一些对比：</p><p><img src="HTTP缓存分类.png" alt="HTTP缓存分类"></p><h2 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h2><p>强制缓存在缓存数据未失效的情况下（即Cache-Control的max-age没有过期或者Expires的缓存时间没有过期），那么就会直接使用浏览器的缓存数据，不会再向服务器发送任何请求。</p><p>强制缓存生效时，http状态码为200。这种方式页面的加载速度是最快的，性能也是很好的，但是在这期间，如果服务器端的资源修改了，页面上是拿不到的，因为它不会再向服务器发请求了。</p><p>这种情况就是我们在开发种经常遇到的，比如你修改了页面上的某个样式，在页面上刷新了但没有生效，因为走的是强缓存，所以Ctrl + F5一顿操作之后就好了。 </p><p>跟强制缓存相关的header头属性有（Pragma/Cache-Control/Expires）</p><h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p>当第一次请求时服务器返回的响应头中没有Cache-Control和Expires或者Cache-Control和Expires过期还或者它的属性设置为no-cache时(即不走强缓存)，那么浏览器第二次请求时就会与服务器进行协商，与服务器端对比判断资源是否进行了修改更新。</p><p>如果服务器端的资源没有修改，那么就会返回304状态码，告诉浏览器可以使用缓存中的数据，这样就减少了服务器的数据传输压力。</p><p>如果数据有更新就会返回200状态码，服务器就会返回更新后的资源并且将缓存信息一起返回。</p><p>跟协商缓存相关的header头属性有（ETag/If-Not-Match 、Last-Modified/If-Modified-Since）请求头和响应头需要成对出现。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>下图是浏览器首次和再次发送http请求的执行流程图：</strong></p><p><img src="首次HTTP请求.png" alt="首次HTTP请求"></p><p><img src="再次HTTP请求.png" alt="再次HTTP请求"></p><h1 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h1><ol><li><a href="https://www.jianshu.com/p/227cee9c8d15">https://www.jianshu.com/p/227cee9c8d15</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前端缓存知识点&quot;&gt;&lt;a href=&quot;#前端缓存知识点&quot; class=&quot;headerlink&quot; title=&quot;前端缓存知识点&quot;&gt;&lt;/a&gt;前端缓存知识点&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;前端缓存一览.png&quot; alt=&quot;前端缓存一览&quot;&gt;​&lt;/p&gt;
&lt;h1 id=&quot;什</summary>
      
    
    
    
    <category term="计算机网络" scheme="https://guoyujian.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="HTTP协议" scheme="https://guoyujian.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="计算机网络" scheme="https://guoyujian.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="HTTP协议" scheme="https://guoyujian.github.io/tags/HTTP%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>HTTPS协议</title>
    <link href="https://guoyujian.github.io/2022/09/24/HTTPS%E5%8D%8F%E8%AE%AE/"/>
    <id>https://guoyujian.github.io/2022/09/24/HTTPS%E5%8D%8F%E8%AE%AE/</id>
    <published>2022-09-23T16:22:25.000Z</published>
    <updated>2022-09-23T16:25:50.622Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><p>加密分为对称加密和非对称加密，HTTPS兼顾两者。</p><p>关于非对称加密，可以查阅相关资料。这里只提一点：</p><blockquote><p><strong>公钥加密，私钥解密！</strong></p></blockquote><h1 id="为什么需要HTTPS"><a href="#为什么需要HTTPS" class="headerlink" title="为什么需要HTTPS"></a>为什么需要HTTPS</h1><p>HTTP 主要有这些不足：</p><ul><li>通信使用明文（不加密），内容可能会被窃听；</li><li>不验证通信方的身份，因此有可能遭遇伪装；</li><li>无法证明报文的完整性，所以有可能已遭篡改；</li></ul><p>为了解决这些问题，HTTPS顺应而生。</p><h1 id="HTTPS介绍"><a href="#HTTPS介绍" class="headerlink" title="HTTPS介绍"></a>HTTPS介绍</h1><p><strong>HTTP+ 加密 + 认证 + 完整性保护=HTTPS</strong>。</p><p>可以这么理解，HTTPS是安全版的HTTP，它不是一个新的协议，而是HTTP 加上加密处理（解决HTTP通信使用明文的问题）和认证（解决HTTP不验证通信方的身份问题）以及完整性保护（解决HTTP无法证明报文完整性的问题）后的东西。</p><p><strong>端口：443</strong></p><p><img src="HTTP和HTTPS对比.png" alt="HTTP和HTTPS对比"></p><p>注：上图并不代表顺序。也就是说<strong>HTTPS是先建立TCP连接，再进行TLS/SSL握手。</strong></p><h1 id="HTTPS通信"><a href="#HTTPS通信" class="headerlink" title="HTTPS通信"></a>HTTPS通信</h1><p>直接上图</p><p><img src="HTTPS通信.png" alt="HTTPS通信">​</p><p>上图基本把HTTPS的通信流程说的非常清晰了，补充两点：</p><ol><li>这里对比HASH是为了防止握手消息被篡改。浏览器与网站互相发送加密的握手消息并验证，目的是为了保证双方都获得了一致的密码，并且可以正常的加密解密数据，为后续真正数据的传输做一次测试。</li><li>因为对称加密要比非对称加密的计算快很多，所以HTTPS没有全程使用非对称加密，而是先使用非对称加密交换对称密钥，再使用对称加密手段通信。</li><li>证书确保了双方身份。</li></ol><p>另外，HTTPS一般使用的加密与HASH算法如下：</p><ul><li>非对称加密算法：RSA，DSA/DSS</li><li>对称加密算法：AES，RC4，3DES</li><li>HASH算法：MD5，SHA1，SHA256</li></ul><h1 id="HTTPS-的优缺点"><a href="#HTTPS-的优缺点" class="headerlink" title="HTTPS 的优缺点?"></a>HTTPS 的优缺点?</h1><p>优点</p><ul><li><p>安全性：</p><ul><li>使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；</li><li>HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。</li><li>HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</li></ul></li><li>SEO方面：谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。</li></ul><p>缺点</p><ul><li>在相同网络环境中，HTTPS 相比 HTTP 无论是响应时间还是耗电量都有大幅度上升。</li><li>HTTPS 的安全是有范围的，在黑客攻击、服务器劫持等情况下几乎起不到作用。</li><li>在现有的证书机制下，中间人攻击依然有可能发生。</li><li>HTTPS 需要更多的服务器资源，也会导致成本的升高。</li></ul><h1 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h1><ol><li><a href="https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html">SSL/TLS协议运行机制的概述</a></li><li><a href="https://www.cnblogs.com/zery/p/5164795.html">HTTPS 原理解析</a></li><li><a href="https://cloud.tencent.com/developer/article/1007810?from=article.detail.1017988">HTTPS 建立连接的详细过程</a></li><li><a href="https://juejin.cn/post/6906126429381984264">HTTPS连接过程</a></li><li><a href="https://zhuanlan.zhihu.com/p/45390160">HTTPS详细介绍</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前置知识&quot;&gt;&lt;a href=&quot;#前置知识&quot; class=&quot;headerlink&quot; title=&quot;前置知识&quot;&gt;&lt;/a&gt;前置知识&lt;/h1&gt;&lt;p&gt;加密分为对称加密和非对称加密，HTTPS兼顾两者。&lt;/p&gt;
&lt;p&gt;关于非对称加密，可以查阅相关资料。这里只提一点：&lt;/p&gt;
</summary>
      
    
    
    
    <category term="计算机网络" scheme="https://guoyujian.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="HTTP协议" scheme="https://guoyujian.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="计算机网络" scheme="https://guoyujian.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="HTTP协议" scheme="https://guoyujian.github.io/tags/HTTP%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>HTTP面试题</title>
    <link href="https://guoyujian.github.io/2022/09/24/HTTP%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://guoyujian.github.io/2022/09/24/HTTP%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2022-09-23T16:07:45.000Z</published>
    <updated>2022-09-23T16:21:17.281Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作为复习，也作为一个目录</p></blockquote><h1 id="说一下HTTP协议"><a href="#说一下HTTP协议" class="headerlink" title="说一下HTTP协议"></a>说一下HTTP协议</h1><p>HTTP全称是Hyper Text Transfer Protocol。即<strong>超文本传输协议</strong>，它是以<strong>TCP/IP</strong>为基础来传输HTML，文件，图片等。 它本身处于<strong>应用层</strong>，<strong>端口号80</strong>。</p><ol><li>HTTP是基于<strong>浏览器/服务器</strong>架构；</li><li>HTTP是<strong>无状态</strong>协议：HTTP本身并不保存用户的任何信息，也不会对传输的数据，状态信息进行持久化；</li><li>HTTP是<strong>无连接</strong>协议：每次连接只处理一个请求，服务器处理完用户请求，即断开连接，借此节约传输时间。</li></ol><h1 id="HTTP通信过程"><a href="#HTTP通信过程" class="headerlink" title="HTTP通信过程"></a>HTTP通信过程</h1><ol><li>用户输入网址</li><li>DNS服务器解析域名</li><li>浏览器和服务器建立TCP连接</li><li>浏览器向服务器发送请求行</li><li>浏览器向服务器发送请求头，并以空行代表发送结束，如果请求类型为<code>post</code>，则继续发送请求体</li><li>服务器应答协议版本号和应答状态码</li><li>服务器发送响应头，并以空行代表发送结束</li><li>服务器发送数据：以<code>Content-Type</code>给出的格式发送用户所请求的信息</li><li>服务器关闭TCP连接：如果浏览器或者服务器的头信息中加入了这样一段代码：<code>connection：Keep-alive</code> 则TCP连接会保持打开状态</li><li>客户端浏览器解析HTML内容</li></ol><p>下图整理了HTTP通信的关键步骤：</p><p><img src="http通信过程.png" alt="计算机网络-http通信过程">​</p><h1 id="说一下HTTPS协议"><a href="#说一下HTTPS协议" class="headerlink" title="说一下HTTPS协议"></a>说一下HTTPS协议</h1><p>可以看我的博客：《HTTPS协议》</p><h1 id="HTTP与HTTPS的对比"><a href="#HTTP与HTTPS的对比" class="headerlink" title="HTTP与HTTPS的对比"></a>HTTP与HTTPS的对比</h1><ul><li>两者工作的端口号不同：HTTP工作在80，HTTPS工作在443；</li><li>HTTPS需要用到CA（数字证书认证机构）申请证书，一般需要一定费用；</li><li>HTTP响应比HTTPS快，主要因为HTTPS除了TCP3次握手外还要加上<strong>SSL9次握手</strong>共12次握手；</li><li>HTTPS是构建在SSL/TLS上的HTTP协议，因此需要占用服务器资源。</li></ul><h1 id="HTTP缓存​"><a href="#HTTP缓存​" class="headerlink" title="HTTP缓存​"></a>HTTP缓存​</h1><p>http缓存指的是: 当客户端向服务器请求资源时，会先抵达<strong>浏览器缓存</strong>，如果浏览器有“要请求资源”的副本，就可以<strong>直接从浏览器缓存中提取</strong>而不是从原始服务器中提取这个资源。</p><p>常见的http缓存<strong>只能缓存get请求</strong>响应的资源，对于其他类型的响应则无能为力，所以后续说的请求缓存都是指GET请求。<br>http缓存都是从第二次请求开始的。第一次请求资源时，服务器返回资源，并在respone header头中回传资源的缓存参数；第二次请求时，浏览器判断这些请求参数，命中强缓存就直接200，否则就把请求参数加到request header头中传给服务器，看是否命中协商缓存，命中则返回304，否则服务器会返回新的资源。（可以画个图理解一下）</p><p>HTTP 缓存又分为<strong>强缓存</strong>和 <strong>协商缓存</strong> ：</p><p><strong>强制缓存</strong>：在缓存数据未失效的情况下（即Cache-Control的max-age没有过期或者Expires的缓存时间没有过期），那么就会直接使用浏览器的缓存数据，不会再向服务器发送任何请求。</p><p><strong>协商缓存</strong>：当第一次请求时服务器返回的响应头中没有Cache-Control和Expires或者Cache-Control和Expires过期还或者它的属性设置为no-cache时(即不走强缓存)，那么浏览器第二次请求时就会与服务器进行 <strong>协商</strong>，与服务器端对比判断资源是否进行了修改更新。如果服务器端的资源没有修改，那么就会返回304状态码，告诉浏览器可以使用缓存中的数据，这样就减少了服务器的数据传输压力。如果数据有更新就会返回200状态码，服务器就会返回更新后的资源并且将缓存信息一起返回。</p><h1 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h1><ul><li>1xx：<strong>目前是协议的中间状态，还需要后续请求。</strong><ul><li>101 切换请求协议，从 HTTP 切换到 WebSocket</li></ul></li><li>2xx：<strong>表示请求成功。</strong><ul><li>200 请求成功，有响应体</li></ul></li><li><p>3xx：<strong>表示重定向状态，需要重新请求。</strong></p><ul><li>301 永久重定向：会缓存</li><li>302 临时重定向：不会缓存</li><li>304 协商缓存命中</li></ul></li><li><p>4xx：<strong>请求报文错误。</strong></p><ul><li>403 服务器禁止访问</li><li>404 资源未找到</li><li>400 请求错误</li></ul></li><li><p>5xx：<strong>服务器错误。</strong></p><ul><li>500 服务器端错误</li><li>503 服务器繁忙</li></ul></li></ul><h1 id="一个典型的HTTP请求报文包括哪些部分？响应报文呢？"><a href="#一个典型的HTTP请求报文包括哪些部分？响应报文呢？" class="headerlink" title="一个典型的HTTP请求报文包括哪些部分？响应报文呢？"></a>一个典型的HTTP请求报文包括哪些部分？响应报文呢？</h1><p>一个HTTP请求报文包括：  <strong>请求头，请求行，空行，请求体</strong>。</p><p>一个响应报文包括： <strong>响应行，响应头，空行，响应体</strong> 。</p><p>具体参考我的博客《详解HTTP协议》</p><h1 id="HTTP1-0、HTTP1-1、HTTP2-0区别"><a href="#HTTP1-0、HTTP1-1、HTTP2-0区别" class="headerlink" title="HTTP1.0、HTTP1.1、HTTP2.0区别"></a>HTTP1.0、HTTP1.1、HTTP2.0区别</h1><h2 id="HTTP1-0和HTTP1-1的区别-长短连接的区别"><a href="#HTTP1-0和HTTP1-1的区别-长短连接的区别" class="headerlink" title="HTTP1.0和HTTP1.1的区别/长短连接的区别"></a>HTTP1.0和HTTP1.1的区别/长短连接的区别</h2><p>这里主要回答长短连接的区别就行吧。。</p><p>在HTTP/1.0中采用短连接。客户端和服务器每进行一次HTTP操作，就建立一次连接，任务中断连接；Connection: close</p><p>在HTTP/1.1默认采用长连接和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。Connection: keep-alive，就是保持连接。</p><hr><p>长连接适用的场景：长连接适用于操作频繁/点对点通讯等连接数不太多的情况，如：一些游戏/即时通讯场景应该使用长连接；</p><p>短连接适用的场景： 短连接适用于大量连接的场景，如Web【wapWeb/H5等】的http服务，长连接对于服务端来说会耗费一定资源。</p><blockquote><p>补充其他区别：</p><ul><li>长短连接</li><li><strong>缓存处理</strong>：在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略，可供选择的缓存头来控制缓存策略。</li><li><strong>带宽优化及网络连接的使用</strong>：HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li><li><strong>错误通知的管理</strong>：在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li><li><strong>Host头处理</strong>：在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。</li></ul></blockquote><h2 id="HTTP1和HTTP2的区别"><a href="#HTTP1和HTTP2的区别" class="headerlink" title="HTTP1和HTTP2的区别"></a>HTTP1和HTTP2的区别</h2><p>HTTP2.0是第二代TCP协议。它与HTTP1.1的不同点在于：</p><ul><li>HTTP2采用<strong>二进制</strong>而非文本格式；此属性减轻了框架的复杂性，并简化了由于包含文本和可选空格的命令而导致混淆的命令的实现。</li><li>HTTP2是 <strong>完全多路复用</strong> ，而线端阻塞的——只需一个连接可以实现并行；</li><li>HTTP2使用<strong>标头（headers）压缩</strong> ，减小了开销；</li><li>HTTP2让服务器可以将响应主动推送到客户端缓存中。</li></ul><p>名词解释：</p><blockquote><p>线端阻塞和多路复用</p><p>HTTP/1.x 有个问题叫线端阻塞(head-of-line blocking), 它是指<strong>一个连接(connection)一次只提交一个请求的效率比较高, 多了就会变慢</strong>。 HTTP/1.1 试过用流水线(pipelining)来解决这个问题, 但是效果并不理想(数据量较大或者速度较慢的响应, 会阻碍排在他后面的请求)。</p><p>多路传输(Multiplexing)能很好的解决这些问题, 因为它能同时处理多个消息的请求和响应; 甚至可以在传输过程中将一个消息跟另外一个掺杂在一起。所以<strong>客户端只需要一个连接</strong>就能加载一个页面。减少额外的往返时间。</p><p><img src="http1和2建立连接.png" alt="http1和2建立连接"></p><p>主动推送：通俗理解就是客户端请求了html，服务器觉得和其相关的css也会被关联到，于是主动同送其他资源到客户端。</p></blockquote><h1 id="GET、POST区别"><a href="#GET、POST区别" class="headerlink" title="GET、POST区别"></a>GET、POST区别</h1><p>具体看我的博客《详解HTTP协议》和《HTTP协议幂等性》</p><p><img src="get和post区别.png" alt="get和post区别"></p><p>‍</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;作为复习，也作为一个目录&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;说一下HTTP协议&quot;&gt;&lt;a href=&quot;#说一下HTTP协议&quot; class=&quot;headerlink&quot; title=&quot;说一下HTTP协议&quot;&gt;&lt;/a&gt;说一下HTTP协议&lt;/h</summary>
      
    
    
    
    <category term="计算机网络" scheme="https://guoyujian.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="HTTP协议" scheme="https://guoyujian.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="计算机网络" scheme="https://guoyujian.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="HTTP协议" scheme="https://guoyujian.github.io/tags/HTTP%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>使用腾讯会议的屏幕共享功能时开启PPT演示者视图的方法</title>
    <link href="https://guoyujian.github.io/2022/09/11/%E4%BD%BF%E7%94%A8%E8%85%BE%E8%AE%AF%E4%BC%9A%E8%AE%AE%E7%9A%84%E5%B1%8F%E5%B9%95%E5%85%B1%E4%BA%AB%E5%8A%9F%E8%83%BD%E6%97%B6%E5%BC%80%E5%90%AFPPT%E6%BC%94%E7%A4%BA%E8%80%85%E8%A7%86%E5%9B%BE%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>https://guoyujian.github.io/2022/09/11/%E4%BD%BF%E7%94%A8%E8%85%BE%E8%AE%AF%E4%BC%9A%E8%AE%AE%E7%9A%84%E5%B1%8F%E5%B9%95%E5%85%B1%E4%BA%AB%E5%8A%9F%E8%83%BD%E6%97%B6%E5%BC%80%E5%90%AFPPT%E6%BC%94%E7%A4%BA%E8%80%85%E8%A7%86%E5%9B%BE%E7%9A%84%E6%96%B9%E6%B3%95/</id>
    <published>2022-09-11T06:13:47.000Z</published>
    <updated>2022-09-11T06:14:43.767Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://meeting.tencent.com/support-doc-detail/79/index.html">https://meeting.tencent.com/support-doc-detail/79/index.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://meeting.tencent.com/support-doc-detail/79/index.html&quot;&gt;https://meeting.tencent.com/support-doc-detail/79/index.html&lt;/a&gt;&lt;/</summary>
      
    
    
    
    <category term="工具箱" scheme="https://guoyujian.github.io/categories/%E5%B7%A5%E5%85%B7%E7%AE%B1/"/>
    
    
    <category term="腾讯会议" scheme="https://guoyujian.github.io/tags/%E8%85%BE%E8%AE%AF%E4%BC%9A%E8%AE%AE/"/>
    
    <category term="ppt" scheme="https://guoyujian.github.io/tags/ppt/"/>
    
    <category term="演示者视图" scheme="https://guoyujian.github.io/tags/%E6%BC%94%E7%A4%BA%E8%80%85%E8%A7%86%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>markdown公式编辑语法</title>
    <link href="https://guoyujian.github.io/2022/09/11/markdown%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91%E8%AF%AD%E6%B3%95/"/>
    <id>https://guoyujian.github.io/2022/09/11/markdown%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91%E8%AF%AD%E6%B3%95/</id>
    <published>2022-09-11T06:06:19.000Z</published>
    <updated>2022-09-11T06:10:33.036Z</updated>
    
    <content type="html"><![CDATA[<p>下面两个连接给出的公式语法涵盖了大部分的内容，第一个是官方连接。</p><ol><li><a href="https://katex.org/docs/supported.html">Supported Functions</a></li><li><a href="https://blog.csdn.net/weixin_42782150/article/details/104878759">史上最全Markdown公式、符号总结！！！</a></li></ol><p>另外推荐一款公式生成软件</p><blockquote><p><strong>mathpix snipping tool</strong></p></blockquote><p>通过截图生成公式code，可以直接复制公式代码，也可以直接复制到word等。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;下面两个连接给出的公式语法涵盖了大部分的内容，第一个是官方连接。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://katex.org/docs/supported.html&quot;&gt;Supported Functions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;h</summary>
      
    
    
    
    <category term="工具箱" scheme="https://guoyujian.github.io/categories/%E5%B7%A5%E5%85%B7%E7%AE%B1/"/>
    
    
    <category term="markdown" scheme="https://guoyujian.github.io/tags/markdown/"/>
    
    <category term="typora" scheme="https://guoyujian.github.io/tags/typora/"/>
    
  </entry>
  
  <entry>
    <title>【不经意传输】算法介绍</title>
    <link href="https://guoyujian.github.io/2022/09/11/%E3%80%90%E4%B8%8D%E7%BB%8F%E6%84%8F%E4%BC%A0%E8%BE%93%E3%80%91%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/"/>
    <id>https://guoyujian.github.io/2022/09/11/%E3%80%90%E4%B8%8D%E7%BB%8F%E6%84%8F%E4%BC%A0%E8%BE%93%E3%80%91%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/</id>
    <published>2022-09-11T05:32:22.000Z</published>
    <updated>2022-09-11T05:38:01.807Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>“不经意传输”要解决这类问题：你需要给对方多条信息，但是你又必须确保对方只获得其中一条，但是对方又希望能够确保你不知道他看到哪一条信息。</p><p>设计一个具体场景：你给你的哥们介绍相亲女朋友，你有两个可供介绍的单身女性，但是你不想同时将两人的情况和联系方式给对方。但你也无法抉择到底给哪个，所以你想让他随机抽签选择一个。但与此同时，你的哥们也不想让你知道，他最终抽到了谁。</p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p><strong>不经意传输</strong>（Oblivious Transfer，简称OT）是一个密码学协议，在这个协议中，消息发送者从一些待发送的消息中发送一条给接收者，但事后对发送了哪一条消息仍然oblivious（不知道），这个协议也叫茫然传输协议。</p><p>不经意传输是密码学中的一个基本而重要的问题，被认为是该领域的关键问题之一，对于<strong>安全多方计算</strong>来说是完整的实现。</p><p>例如下图，Alice是消息发送者，Bob是消息接受者。Alice想要将消息$M_0$、$M_1$之一传给Bob，Bob只能得到自己想要的那个（$M_0$或$M_1$）不能获取另外一个消息，Alice也不能知道Bob选的是哪一条消息。</p><p><img src="不经意传输1.png" alt="不经意传输1"></p><h1 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h1><p>第一种形式的不经意传输，最初是在1981由Michael O.Rabin提出，在这种不经意传输中，发送者Alice发送一条消息给接收着Bob，而Bob以1/2的概率接收到信息，在结束后Alice并不知道Bob是否接收到了信息，而Bob能确信地知道自己是否收到了信息。</p><p>另一种更实用的不经意传输协议，被称为2选一不经意传输（1 out 2 oblivious transfer）由 Shimon Even，Oded Goldreich和Abraham Lempel在1985年提出，在这种形式的不经意传输模型中，Alice每次发两条信息（m1、m2）给Bob，<strong>Bob提供一个输入</strong>，并根据输入获得输出信息，在协议结束后，Bob得到了自己想要的那条信息（m1或者m2），而Alice并不知道Bob最终得到的是哪条。</p><blockquote><p>这个输入，我的理解是通知发送者发哪些消息，发送消息的范围</p></blockquote><p>1986年，Brassard等人将2选1不经意传输拓展为n选1。</p><p><img src="不经意传输2.png" alt="不经意传输2"></p><p>不经意传输一种实现方式是<strong>基于RSA公钥算法</strong>，下面就2选1不经意传输的实现做简要介绍。</p><h1 id="基于RSA公钥算法的2选1不经意传输"><a href="#基于RSA公钥算法的2选1不经意传输" class="headerlink" title="基于RSA公钥算法的2选1不经意传输"></a>基于RSA公钥算法的2选1不经意传输</h1><p>先把「基于RSA公钥算法的2选1不经意传输」的流程图列出来：</p><p><img src="不经意传输流程.png" alt="不经意传输流程"></p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ol><li>发送者Alice生成两对RSA公私钥$(puk0, pri0)$，$(puk1, pri1)$，并将两个公钥$puk0$和$puk1$发送给Bob。</li><li>Bob生成一个随机数$r$，并用收到的两个公钥之一加密随机数，$c=Encrypt(r)$。（用哪个秘钥取决于想获取哪条数据，例如如果想要得到消息$M_0$就用$puk0$加密随机数，如果想要得到$M_1$就用$puk1$加密随机数），并将密文结果发送给Alice。</li><li>Alice用自己的两个私钥分别解密收到随机数密文，得到两个解密结果：$k_0=Decrypt(c, pri_0)$，$k_1=Decrypt(c, pri_1)$。（$k_0$，$k_1$其中一个就是随机数$r$）。并将两个结果分别与两条信息进行异或，生成掩码消息：$e_0=k_0\bigoplus m_0$，$e_1=k_1\bigoplus m_1$，并将两个结果$e_0$，$e_1$发给Bob。</li><li>Bob用之前生成的随机数$r$与收到的$e_0$，$e_1$分别做异或操作，得到的两个结果中只有一条为真实数据，另外一条为随机数：$m^{‘}_0=e_0\bigoplus r$，$m^{‘}_1=e_1\bigoplus r$。</li><li>Bob在步骤2中，如果使用$puk0$加密，得到的$m^{‘}_0=m_0$，反之是$m_1$。</li></ol><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>在此过程中第3步最为关键，如果Alice无法从用两条私钥解密得到的结果$k_0$、$k_1$中区分出Bob的真实随机数，则能保证Alice无法得知Bob将要获取的是哪条数据。Bob没有私钥也就无法得出真实的私钥解密结果（如果$k_0$为真实随机数，Bob无法得知$k_1$的值），所以也就只能得到自己想要的那条数据而无法得到另外一条，保障协议能执行成功。</p><h1 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h1><ol><li><a href="https://learnblockchain.cn/article/2022">区块链中的数学 - 不经意传输</a></li><li><a href="https://zhuanlan.zhihu.com/p/208295083">什么是不经意传输</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;“不经意传输”要解决这类问题：你需要给对方多条信息，但是你又必须确保对方只获得其中一条，但是对方又希望能够确保你不知道他看到哪一条信息。&lt;/</summary>
      
    
    
    
    <category term="密码学" scheme="https://guoyujian.github.io/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
    <category term="密码学" scheme="https://guoyujian.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>RSA加密算法</title>
    <link href="https://guoyujian.github.io/2022/08/28/RSA%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    <id>https://guoyujian.github.io/2022/08/28/RSA%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</id>
    <published>2022-08-28T15:17:00.000Z</published>
    <updated>2022-08-28T15:28:04.869Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对称加密与非对称加密"><a href="#对称加密与非对称加密" class="headerlink" title="对称加密与非对称加密"></a>对称加密与非对称加密</h1><p>使用相同的规则（秘钥）进行加密解密的算法成为“<strong>对称加密算法</strong>”，这种加密模式有一个最大弱点：甲方必须把加密规则告诉乙方，否则无法解密。保存和传递密钥，就成了最头疼的问题。</p><p>1976年，两位美国计算机学家Whitfield Diffie 和 Martin Hellman，提出了一种崭新构思，可以在不直接传递密钥的情况下，完成解密。这被称为<a href="https://en.wikipedia.org/wiki/Diffie–Hellman_key_exchange">“Diffie-Hellman密钥交换算法”</a>。这个算法启发了其他科学家。人们认识到，加密和解密可以使用不同的规则，只要这两种规则之间存在某种对应关系即可，这样就避免了直接传递密钥。</p><p>这种新的加密模式被称为”非对称加密算法”。</p><blockquote><p>（1）乙方生成两把密钥（公钥和私钥）。公钥是公开的，任何人都可以获得，私钥则是保密的。</p><p>（2）甲方获取乙方的公钥，然后用它对信息加密。</p><p>（3）乙方得到加密后的信息，用私钥解密。</p></blockquote><p>如果公钥加密的信息只有私钥解得开，那么只要私钥不泄漏，通信就是安全的。</p><blockquote><p> 我的理解：RSA加密算法就是一种非对称加密算法。甲向乙发送消息，乙先生成私钥和公钥，乙把公钥给甲，甲用公钥将信息加密，将加密信息发给乙，乙拿私钥解密。</p></blockquote><p>在介绍RSA算法之前需要先介绍一点数学知识。</p><h1 id="RSA算法的数学基础"><a href="#RSA算法的数学基础" class="headerlink" title="RSA算法的数学基础"></a>RSA算法的数学基础</h1><h2 id="互质关系"><a href="#互质关系" class="headerlink" title="互质关系"></a>互质关系</h2><p>如果两个正整数，除了1以外，没有其他公因子，我们就称这两个数是<a href="https://zh.wikipedia.org/zh-cn/互素">互质关系</a>（coprime）。比如，15和32没有公因子，所以它们是互质关系。这说明，不是质数也可以构成互质关系。</p><p>关于互质关系，不难得到以下结论：</p><blockquote><ol><li>任意两个质数构成互质关系，比如13和61。☆</li><li>一个数是质数，另一个数只要不是前者的倍数，两者就构成互质关系，比如3和10。</li><li>如果两个数之中，较大的那个数是质数，则两者构成互质关系，比如97和57。</li><li>1和任意一个自然数是都是互质关系，比如1和99。</li><li>p是大于1的整数，则p和p-1构成互质关系，比如57和56。</li><li>p是大于1的奇数，则p和p-2构成互质关系，比如17和15。</li></ol></blockquote><h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><p>对于任意给定的正整数n，计算在小于等于n的正整数之中，有多少个与n构成互质关系的方法就叫做<strong>欧拉函数</strong>。以φ(n)表示。在1到8之中，与8形成互质关系的是1、3、5、7，所以 φ(n) = 4。</p><p><strong>第一种情况</strong></p><p>如果n=1，则 φ(1) = 1 。因为1与任何数（包括自身）都构成互质关系。</p><p><strong>第二种情况</strong></p><p>如果n是质数，则 φ(n)=n-1。因为质数与小于它的每一个数，都构成互质关系。比如5与1、2、3、4都构成互质关系。</p><p><strong>第三种情况</strong></p><p>如果n是质数的某一个次方，即$ n = p^k $ （p为质数，k为大于等于1的整数），则</p><script type="math/tex; mode=display">φ(p^k) = p^k - p^{k-1}</script><p>比如 $φ(8) = φ(2^3) = 2^3 - 2^2 = 4$。</p><p>这是因为只有当一个数不包含质数p，才可能与n互质。而包含质数p的数一共有$p^{k-1}$个，即$1×p$、$2×p$、$3×p$、…、$p^{k-1}×p$，把它们去除，剩下的就是与n互质的数。</p><p>上面的式子还可以写成下面的形式：</p><script type="math/tex; mode=display">φ(p^k) = p^k - p^{k-1} = p^k(1-\frac{1}{p})</script><p>可以看出，上面的第二种情况是 k=1 时的特例。</p><p><strong>第四种情况</strong></p><p>如果n可以分解成两个互质的整数之积，$n = p_1 <em> p_2$，则$φ(n) = φ(p_1</em>p_2) = φ(p_1) * φ(p_2)$</p><p>即积的欧拉函数等于欧拉函数的积。比如，$φ(56)=φ(8×7)=φ(8)×φ(7)=4×6=24$。</p><p>这一条的证明要用到<a href="https://en.wikipedia.org/wiki/Chinese_remainder_theorem">“中国剩余定理”</a>，这里就不展开了。</p><p><strong>第五种情况</strong></p><p>因为任意一个大于1的正整数，都可以写成一系列质数的积。</p><script type="math/tex; mode=display">n = p_1^{k_1}p_2^{k_2}…p_r^{k_r}</script><p>根据第4条的结论，得到</p><script type="math/tex; mode=display">φ(n)=φ(p_1^{k_1})φ(p_2^{k_2})…φ(p_r^{k_r})</script><p>再根据第3条的结论，得到</p><script type="math/tex; mode=display">φ(n)=p_1^{k_1}p_2^{k_2}…p_r^{k_r}(1-\frac{1}{p_1})(1-\frac{1}{p_2})…(1-\frac{1}{p_r})</script><p>也就等于</p><script type="math/tex; mode=display">φ(n)=n(1-\frac{1}{p_1})(1-\frac{1}{p_2})…(1-\frac{1}{p_r})</script><p>这就是欧拉函数的通用计算公式。比如，1323的欧拉函数，计算过程如下：</p><script type="math/tex; mode=display">φ(1323)=φ(3^3*7^2)=1323(1-\frac{1}{3})(1-\frac{1}{7})=756</script><h2 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h2><p>欧拉函数的用处，在于<a href="https://zh.wikipedia.org/wiki/欧拉定理_(数论">欧拉定理</a>)。”欧拉定理”指的是：</p><blockquote><p>如果两个正整数a和n互质，则n的欧拉函数 φ(n) 可以让下面的等式成立：</p><script type="math/tex; mode=display">a^{φ(n)}\equiv1 \pmod n</script></blockquote><p>也就是说，a的φ(n)次方被n除的余数为1。或者说，a的φ(n)次方减去1，可以被n整除。比如，3和7互质，而7的欧拉函数φ(7)等于6，所以3的6次方（729）减去1，可以被7整除（728/7=104）。</p><p>欧拉定理的证明比较复杂，这里就省略了。我们只要记住它的结论就行了。</p><p>欧拉定理可以大大简化某些运算。比如，7和10互质，根据欧拉定理，</p><script type="math/tex; mode=display">7^{φ(10)}\equiv1 \pmod {10}</script><p>已知 φ(10) 等于4，所以马上得到7的4倍数次方的个位数肯定是1。</p><script type="math/tex; mode=display">7^{4k}\equiv1 \pmod {10}</script><p>因此，7的任意次方的个位数（例如7的222次方），心算就可以算出来。</p><p>欧拉定理有一个特殊情况。</p><blockquote><p>假设正整数a与质数p互质，因为质数p的φ(p)等于p-1，则欧拉定理可以写成</p><script type="math/tex; mode=display">a^{p-1} \equiv 1 \pmod p</script></blockquote><p>这就是著名的<a href="https://zh.wikipedia.org/wiki/费马小定理">费马小定理</a>。它是欧拉定理的特例。</p><p>欧拉定理是RSA算法的核心。理解了这个定理，就可以理解RSA。</p><h2 id="模反元素"><a href="#模反元素" class="headerlink" title="模反元素"></a>模反元素</h2><p>还剩下最后一个概念：</p><blockquote><p>如果两个正整数a和n互质，那么一定可以找到整数b，使得 ab-1 被n整除，或者说ab被n除的余数是1。</p><script type="math/tex; mode=display">ab \equiv 1 \pmod n</script><p>这时，b就叫做a的<a href="https://zh.wikipedia.org/wiki/模反元素">“模反元素”</a>。</p></blockquote><p>比如，3和11互质，那么3的模反元素就是4，因为 (3 × 4)-1 可以被11整除。显然，模反元素不止一个， 4加减11的整数倍都是3的模反元素 {…,-18,-7,4,15,26,…}，即如果b是a的模反元素，则 b+kn 都是a的模反元素。</p><p>欧拉定理可以用来证明模反元素必然存在。</p><script type="math/tex; mode=display">a^{φ(n)}=a*a^{φ(n)-1} \equiv 1 \pmod n</script><p>可以看到，a的 φ(n)-1 次方，就是a的模反元素。</p><h1 id="RSA算法"><a href="#RSA算法" class="headerlink" title="RSA算法"></a>RSA算法</h1><h2 id="密钥生成的步骤"><a href="#密钥生成的步骤" class="headerlink" title="密钥生成的步骤"></a>密钥生成的步骤</h2><p>我们通过一个例子，来理解RSA算法。假设爱丽丝要与鲍勃进行加密通信，她该怎么生成公钥和私钥呢？</p><p><img src="bg2013070302.png" alt="img"></p><p><strong>第一步，随机选择两个不相等的质数p和q。</strong></p><p>爱丽丝选择了61和53。（实际应用中，这两个质数越大，就越难破解。）</p><p><strong>第二步，计算p和q的乘积n。</strong></p><p>爱丽丝就把61和53相乘。</p><script type="math/tex; mode=display">n = 61*53 = 3233</script><p>n的二进制长度就是密钥长度。3233写成二进制是110010100001，一共有12位，所以这个密钥就是12位。</p><p>实际应用中，RSA密钥一般是1024位，重要场合则为2048位。</p><p><strong>第三步，计算n的欧拉函数φ(n)。</strong></p><p>根据公式：</p><script type="math/tex; mode=display">φ(n) = (p-1)(q-1)</script><p>$φ(3233)=φ(61<em>53)=φ(61)</em>φ（53）=60*52=3120$</p><p><strong>第四步，随机选择一个整数e，条件是1&lt; e &lt; φ(n)，且e与φ(n) 互质。</strong></p><p>爱丽丝就在1到3120之间，随机选择了17。（实际应用中，常常选择65537。）</p><p><strong>第五步，计算e对于φ(n)的模反元素d。</strong></p><p>所谓<a href="https://zh.wikipedia.org/wiki/模反元素">“模反元素”</a>就是指有一个整数d，可以使得ed被φ(n)除的余数为1。</p><script type="math/tex; mode=display">ed \equiv 1 \pmod {φ(n)}</script><p>这个式子等价于</p><script type="math/tex; mode=display">ed - 1 = k φ(n)</script><p>于是，找到模反元素d，实质上就是对下面这个二元一次方程求解。</p><script type="math/tex; mode=display">ed - kφ(n) = 1</script><p>已知 e=17, φ(n)=3120，</p><script type="math/tex; mode=display">17d-3120k=1</script><p>这个方程可以用<a href="https://zh.wikipedia.org/wiki/扩展欧几里得算法">“扩展欧几里得算法”</a>求解，此处省略具体过程。总之，爱丽丝算出一组整数解为 (d, k)=(2753,-15)，即 d=2753。</p><p>至此所有计算完成。</p><p><strong>第六步，将n和e封装成公钥，n和d封装成私钥。</strong></p><p>在爱丽丝的例子中，n=3233，e=17，d=2753，所以公钥就是(n, e) =  (3233,17)，私钥就是(n, d)=(3233, 2753)。</p><h2 id="RSA算法的可靠性"><a href="#RSA算法的可靠性" class="headerlink" title="RSA算法的可靠性"></a>RSA算法的可靠性</h2><p>回顾上面的密钥生成步骤，一共出现六个数字：</p><blockquote><p>p<br>q<br>n<br>φ(n)<br>e<br>d</p></blockquote><p>这六个数字之中，公钥用到了两个（n和e），其余四个数字都是不公开的。其中最关键的是d，因为n和d组成了私钥，一旦d泄漏，就等于私钥泄漏。</p><p><strong>那么，有无可能在已知n和e的情况下，推导出d？</strong></p><blockquote><ol><li>ed≡1 (mod φ(n))。只有知道e和φ(n)，才能算出d。</li><li>φ(n)=(p-1)(q-1)。只有知道p和q，才能算出φ(n)。</li><li>n=pq。只有将n因数分解，才能算出p和q。</li></ol></blockquote><p><strong>结论：如果n可以被因数分解，d就可以算出，也就意味着私钥被破解。</strong></p><p>可是，大整数的因数分解，是一件非常困难的事情。目前，除了暴力破解，还没有发现别的有效方法。维基百科这样写道：</p><blockquote><p>“对极大整数做因数分解的难度决定了RSA算法的可靠性。换言之，对一极大整数做因数分解愈困难，RSA算法愈可靠。</p><p>假如有人找到一种快速因数分解的算法，那么RSA的可靠性就会极度下降。但找到这样的算法的可能性是非常小的。今天只有短的RSA密钥才可能被暴力破解。到2008年为止，世界上还没有任何可靠的攻击RSA算法的方式。</p><p>只要密钥长度足够长，用RSA加密的信息实际上是不能被解破的。”</p></blockquote><p>举例来说，你可以对3233进行因数分解（61×53），但是你没法对下面这个整数进行因数分解。</p><blockquote><p>12301866845301177551304949<br>58384962720772853569595334<br>79219732245215172640050726<br>36575187452021997864693899<br>56474942774063845925192557<br>32630345373154826850791702<br>61221429134616704292143116<br>02221240479274737794080665<br>351419597459856902143413</p></blockquote><p>它等于这样两个质数的乘积：</p><blockquote><p>33478071698956898786044169<br>84821269081770479498371376<br>85689124313889828837938780<br>02287614711652531743087737<br>814467999489<br>×<br>36746043666799590428244633<br>79962795263227915816434308<br>76426760322838157396665112<br>79233373417143396810270092<br>798736308917</p></blockquote><p>事实上，这大概是人类已经分解的最大整数（232个十进制位，768个二进制位）。比它更大的因数分解，还没有被报道过，因此目前被破解的最长RSA密钥就是768位。</p><h2 id="加密和解密"><a href="#加密和解密" class="headerlink" title="加密和解密"></a>加密和解密</h2><p>有了公钥和密钥，就能进行加密和解密了。</p><p><strong>加密要用公钥 (n,e)</strong></p><p>假设鲍勃要向爱丽丝发送加密信息m，他就要用爱丽丝的公钥 (n,e) 对m进行加密。这里需要注意，m必须是整数（字符串可以取ascii值或unicode值），且m必须小于n。</p><p>所谓”加密”，就是算出下式的c：</p><script type="math/tex; mode=display">m^e \equiv c \pmod n</script><p>爱丽丝的公钥是 (3233, 17)，鲍勃的m假设是65，那么可以算出下面的等式：</p><script type="math/tex; mode=display">65^{17} \equiv 2790 \pmod {3233}</script><p>于是，c等于2790，鲍勃就把2790发给了爱丽丝。</p><p><strong>解密要用私钥(n,d)</strong></p><p>爱丽丝拿到鲍勃发来的2790以后，就用自己的私钥(3233, 2753) 进行解密。可以证明，下面的等式一定成立：</p><script type="math/tex; mode=display">c^d \equiv m \pmod n</script><p>也就是说，c的d次方除以n的余数为m。现在，c等于2790，私钥是(3233, 2753)，那么，爱丽丝算出</p><script type="math/tex; mode=display">2790^{2753}\equiv65 \pmod {3233}</script><p>因此，爱丽丝知道了鲍勃加密前的原文就是65。</p><p>至此，”加密—解密”的整个过程全部完成。</p><p>我们可以看到，如果不知道d，就没有办法从c求出m。而前面已经说过，要知道d就必须分解n，这是极难做到的，所以RSA算法保证了通信安全。</p><p>你可能会问，公钥(n,e) 只能加密小于n的整数m，那么如果要加密大于n的整数，该怎么办？有两种解决方法：一种是把长信息分割成若干段短消息，每段分别加密；另一种是先选择一种”对称性加密算法”（比如<a href="https://zh.wikipedia.org/wiki/资料加密标准">DES</a>），用这种算法的密钥加密信息，再用RSA公钥加密DES密钥。</p><h2 id="私钥解密的证明"><a href="#私钥解密的证明" class="headerlink" title="私钥解密的证明"></a>私钥解密的证明</h2><p>最后，我们来证明，为什么用私钥解密，一定可以正确地得到m。也就是证明下面这个式子：</p><script type="math/tex; mode=display">c^d\equiv m \pmod n</script><p>因为，根据加密规则</p><script type="math/tex; mode=display">m^e\equiv c \pmod n</script><p>于是，c可以写成下面的形式：</p><script type="math/tex; mode=display">c = m^e -kn</script><p>将c代入要我们要证明的那个解密规则：</p><script type="math/tex; mode=display">(m^e-kn)^d=m \pmod n</script><p>左边二项式拆出来，除了第一项$m^e$，其他项都是n的倍数，所以它等同于求证</p><script type="math/tex; mode=display">m^{ed} \equiv m \pmod n</script><p>由于</p><script type="math/tex; mode=display">ed \equiv 1 \pmod {φ(n)}</script><p>所以</p><script type="math/tex; mode=display">ed = h φ(n) + 1</script><p>将ed代入：</p><script type="math/tex; mode=display">m^{hφ(n)+1}=m \pmod n</script><p>接下来，分成两种情况证明上面这个式子。</p><p><strong>（1）m与n互质。</strong></p><p>根据欧拉定理，此时</p><script type="math/tex; mode=display">m^{φ(n)} \equiv 1 \pmod n</script><p>得到</p><script type="math/tex; mode=display">(m^{φ(n)})^h*m \equiv m \pmod n</script><p>原式得到证明。</p><p><strong>（2）m与n不是互质关系。</strong></p><p>此时，由于n等于质数p和q的乘积，所以m必然等于kp或kq。</p><p>以 m = kp为例，考虑到这时k与q必然互质，则根据欧拉定理，下面的式子成立：</p><script type="math/tex; mode=display">(kp)^{q-1} \equiv 1 \pmod q</script><p>进一步得到</p><script type="math/tex; mode=display">[(kp)^{q-1}]^{h(p-1)}*kp \equiv kp \pmod q</script><p>即</p><script type="math/tex; mode=display">(kp)^{ed} \equiv kp \pmod q</script><p>将它改写成下面的等式</p><script type="math/tex; mode=display">(kp)^{ed} = tq + kp</script><p>这时t必然能被p整除，即 t=t’p</p><script type="math/tex; mode=display">(kp)^{ed}=t'pq+kp</script><p>因为 m=kp，n=pq，所以</p><script type="math/tex; mode=display">m^{ed} \equiv m \pmod n</script><p>原式得到证明。</p><h1 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h1><ol><li><a href="https://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html">RSA算法原理（一）</a></li><li><a href="https://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html">RSA算法原理（二）</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;对称加密与非对称加密&quot;&gt;&lt;a href=&quot;#对称加密与非对称加密&quot; class=&quot;headerlink&quot; title=&quot;对称加密与非对称加密&quot;&gt;&lt;/a&gt;对称加密与非对称加密&lt;/h1&gt;&lt;p&gt;使用相同的规则（秘钥）进行加密解密的算法成为“&lt;strong&gt;对称加密算法&lt;</summary>
      
    
    
    
    <category term="加密算法" scheme="https://guoyujian.github.io/categories/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="加密算法" scheme="https://guoyujian.github.io/tags/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>深度学习中图像分类问题的总结</title>
    <link href="https://guoyujian.github.io/2022/08/16/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%BB%E7%BB%93/"/>
    <id>https://guoyujian.github.io/2022/08/16/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%BB%E7%BB%93/</id>
    <published>2022-08-16T12:25:28.000Z</published>
    <updated>2022-08-16T15:11:48.095Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><blockquote><p>企业实习中遇到的场景。</p><p>输入是ICU中病人的一段视频，输出是基于判断该病人是否贫血。</p><p>甲方给出了300多个的视频，每个视频对应一个病人。其中重度贫血样本最少，轻度贫血的样本量最多。</p><p>（说实在的，这个任务实在是有点玄学，查了一些资料，也没有理论依据。但是甲方说有经验的医生看几眼就能看出来<strong>病人</strong>是否是贫血，所以只能硬着头皮做。）</p><p>在实践过程中，得到了专家的指点，故把专家给出的技巧和实践中遇到的若干问题和解决思路记录下来。</p></blockquote><h1 id="数据处理和算法流程"><a href="#数据处理和算法流程" class="headerlink" title="数据处理和算法流程"></a>数据处理和算法流程</h1><p>如图。圆角矩形是数据，矩形是处理流程</p><p><img src="image-20220816222412537.png" alt="数据处理和算法流程"></p><h1 id="指导纪要"><a href="#指导纪要" class="headerlink" title="指导纪要"></a>指导纪要</h1><p>本节记录专家给出的一些指导要点。</p><h2 id="明确需求"><a href="#明确需求" class="headerlink" title="明确需求"></a>明确需求</h2><p>在开始之前，需要明确需求，针对本次任务主要是明确一下几点：</p><ol><li>目标是什么？最终的算法模型是科研，还是落地应用。如果是落地应用，那么可能更看重重度贫血的召回。</li><li>明确输入：是一段视频，还是一张照片，如果是一段视频还要考虑时序信息。</li><li>预测样本是已知的还是未知的：未知。</li><li>是否能有更多的数据？能，但比较慢，毕竟实际情况就是ICU的病床数量比较少。总样本量就那些。</li></ol><h2 id="分析bad-case"><a href="#分析bad-case" class="headerlink" title="分析bad case"></a>分析bad case</h2><p>找一个模型快速实现，（我们这里使用的是Efficient Net），基于这个baseline，分析bad case。</p><p>所谓bad case 就是模型经过训练后，预测错的case。分析bad case非常重要。（这一点在我实践的过程中没有重视，原因是ICU的病人的视频和照片容易引起不适）</p><p>分析bad case的目的有如下几个：</p><ol><li>确定算法上限：<strong>数据决定算法上限，模型只是在逼近这个上限。</strong>我们的模型做到什么样才算可以交差了，不是拍脑袋决定的，而是由本步骤得到的算法上限决定的。</li><li>如果人眼分辨起来都比较困难，那该任务可能是不可实现的。</li><li>纠正数据（标注）问题。在分析bad case的时候我发现有一些视频帧非常模糊，后面通过计算清晰度，将视频帧中比较模糊的图像去除掉了。</li></ol><h2 id="调参"><a href="#调参" class="headerlink" title="调参"></a>调参</h2><p>在明确了算法上限之后，再进行调参。</p><ol><li>train阶段：<ol><li>针对数据不均衡的问题，主要有三种方式：对每一个类别进行加权；把占比大的分类样本量调低；数据增强。（前两种在以前的实践中提升不大，最后一种PyTorch有现成的code）</li><li>针对模型，一般来说<strong>模型的分类力度要比需求的粒度更细</strong>，在该场景下，需求要求二分类，而模型取四分类。方便后续的调整。</li><li>测试后，画出<strong>混淆矩阵</strong>，看哪几个子类容易混淆，再对混淆的子类单独训练模型。（多个模型级联）</li><li>更换loss：我们尝试了把交叉熵损失换成center loss、focal loss，但效果也没有好到哪去。</li></ol></li><li>val阶段：<ol><li>loss：在该场景下，模型会给出四个分数，分别对应四个类别的可能性。一般是取四个分数中max对应的分类，作为最后的分类结果。<strong>修改阈值</strong>以改变最后的分类结果（比如，当重度贫血的概率大于人为设定的X时，就认为分类结果为重度贫血）。</li><li>X怎么定？X的值取决于指标。比如我想要重度贫血的Recall达到99%，那我把预测的重度贫血的分数由高到低排序，画一个最低线，在该线之上都被预测为重度贫血，那么该线就是我们想要的X。</li><li>loss：也可以给四个分数分别乘上四个权重。这条与上条的区别是，上一条可以轻易的确保Precision或Recall。</li></ol></li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="手工提取特征V-S-自动提取特征"><a href="#手工提取特征V-S-自动提取特征" class="headerlink" title="手工提取特征V.S.自动提取特征"></a>手工提取特征V.S.自动提取特征</h3><p>上面的<em>数据处理流程图</em>中可见，为了避免背景（病床等）干扰，我们先用网上一个训练好的模型提取人脸。再把提取的人脸拿去训练。</p><p>由于提取的效果有限，后来又使用K-means算法对颜色进行聚类，设置一个阈值，把大部分图像中病人的插管，口罩等去掉，用黑色背景代替。（当然效果依然有限）</p><p>一开始我们认为通过手工提取特征后，再丢到网络里训练，这样的效果会更好。</p><p>但专家认为并非如此，实际效果也确实如专家所料。</p><p>专家说，手工提取特征的缺点是，提取特征的同时会损害图像本身（图像出现一小块一小块的黑色背景）；其次，手工提取特征需要手工设定一个阈值，而这个阈值的最佳情形在训练集和测试集可能是不同的。</p><p>专家又说，<strong>在以往的实践中，深度学习的自动提取特征效果更好、更稳定。</strong></p><h3 id="三百个样本够不够用"><a href="#三百个样本够不够用" class="headerlink" title="三百个样本够不够用"></a>三百个样本够不够用</h3><p><strong>样本够不够取决于问题的难度。</strong>没有绝对意义上的够不够。</p><h3 id="预训练OR没有预训练"><a href="#预训练OR没有预训练" class="headerlink" title="预训练OR没有预训练"></a>预训练OR没有预训练</h3><p><strong>使用预训练的网络模型要比没有预训练的模型更好。</strong>（具体原因忘了。）</p><h3 id="交叉验证"><a href="#交叉验证" class="headerlink" title="交叉验证"></a>交叉验证</h3><p>虽然数据都是随机的分到train或者val，但是为了防止，分到train的数据太简单、val的数据太难和分到train的数据太难、val的数据太简单，会导致模型最后的效果不一样。<strong>为了提高模型的鲁棒性，需要K-Fold交叉验证。</strong></p><h3 id="多次迭代训练"><a href="#多次迭代训练" class="headerlink" title="多次迭代训练"></a>多次迭代训练</h3><p>由易到难多轮迭代。</p><p>先人工筛选出一些<strong>简单</strong>样本，按照一定比例组织数据进行训练，得到一个可以分类简单样本的模型。</p><p>再筛选出比简单样本稍难一点的样本，按照一定比例组织数据进行训练，得到一个可以分类比简单样本稍难样本的模型。</p><p>……</p><p>依次类推，直到所有样本都丢进去训练。</p><blockquote><p>这里所说的简单是人容易分辨的。</p><p>如果所有样本人都不容易看出来怎么办？</p><p>那就先进行一次整体的训练。找到本次训练中模型预测正确的样本，这样的样本即为模型认为的简单样本</p></blockquote><p>这种方法的优点是，效果会更好。（专家的原话是，屡试不爽）</p><p>我想可能是因为它比较符合人由易到难的学习思路。</p><p>缺点就是耗时长，人干预的时间长。（毕竟需要挑样本，挺累的。。）</p><h3 id="Attention"><a href="#Attention" class="headerlink" title="Attention"></a>Attention</h3><p>如果希望模型集中到某些局部特征可以使用attention机制。</p><h3 id="对于不清楚的代码或者参数"><a href="#对于不清楚的代码或者参数" class="headerlink" title="对于不清楚的代码或者参数"></a>对于不清楚的代码或者参数</h3><p>细究论文、源码。</p><h1 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;企业实习中遇到的场景。&lt;/p&gt;
&lt;p&gt;输入是ICU中病人的一段视频，输出是基于判断该病人是否贫血。&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="深度学习" scheme="https://guoyujian.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="深度学习" scheme="https://guoyujian.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="计算机视觉" scheme="https://guoyujian.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
  </entry>
  
  <entry>
    <title>力扣-前K个高频元素-用流来做</title>
    <link href="https://guoyujian.github.io/2022/07/11/%E5%8A%9B%E6%89%A3-%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0-%E7%94%A8%E6%B5%81%E6%9D%A5%E5%81%9A/"/>
    <id>https://guoyujian.github.io/2022/07/11/%E5%8A%9B%E6%89%A3-%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0-%E7%94%A8%E6%B5%81%E6%9D%A5%E5%81%9A/</id>
    <published>2022-07-11T13:06:28.000Z</published>
    <updated>2022-07-11T13:40:10.607Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>使用Java8 Stream来完成力扣 <a href="https://leetcode.cn/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a></p></blockquote><h1 id="题目及思路"><a href="#题目及思路" class="headerlink" title="题目及思路"></a>题目及思路</h1><blockquote><p>给一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 <strong>任意顺序</strong> 返回答案。</p><p>例如：</p><p>输入: nums = [1,1,1,2,2,3], k = 2</p><p>输出: [1,2]</p></blockquote><p>思路很简单：</p><p>将<key: 元素，value: 元素出现的次数>存到Map中，将map按value倒序排序，输出前k个返回。</p><h1 id="经典做法"><a href="#经典做法" class="headerlink" title="经典做法"></a>经典做法</h1><p>下面是根据上面的思路实现的代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> tmp[] = &#123;&#125;;</span><br><span class="line">            <span class="keyword">return</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建返回的res数组</span></span><br><span class="line">        <span class="type">int</span> res[] = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="comment">//创建map</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//将nums数组中元素和元素出现的次数保存到map中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(num)) &#123;</span><br><span class="line">                map.put(num, map.get(num)+<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(num, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建map.entrySet()的list用于排序</span></span><br><span class="line">        List&lt;Map.Entry&lt;Integer, Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(map.entrySet());</span><br><span class="line">        <span class="comment">//按map的值倒序排序</span></span><br><span class="line">        Collections.sort(list, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Map.Entry&lt;Integer, Integer&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Map.Entry&lt;Integer, Integer&gt; o1, Map.Entry&lt;Integer, Integer&gt; o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> o2.getValue() - o1.getValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//取出前k个放到res中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            res[i] = list.get(i).getKey();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用Stream"><a href="#使用Stream" class="headerlink" title="使用Stream"></a>使用Stream</h1><p>使用Stream实现的代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(nums) <span class="comment">// IntStream</span></span><br><span class="line">                .boxed() <span class="comment">// Stream&lt;Integer&gt;</span></span><br><span class="line">                .collect(Collectors.toMap(key -&gt; key, value -&gt; <span class="number">1</span>, Integer::sum)) <span class="comment">// Map&lt;Integer, Integer&gt;</span></span><br><span class="line">                .entrySet() <span class="comment">// Set&lt;Map&lt;K, V&gt;.Entry&lt;Integer, Integer&gt;&gt;</span></span><br><span class="line">                .stream() <span class="comment">// Stream&lt;Map&lt;K, V&gt;.Entry&lt;Integer, Integer&gt;&gt;</span></span><br><span class="line">                .sorted(Map.Entry.comparingByValue(Comparator.reverseOrder()))</span><br><span class="line">                .map(Map.Entry::getKey) <span class="comment">// Stream&lt;Integer&gt;</span></span><br><span class="line">                .limit(k)</span><br><span class="line">                .mapToInt(i -&gt; i) <span class="comment">//IntStream</span></span><br><span class="line">                .toArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是非常的简洁明了？下面对代码做一下必要解释</p><ul><li><p>为了将<code>int[]</code>转为流，使用了<code>Arrays.stream(nums)</code></p></li><li><p>需要注意的是，普通的流总是包装类，但这里直接得到了IntStream，为了后面封装为<code>Map&lt;Integer, Integer&gt;</code>，所以需要使用<code>boxed()</code>将IntStream转为<code>Stream&lt;Integer&gt;</code></p></li><li><p><code>collect</code>将Stream收集到一个Map</p></li><li><p><code>Collectors.toMap</code>的三个参数分别是，收集到Map的key，value当遇到重复key时的处理方法；</p></li><li><p>3-5行的代码等价于下面</p><ul><li><pre><code class="lang-java">Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();Arrays.stream(nums).forEach(num -&gt; &#123;    map.put(num, map.getOrDefault(num, 0) + 1);&#125;);</code></pre></li></ul></li><li><p>为了从map中再次获得流，我们使用代码先得到map的set在获得流。代码对应<code>entryset()</code>和<code>stream()</code></p></li><li><p>获得流之后需要根据value进行倒序排序，使用<code>sorted()</code>，其传入的参数是一个比较器</p></li><li><p>排序之后映射使用map()将<code>Stream&lt;Map&lt;K, V&gt;.Entry&lt;Integer, Integer&gt;&gt;</code>映射为<code>Stream&lt;Integer&gt;</code></p></li><li><p>我们只需要前k个，所以用limit(k)</p></li><li><p>使用<code>mapToInt(i -&gt; i)</code>进行拆包，得到IntStream</p></li><li><p><code>toArray()</code>转换为数组并返回。</p></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Java8 Stream在处理集合方面有着很大的优势：</p><ul><li>逻辑清晰</li><li>代码简洁</li><li>……</li></ul><p>但我刚接触，使用起来不是很熟悉，还需要再多练习。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>null</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;使用Java8 Stream来完成力扣 &lt;a href=&quot;https://leetcode.cn/problems/top-k-frequent-elements/&quot;&gt;347. 前 K 个高频元素&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://guoyujian.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://guoyujian.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>分库分表总结</title>
    <link href="https://guoyujian.github.io/2022/07/10/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E6%80%BB%E7%BB%93/"/>
    <id>https://guoyujian.github.io/2022/07/10/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E6%80%BB%E7%BB%93/</id>
    <published>2022-07-10T08:45:53.000Z</published>
    <updated>2022-07-10T08:45:53.096Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么要分库分表"><a href="#为什么要分库分表" class="headerlink" title="为什么要分库分表"></a>为什么要分库分表</h1><p>移动互联网时代，海量的用户每天产生海量的数量，比如：用户表、订单表、交易流水表。</p><p>以支付宝用户为例，8亿；微信用户更是10亿。订单表更夸张，比如美团外卖，每天都是几千万的订单。淘宝的历史订单总量应该百亿，甚至千亿级别，这些海量数据远不是一张表能Hold住的。</p><p>事实上MySQL单表可以存储10亿级数据，只是这时候性能比较差，<strong>业界公认MySQL单表容量在1KW以下是最佳状态，因为这时它的BTREE索引树高在3~5之间。</strong></p><p>既然<strong>一张表无法搞定，那么就想办法将数据放到多个地方</strong>，目前比较普遍的方案有3个：</p><blockquote><ol><li>分区；</li><li>分库分表；</li><li>NoSQL/NewSQL；NoSQL比较具有代表性的是MongoDB，es。NewSQL比较具有代表性的是TiDB。</li></ol></blockquote><h2 id="数据库架构演变：从读写分离到分库分表"><a href="#数据库架构演变：从读写分离到分库分表" class="headerlink" title="数据库架构演变：从读写分离到分库分表"></a>数据库架构演变：从读写分离到分库分表</h2><p>刚开始我们只用单机数据库就够了，随后面对越来越多的请求，我们将数据库的<strong>写操作和读操作进行分离</strong>， 使用多个从库副本<strong>（Slaver Replication）</strong>负责读，使用主库<strong>（Master）</strong>负责写， 从库从主库同步更新数据，保持数据一致。架构上就是数据库主从同步。 从库可以水平扩展，所以更多的读请求不成问题。</p><p>但是当用户量级上来后，写请求越来越多，该怎么办？加一个Master是不能解决问题的， 因为数据要保存一致性，写操作需要2个master之间同步，相当于是重复了，而且更加复杂。</p><p>这时就需要用到<strong>分库分表（sharding），对写操作进行切分。</strong></p><h2 id="为什么不NoSQL-NewSQL"><a href="#为什么不NoSQL-NewSQL" class="headerlink" title="为什么不NoSQL/NewSQL?"></a>为什么不NoSQL/NewSQL?</h2><p>首先，为什么不选择第三种方案NoSQL/NewSQL，我认为主要是RDBMS有以下几个优点：</p><blockquote><p>RDBMS：关系型数据库管理系统（Relational Database Management System）</p><ul><li>RDBMS生态完善；</li><li>RDBMS绝对稳定；</li><li>RDBMS的事务特性；</li></ul></blockquote><p>NoSQL/NewSQL作为新生儿，在我们把可靠性当做首要考察对象时，它是无法与RDBMS相提并论的。RDBMS发展几十年，只要有软件的地方，它都是核心存储的首选。</p><p>目前绝大部分公司的核心数据都是：<strong>以RDBMS存储为主，NoSQL/NewSQL存储为辅</strong>！互联网公司又以MySQL为主，国企&amp;银行等不差钱的企业以Oracle/DB2为主！NoSQL/NewSQL宣传的无论多牛逼，就现在各大公司对它的定位，都是RDBMS的补充，而不是取而代之！</p><h2 id="为什么不分区"><a href="#为什么不分区" class="headerlink" title="为什么不分区?"></a>为什么不分区?</h2><p>我们再看分区表方案。了解这个方案之前，先了解它的原理：</p><p>分区：就是把一张表的数据分成N个区块，在逻辑上看最终只是一张表，但底层是由N个物理区块组成的，分区实现比较简单，数据库mysql、oracle等很容易就可支持。</p><blockquote><p><strong>分区表是由多个相关的底层表实现，这些底层表也是由句柄对象表示</strong>，所以我们也可以直接访问各个分区，存储引擎管理分区的各个底层表和管理普通表一样（所有的底层表都必须使用相同的存储引擎），<strong>分区表的索引只是在各个底层表上各自加上一个相同的索引</strong>，从存储引擎的角度来看，底层表和一个普通表没有任何不同，存储引擎也无须知道这是一个普通表还是一个分区表的一部分。</p></blockquote><p>一旦分表，一个库中的表会越来越多</p><blockquote><p>将整个数据库比作图书馆，一张表就是一本书。当要在一本书中查找某项内容时，如果不分章节，查找的效率将会下降。而同理，在数据库中就是分区。</p></blockquote><ul><li><strong>什么时候考虑使用分区</strong>：一张表的查询速度已经慢到影响使用的时候。</li></ul><blockquote><ol><li>sql经过优化</li><li>数据量大</li><li>表中的数据是分段的</li><li>对数据的操作往往只涉及一部分数据，而不是所有的数据</li></ol></blockquote><ul><li><p><strong>分区解决的问题</strong>：主要可以提升查询效率</p></li><li><p><strong>分区的实现方式</strong>（简单）：</p></li></ul><blockquote><p>mysql5 开始支持分区功能</p><p>CREATE TABLE sales (</p><p>id INT AUTO_INCREMENT,</p><p>amount DOUBLE NOT NULL,</p><p>order_day DATETIME NOT NULL,</p><p>PRIMARY KEY(id, order_day)</p><p>) ENGINE=Innodb</p><p>PARTITION BY RANGE(YEAR(order_day)) (</p><p>PARTITION p_2010 VALUES LESS THAN (2010),</p><p>PARTITION p_2011 VALUES LESS THAN (2011),</p><p>PARTITION p_2012 VALUES LESS THAN (2012),</p><p>PARTITION p_catchall VALUES LESS THAN MAXVALUE);</p></blockquote><ul><li>事实上，这个方案也不错，<strong>它对用户屏蔽了sharding的细节，即使查询条件没有sharding column，它也能正常工作（只是这时候性能一般）。</strong></li><li>不过它的缺点很明显：<strong>很多的资源都受到单机的限制，例如连接数，网络吞吐等</strong>！虽然每个分区可以独立存储，但是分区表的总入口还是一个MySQL示例。从而导致它的并发能力非常一般，远远达不到互联网高并发的要求！</li><li>至于网上提到的一些其他缺点比如：无法使用外键，不支持全文索引。我认为这都不算缺点，21世纪的项目如果还是使用外键和数据库的全文索引，我都懒得吐槽了！</li></ul><p>所以，<strong>如果使用分区表，你的业应该具备如下两个特点：</strong></p><blockquote><p>数据不是海量（分区数有限，存储能力就有限）；</p><p>并发能力要求不高；</p></blockquote><h1 id="分库分表概述"><a href="#分库分表概述" class="headerlink" title="分库分表概述"></a>分库分表概述</h1><p><img src="分库分表概述.jpg" alt="分库分表概述"></p><blockquote><p>读写分离：分散数据库读写操作压力</p><p>分库分表：分散存储压力</p></blockquote><h1 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h1><p><img src="适用场景.png" alt="适用场景"></p><ul><li>类似读写分离，分库分表也是确定没有其他优化空间之后才采取的优化方案。</li><li>那如果业务真的发展很快岂不是很快要进行分库分表了？那为何不一开始就设计好呢？</li></ul><p><strong>按照架构设计的“三原则”（简单原则，合适原则，演化原则）</strong>，简单分析一下：</p><blockquote><p>首先，<strong>这里的“如果”事实上发生的概率比较低</strong>，做10个业务有一个业务能活下去就很不错了，更何况快速发展，和中彩票的概率差不多。如果我们每个业务上来就按照淘宝、微信的规模去做架构设计，不但会累死自己，还会害死业务。</p><p>其次，<strong>如果业务真的发展很快，后面进行分库分表也不迟</strong>。因为业务发展好，相应的资源投入就会加大，可以投入更多的人和更多的钱，那业务分库带来的代码和业务复杂问题就可以通过加人来解决，成本问题也可以通过增加资金来解决。</p></blockquote><h1 id="分库分表的方式方法"><a href="#分库分表的方式方法" class="headerlink" title="分库分表的方式方法"></a>分库分表的方式方法</h1><blockquote><p>一般就是<strong>垂直切分和水平切分</strong>，这是一种结果集描述的切分方式，是物理空间上的切分。</p><p>我们从面临的问题，开始解决，阐述： 首先是用户请求量太大，我们就堆机器搞定（这不是本文重点）。</p><p>然后是单个库太大，这时我们要看是因为<strong>表多而导致数据多</strong>，还是因为<strong>单张表里面的数据多</strong>。</p><p>如果是因为表多而数据多，使用垂直切分，根据业务切分成不同的库。</p><p>如果是因为单张表的数据量太大，这时要用水平切分，即把表的数据按<strong>某种规则</strong>切分成多张表，甚至多个库上的多张表。 </p><p><strong>分库分表的顺序应该是先垂直分，后水平分</strong>。 因为垂直分更简单，更符合我们处理现实世界问题的方式。</p></blockquote><h2 id="垂直拆分"><a href="#垂直拆分" class="headerlink" title="垂直拆分"></a>垂直拆分</h2><h3 id="垂直分表"><a href="#垂直分表" class="headerlink" title="垂直分表"></a>垂直分表</h3><blockquote><p>也就是“大表拆小表”，基于列字段进行的。</p><p>一般是表中的字段较多，将不常用的， 数据较大，长度较长（比如text类型字段）的拆分到“扩展表“。</p><p>一般是针对那种几百列的大表，也避免查询时，数据量太大造成的“跨页”问题。</p></blockquote><h4 id="垂直分库"><a href="#垂直分库" class="headerlink" title="垂直分库"></a>垂直分库</h4><blockquote><p>垂直分库针对的是一个系统中的不同业务进行拆分，比如用户User一个库，商品Producet一个库，订单Order一个库。</p><p>切分后，要放在多个服务器上，而不是一个服务器上。</p><p>为什么？ 我们想象一下，一个购物网站对外提供服务，会有用户，商品，订单等的CRUD。没拆分之前， 全部都是落到单一的库上的，这会让数据库的<strong>单库处理能力成为瓶颈</strong>。</p><p>按垂直分库后，如果还是放在一个数据库服务器上， 随着用户量增大，这会让<strong>单个数据库的处理能力成为瓶颈</strong>，还有<strong>单个服务器的磁盘空间，内存，tps等非常吃紧</strong>。 所以我们要拆分到多个服务器上，这样上面的问题都解决了，以后也不会面对单机资源问题。</p><p>数据库业务层面的拆分，和服务的“治理”，“降级”机制类似，也能对不同业务的数据分别的进行管理，维护，监控，扩展等。</p><p>数据库往往最容易成为应用系统的瓶颈，<strong>而数据库本身属于“有状态”的，相对于Web和应用服务器来讲，是比较难实现“横向扩展”的。</strong></p><p>数据库的连接资源比较宝贵且单机处理能力也有限，在高并发场景下，垂直分库一定程度上能够突破IO、连接数及单机硬件资源的瓶颈。</p></blockquote><p><img src="业务分库1.jpg" alt="业务分库1"></p><p><img src="业务分库2.jpg" alt="业务分库2"></p><h2 id="水平拆分"><a href="#水平拆分" class="headerlink" title="水平拆分"></a>水平拆分</h2><h3 id="水平分表"><a href="#水平分表" class="headerlink" title="水平分表"></a>水平分表</h3><blockquote><p>针对数据量巨大的单张表（比如订单表），按照某种规则（<strong>RANGE，HASH取模</strong>等），切分到多张表里面去。 但是这些表还是在同一个库中，所以<strong>库级别的数据库操作还是有IO瓶颈</strong>。不建议采用。</p></blockquote><h3 id="水平分库分表"><a href="#水平分库分表" class="headerlink" title="水平分库分表"></a>水平分库分表</h3><blockquote><p>将单张表的数据切分到多个服务器上去，每个服务器具有相应的库与表，只是表中数据集合不同。 水平分库分表能够有效的缓解单机和单库的性能瓶颈和压力，突破IO、连接数、硬件资源等的瓶颈。</p></blockquote><h3 id="水平分库分表切分规则"><a href="#水平分库分表切分规则" class="headerlink" title="水平分库分表切分规则"></a>水平分库分表切分规则</h3><p><strong>RANGE</strong></p><blockquote><p>从0到10000一个表，10001到20000一个表；</p></blockquote><p><strong>HASH取模</strong></p><blockquote><p>一个商场系统，一般都是将用户，订单作为主表，然后将和它们相关的作为附表，这样不会造成跨库事务之类的问题。 <strong>取用户id，然后hash取模</strong>，分配到不同的数据库上。</p></blockquote><p><strong>地理区域</strong></p><blockquote><p>比如按照华东，华南，华北这样来区分业务，七牛云应该就是如此。</p></blockquote><p><strong>时间</strong></p><blockquote><p>按照时间切分，就是将6个月前，甚至一年前的数据切出去放到另外的一张表，因为随着时间流逝，这些表的数据 被查询的概率变小，所以没必要和“热数据”放在一起，这个也是“冷热数据分离”。</p></blockquote><h2 id="业务分表"><a href="#业务分表" class="headerlink" title="业务分表"></a>业务分表</h2><p><img src="业务分表.png" alt="业务分表"></p><p><img src="业务分表2.jpg" alt="业务分表2"></p><h1 id="分库分表后面临的问题"><a href="#分库分表后面临的问题" class="headerlink" title="分库分表后面临的问题"></a>分库分表后面临的问题</h1><h2 id="事务支持"><a href="#事务支持" class="headerlink" title="事务支持"></a>事务支持</h2><blockquote><p>分库分表后，就成了<strong>分布式事务</strong>了。</p><p>如果依赖数据库本身的分布式事务管理功能去执行事务，将付出高昂的性能代价； 如果由应用程序去协助控制，形成程序逻辑上的事务，又会造成编程方面的负担。</p></blockquote><h2 id="路由问题："><a href="#路由问题：" class="headerlink" title="路由问题："></a>路由问题：</h2><blockquote><p>垂直分表：增加表操作的次数</p><p>水平分表：<strong>路由问题</strong></p></blockquote><p> <img src="路由问题.jpg" alt="路由问题"></p><h2 id="数据库操作问题"><a href="#数据库操作问题" class="headerlink" title="数据库操作问题"></a>数据库操作问题</h2><h3 id="多库结果集合并（group-by，order-by）"><a href="#多库结果集合并（group-by，order-by）" class="headerlink" title="多库结果集合并（group by，order by）"></a>多库结果集合并（group by，order by）</h3><h3 id="跨库join"><a href="#跨库join" class="headerlink" title="跨库join"></a>跨库join</h3><blockquote><p>分库分表后表之间的关联操作将受到限制，我们无法join位于不同分库的表，也无法join分表粒度不同的表， 结果原本一次查询能够完成的业务，可能需要多次查询才能完成。</p><p>粗略的解决方法： 全局表：基础数据，所有库都拷贝一份。 字段冗余：这样有些字段就不用join去查询了。 系统层组装：分别查询出所有，然后组装起来，较复杂。</p></blockquote><p><img src="数据库操作问题.png" alt="数据库操作问题"></p><ul><li>解决方法</li></ul><p><img src="解决方法.png" alt="解决方法"></p><p>类似读写分离，具体实现也是“程序代码封装”和“中间件封装”，但具体实现复杂一些，因为还有要判断SQL中具体操作的表，具体操作（例如count、order by、group by等），根据具体操作做不同的处理。</p><h2 id="多分片（水平切分）返回结果合并（排序）"><a href="#多分片（水平切分）返回结果合并（排序）" class="headerlink" title="多分片（水平切分）返回结果合并（排序）"></a>多分片（水平切分）返回结果合并（排序）</h2><h3 id="①-Select-None-Aggregate-Function的有序记录合并排序"><a href="#①-Select-None-Aggregate-Function的有序记录合并排序" class="headerlink" title="① Select + None Aggregate Function的有序记录合并排序"></a>① Select + None Aggregate Function的有序记录合并排序</h3><blockquote><p>解决思路：对各分片返回的有序记录，进行排序去重合并。此处主要是编写排序去重合并算法。</p></blockquote><h3 id="②-Select-None-Aggregate-Function的无序记录合并"><a href="#②-Select-None-Aggregate-Function的无序记录合并" class="headerlink" title="② Select + None Aggregate Function的无序记录合并"></a>② Select + None Aggregate Function的无序记录合并</h3><blockquote><p>解决思路：对各分片返回的无序记录，进行去重合并。</p><ul><li>优点：实现比较简单。</li><li>缺点：数据量越大，字段越多，去重处理就会越耗时。</li></ul></blockquote><h3 id="③-Select-Aggregate-Function的记录合并（排序）Oracle常用聚合函数：Count、Max、Min、Avg、Sum。"><a href="#③-Select-Aggregate-Function的记录合并（排序）Oracle常用聚合函数：Count、Max、Min、Avg、Sum。" class="headerlink" title="③ Select + Aggregate Function的记录合并（排序）Oracle常用聚合函数：Count、Max、Min、Avg、Sum。"></a>③ Select + Aggregate Function的记录合并（排序）Oracle常用聚合函数：Count、Max、Min、Avg、Sum。</h3><blockquote><ul><li>AF：Max、Min<ul><li>思路：通过算法对各分片返回结果再求max、min值。</li></ul></li><li>AF：Avg、Sum、Count<ul><li>思路：分片间无重复记录或字段时，通过算法对各分片返回结果再求avg、sum、count值。分片间有重复记录或字段时，先对各分片记录去重合并，再通过算法求avg、sum、count值。</li></ul></li></ul></blockquote><p>比如：</p><blockquote><p>select count(*) from user</p><p>select count(deptno) from user;</p><p>select count(distinct deptno) from user;</p></blockquote><h2 id="多分片（水平切分）返回结果分页"><a href="#多分片（水平切分）返回结果分页" class="headerlink" title="多分片（水平切分）返回结果分页"></a>多分片（水平切分）返回结果分页</h2><blockquote><p>解决思路：合并各分片返回结果，逻辑分页。</p><ul><li>优点：  实现简单。</li><li>缺点：  数据量越大，缓存压力就越大。分片数据量越大，查询也会越慢。</li></ul></blockquote><h2 id="多分片（水平切分）查询有分组语法的合并"><a href="#多分片（水平切分）查询有分组语法的合并" class="headerlink" title="多分片（水平切分）查询有分组语法的合并"></a>多分片（水平切分）查询有分组语法的合并</h2><h3 id="①-Group-By-Having-None-Aggregate-Function时"><a href="#①-Group-By-Having-None-Aggregate-Function时" class="headerlink" title="① Group By Having + None Aggregate Function时"></a>① Group By Having + None Aggregate Function时</h3><blockquote><ul><li>Select + None Aggregate Function<ul><li>比如：select job user group by job;</li><li>思路：直接去重（排序）合并。</li></ul></li><li>Select + Aggregate Function<ul><li>比如：select max(sal),job user group by job;</li><li>思路：同Select + Aggregate Function的记录合并（排序）。</li></ul></li></ul></blockquote><h3 id="②-Group-By-Having-Aggregate-Function时"><a href="#②-Group-By-Having-Aggregate-Function时" class="headerlink" title="② Group By Having + Aggregate Function时"></a>② Group By Having + Aggregate Function时</h3><blockquote><p>解决思路：去掉having AF条件查询各分片，然后把数据放到一张表里。再用group by having 聚合函数查询。</p></blockquote><h2 id="分布式数据库架构—排序分组分页参考解决方案"><a href="#分布式数据库架构—排序分组分页参考解决方案" class="headerlink" title="分布式数据库架构—排序分组分页参考解决方案"></a>分布式数据库架构—排序分组分页参考解决方案</h2><blockquote><ul><li>解决方案1：Hadoop + Hive。<ul><li>思路：使用Hadoop HDFS来存储数据，通过Hdoop MapReduce完成数据计算，通过Hive HQL语言使用部分与RDBBS一样的表格查询特性和分布式存储计算特性。</li><li>优点：<ul><li>可以解决问题</li><li>具有并发处理能力</li><li>可以离线处理</li></ul></li><li>缺点： <ul><li>实时性不能保证</li><li>网络延迟会增加</li><li>异常捕获难度增加</li><li>Web应用起来比较复杂</li></ul></li></ul></li><li>解决方案2：总库集中查询。<ul><li>优点：<ul><li>可以解决问题</li><li>实现简单</li></ul></li><li>缺点：<ul><li>总库数据不能太大</li><li>并发压力大</li></ul></li></ul></li></ul></blockquote><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>对于分布式数据库架构来说，排序、分页、分组一直就是一个比较复杂的问题。避免此问题需要好好地设计分库、分表策略。同时根据特定的场景来解决问题。也可以 充分利用海量数据存储（Hadoop-HDFS|Hive|HBse）、搜索引擎（Lucene|Solr）及分布式计算（MapReduce）等技术来 解决问题。</p><p>另外，也可以用NoSQL技术替代关系性数据库来解决问题，比如MogonDB/Redis。</p><h1 id="参考（COPY）资料"><a href="#参考（COPY）资料" class="headerlink" title="参考（COPY）资料"></a>参考（COPY）资料</h1><ol><li><a href="https://blog.csdn.net/fly910905/article/details/87090092">分库分表：应用场景、方式方法、面临问题</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;为什么要分库分表&quot;&gt;&lt;a href=&quot;#为什么要分库分表&quot; class=&quot;headerlink&quot; title=&quot;为什么要分库分表&quot;&gt;&lt;/a&gt;为什么要分库分表&lt;/h1&gt;&lt;p&gt;移动互联网时代，海量的用户每天产生海量的数量，比如：用户表、订单表、交易流水表。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="数据库" scheme="https://guoyujian.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库" scheme="https://guoyujian.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>【读书笔记】生而贫穷</title>
    <link href="https://guoyujian.github.io/2022/06/02/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91%E7%94%9F%E8%80%8C%E8%B4%AB%E7%A9%B7/"/>
    <id>https://guoyujian.github.io/2022/06/02/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91%E7%94%9F%E8%80%8C%E8%B4%AB%E7%A9%B7/</id>
    <published>2022-06-02T02:04:03.000Z</published>
    <updated>2022-06-02T02:04:03.611Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>第一个Spring应用</title>
    <link href="https://guoyujian.github.io/2022/05/26/%E7%AC%AC%E4%B8%80%E4%B8%AASpring%E5%BA%94%E7%94%A8/"/>
    <id>https://guoyujian.github.io/2022/05/26/%E7%AC%AC%E4%B8%80%E4%B8%AASpring%E5%BA%94%E7%94%A8/</id>
    <published>2022-05-26T15:38:02.000Z</published>
    <updated>2022-05-26T16:32:33.625Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本人以前学过Spring，也写过相关业务代码。但是对Spring理解不深刻，故重新认识Spring</p></blockquote><h1 id="初始化Spring项目"><a href="#初始化Spring项目" class="headerlink" title="初始化Spring项目"></a>初始化Spring项目</h1><p>我这里使用的是IDEA初始化Spring项目。</p><p>创建一个项目，并做如下设置，选择下一步。</p><p><img src="image-20220526234222155.png" alt="init"></p><p>配置新项目：</p><p><img src="image-20220526234348424.png" alt="config1"></p><p>选择Spring Boot的版本和插件，选择下一步。</p><p><img src="image-20220526234432034.png" alt="config2"></p><p>配置项目名称等。选择完成。</p><p><img src="image-20220526234505163.png" alt="config3"></p><blockquote><p>这里配置有问题也没关系，在pom.xml文件中做修改即可。</p></blockquote><h1 id="认识Spring项目"><a href="#认识Spring项目" class="headerlink" title="认识Spring项目"></a>认识Spring项目</h1><blockquote><p>本项目上传到了GitHub：<a href="https://github.com/guoyujian/spring-in-action5-code">https://github.com/guoyujian/spring-in-action5-code</a></p></blockquote><h2 id="mvnw和mvnw-cmd"><a href="#mvnw和mvnw-cmd" class="headerlink" title="mvnw和mvnw.cmd"></a>mvnw和mvnw.cmd</h2><p>mvnw和mvnw.cmd是Maven包装器（wrapper）脚本。借助这些脚本，即便你的机器上没有安装Maven，也可以构建项目。</p><h2 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h2><p>下面是我的pom.xml配置</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;version&gt;2.7.0&lt;/version&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>sia<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>taco-cloud<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>taco-cloud<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Taco Cloud Example<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>11<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--以下都是我加的--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>注意几点：</p><ol><li>parent/version标签指定了所有Spring相关包的版本，这样我们就不用在下面的dependency中配置版本。</li><li>packaging指出了打包方式，相比于war，jar更加流行。</li><li>properties/java.version指定了运行的java版本</li><li>dependencies标签下面全是依赖。其实一个最基本的项目是不需要这么多dependency的。可以自行注释掉这些dependency测试一下。</li></ol></blockquote><h2 id="TacoCloudApplication"><a href="#TacoCloudApplication" class="headerlink" title="TacoCloudApplication"></a>TacoCloudApplication</h2><p>这是主类。代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TacoCloudApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(TacoCloudApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中最重要的是@SpringBootApplication注解，这是一个组合注解，它组合了3个其他的注解：</p><ul><li>@SpringBootConfiguration：将该类声明为配置类。尽管这个类目前还没有太多的配置，但是后续我们可以按需添加基于Java的Spring框架配置。这个注解实际上是@Configuration注解的特殊形式。</li><li>@EnableAutoConfiguration：启用Spring Boot的自动配置。我们随后会介绍自动配置的更多功能。就现在来说，我们只需要知道这个注解会告诉Spring Boot自动配置它认为我们会用到的组件。</li><li>@ComponentScan：启用组件扫描。这样我们能够通过像@Component、@Controller、@Service这样的注解声明其他类，Spring会自动发现它们并将它们注册为Spring应用上下文中的组件。</li></ul><h2 id="TacoCloudApplicationTests"><a href="#TacoCloudApplicationTests" class="headerlink" title="TacoCloudApplicationTests"></a>TacoCloudApplicationTests</h2><p>测试类。后面细讲。</p><h2 id="resources"><a href="#resources" class="headerlink" title="resources/"></a>resources/</h2><p>该目录下，有</p><p><code>templates/</code>：存放thymeleaf模板，由于现在前后端分离开发，thymeleaf是用来代替jsp的一个东西，所以这个文件夹和thymeleaf没那么重要。</p><p><code>static/</code>：存放静态资源，图片，JS啥的，同上，不重要</p><p><code>application.properties</code>：Spring的配置文件，可以是yml，重要</p><h1 id="编写简单的Spring应用"><a href="#编写简单的Spring应用" class="headerlink" title="编写简单的Spring应用"></a>编写简单的Spring应用</h1><h2 id="MyController"><a href="#MyController" class="headerlink" title="MyController"></a>MyController</h2><p>在<code>tacos</code>包下面加入MyController，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/home&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">home</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;home&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>该类有一个@Controller注解所以Spring的组件扫描功能会自动发现它，并创建一个HomeController实例作为Spring应用上下文中的bean。实际上，有一些其他的注解与@Controller有着类似的目的（包括@Component、@Service和@Repository）。你可以为HomeController添加上述的任意其他注解，其作用是完全相同的。但是，在这里选择使用@Controller更能描述这个组件在应用中的角色。</p><p>home()是一个简单的控制器方法。它带有@GetMapping注解，表明如果针对<code>/home</code>发送HTTP GET请求，那么这个方法将会处理请求。</p><p>该方法所做的只是返回String类型的home值。这个值将会被解析为视图的逻辑名。视图如何实现取决于多个因素，但是因为Thymeleaf位于类路径中，所以我们可以使用Thymeleaf来定义模板。</p><p>模板名称是由逻辑视图名派生而来的，再加上“/templates/”前缀和“.html”后缀。最终形成的模板路径将是“/templates/home.html”。所以，我们需要将模板放到项目的“/src/main/resources/templates/home.html”目录中。</p><h2 id="home-html"><a href="#home-html" class="headerlink" title="home.html"></a>home.html</h2><p>这块代码很简单：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">hello!</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="编写测试类"><a href="#编写测试类" class="headerlink" title="编写测试类"></a>编写测试类</h2><p>在上面的TacoCloudApplicationTests测试类中编写代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.hamcrest.Matchers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.web.servlet.MockMvc;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.web.servlet.RequestBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@WebMvcTest(MyController.class)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TacoCloudApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MockMvc mvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHomePage</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        mvc.perform(MockMvcRequestBuilders.get(<span class="string">&quot;/home&quot;</span>))</span><br><span class="line">                .andExpect(MockMvcResultMatchers.status().isOk())</span><br><span class="line">                .andExpect(MockMvcResultMatchers.view().name(<span class="string">&quot;home&quot;</span>))</span><br><span class="line">                .andExpect(MockMvcResultMatchers.content().string(Matchers.containsString(<span class="string">&quot;hello&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这个类带有@RunWith(SpringRunner.class)注解。@RunWith是JUnit的注解，它会提供一个测试运行器（runner）来指导JUnit如何运行测试。可以将其想象为给JUnit应用一个插件，以提供自定义的测试行为。在本例中，为JUnit提供的是SpringRunner，这是一个Spring提供的测试运行器，它会创建测试运行所需的Spring应用上下文。</p><p>@WebMvcTest注解。这是Spring Boot所提供的一个特殊测试注解，它会让这个测试在Spring MVC应用的上下文中执行。更具体来讲，在本例中，它会将MyController注册到Spring MVC中，这样的话，我们就可以向它发送请求了。</p><p>测试类被注入了一个MockMvc，能够让测试实现mockup。通过testHomePage()方法，我们定义了针对主页想要执行的测试。它首先使用MockMvc对象对“/home”（根路径）发起HTTP GET请求。对于这个请求，我们设置了如下的预期（assert）：</p><ul><li>响应应该具备HTTP 200 (OK)状态</li><li>视图的逻辑名称应该是home</li><li>渲染后的视图应该包含文本hello</li></ul><blockquote><p>注意，如果Spring版本为2.7.0，这里@Autowired会报错，目前还不知道为什么。</p></blockquote><p>执行这个测试类，发现程序执行成功了。</p><p><img src="image-20220527003138947.png" alt="res"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对本人来说，最大的收获就是如何编写测试类，对Spring应用进行快速测试。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>《Spring 实战（第五版）》</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本人以前学过Spring，也写过相关业务代码。但是对Spring理解不深刻，故重新认识Spring&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;初始化Spring项目&quot;&gt;&lt;a href=&quot;#初始化Spring项目&quot; class=&quot;heade</summary>
      
    
    
    
    <category term="Java" scheme="https://guoyujian.github.io/categories/Java/"/>
    
    <category term="Springy" scheme="https://guoyujian.github.io/categories/Java/Springy/"/>
    
    
    <category term="Java" scheme="https://guoyujian.github.io/tags/Java/"/>
    
    <category term="Spring" scheme="https://guoyujian.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Java8 流（1）</title>
    <link href="https://guoyujian.github.io/2022/05/22/Java8-%E6%B5%81%EF%BC%881%EF%BC%89/"/>
    <id>https://guoyujian.github.io/2022/05/22/Java8-%E6%B5%81%EF%BC%881%EF%BC%89/</id>
    <published>2022-05-22T07:08:00.000Z</published>
    <updated>2022-05-22T07:08:00.675Z</updated>
    
    <content type="html"><![CDATA[<h1 id="流是什么"><a href="#流是什么" class="headerlink" title="流是什么"></a>流是什么</h1><p>流是Java API的新成员，它允许你以<strong>声明性</strong>方式处理数据集合（通过查询语句来表达，而不是临时编写一个实现）。就现在来说，你可以把它们看成遍历数据集的高级迭代器。</p><p>此外，流还可以透明的并行处理，你无需写任何多线程代码了！</p><hr><p>在继续介绍之前，先定义一会要使用到的集合对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Dish&gt; menu = Arrays.asList(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Dish</span>(<span class="string">&quot;pork&quot;</span>, <span class="literal">false</span>, <span class="number">800</span>, Dish.Type.MEAT),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Dish</span>(<span class="string">&quot;beef&quot;</span>, <span class="literal">false</span>, <span class="number">700</span>, Dish.Type.MEAT),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Dish</span>(<span class="string">&quot;chicken&quot;</span>, <span class="literal">false</span>, <span class="number">400</span>, Dish.Type.MEAT),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Dish</span>(<span class="string">&quot;french fries&quot;</span>, <span class="literal">true</span>, <span class="number">530</span>, Dish.Type.OTHER),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Dish</span>(<span class="string">&quot;rice&quot;</span>, <span class="literal">true</span>, <span class="number">350</span>, Dish.Type.OTHER),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Dish</span>(<span class="string">&quot;season fruit&quot;</span>, <span class="literal">true</span>, <span class="number">120</span>, Dish.Type.OTHER),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Dish</span>(<span class="string">&quot;pizza&quot;</span>, <span class="literal">true</span>, <span class="number">550</span>, Dish.Type.OTHER),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Dish</span>(<span class="string">&quot;prawns&quot;</span>, <span class="literal">false</span>, <span class="number">300</span>, Dish.Type.FISH),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Dish</span>(<span class="string">&quot;salmon&quot;</span>, <span class="literal">false</span>, <span class="number">450</span>, Dish.Type.FISH) );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Dish对象的声明如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dish</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> vegetarian;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> calories;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Type type;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dish</span><span class="params">(String name, <span class="type">boolean</span> vegetarian, <span class="type">int</span> calories, Type type)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.vegetarian = vegetarian;</span><br><span class="line">        <span class="built_in">this</span>.calories = calories;</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//getter、setter</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Type</span> &#123;MEAT, FISH, OTHER&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="流简介"><a href="#流简介" class="headerlink" title="流简介"></a>流简介</h1><blockquote><p>简短的定义就是“从支持数据处理操作的源生成的元素序列”</p></blockquote><ul><li><strong>元素序列</strong>——就像集合一样，流也提供了一个接口，可以访问特定元素类型的一组有序值。因为集合是数据结构，所以它的主要目的是以特定的时间/空间复杂度存储和访问元素（如ArrayList 与 LinkedList）。但流的目的在于表达计算。<strong>集合讲的是数据，流讲的是计算</strong>。我们会在后面详细解 释这个思想。</li><li><strong>源</strong>——流会使用一个提供数据的源，如集合、数组或输入/输出资源。 请注意，从有序集合生成流时会保留原有的顺序。由列表生成的流，其元素顺序与列表一致。</li><li><strong>数据处理操作</strong>——流的数据处理功能支持类似于数据库的操作，以及函数式编程语言中 的常用操作，如filter、map、reduce、find、match、sort等。流操作可以顺序执行，也可并行执行。</li></ul><p>此外，流操作有两个重要的特点。</p><ul><li><strong>流水线</strong>——很多流操作本身会返回一个流，这样多个操作就可以链接起来，形成一个大的流水线。这让一些优化成为可能，如延迟和短路。流水线的操作可以看作对数据源进行数据库式查询。</li><li><strong>内部迭代</strong>——与使用迭代器显式迭代的集合不同，流的迭代操作是在背后进行的。</li></ul><p>举例：筛选菜单中卡路里高于300的三个菜名</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; res = menu.stream()</span><br><span class="line">    .filter(d -&gt; d.getCalories() &gt; <span class="number">300</span>)</span><br><span class="line">    .map(d -&gt; d.getName())</span><br><span class="line">    .limit(<span class="number">3</span>)</span><br><span class="line">    .collect(Collectors.toList());</span><br><span class="line">System.out.println(res);</span><br></pre></td></tr></table></figure><blockquote><p>在本例中，我们先是对menu调用stream方法，由菜单得到一个流。<strong>数据源</strong>是菜单列表， 它给流提供一个<strong>元素序列</strong>。接下来，对流应用一系列数据处理操作：filter、map、limit 和collect。除了collect之外，所有这些操作都会返回另一个流，这样它们就可以接成一条流水线，于是就可以看作对源的一个查询。最后，collect操作开始处理流水线，并返回结果（它和别的操作不一样，因为它返回的不是流，在这里是一个List）。在调用collect之前，没有任何结果产生，实际上根本就没有从menu里选择元素。你可以这么理解：链中的方法调用都在排队等待，直到调用collect。</p></blockquote><p>过程如下：</p><p><img src="img1.png" alt="流可视化"></p><h1 id="流与集合"><a href="#流与集合" class="headerlink" title="流与集合"></a>流与集合</h1><blockquote><p>简单地说，集合与流之间的差异就在于什么时候进行计算。集合是一个内存中的数据结构， 它包含数据结构中目前所有的值——集合中的每个元素都得先算出来才能添加到集合中。（你可 以往集合里加东西或者删减东西，但是不管什么时候，集合中的每个元素都是放在内存里的，元素 都得先算出来才能成为集合的一部分。）</p><p>相比之下，流则是在概念上固定的数据结构（你不能添加或删除元素），其元素则是按需计 算的。</p></blockquote><ul><li>与集合不同，流只能遍历一次</li><li>集合是外部迭代，而流使用内部迭代——它帮你把迭代做了</li></ul><h1 id="流操作"><a href="#流操作" class="headerlink" title="流操作"></a>流操作</h1><p>stream定义了很多操作，分为两类：</p><ol><li>filter、map和limit可以连成一条流水线；</li><li>collect触发流水线执行并关闭它；</li></ol><p>可以连接起来的流操作称为中间操作，关闭流的操作称为终端操作。</p><p>总而言之，流的使用一般包括三件事：</p><ol><li>一个数据源（如集合）来执行一个查询；</li><li>一个中间操作链，形成一条流的流水线；</li><li>一个中间操作，执行流水线，并能生成结果。</li></ol><h1 id="使用流"><a href="#使用流" class="headerlink" title="使用流"></a>使用流</h1><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p>Streams接口支持filter方法（你现在应该很熟悉了）。该操作会接受一个<a href="https://geek-docs.com/java/java-tutorial/predicate.html">谓词</a>（一个返回 boolean的函数）作为参数，并返回一个包括所有符合谓词的元素的流。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 筛选所有素菜</span></span><br><span class="line">List&lt;Dish&gt; vegetarianMenu = menu.stream() </span><br><span class="line">                .filter(Dish::isVegetarian) </span><br><span class="line">                .collect(toList());</span><br></pre></td></tr></table></figure><h2 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h2><p>和数据库的distinct关键词很像，它会返回一个元素各异（即无重复的，根据流所生成元素的 hashCode和equals方法实现）的流。</p><h2 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h2><p>和数据库的limit关键词很像，该方法会返回一个不超过给定长度的流。</p><h2 id="skip"><a href="#skip" class="headerlink" title="skip"></a>skip</h2><p>流还支持skip(n)方法，返回一个扔掉了前n个元素的流。</p><h2 id="☆map"><a href="#☆map" class="headerlink" title="☆map"></a>☆map</h2><p><strong>对流中每一个元素应用函数</strong>。流支持map方法，这个方法接收一个函数作为参数，这个函数会被应用到流中的每个元素，并将其映 成一个新的元素，（创建新版本而不是修改原始流）例如，下面的代码把方法引用Dish::getName传给了map方法， 来提取流中菜肴的名称：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; dishNames = menu.stream() </span><br><span class="line">                             .map(Dish::getName) </span><br><span class="line">                             .collect(toList());</span><br></pre></td></tr></table></figure><h2 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h2><p>当给定单词列表<code>[&quot;Hello&quot;,&quot;World&quot;]</code>，想要返回各不相同的字符列表<code>[&quot;H&quot;,&quot;e&quot;,&quot;l&quot;, &quot;o&quot;,&quot;W&quot;,&quot;r&quot;,&quot;d&quot;]</code>。如果你使用<code>map(word -&gt; word.split(&quot;&quot;))</code>，你会发现这根本不起作用，这个方法的问题在于，传递给map方法的Lambda（word -&gt; word.split(“”)）为每个单词返回了一个String[]（String 列表）。因此，map返回的流实际上是Stream<String[]>类型的。你真正想要的是用 Stream来表示一个字符流。</p><p>此时你可以使用flatMap。使用flatMap方法的效果是，各个数组并不是分别映射成一个流，而映射成流的内容。所 有使用map(Arrays::stream)时生成的单个流都被合并起来，即扁平化为一个流。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; uniqueCharacters = words.stream() </span><br><span class="line">                                    .map(w -&gt; w.split(<span class="string">&quot;&quot;</span>)) </span><br><span class="line">                                    .flatMap(Arrays::stream) </span><br><span class="line">                                    .distinct() </span><br><span class="line">                                    .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><h2 id="查找与匹配"><a href="#查找与匹配" class="headerlink" title="查找与匹配"></a>查找与匹配</h2><blockquote><p> 另一个常见的数据处理操作是看看数据集中的某些元素是否匹配一个给定的属性， Stream API通过allMatch、anyMatch、noneMatch、findFirst和findAny方法提供了这样的工具。</p></blockquote><h3 id="anyMatch"><a href="#anyMatch" class="headerlink" title="anyMatch"></a>anyMatch</h3><p>anyMatch方法可以解决 “流中是否有一个元素能匹配给定的谓词”。比如，你可以用它来看看菜单里面是否有素食可选择：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">menu.stream().anyMatch(Dish::isVegetarian)</span><br></pre></td></tr></table></figure><p>anyMatch方法返回一个boolean，因此是一个终端操作</p><h3 id="allMatch"><a href="#allMatch" class="headerlink" title="allMatch"></a>allMatch</h3><p>allMatch方法会检查流中的元素是否都能匹配给定的谓词。</p><h3 id="noneMatch"><a href="#noneMatch" class="headerlink" title="noneMatch"></a>noneMatch</h3><p>noneMatch它可以确保流中没有任何元素与给定的谓词匹配。</p><h3 id="findany"><a href="#findany" class="headerlink" title="findany"></a>findany</h3><p>findAny方法将返回当前流中的任意元素，它返回的是<code>Optional&lt;T&gt;</code></p><h3 id="findFirst"><a href="#findFirst" class="headerlink" title="findFirst"></a>findFirst</h3><p>findFirst查找第一个元素</p><h2 id="归约"><a href="#归约" class="headerlink" title="归约"></a>归约</h2><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><p>使用reduce，你可以像下面这样对流中所有的元素求和：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int sum = numbers.stream().reduce(0, (a, b) -&gt; a + b);</span><br></pre></td></tr></table></figure><p>reduce接受两个参数：</p><ul><li>一个初始值，这里是0；</li><li>一个BinaryOperator来将两个元素结合起来产生一个新值，这里我们用的是 lambda (a, b) -&gt; a + b。</li></ul><p>你也很容易把所有的元素相乘，只需要将另一个Lambda：(a, b) -&gt; a * b传递给reduce 操作就可以了：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int product = numbers.stream().reduce(1, (a, b) -&gt; a * b);</span><br></pre></td></tr></table></figure><p>reduce还有一个重载的变体，它不接受初始值，但是会返回一个Optional对象：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Optional&lt;Integer&gt; sum = numbers.stream().reduce((a, b) -&gt; (a + b));</span><br></pre></td></tr></table></figure><blockquote><p>为什么它返回一个Optional呢？考虑流中没有任何元素的情况。reduce操作无 法返回其和，因为它没有初始值。这就是为什么结果被包裹在一个Optional对象里，以表明和可能不存在。</p><p>map和reduce的连接通常称为map-reduce模式，因Google用它来进行网络搜索而出名， 因为它很容易并行化。</p></blockquote><h3 id="中间操作和终端操作表"><a href="#中间操作和终端操作表" class="headerlink" title="中间操作和终端操作表"></a>中间操作和终端操作表</h3><p><img src="img2.png" alt="操作表"></p><h2 id="数值流"><a href="#数值流" class="headerlink" title="数值流"></a>数值流</h2><p>我们在前面看到了可以使用reduce方法计算流中元素的总和。例如，你可以像下面这样计 算菜单的热量：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int calories = menu.stream() </span><br><span class="line">                .map(Dish::getCalories) </span><br><span class="line">                .reduce(0, Integer::sum);</span><br></pre></td></tr></table></figure><p>这段代码的问题是，它有一个暗含的装箱成本。每个Integer都必须拆箱成一个原始类型， 再进行求和。但是Stream为我们提供了更好的解决办法</p><h3 id="原始类型流特化"><a href="#原始类型流特化" class="headerlink" title="原始类型流特化"></a>原始类型流特化</h3><p>Java 8引入了三个原始类型特化流接口来解决这个问题：IntStream、DoubleStream和 LongStream，分别将流中的元素特化为int、long和double，从而避免了暗含的装箱成本。</p><h3 id="映射到数值流"><a href="#映射到数值流" class="headerlink" title="映射到数值流"></a>映射到数值流</h3><p>将流转换为特化版本的常用方法是mapToInt、mapToDouble和mapToLong。这些方法和前 面说的map方法的工作方式一样，只是它们返回的是一个特化流，而不是Stream。</p><p>你可以像下面这样用mapToInt对menu中的卡路里求和：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int calories = menu.stream() </span><br><span class="line">                .mapToInt(Dish::getCalories) </span><br><span class="line">                .sum();</span><br></pre></td></tr></table></figure><blockquote><p>这里，mapToInt会从每道菜中提取热量（用一个Integer表示），并返回一个IntStream （而不是一个Stream）。然后你就可以调用IntStream接口中定义的sum方法，对卡 路里求和了！请注意，如果流是空的，sum默认返回0。IntStream还支持其他的方便方法，如 max、min、average等。</p></blockquote><h3 id="转换回对象流"><a href="#转换回对象流" class="headerlink" title="转换回对象流"></a>转换回对象流</h3><p>同样，一旦有了数值流，你可能会想把它转换回非特化流。例如，IntStream上的操作只能 产生原始整数： IntStream 的 map 操作接受的 Lambda 必须接受 int 并返回 int （一个IntUnaryOperator）。但是你可能想要生成另一类值，比如Dish。为此，你需要访问Stream 接口中定义的那些更广义的操作。要把原始流转换成一般流（每个int都会装箱成一个 Integer），可以使用boxed方法</p><h3 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a>数值范围</h3><p>假设你想要生成1和100之间的所有数值， Java 8引入了两个可以用于IntStream和LongStream的静态方法，帮助生成这种范围： range和rangeClosed。这两个方法都是第一个参数接受起始值，第二个参数接受结束值。但 range是不包含结束值的，而rangeClosed则包含结束值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里的范围是[1,100] 结果为50个</span></span><br><span class="line"><span class="type">int</span> <span class="variable">evenNumbers</span> <span class="operator">=</span> IntStream.rangeClosed(<span class="number">1</span>, <span class="number">100</span>)</span><br><span class="line">                            .filter(n -&gt; n % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                            .count();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的范围是[1,100) 不包含100 结果为49</span></span><br><span class="line"><span class="type">int</span> <span class="variable">evenNumbers2</span> <span class="operator">=</span> IntStream.range(<span class="number">1</span>, <span class="number">100</span>)</span><br><span class="line">                            .filter(n -&gt; n % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                            .count();</span><br></pre></td></tr></table></figure><h3 id="应用：勾股数"><a href="#应用：勾股数" class="headerlink" title="应用：勾股数"></a>应用：勾股数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">生成N个勾股数三元组，例(3,4,5), (5,12,13)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Stream&lt;<span class="type">double</span>[]&gt; stream = IntStream.rangeClosed(<span class="number">1</span>, <span class="number">100</span>) <span class="comment">// 生成1-100的int(a)</span></span><br><span class="line">    .boxed() <span class="comment">//封装为Stream&lt;Integer&gt;才能继续流的操作</span></span><br><span class="line">    .flatMap(a -&gt; IntStream.rangeClosed(a, <span class="number">100</span>) <span class="comment">//// 生成a-100的int(b)</span></span><br><span class="line">             .mapToObj(b -&gt; <span class="keyword">new</span> <span class="title class_">double</span>[]&#123;a, b, Math.sqrt(a * a + b * b)&#125;)) <span class="comment">//生成三元组 a,b,a^2+b^2的开方</span></span><br><span class="line">    .filter(t -&gt; t[<span class="number">2</span>] % <span class="number">1</span> == <span class="number">0</span>); <span class="comment">// 筛选掉非整数</span></span><br><span class="line">stream.limit(<span class="number">4</span>).forEach(t -&gt; System.out.println(t[<span class="number">0</span>] + <span class="string">&quot;, &quot;</span> + t[<span class="number">1</span>] + <span class="string">&quot;, &quot;</span> + t[<span class="number">2</span>])); <span class="comment">//打印前四个</span></span><br></pre></td></tr></table></figure><h2 id="构建流"><a href="#构建流" class="headerlink" title="构建流"></a>构建流</h2><h3 id="由值创建流"><a href="#由值创建流" class="headerlink" title="由值创建流"></a>由值创建流</h3><p>你可以使用静态方法<code>Stream.of</code>，通过显式值创建一个流。它可以接受任意数量的参数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;Java 8 &quot;</span>, <span class="string">&quot;Lambdas &quot;</span>, <span class="string">&quot;In &quot;</span>, <span class="string">&quot;Action&quot;</span>); </span><br></pre></td></tr></table></figure><p>你可以使用empty得到一个空流，如下所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; emptyStream = Stream.empty();</span><br></pre></td></tr></table></figure><h3 id="数组创建流"><a href="#数组创建流" class="headerlink" title="数组创建流"></a>数组创建流</h3><p>你可以使用静态方法<code>Arrays.stream</code>从数组创建一个流。它接受一个数组作为参数。例如， 你可以将一个原始类型int的数组转换成一个IntStream，如下所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] numbers = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;; </span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> Arrays.stream(numbers).sum();</span><br></pre></td></tr></table></figure><h3 id="由文件生成流"><a href="#由文件生成流" class="headerlink" title="由文件生成流"></a>由文件生成流</h3><p>Java中用于处理文件等I/O操作的NIO API（非阻塞I/O）已更新，以便利用Stream API。 java.nio.file.Files中的很多静态方法都会返回一个流。</p><blockquote><p>例如，一个很有用的方法是Files.lines，它会返回一个由指定文件中的各行构成的字符串流。使用你迄今所学的内容， 你可以用这个方法看看一个文件中有多少各不相同的词：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">uniqueWords</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">Stream&lt;String&gt; lines = Files.lines(Paths.get(<span class="string">&quot;data.txt&quot;</span>), </span><br><span class="line">uniqueWords = lines.flatMap(line -&gt; Arrays.stream(line.split(<span class="string">&quot; &quot;</span>)))</span><br><span class="line">                .distinct() </span><br><span class="line">                .count(); </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="由函数生成无限流"><a href="#由函数生成无限流" class="headerlink" title="由函数生成无限流"></a>由函数生成无限流</h3><p>Stream API提供了两个静态方法来从函数生成流：Stream.iterate和Stream.generate。 这两个操作可以创建所谓的无限流：不像从固定集合创建的流那样有固定大小的流。由iterate 和generate产生的流会用<strong>给定的函数按需创建值</strong>，因此可以无穷无尽地计算下去！一般来说， 应该使用limit(n)来对这种流加以限制</p><h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><p>我们先来看一个iterate的简单例子，然后再解释：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.iterate(<span class="number">0</span>, n -&gt; n + <span class="number">2</span>) </span><br><span class="line">    .limit(<span class="number">10</span>) </span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>iterate方法接受一个初始值（在这里是0），还有一个依次应用在每个产生的新值上的 Lambda（UnaryOperator类型）。这里，我们使用Lambda n -&gt; n + 2，返回的是前一个元 素加上2</p><h4 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h4><p>与iterate方法类似，generate方法也可让你按需生成一个无限流。但generate不是依次 对每个新生成的值应用函数的。它接受一个Supplier类型的Lambda提供新的值。我们先来 看一个简单的用法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.generate(Math::random) </span><br><span class="line">    .limit(<span class="number">5</span>) </span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>这段代码将生成一个流，其中有五个0到1之间的随机双精度数。例如，运行一次得到了下面 的结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0.9410810294106129 </span><br><span class="line">0.6586270755634592 </span><br><span class="line">0.9592859117266873 </span><br><span class="line">0.13743396659487006 </span><br><span class="line">0.3942776037651241</span><br></pre></td></tr></table></figure><p>Math.Random静态方法被用作新值生成器。</p><p>详略。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>《Java8 实战》</li><li><a href="https://github.com/caotinging/Java8Action#%E6%B5%81%E6%98%AF%E4%BB%80%E4%B9%88">《java8实战》学习笔记</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;流是什么&quot;&gt;&lt;a href=&quot;#流是什么&quot; class=&quot;headerlink&quot; title=&quot;流是什么&quot;&gt;&lt;/a&gt;流是什么&lt;/h1&gt;&lt;p&gt;流是Java API的新成员，它允许你以&lt;strong&gt;声明性&lt;/strong&gt;方式处理数据集合（通过查询语句来表达，而不是</summary>
      
    
    
    
    <category term="Java" scheme="https://guoyujian.github.io/categories/Java/"/>
    
    <category term="Java8" scheme="https://guoyujian.github.io/categories/Java/Java8/"/>
    
    
    <category term="Java" scheme="https://guoyujian.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>经典内排序算法汇总</title>
    <link href="https://guoyujian.github.io/2022/05/18/%E7%BB%8F%E5%85%B8%E5%86%85%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/"/>
    <id>https://guoyujian.github.io/2022/05/18/%E7%BB%8F%E5%85%B8%E5%86%85%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/</id>
    <published>2022-05-18T14:46:51.772Z</published>
    <updated>2022-04-12T14:57:08.874Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文介绍几种经典、常考的内排序算法。</p><p>本文试图建立一个比较标准的快速排序、归并排序、堆排序算法代码。</p><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>了解。</p><h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>每一轮选取未排定的部分中<strong>最小</strong>的部分交换到未排定部分的最开头，经过若干个步骤，就能排定整个数组。即：先选出最小的，再选出第 2 小的，以此类推。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>略</p><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>了解</p><h2 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h2><p>每次将一个数字插入一个有序的数组里，成为一个长度更长的有序数组，有限次操作以后，数组整体有序。</p><p><img src="插入排序.gif" alt="插入排序排序"></p><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><p>略</p><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>了解</p><h2 id="算法思想-2"><a href="#算法思想-2" class="headerlink" title="算法思想"></a>算法思想</h2><p>外层循环每一次经过两两比较，把每一轮未排定部分最大的元素放到了数组的末尾；<br>「冒泡排序」有个特点：在遍历的过程中，提前检测到数组是有序的，从而结束排序，而不像「选择排序」那样，即使输入数据是有序的，「选择排序」依然需要「傻乎乎」地走完所有的流程。</p><h2 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h2><p>略</p><h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p>了解</p><h2 id="算法思想-3"><a href="#算法思想-3" class="headerlink" title="算法思想"></a>算法思想</h2><p>插入排序的优化。在插入排序里，如果靠后的数字较小，它来到前面就得交换多次。「希尔排序」改进了这种做法。带间隔地使用插入排序，直到最后「间隔」为 11 的时候，就是标准的「插入排序」，此时数组里的元素已经「几乎有序」了。</p><h2 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h2><p>略</p><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>重要</p><h2 id="算法思想-4"><a href="#算法思想-4" class="headerlink" title="算法思想"></a>算法思想</h2><p>快速排序每一次都排定一个元素（这个元素呆在了它最终应该呆的位置），然后递归地去排它左边的部分和右边的部分，依次进行下去，直到数组有序。</p><h2 id="实现（递归）"><a href="#实现（递归）" class="headerlink" title="实现（递归）"></a>实现（递归）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//https://mp.weixin.qq.com/s/8ZTMhvHJK_He48PpSt_AmQ</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Quick</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 为了避免出现耗时的极端情况，先随机打乱</span></span><br><span class="line">        shuffle(nums);</span><br><span class="line">        <span class="comment">// 排序整个数组（原地修改）</span></span><br><span class="line">        sort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lo &gt;= hi) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对 nums[lo..hi] 进行切分</span></span><br><span class="line">        <span class="comment">// 使得 nums[lo..p-1] &lt;= nums[p] &lt; nums[p+1..hi]</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> partition(nums, lo, hi);</span><br><span class="line"></span><br><span class="line">        sort(nums, lo, p - <span class="number">1</span>);</span><br><span class="line">        sort(nums, p + <span class="number">1</span>, hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对 nums[lo..hi] 进行切分</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> nums[lo];</span><br><span class="line">        <span class="comment">// 关于区间的边界控制需格外小心，稍有不慎就会出错</span></span><br><span class="line">        <span class="comment">// 我这里把 i, j 定义为开区间，同时定义：</span></span><br><span class="line">        <span class="comment">// [lo, i) &lt;= pivot；(j, hi] &gt; pivot</span></span><br><span class="line">        <span class="comment">// 之后都要正确维护这个边界区间的定义</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo + <span class="number">1</span>, j = hi;</span><br><span class="line">        <span class="comment">// 当 i &gt; j 时结束循环，以保证区间 [lo, hi] 都被覆盖</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; hi &amp;&amp; nums[i] &lt;= pivot) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="comment">// 此 while 结束时恰好 nums[i] &gt; pivot</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; lo &amp;&amp; nums[j] &gt; pivot) &#123;</span><br><span class="line">                j--;</span><br><span class="line">                <span class="comment">// 此 while 结束时恰好 nums[j] &lt;= pivot</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 此时 [lo, i) &lt;= pivot &amp;&amp; (j, hi] &gt; pivot</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= j) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将 pivot 放到合适的位置，即 pivot 左边元素较小，右边元素较大</span></span><br><span class="line">        swap(nums, lo, j);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 洗牌算法，将输入的数组随机打乱</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shuffle</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 生成 [i, n - 1] 的随机数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> i + rand.nextInt(n - i);</span><br><span class="line">            swap(nums, i, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原地交换数组中的两个元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现（非递归）"><a href="#实现（非递归）" class="headerlink" title="实现（非递归）"></a>实现（非递归）</h2><p>暂略</p><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>重要</p><h2 id="算法思想-5"><a href="#算法思想-5" class="headerlink" title="算法思想"></a>算法思想</h2><p>借助额外空间，合并两个有序数组，得到更长的有序数组。</p><h2 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Merge</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于辅助合并有序数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] temp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 先给辅助数组开辟内存空间</span></span><br><span class="line">        temp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="comment">// 排序整个数组（原地修改）</span></span><br><span class="line">        sort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义：将子数组 nums[lo..hi] 进行排序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lo == hi) &#123;</span><br><span class="line">            <span class="comment">// 单个元素不用排序</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这样写是为了防止溢出，效果等同于 (hi + lo) / 2</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 先对左半部分数组 nums[lo..mid] 排序</span></span><br><span class="line">        sort(nums, lo, mid);</span><br><span class="line">        <span class="comment">// 再对右半部分数组 nums[mid+1..hi] 排序</span></span><br><span class="line">        sort(nums, mid + <span class="number">1</span>, hi);</span><br><span class="line">        <span class="comment">// 将两部分有序数组合并成一个有序数组</span></span><br><span class="line">        merge(nums, lo, mid, hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 nums[lo..mid] 和 nums[mid+1..hi] 这两个有序数组合并成一个有序数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> mid, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="comment">// 先把 nums[lo..hi] 复制到辅助数组中</span></span><br><span class="line">        <span class="comment">// 以便合并后的结果能够直接存入 nums</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo; i &lt;= hi; i++) &#123;</span><br><span class="line">            temp[i] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数组双指针技巧，合并两个有序数组</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo, j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> lo; p &lt;= hi; p++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == mid + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 左半边数组已全部被合并</span></span><br><span class="line">                nums[p] = temp[j++];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == hi + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 右半边数组已全部被合并</span></span><br><span class="line">                nums[p] = temp[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp[i] &gt; temp[j]) &#123;</span><br><span class="line">                nums[p] = temp[j++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[p] = temp[i++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>重要</p><h2 id="算法思想-6"><a href="#算法思想-6" class="headerlink" title="算法思想"></a>算法思想</h2><p>将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列。</p><h2 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">// 将数组整理成堆</span></span><br><span class="line">        heapify(nums);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环不变量：区间 [0, i] 堆有序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len - <span class="number">1</span>; i &gt;= <span class="number">1</span>; ) &#123;</span><br><span class="line">            <span class="comment">// 把堆顶元素（当前最大）交换到数组末尾</span></span><br><span class="line">            swap(nums, <span class="number">0</span>, i);</span><br><span class="line">            <span class="comment">// 逐步减少堆有序的部分</span></span><br><span class="line">            i--;</span><br><span class="line">            <span class="comment">// 下标 0 位置下沉操作，使得区间 [0, i] 堆有序</span></span><br><span class="line">            siftDown(nums, <span class="number">0</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将数组整理成堆（堆有序）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">// 只需要从 i = (len - 1) / 2 这个位置开始逐层下移</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (len - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            siftDown(nums, i, len - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k    当前下沉元素的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end  [0, end] 是 nums 的有效部分</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftDown</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span> * k + <span class="number">1</span> &lt;= end) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span> * k + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> &lt;= end &amp;&amp; nums[j + <span class="number">1</span>] &gt; nums[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; nums[k]) &#123;</span><br><span class="line">                swap(nums, j, k);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> index1, <span class="type">int</span> index2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[index1];</span><br><span class="line">        nums[index1] = nums[index2];</span><br><span class="line">        nums[index2] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="排序复杂度比较"><a href="#排序复杂度比较" class="headerlink" title="排序复杂度比较"></a>排序复杂度比较</h1><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/sort.png" alt="图片来源：菜鸟教程/十大经典排序"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://leetcode-cn.com/problems/sort-an-array/solution/fu-xi-ji-chu-pai-xu-suan-fa-java-by-liweiwei1419/">复习基础排序算法</a></li><li><a href="https://www.runoob.com/w3cnote/ten-sorting-algorithm.html">菜鸟教程：十大排序算法</a></li><li>《算法 第四版》</li><li><a href="https://mp.weixin.qq.com/s/8ZTMhvHJK_He48PpSt_AmQ">快速排序的正确理解方式及运用</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&amp;mid=2247495989&amp;idx=1&amp;sn=30e34ac75dd1c724205e9c8b0f488e35&amp;scene=21#wechat_redirect">归并排序的正确理解方式及运用</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文介绍几种经典、常考的内排序算法。&lt;/p&gt;
&lt;p&gt;本文试图建立一个比较标准的快速排序、归并排序、堆排序算法代码。&lt;/p&gt;
&lt;h1 id=&quot;</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://guoyujian.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="排序" scheme="https://guoyujian.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
    <category term="排序" scheme="https://guoyujian.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java8新特性1：行为参数化</title>
    <link href="https://guoyujian.github.io/2022/05/05/Java8%E6%96%B0%E7%89%B9%E6%80%A71%EF%BC%9A%E8%A1%8C%E4%B8%BA%E5%8F%82%E6%95%B0%E5%8C%96/"/>
    <id>https://guoyujian.github.io/2022/05/05/Java8%E6%96%B0%E7%89%B9%E6%80%A71%EF%BC%9A%E8%A1%8C%E4%B8%BA%E5%8F%82%E6%95%B0%E5%8C%96/</id>
    <published>2022-05-05T14:43:20.000Z</published>
    <updated>2022-05-05T15:31:09.939Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在软件工程中，一个众所周知的问题就是，<strong>不管你做什么，用户的需求肯定会变</strong>。<br><strong>行为参数化</strong>就是可以帮助你处理频繁变更的需求的一种软件开发模式。一言以蔽之，它意味着拿出一个代码块，把它准备好却不去执行它。这个代码块以后可以被你程序的其他部分调用，这意味着你可以推迟这块代码的执行。例如，你可以将代码块作为参数传递给另一个方法，稍后再去执行它。这样，这个方法的行为就基于那块代码被参数化了。</p><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><p>通过逐步改进案例，来熟悉什么是“行为参数化”。</p><blockquote><p>需求：农民希望筛选出1. 绿色的苹果，2. 重量大于150的苹果 3….</p></blockquote><h2 id="方案1"><a href="#方案1" class="headerlink" title="方案1"></a>方案1</h2><p>可能的代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据颜色筛选苹果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> apples</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> color</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Apple&gt; <span class="title function_">filterByColor</span><span class="params">(List&lt;Apple&gt; apples, String color)</span> &#123;</span><br><span class="line">    List&lt;Apple&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Apple apple : apples) &#123;</span><br><span class="line">        <span class="keyword">if</span>(apple.getColor().equals(color)) &#123;</span><br><span class="line">            res.add(apple);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据重量筛选苹果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> apples</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weight</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Apple&gt; <span class="title function_">filterByWeight</span><span class="params">(List&lt;Apple&gt; apples, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">    List&lt;Apple&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Apple apple : apples) &#123;</span><br><span class="line">        <span class="keyword">if</span>(apple.getWeight() &gt; weight) &#123;</span><br><span class="line">            res.add(apple);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>农民通过调用来获得答案</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">filterByColor(apples, <span class="string">&quot;green&quot;</span>);</span><br><span class="line">filterByWeight(apples, <span class="number">150</span>);</span><br></pre></td></tr></table></figure><p>这样做打破了<strong>DRY（Don’t RepeatYourself，不要重复自己）的软件工程原则</strong>。这样做出现了大量的重复代码，当你想要修改某些逻辑，比如优化遍历语句时，你需要修改所有方法中的代码。</p><p>另一种方案是，把所有参数都整合到一个方法中去，签名如下：<code>public static List&lt;Apple&gt; filterByColor(List&lt;Apple&gt; apples, String color, int weight)</code></p><p>这样做不仅笨拙，而且面对变化不能做出调整，如果有新的筛选条件，比如产地，大小，形状等怎么办？</p><h2 id="方案2：行为参数化"><a href="#方案2：行为参数化" class="headerlink" title="方案2：行为参数化"></a>方案2：行为参数化</h2><p>让我们后退一步来看看更高层次的抽象。一种可能的解决方案是对你的选择标准建模：你考虑的是苹果，需要根据Apple的某些属性（比如它是绿色的吗？重量超过150克吗？）来返回一个boolean值。我们把它称为<strong>谓词</strong>（即一个返回boolean值的函数）。让我们定义一个接口来对选择标准建模：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ApplePredicate</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Apple apple)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们就可以用ApplePredicate的多个实现代表不同的选择标准：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppleGreenColorPredicate</span> <span class="keyword">implements</span> <span class="title class_">ApplePredicate</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Apple apple)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;green&quot;</span>.equals(apple.getColor());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppleHeavyWeightPredicate</span> <span class="keyword">implements</span> <span class="title class_">ApplePredicate</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Apple apple)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> apple.getWeight() &gt; <span class="number">150</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以把这些标准看作filter方法的不同行为。你刚做的这些和“<strong>策略设计模式</strong>”相关，它让你定义一族算法，把它们封装起来（称为“策略”），然后在运行时选择一个算法。在这里，算法族就是ApplePredicate，不同的策略就是AppleHeavyWeightPredicate和AppleGreenColorPredicate。</p><p>但是，该怎么利用ApplePredicate的不同实现呢？你需要filterApples方法接受ApplePredicate对象，对Apple做条件测试。这就是行为参数化：<strong>让方法接受多种行为（或战略）作为参数</strong>，并在内部使用，来完成不同的行为。这在软件工程上有很大好处：现在你把filterApples方法迭代集合的逻辑与你要应用到集合中每个元素的行为（这里是一个谓词）区分开了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Apple&gt; <span class="title function_">filterApples</span><span class="params">(List&lt;Apple&gt; apples, ApplePredicate p)</span> &#123;</span><br><span class="line">    List&lt;Apple&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Apple apple : apples) &#123;</span><br><span class="line">        <span class="keyword">if</span>(p.test(apple)) &#123;</span><br><span class="line">            res.add(apple);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：这样做有一点缺憾就是，我明明重要的只有一个test方法，但是filterApples只能接受对象，所以我们不得不把test方法封装在ApplePredicate对象中进行传递。后面会使用Lambda表达式进行简化。</p><h2 id="方案2-1：使用匿名类改进"><a href="#方案2-1：使用匿名类改进" class="headerlink" title="方案2-1：使用匿名类改进"></a>方案2-1：使用匿名类改进</h2><p>对于以上代码的调用我们要费很大劲，创建ApplePredicate的两个实现类，然后把这两个类实例化传入到filterApples方法中去。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">filterApples(apples, <span class="keyword">new</span> <span class="title class_">AppleGreenColorPredicate</span>());</span><br></pre></td></tr></table></figure><p>我们可以使用匿名类简化这一流程。以筛选出绿色苹果为例，改进后的代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">filterApples(apples, <span class="keyword">new</span> <span class="title class_">ApplePredicate</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Apple apple)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;green&quot;</span>.equals(apple.getColor());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>但匿名类还不够好：</p><ul><li>笨重：每次实现新的<code>new ApplePredicate()</code>都要写很多模板代码<code>...test...</code></li><li>费解：这里不过多解释</li></ul><p>因此我们可以使用Lambda表达式让代码更干净</p><h2 id="方案2-2：使用Lambda表达式"><a href="#方案2-2：使用Lambda表达式" class="headerlink" title="方案2-2：使用Lambda表达式"></a>方案2-2：使用Lambda表达式</h2><p>使用Lambda表达式让上述代码重写为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">filterApples(apples, (Apple apple) -&gt; <span class="string">&quot;green&quot;</span>.equals(apple.getColor()) );</span><br></pre></td></tr></table></figure><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>将苹果按照重量由大到小排序</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对苹果按重量排序，使用java8 Collections.sort</span></span><br><span class="line"><span class="comment">//使用匿名类</span></span><br><span class="line">Collections.sort(apples, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Apple&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Apple a1, Apple a2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a1.getWeight() - a2.getWeight();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用lambda表达式</span></span><br><span class="line">Collections.sort(apples, (Apple a1, Apple a2) -&gt; a1.getWeight() - a2.getWeight() );</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>《Java 8实战》</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;在软件工程中，一个众所周知的问题就是，&lt;strong&gt;不管你做什么，用户的需求肯定会变&lt;/strong&gt;。&lt;br&gt;&lt;strong&gt;行为参数化</summary>
      
    
    
    
    <category term="Java" scheme="https://guoyujian.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://guoyujian.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Docker 基础知识整理</title>
    <link href="https://guoyujian.github.io/2022/05/02/Docker-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"/>
    <id>https://guoyujian.github.io/2022/05/02/Docker-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/</id>
    <published>2022-05-02T15:37:00.000Z</published>
    <updated>2022-05-18T14:32:47.406Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker-能做什么"><a href="#Docker-能做什么" class="headerlink" title="Docker 能做什么"></a>Docker 能做什么</h1><p>以前学习的时候，想要搭建一个Hadoop集群，那就要安装一个VMWare，然后装至少三个虚拟机。每个虚拟机至少20GB以上，有了Docker，你只需要安装一台虚拟机（Linux操作系统），在这台虚拟机上启动多个Docker容器，每个容器只有几百兆。</p><p>Docker将硬件要求和应用环境之间进一步解耦，大大提升了程序🐒的生产力和幸福指数。</p><p>Docker的应用场景包括但不限于：</p><ul><li>本地依赖：快速尝试开源项目而不用操心环境配置。</li><li>搭建环境：同一个Docker配置可以在不同的环境中运行。</li><li>微服务</li><li>扩容：Docker支持水平扩容。</li><li>……</li></ul><h1 id="Docker和虚拟机技术的比较"><a href="#Docker和虚拟机技术的比较" class="headerlink" title="Docker和虚拟机技术的比较"></a>Docker和虚拟机技术的比较</h1><p>自己查。</p><h1 id="Docker核心组件"><a href="#Docker核心组件" class="headerlink" title="Docker核心组件"></a>Docker核心组件</h1><ul><li>Docker客户端：Client</li><li>Docker服务器：Docker daemon</li><li>Docker镜像：Image</li><li>Registry</li><li>Docker容器：Container</li></ul><p><img src="image-20220428230419609.png" alt="Docker架构"></p><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>Docker客户端是执行Docker命令的地方。<code>docker run</code>等等</p><p>Docker客户端也支持REST API</p><h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><p>Docker daemon运行在Docker host上，负责创建、运行、监控容器，构建、存储镜像。</p><p>Docker服务器默认情况下只响应来自本地Host的客户端请求，如果要允许远程客户端请求，则需要修改配置（Google）</p><h2 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h2><p>Docker镜像看成只读模板，通过它可以创建Docker容器。</p><p>例如某个镜像可能包含一个操作系统、一个Apache HTTP Server以及用户开发的Web应用。</p><p>镜像有多种生成方法：（1）从无到有开始创建镜像；（2）下载并使用别人创建好的现成的镜像；（3）在现有镜像上创建新的镜像。可以将镜像的内容和创建步骤描述在一个文本文件（Dockerfile）中，通过执行dockerbuild 命令可以构建出Docker镜像，后面讨论。</p><h2 id="Docker-容器"><a href="#Docker-容器" class="headerlink" title="Docker 容器"></a>Docker 容器</h2><p>Docker容器就是Docker镜像的运行实例。</p><p>如果镜像是软件生命周期的构建和打包阶段，那么容器则是启动和运行阶段。（类似于程序与线程的关系。）</p><h2 id="Registry"><a href="#Registry" class="headerlink" title="Registry"></a>Registry</h2><p>Registry是存放Docker镜像的仓库。</p><h1 id="hello-word"><a href="#hello-word" class="headerlink" title="hello-word"></a>hello-word</h1><p>本节介绍Docker安装到运行一个Container的基本流程。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">官方安装脚本自动安装</span></span><br><span class="line">curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun</span><br></pre></td></tr></table></figure><h2 id="启动Docker服务器"><a href="#启动Docker服务器" class="headerlink" title="启动Docker服务器"></a>启动Docker服务器</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><h2 id="拉取hello-world镜像"><a href="#拉取hello-world镜像" class="headerlink" title="拉取hello-world镜像"></a>拉取hello-world镜像</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull hello-world </span><br></pre></td></tr></table></figure><h2 id="查看image信息"><a href="#查看image信息" class="headerlink" title="查看image信息"></a>查看image信息</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop01 ~]# docker images hello-world</span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED        SIZE</span><br><span class="line">hello-world   latest    feb5d9fea6a5   7 months ago   13.3kB</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="运行hello-world"><a href="#运行hello-world" class="headerlink" title="运行hello-world"></a>运行hello-world</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop01 ~]# docker run hello-world</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="查看Dockerfile"><a href="#查看Dockerfile" class="headerlink" title="查看Dockerfile"></a>查看Dockerfile</h2><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> scratch</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> hello/</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;hello/&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>只有短短三条指令。</p><ol><li>FROM scratch：镜像是从白手起家，从0开始构建。</li><li>COPY hello/：将宿主机上的文件“hello”复制到镜像的根目录。</li><li>CMD[“/hello”]：容器启动时，执行/hello。</li></ol><h1 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h1><h2 id="base-镜像"><a href="#base-镜像" class="headerlink" title="base 镜像"></a>base 镜像</h2><p>hello-world虽然是一个完整的镜像，但它并没有什么实际用途。通常来说，我们希望镜像能提供一个基本的操作系统环境，用户可以根据需要安装和配置软件。这样的镜像我们称作base镜像。</p><p>base镜像有两层含义：（1）不依赖其他镜像，从scratch构建；（2）其他镜像可以以之为基础进行扩展。</p><p>能称作base镜像的通常都是各种Linux发行版的Docker镜像，比如Ubuntu、Debian、CentOS等。</p><p>我们尝试下载并查看centos的镜像：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop01 ~]# docker pull centos</span><br><span class="line">...</span><br><span class="line">[root@hadoop01 ~]# docker images centos</span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED        SIZE</span><br><span class="line">centos       latest    5d0da3dc9764   7 months ago   231MB</span><br></pre></td></tr></table></figure><blockquote><p>为什么一个centos镜像只有200MB？</p><p>答：Linux操作系统由内核空间（bootfs/kernel）和用户空间（rootfs）组成。</p><p>Linux刚启动时会加载bootfs文件系统，之后bootfs会被卸载掉。</p><p>用户空间的文件系统是rootfs，包含我们熟悉的/dev、/proc、/bin等目录。对于base镜像来说，底层直接用Host的kernel，自己只需要提供rootfs就行了。<strong>而对于一个精简的OS, rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了。</strong></p><p>因此，base镜像只是在用户空间与发行版一致，kernel版本与发行版是不同的。镜像的Kernel版本取决于Docker Host（Docker装在哪台机器上，这台机器就是Docker Host）。所以容器只能使用Host的kernel，并且不能修改</p><p>base镜像提供的是最小安装的Linux发行版。</p></blockquote><h2 id="镜像分层"><a href="#镜像分层" class="headerlink" title="镜像分层"></a>镜像分层</h2><p>我们拿一个Dockerfile来举例：</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> debian</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install emacs</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install apach2</span></span><br></pre></td></tr></table></figure><p>上述构建过程如图所示：</p><p><img src="image-20220428234124163.png" alt="构建"></p><p>可以看到，新镜像是从base镜像一层一层叠加生成的。每安装一个软件，就在现有镜像的基础上增加一层。</p><blockquote><p>为什么Docker镜像要采用这种分层结构呢？</p><ul><li>最大的一个好处就是：共享资源。比如：有多个镜像都从相同的base镜像构建而来，那么Docker Host只需在磁盘上保存一份base镜像；同时内存中也只需加载一份base镜像，就可以为所有容器服务了，而且镜像的每一层都可以被共享，我们将在后面更深入地讨论这个特性。</li></ul><p>如果多个容器共享一份基础镜像，当某个容器修改了基础镜像的内容，比如/etc下的文件，这时其他容器的 /etc是否也会被修改？</p><ul><li>答案是不会！修改会被限制在单个容器内。这就是我们接下来要学习的容器Copy-on-Write特性。</li></ul></blockquote><h2 id="Copy-on-Write特性"><a href="#Copy-on-Write特性" class="headerlink" title="Copy-on-Write特性"></a>Copy-on-Write特性</h2><p>对于Dockerfile的每一行构建语句都会增加一层镜像，而当容器启动时，一个新的<strong>可写层</strong>被加载到镜像的顶部。这是特殊的一层，这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。所有对容器的改动，无论添加、删除，还是修改文件都只会发生在容器层中。<strong>只有容器层是可写的，容器层下面的所有镜像层都是只读的。</strong></p><ol><li>添加文件。在容器中创建文件时，新文件被添加到容器层中。</li><li>读取文件。在容器中读取某个文件时，Docker会从上往下依次在各镜像层中查找此文件。一旦找到，打开并读入内存。</li><li>修改文件。在容器中修改已存在的文件时，Docker会从上往下依次在各镜像层中查找此文件。一旦找到，<strong>立即将其复制到容器层</strong>，然后修改之。</li><li>删除文件。在容器中删除文件时，Docker也是从上往下依次在镜像层中查找此文件。找到后，会在容器层中记录下此删除操作。</li></ol><p>只有当需要修改时才复制一份数据，这种特性被称作Copy-on-Write。可见，容器层保存的是镜像变化的部分，不会对镜像本身进行任何修改。</p><p>这样就解释了我们前面提出的问题：容器层记录对镜像的修改，所有镜像层都是只读的，不会被容器修改，所以镜像可以被多个容器共享。</p><h2 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h2><p>Docker提供了两种构建镜像的方法： <code>docker commit</code>命令与Dockerfile构建文件。</p><h3 id="docker-commit（不推荐）"><a href="#docker-commit（不推荐）" class="headerlink" title="docker commit（不推荐）"></a>docker commit（不推荐）</h3><p>docker commit命令是创建新镜像最直观的方法，其过程包含三个步骤：运行容器。修改容器。将容器保存为新的镜像。</p><p>下面的例子将在CentOS base镜像中安装vim并保存为新镜像：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it ubuntu # 启动Container并进入容器</span><br><span class="line">vim # command not found</span><br><span class="line">apt-get install -y vim # 安装vim</span><br><span class="line">vim # 发现命令可以执行成功了</span><br></pre></td></tr></table></figure><p>在新窗口使用命令查看容器：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop01 ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE             COMMAND       CREATED          STATUS          PORTS     NAMES</span><br><span class="line">013be1649d31   centos:7.2.1511   &quot;/bin/bash&quot;   54 seconds ago   Up 53 seconds             frosty_kowalevski</span><br></pre></td></tr></table></figure><p>frosty_kowalevski是Docker为我们的容器随机分配的名字。</p><p>执行docker commit命令将容器保存为镜像，然后查看镜像</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop01 ~]# docker commit frosty_kowalevski centos_test</span><br><span class="line">sha256:5889b0d6ca05e96a7d1ba31dcc732d36b0651ebf7725bf0fb91def9aa2211420</span><br><span class="line">[root@hadoop01 ~]# docker images</span><br><span class="line">REPOSITORY    TAG        IMAGE ID       CREATED         SIZE</span><br><span class="line">centos_test   latest     5889b0d6ca05   6 seconds ago   409MB</span><br><span class="line">httpd         latest     c30a46771695   10 days ago     144MB</span><br><span class="line">hello-world   latest     feb5d9fea6a5   7 months ago    13.3kB</span><br><span class="line">centos        7.2.1511   9aec5c5fe4ba   3 years ago     195MB</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上演示了如何用docker commit创建新镜像。然而，Docker并不建议用户通过这种方式构建镜像。原因如下：</p><ol><li>这是一种手工创建镜像的方式，容易出错，效率低且可重复性弱。比如要在debian base镜像中也加入vi，还得重复前面的所有步骤。</li><li>更重要的：使用者并不知道镜像是如何创建出来的，里面是否有恶意程序。也就是说无法对镜像进行审计，存在安全隐患。</li></ol><p>既然docker commit不是推荐的方法，我们为什么还要花时间学习呢？原因是：即便是用Dockerfile（推荐方法）构建镜像，底层也是docker commit一层一层构建新镜像的。学习docker commit能够帮助我们更加深入地理解构建过程和镜像的分层结构。</p><h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><p>使用Dockerfile创建上一节的centos_test镜像</p><h4 id="编辑Dockerfile文件"><a href="#编辑Dockerfile文件" class="headerlink" title="编辑Dockerfile文件"></a>编辑Dockerfile文件</h4><p>创建一个Dockerfile，内容为</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos:<span class="number">7.2</span>.<span class="number">1511</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum -y install vim</span></span><br></pre></td></tr></table></figure><blockquote><p>注意这里<code>-y</code>必须加，否则在执行yum install时，很可能因为需要用户输入<code>yes</code>而失败</p></blockquote><p>执行build命令，并进行分析：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop01 docker]# pwd</span><br><span class="line">/root/docker</span><br><span class="line">[root@hadoop01 docker]# ls</span><br><span class="line">Dockerfile</span><br><span class="line">[root@hadoop01 docker]# docker build -t centos-vim-dockerfile-image .</span><br><span class="line">Sending build context to Docker daemon  2.048kB</span><br><span class="line">Step 1/2 : FROM centos:7.2.1511</span><br><span class="line"><span class="meta prompt_"> ---&gt; </span><span class="language-bash">9aec5c5fe4ba</span></span><br><span class="line">Step 2/2 : RUN yum install vim</span><br><span class="line"><span class="meta prompt_"> ---&gt; </span><span class="language-bash">Running <span class="keyword">in</span> 1caec46cd6a4</span></span><br><span class="line">Loaded plugins: fastestmirror</span><br><span class="line">……</span><br><span class="line">Successfully built b93576fddd48</span><br><span class="line">Successfully tagged centos-vim-dockerfile-image:latest</span><br></pre></td></tr></table></figure><ol><li>第三行显示文件夹下的所有文件，这里只有我们编写好的Dockerfile，值得注意的是，文件名必须叫“Dockerfile”否则执行docker build时会显示文件不存在。</li><li>第五行执行docker build命令，-t参数指定了镜像的名字，最后的点表示指定docker context为当前目录。</li><li>关于docker context：Docker默认会从build context中查找Dockerfile文件；Docker将build context中的所有文件发送给Docker daemon；Dockerfile中的ADD、COPY等命令可以将build context中的文件添加到镜像。因此不要在docker context加入不需要的文件。</li><li>第7到14行显示了执行docker build的具体过程。</li></ol><p>构建好的镜像可以通过docker history命令查看构建过程：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop01 docker]# docker history centos-vim-dockerfile-image:latest </span><br><span class="line">IMAGE          CREATED         CREATED BY                                      SIZE      COMMENT</span><br><span class="line">b93576fddd48   6 minutes ago   /bin/sh -c yum -y install vim                   214MB     </span><br><span class="line">9aec5c5fe4ba   3 years ago     /bin/sh -c #(nop)  CMD [&quot;/bin/bash&quot;]            0B        </span><br><span class="line">&lt;missing&gt;      3 years ago     /bin/sh -c #(nop)  LABEL license=GPLv2          0B        </span><br><span class="line">&lt;missing&gt;      3 years ago     /bin/sh -c #(nop)  LABEL vendor=CentOS          0B        </span><br><span class="line">&lt;missing&gt;      3 years ago     /bin/sh -c #(nop)  LABEL name=CentOS Base Im…   0B        </span><br><span class="line">&lt;missing&gt;      3 years ago     /bin/sh -c #(nop) ADD file:e76000d9816e4e380…   195MB     </span><br><span class="line">&lt;missing&gt;      3 years ago     /bin/sh -c #(nop)  MAINTAINER The CentOS Pro…   0B        </span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="镜像的缓存特性"><a href="#镜像的缓存特性" class="headerlink" title="镜像的缓存特性"></a>镜像的缓存特性</h4><p>Docker会缓存已有镜像的镜像层，构建新镜像时，如果某镜像层已经存在，就直接使用，无须重新创建。</p><p>例如在之前的Dockerfile中加入一行：</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos:<span class="number">7.2</span>.<span class="number">1511</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum -y install vim</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> <span class="built_in">test</span>/</span></span><br></pre></td></tr></table></figure><p>则在执行的过程中，之前已经运行过相同的RUN指令，这次直接使用缓存中的镜像层</p><h4 id="Dockerfile构建过程"><a href="#Dockerfile构建过程" class="headerlink" title="Dockerfile构建过程"></a>Dockerfile构建过程</h4><p>总结一下通过Dockerfile构建镜像的过程：</p><ol><li>从base镜像运行一个容器。</li><li>执行一条指令，对容器做修改。</li><li>执行类似docker commit的操作，生成一个新的镜像层。</li><li>Docker再基于刚刚提交的镜像运行一个新容器。</li><li>重复2～4步，直到Dockerfile中的所有指令执行完毕。</li></ol><p>从这个过程可以看出，如果Dockerfile由于某种原因执行到某个指令失败了，我们也将能够得到前一个指令成功执行构建出的镜像，这对调试Dockerfile非常有帮助。</p><h4 id="调试Dockerfile"><a href="#调试Dockerfile" class="headerlink" title="调试Dockerfile"></a>调试Dockerfile</h4><p>一句话概括就是：启动失败的前一层构建成功镜像的容器，进入容器，执行失败的语句，从而查看问题所在。</p><h2 id="分发镜像"><a href="#分发镜像" class="headerlink" title="分发镜像"></a>分发镜像</h2><h3 id="docker-tag"><a href="#docker-tag" class="headerlink" title="docker tag"></a>docker tag</h3><p>这里注意tag为lastest，注意docker tag的合并方式。</p><h3 id="使用公共的Registry"><a href="#使用公共的Registry" class="headerlink" title="使用公共的Registry"></a>使用公共的Registry</h3><p>看官方文档去。</p><h1 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h1><h2 id="运行容器的三种方法"><a href="#运行容器的三种方法" class="headerlink" title="运行容器的三种方法"></a>运行容器的三种方法</h2><ul><li>CMD指令</li><li>ENTRYPOINT指令</li><li>在docker run命令行中指定，例如，<code>docker run ubuntu pwd</code></li></ul><h2 id="长期运行容器"><a href="#长期运行容器" class="headerlink" title="长期运行容器"></a>长期运行容器</h2><p>容器在执行完启动时的指令后就会退出。想要让容器保持运行状态，那运行的命令不退出就好了。。</p><h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><p>在容器running时，我们可以进入容器work，有两种方法，</p><ul><li>docker attach</li><li>docker exec</li></ul><p>详细见常用命令总结章节</p><p>docker attach和docker exec区别：</p><ol><li>attach直接进入容器启动命令的终端，不会启动新的进程。</li><li>exec则是在容器中打开新的终端，并且可以启动新的进程。</li><li>如果想直接在终端中查看启动命令的输出，用attach；其他情况使用exec。</li></ol><h2 id="docker-start-stop-restart"><a href="#docker-start-stop-restart" class="headerlink" title="docker start/stop/restart"></a>docker start/stop/restart</h2><p>容器在docker host中实际上是一个进程，通过<code>docker start/stop/restart &lt;container id&gt;</code>命令启动，停止和重启容器。</p><h2 id="docker-pause-unpause"><a href="#docker-pause-unpause" class="headerlink" title="docker pause/unpause"></a>docker pause/unpause</h2><p>通过<code>docker pause/unpause &lt;container id&gt;</code>命令暂停和恢复容器。</p><h2 id="docker-rm"><a href="#docker-rm" class="headerlink" title="docker rm"></a>docker rm</h2><p>通过<code>docker rm &lt;container id&gt;</code>命令删除容器。</p><h2 id="docker生命周期"><a href="#docker生命周期" class="headerlink" title="docker生命周期"></a>docker生命周期</h2><p><img src="image-20220502225040947.png" alt="docker生命周期"></p><h2 id="资源限制"><a href="#资源限制" class="headerlink" title="资源限制"></a>资源限制</h2><p>一个docker host 会运行若干容器，对于容器，Docker也提供了类似的机制避免某个容器因占用太多资源而影响其他容器乃至整个host的性能。</p><p>docker 提供命令以限制容器的内存，CPU，BlockIO（磁盘读写）等。</p><p>具体请查阅相关资料。</p><h2 id="实现容器的底层技术"><a href="#实现容器的底层技术" class="headerlink" title="实现容器的底层技术"></a>实现容器的底层技术</h2><p>cgroup和namespace是最重要的两种技术。cgroup实现资源限额，namespace实现资源隔离。</p><p>Linux使用了6种namespace，分别对应6种资源：Mount、UTS、IPC、PID、Network和User。</p><p>具体用到再说。</p><h1 id="Docker-网络"><a href="#Docker-网络" class="headerlink" title="Docker 网络"></a>Docker 网络</h1><p>4种网络：</p><ul><li>none：封闭网络，对安全性要求高并且不需要联网的应用可以使用none网络。</li><li>host： 连接到host网络的容器共享Docker host的网络栈，容器的网络配置与host完全一样。可以通过 —network=host指定使用host网络。</li><li>bridge：Docker安装时会创建一个命名为docker0的Linuxbridge。如果不指定—network，创建的容器默认都会挂到docker0上。</li><li>user-defined：除了none、host、bridge这三个自动创建的网络，用户也可以根据业务需要创建user-defined网络。</li></ul><h2 id="容器间通信"><a href="#容器间通信" class="headerlink" title="容器间通信"></a>容器间通信</h2><p>待补充</p><h2 id="将容器与外部世界连接"><a href="#将容器与外部世界连接" class="headerlink" title="将容器与外部世界连接"></a>将容器与外部世界连接</h2><p>待补充</p><h1 id="Docker-存储"><a href="#Docker-存储" class="headerlink" title="Docker 存储"></a>Docker 存储</h1><p>待补充</p><h1 id="常用命令总结"><a href="#常用命令总结" class="headerlink" title="常用命令总结"></a>常用命令总结</h1><h2 id="Docker镜像-1"><a href="#Docker镜像-1" class="headerlink" title="Docker镜像"></a>Docker镜像</h2><h3 id="docker-images"><a href="#docker-images" class="headerlink" title="docker  images"></a>docker  images</h3><p>列出镜像</p><p><code>docker images [OPTIONS] [REPOSITORY[:TAG]]</code></p><p>OPTIONS说明：</p><ul><li><strong>-a :</strong>列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）；</li></ul><h3 id="docker-rmi"><a href="#docker-rmi" class="headerlink" title="docker rmi"></a>docker rmi</h3><p><code>docker rmi [OPTIONS] IMAGE [IMAGE...]</code></p><p>删除本地镜像</p><h3 id="docker-build"><a href="#docker-build" class="headerlink" title="docker build"></a>docker build</h3><p>使用 Dockerfile 创建镜像。</p><p><code>docker build [OPTIONS] PATH | URL | -</code></p><p>OPTIONS说明：</p><ul><li><strong>—build-arg=[] :</strong>设置镜像创建时的变量；</li><li><strong>—cpu-shares :</strong>设置 cpu 使用权重；</li><li><strong>-f :</strong>指定要使用的Dockerfile路径；</li><li><strong>—force-rm :</strong>设置镜像过程中删除中间容器；</li><li><strong>—isolation :</strong>使用容器隔离技术；</li><li><strong>-m :</strong>设置内存最大值；</li><li><strong>—memory-swap :</strong>设置Swap的最大值为内存+swap，”-1”表示不限swap；</li><li><strong>—no-cache :</strong>创建镜像的过程不使用缓存；</li><li><strong>—pull :</strong>尝试去更新镜像的新版本；</li><li><strong>—quiet, -q :</strong>安静模式，成功后只输出镜像 ID；</li><li><strong>—rm :</strong>设置镜像成功后删除中间容器；</li><li><strong>—tag, -t:</strong> 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。</li><li><strong>—network:</strong> 默认 default。在构建期间设置RUN指令的网络模式</li></ul><h3 id="docker-history"><a href="#docker-history" class="headerlink" title="docker history"></a>docker history</h3><p>查看指定镜像的创建历史。</p><p><code>docker history [OPTIONS] IMAGE</code></p><hr><h3 id="docker-login"><a href="#docker-login" class="headerlink" title="docker login"></a>docker login</h3><p> 登陆到一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub</p><h3 id="docker-pull"><a href="#docker-pull" class="headerlink" title="docker pull"></a>docker pull</h3><p>拉取镜像</p><h3 id="docker-push"><a href="#docker-push" class="headerlink" title="docker push"></a>docker push</h3><p>推送镜像</p><h3 id="docker-search"><a href="#docker-search" class="headerlink" title="docker search"></a>docker search</h3><p>查找镜像</p><h2 id="Docker-容器-1"><a href="#Docker-容器-1" class="headerlink" title="Docker 容器"></a>Docker 容器</h2><h3 id="docker-run"><a href="#docker-run" class="headerlink" title="docker run"></a>docker run</h3><p><strong>docker run ：</strong>创建一个新的容器并运行一个命令</p><p><code>docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</code></p><p>OPTIONS说明：</p><ul><li><strong>-d:</strong> 后台运行容器，并返回容器ID；</li><li><strong>-i:</strong> 以交互模式运行容器，通常与 -t 同时使用；</li><li><strong>-p:</strong> 指定端口映射，格式为：<strong>主机(宿主)端口:容器端口</strong></li><li><strong>-t:</strong> 为容器重新分配一个伪输入终端，通常与 -i 同时使用；</li><li><strong>—name=”nginx-lb”:</strong> 为容器指定一个名称；</li><li><strong>—dns 8.8.8.8:</strong> 指定容器使用的DNS服务器，默认和宿主一致；</li><li><strong>—dns-search example.com:</strong> 指定容器DNS搜索域名，默认和宿主一致；</li><li><strong>-h “mars”:</strong> 指定容器的hostname；</li><li><strong>-e username=”ritchie”:</strong> 设置环境变量；</li><li><strong>-m :</strong>设置容器使用内存最大值；</li><li><strong>—net=”bridge”:</strong> 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型；</li><li><strong>—expose=[]:</strong> 开放一个端口或一组端口；</li></ul><h3 id="docker-start-stop-restart-1"><a href="#docker-start-stop-restart-1" class="headerlink" title="docker start/stop/restart"></a>docker start/stop/restart</h3><p><strong>docker start</strong> :启动一个或多个已经被停止的容器</p><p><strong>docker stop</strong> :停止一个运行中的容器</p><p><strong>docker restart</strong> :重启容器</p><h3 id="docker-rm-1"><a href="#docker-rm-1" class="headerlink" title="docker rm"></a>docker rm</h3><p><strong>docker rm ：</strong>删除一个或多个容器。</p><h3 id="docker-pause-unpause-1"><a href="#docker-pause-unpause-1" class="headerlink" title="docker pause/unpause"></a>docker pause/unpause</h3><p><strong>docker pause</strong> :暂停容器中所有的进程。</p><p><strong>docker unpause</strong> :恢复容器中所有的进程。</p><h3 id="docker-create"><a href="#docker-create" class="headerlink" title="docker create"></a>docker create</h3><p><strong>docker create ：</strong>创建一个新的容器但不启动它；用法同docker run</p><h3 id="docker-attach"><a href="#docker-attach" class="headerlink" title="docker attach"></a>docker attach</h3><p><strong>docker attach :</strong>连接到正在运行中的容器。</p><p>要attach上去的容器必须正在运行，可以同时连接上同一个container来共享屏幕（与screen命令的attach类似）。</p><h3 id="docker-exec"><a href="#docker-exec" class="headerlink" title="docker exec"></a>docker exec</h3><p><strong>docker exec ：</strong>在运行的容器中执行命令</p><p><code>docker exec [OPTIONS] CONTAINER COMMAND [ARG...]</code></p><p>OPTIONS说明：</p><ul><li><strong>-d :</strong>分离模式: 在后台运行</li><li><strong>-t :</strong>分配一个伪终端</li></ul><h3 id="docker-ps"><a href="#docker-ps" class="headerlink" title="docker ps"></a>docker ps</h3><p>列出容器</p><p><code>docker ps [OPTIONS]</code></p><p>OPTIONS说明：</p><ul><li><strong>-a :</strong>显示所有的容器，包括未运行的。</li><li><strong>-n :</strong>列出最近创建的n个容器。</li><li><strong>-q :</strong>静默模式，只显示容器编号。</li></ul><h3 id="docker-inspect"><a href="#docker-inspect" class="headerlink" title="docker inspect"></a>docker inspect</h3><p><strong>docker inspect :</strong> 获取容器/镜像的元数据。</p><h3 id="docker-top"><a href="#docker-top" class="headerlink" title="docker top"></a>docker top</h3><p>查看容器中运行的进程信息，支持 ps 命令参数。</p><p>容器运行时不一定有/bin/bash终端来交互执行top命令，而且容器还不一定有top命令，可以使用docker top来实现查看container中正在运行的进程。</p><h3 id="docker-logs"><a href="#docker-logs" class="headerlink" title="docker logs"></a>docker logs</h3><p>获取容器的日志</p><h3 id="docker-commit"><a href="#docker-commit" class="headerlink" title="docker commit"></a>docker commit</h3><p>从容器创建一个新的镜像。</p><p><code>docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</code></p><p>OPTIONS说明：</p><ul><li><strong>-a :</strong>提交的镜像作者；</li><li><strong>-c :</strong>使用Dockerfile指令来创建镜像；</li><li><strong>-m :</strong>提交时的说明文字；</li><li><strong>-p :</strong>在commit时，将容器暂停。</li></ul><h3 id="docker-cp"><a href="#docker-cp" class="headerlink" title="docker cp"></a>docker cp</h3><p>用于容器与主机之间的数据拷贝。</p><p>例如：将主机/www/runoob目录拷贝到容器96f7f14e99ab的/www目录下。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker cp /www/runoob 96f7f14e99ab:/www/</span><br></pre></td></tr></table></figure><h2 id="Dockerfile-1"><a href="#Dockerfile-1" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><ul><li>FROM指定base镜像。</li><li>MAINTAINER设置镜像的作者，可以是任意字符串。</li><li>COPY将文件从build context复制到镜像。COPY支持两种形式： COPY src dest与COPY [“src”, “dest”]。注意：src只能指定build context中的文件或目录。</li><li>ADD与COPY类似，从build context复制文件到镜像。不同的是，如果src是归档文件（tar、zip、tgz、xz等），文件会被自动解压到dest。</li><li>ENV设置环境变量，环境变量可被后面的指令使用。</li><li>EXPOSE指定容器中的进程会监听某个端口，Docker可以将该端口暴露出来。我们会在容器网络部分详细讨论。</li><li>VOLUME将文件或目录声明为volume。我们会在容器存储部分详细讨论。</li><li>WORKDIR为后面的RUN、CMD、ENTRYPOINT、ADD或COPY指令设置镜像中的当前工作目录。</li><li>RUN在容器中运行指定的命令。</li><li>CMD容器启动时运行指定的命令。Dockerfile中可以有多个CMD指令，但只有最后一个生效。CMD可以被dockerrun之后的参数替换。</li><li>ENTRYPOINT设置容器启动时运行的命令。Dockerfile中可以有多个ENTRYPOINT指令，但只有最后一个生效。CMD或docker run之后的参数会被当作参数传递给ENTRYPOINT。</li></ul><h3 id="RUN-vs-CMD-vs-ENTRYPOINT"><a href="#RUN-vs-CMD-vs-ENTRYPOINT" class="headerlink" title="RUN vs CMD vs ENTRYPOINT"></a>RUN vs CMD vs ENTRYPOINT</h3><p>略</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>《每天五分钟玩转Docker容器技术》</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Docker-能做什么&quot;&gt;&lt;a href=&quot;#Docker-能做什么&quot; class=&quot;headerlink&quot; title=&quot;Docker 能做什么&quot;&gt;&lt;/a&gt;Docker 能做什么&lt;/h1&gt;&lt;p&gt;以前学习的时候，想要搭建一个Hadoop集群，那就要安装一个VMWa</summary>
      
    
    
    
    <category term="Docker" scheme="https://guoyujian.github.io/categories/Docker/"/>
    
    
    <category term="Docker" scheme="https://guoyujian.github.io/tags/Docker/"/>
    
    <category term="容器" scheme="https://guoyujian.github.io/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>HashMap知识整理</title>
    <link href="https://guoyujian.github.io/2022/04/21/HashMap%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"/>
    <id>https://guoyujian.github.io/2022/04/21/HashMap%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/</id>
    <published>2022-04-21T15:28:41.000Z</published>
    <updated>2022-05-18T14:33:56.256Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Java为数据结构中的映射定义了一个接口java.util.Map，此接口主要有四个常用的实现类，分别是HashMap、Hashtable、LinkedHashMap和TreeMap，类继承关系如下图所示：</p><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/f7fe16a2.png" alt="Map类图"></p><ol><li><strong>HashMap</strong>：它根据键的hashCode值存储数据，<strong>遍历顺序不确定</strong>。 HashMap<strong>最多只允许一条记录的key为null</strong>，允许多条记录的value为null。HashMap<strong>非线程安全</strong>，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。</li><li><strong>Hashtable</strong>：Hashtable是遗留类，不再推荐使用。</li><li><strong>LinkedHashMap</strong>：LinkedHashMap是HashMap的一个子类，<strong>保存了记录的插入顺序</strong>，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。</li><li><strong>TreeMap</strong>：TreeMap实现SortedMap接口，能够<strong>把它保存的记录根据键排序</strong>，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator**，否则会在运行时抛出java.lang.ClassCastException类型的异常。</li></ol><p>对于上述四种Map类型的类，要求映射中的key是<strong>不可变对象</strong>。不可变对象是该对象在创建后它的哈希值不会被改变。如果对象的哈希值发生变化，Map对象很可能就定位不到映射的位置了。</p><h1 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h1><p>从结构实现来讲，HashMap是数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下如所示。</p><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/e4a19398.png" alt="HashMap存储结构"></p><h2 id="什么是Node"><a href="#什么是Node" class="headerlink" title="什么是Node"></a>什么是Node</h2><p>源码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> hash;    <span class="comment">//用来定位数组索引位置</span></span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;   <span class="comment">//链表的下一个node</span></span><br><span class="line"></span><br><span class="line">        Node(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123; ... &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> K <span class="title function_">getKey</span><span class="params">()</span>&#123; ... &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">getValue</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">setValue</span><span class="params">(V newValue)</span> &#123; ... &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)。上图中的每个黑色圆点就是一个Node对象。</p><blockquote><p>Map.Entry是Map声明的一个内部接口，此接口为泛型，定义为Entry<K,V>。它表示Map中的一个实体（一个key-value对）。接口中有getKey(), getValue方法。</p></blockquote><h2 id="HashMap存储"><a href="#HashMap存储" class="headerlink" title="HashMap存储"></a>HashMap存储</h2><p>HashMap就是使用哈希表来存储的。哈希表为解决冲突，可以采用开放地址法和链地址法等来解决问题，Java中HashMap采用了<strong>链地址法</strong>。链地址法，简单来说，就是数组加链表的结合。在每个数组元素上都一个链表结构，当数据被Hash后，得到数组下标，把数据放在对应下标元素的链表上。</p><p>对于HashMap来说，调用<code>map.put(key, value)</code>方法时，先通过<code>key.hashCode()</code>得到hashCode值（该方法适用于每个Java对象），在对hashCode值进行Hash运算来确定该键值对在哈希桶数组中的存储位置。如果两个key会定位到相同的位置，表示发生了Hash冲突。</p><p>HashMap的存储效率取决于Hash算法和哈希桶数组的大小。如果哈希桶数组很大，即使较差的Hash算法也会比较分散，如果哈希桶数组数组很小，即使好的Hash算法也会出现较多碰撞，所以就需要在空间成本和时间成本之间权衡，其实就是在根据实际情况确定哈希桶数组的大小，并在此基础上设计好的hash算法减少Hash碰撞。那么通过什么方式来控制map使得Hash碰撞的概率又小，哈希桶数组（Node[] table）占用空间又少呢？答案就是好的<strong>Hash算法</strong>和<strong>扩容机制</strong>。</p><h2 id="HashMap关键变量"><a href="#HashMap关键变量" class="headerlink" title="HashMap关键变量"></a>HashMap关键变量</h2><p>在理解Hash和扩容流程之前，我们得先了解下HashMap的几个字段。从HashMap的默认构造函数源码可知，构造函数就是对下面几个字段进行初始化，源码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="type">int</span> threshold;             <span class="comment">// 所能容纳的key-value对极限 </span></span><br><span class="line"><span class="keyword">final</span> <span class="type">float</span> loadFactor;    <span class="comment">// 负载因子</span></span><br><span class="line"><span class="type">int</span> modCount;  </span><br><span class="line"><span class="type">int</span> size;</span><br></pre></td></tr></table></figure><ul><li>table是哈希桶数组，它默认初始化长度length为16</li><li>loadFactor为负载因子(默认值是0.75)</li><li>threshold是HashMap所能容纳的最大数据量的Node(键值对)个数</li><li>threshold = length * Load factor，也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。</li><li>负载因子的定义公式可知，threshold就是在此Load factor和length(数组长度)对应下允许的<strong>最大元素数目</strong>，超过这个数目就重新resize(扩容)，<strong>扩容后的HashMap容量是之前容量的两倍</strong>。默认的负载因子0.75是对空间和时间效率的一个平衡选择，建议大家不要修改，除非在时间和空间比较特殊的情况下，如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值；相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。</li><li>size就是HashMap中<strong>实际存在的键值对数量</strong>。</li><li>modCount字段主要用来记录HashMap内部结构发生变化的次数（比如扩容， 或者链表变为红黑树），主要用于迭代的快速失败。强调一点，内部结构发生变化指的是结构发生变化，例如put新键值对，但是某个key对应的value值被覆盖不属于结构变化。</li></ul><h2 id="哈希桶数组的设计"><a href="#哈希桶数组的设计" class="headerlink" title="哈希桶数组的设计"></a>哈希桶数组的设计</h2><p>在HashMap中，哈希桶数组table的长度length大小必须为2的n次方(一定是合数)，这是一种<strong>非常规</strong>的设计，常规的设计是把桶的大小设计为素数。相对来说素数导致冲突的概率要小于合数，具体证明可以参考<a href="http://blog.csdn.net/liuqiyao_01/article/details/14475159">这篇文章</a>，Hashtable初始化桶大小为11，就是桶大小设计为素数的应用（Hashtable扩容后不能保证还是素数）。HashMap采用这种非常规设计，主要是<strong>为了在取模和扩容时做优化</strong>。同时为了减少冲突，HashMap定位哈希桶索引位置时，也加入了高位参与运算的过程。</p><p>这里存在一个问题，即使负载因子和Hash算法设计的再合理，也免不了会出现拉链过长的情况（即链表很长），一旦出现拉链过长，则会严重影响HashMap的性能。于是，在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树。而当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入、删除、查找等算法。本文不再对红黑树展开讨论，想了解更多红黑树数据结构的工作原理可以参考<a href="http://blog.csdn.net/v_july_v/article/details/6105630">这篇文章</a>。</p><h1 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h1><h2 id="hash算法"><a href="#hash算法" class="headerlink" title="hash算法"></a>hash算法</h2><p>源码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法一：</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;   <span class="comment">//jdk1.8 &amp; jdk1.7</span></span><br><span class="line">     <span class="type">int</span> h;</span><br><span class="line">     <span class="comment">// h = key.hashCode() 为第一步 取hashCode值</span></span><br><span class="line">     <span class="comment">// h ^ (h &gt;&gt;&gt; 16)  为第二步 高位参与运算</span></span><br><span class="line">     <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line">方法二：</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">indexFor</span><span class="params">(<span class="type">int</span> h, <span class="type">int</span> length)</span> &#123;  <span class="comment">//jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的</span></span><br><span class="line">     <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);  <span class="comment">//第三步 取模运算</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的Hash算法本质上就是三步：<strong>取key的hashCode值、高位运算、取模运算</strong>。</p><p>对于任意给定的对象，只要它的hashCode()返回值相同，那么程序调用方法一所计算得到的Hash码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，<strong>模运算的消耗还是比较大</strong>的，在HashMap中是这样做的：调用方法二来计算该对象应该保存在table数组的哪个索引处。</p><p>这个方法（方法二）非常巧妙，它通过h &amp; (table.length -1)来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n次方时，<strong>h&amp; (length-1)运算等价于对length取模</strong>，也就是h%length，但是&amp;比%具有更高的效率。</p><p>在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。</p><p>下面举例说明下，n为table的长度</p><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/45205ec2.png" alt="hash算法"></p><h2 id="HashMap的put方法"><a href="#HashMap的put方法" class="headerlink" title="HashMap的put方法"></a>HashMap的put方法</h2><p>HashMap的put方法执行过程可以通过下图来理解</p><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/d669d29c.png" alt="HashMap的put方法（1.7，1.8有变化）"></p><ol><li>判断键值对数组table是否为空或长度为0，否则执行resize()进行扩容；（这里可以看出，<code>new HashMap()</code>的时候并不会初始化哈希桶数组，而是当第一次执行put操作的时候才会初始化。）</li><li>根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向6，如果table[i]不为空，转向3</li><li>判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向4，这里的相同指的是hashCode以及equals；</li><li>判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向5；</li><li>遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可； </li><li>插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。</li></ol><p>put方法源码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="comment">// 对key的hashCode()做hash</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">               <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">// 步骤①：tab为空则创建</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 步骤②：计算index，并对null做处理 </span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>) </span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 步骤③：节点key存在，直接覆盖value</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 步骤④：判断该链为红黑树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 步骤⑤：该链为链表</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key,value,<span class="literal">null</span>);</span><br><span class="line">                     <span class="comment">//链表长度大于8转换为红黑树进行处理</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st  </span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                 <span class="comment">// key已经存在直接覆盖value</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) </span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 步骤⑥：超过最大容量 就扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><p>扩容(resize)就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。当然Java里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组，就像我们用一个小桶装水，如果想装更多的水，就得换大水桶。</p><blockquote><p>这里有一个不大不小的质疑，如果所有的size到达了threshold，但是所有的键值对都装在了一个哈希桶中，那么其实其他桶是空的，也是可以继续放更多的键值对，那么此时不能说<HashMap对象内部的数组无法装载更多的元素>，但依然会扩容</p></blockquote><p>我们分析下resize的源码，鉴于JDK1.8融入了红黑树，较复杂，为了便于理解我们仍然使用JDK1.7的代码，好理解一些，本质上区别不大，具体区别后文再说。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(<span class="type">int</span> newCapacity)</span> &#123;   <span class="comment">//传入新的容量</span></span><br><span class="line">    Entry[] oldTable = table;    <span class="comment">//引用扩容前的Entry数组</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> oldTable.length;         </span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;  <span class="comment">//扩容前的数组大小如果已经达到最大(2^30)了</span></span><br><span class="line">        threshold = Integer.MAX_VALUE; <span class="comment">//修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> <span class="title class_">Entry</span>[newCapacity];  <span class="comment">//初始化一个新的Entry数组</span></span><br><span class="line">    transfer(newTable);                         <span class="comment">//！！将数据转移到新的Entry数组里</span></span><br><span class="line">    table = newTable;                           <span class="comment">//HashMap的table属性引用新的Entry数组</span></span><br><span class="line">    threshold = (<span class="type">int</span>)(newCapacity * loadFactor);<span class="comment">//修改阈值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Entry[] newTable)</span> &#123;</span><br><span class="line">    Entry[] src = table;                   <span class="comment">//src引用了旧的Entry数组</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; src.length; j++) &#123; <span class="comment">//遍历旧的Entry数组</span></span><br><span class="line">        Entry&lt;K,V&gt; e = src[j];             <span class="comment">//取得旧Entry数组的每个元素</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            src[j] = <span class="literal">null</span>;<span class="comment">//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash, newCapacity); <span class="comment">//！！重新计算每个元素在数组中的位置</span></span><br><span class="line">                e.next = newTable[i]; <span class="comment">//标记[1]，这句不太理解</span></span><br><span class="line">                newTable[i] = e;      <span class="comment">//将元素放在数组上</span></span><br><span class="line">                e = next;             <span class="comment">//访问下一个Entry链上的元素</span></span><br><span class="line">            &#125; <span class="keyword">while</span> (e != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>newTable[i]的引用赋给了e.next，也就是使用了单链表的<strong>头插</strong>入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素终会被放到Entry链的尾部(如果发生了hash冲突的话），这一点和Jdk1.8有区别，下文详解。在旧数组中同一条Entry链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。</p><p>下面举个例子说明下扩容过程。假设了我们的hash算法就是简单的用key mod 一下表的大小（也就是数组的长度）。其中的哈希桶数组table的size=2， 所以key = 3、7、5，put顺序依次为 5、7、3。在mod 2以后都冲突在table[1]这里了。这里假设负载因子 loadFactor=1，即当键值对的实际大小size 大于 table的实际大小时进行扩容。接下来的三个步骤是哈希桶数组 resize成4，然后所有的Node重新rehash的过程。</p><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/b2330062.png" alt="JDK7 HashMap扩容"></p><p>下面我们讲解下JDK1.8做了哪些优化。经过观测可以发现，我们使用的是<strong>2次幂</strong>的扩展(指长度扩为原来2倍)，所以，<strong>元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置</strong>。看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。</p><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/4d8022db.png" alt="img"></p><p>元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：</p><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/d773f86e.png" alt="img"></p><p>因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，<strong>只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”</strong>，可以看看下图为16扩充为32的resize示意图：</p><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/3cc9813a.png" alt="img"></p><p>这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。有一点注意区别，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，<strong>JDK1.8不会倒置</strong>。有兴趣的同学可以研究下JDK1.8的resize源码，写的很赞，如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没超过最大值，就扩充为原来的2倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算新的resize上限</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;，&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 把每个bucket都移动到新的buckets中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// 链表优化重hash的代码块</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 原索引</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 原索引+oldCap</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 原索引放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 原索引+oldCap放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><h2 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h2><p>在多线程使用场景中，应该尽量避免使用线程不安全的HashMap，而使用线程安全的ConcurrentHashMap。那么为什么说HashMap是线程不安全的，下面举例子说明在并发的多线程使用场景中使用HashMap可能造成死循环。代码例子如下(便于理解，仍然使用JDK1.7的环境)：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapInfiniteLoop</span> &#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;Integer,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer,String&gt;(<span class="number">2</span>，<span class="number">0.75f</span>);  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        map.put(<span class="number">5</span>， <span class="string">&quot;C&quot;</span>);  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;Thread1&quot;</span>) &#123;  </span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;  </span><br><span class="line">                map.put(<span class="number">7</span>, <span class="string">&quot;B&quot;</span>);  </span><br><span class="line">                System.out.println(map);  </span><br><span class="line">            &#125;;  </span><br><span class="line">        &#125;.start();  </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;Thread2&quot;</span>) &#123;  </span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;  </span><br><span class="line">                map.put(<span class="number">3</span>, <span class="string">&quot;A);  </span></span><br><span class="line"><span class="string">                System.out.println(map);  </span></span><br><span class="line"><span class="string">            &#125;;  </span></span><br><span class="line"><span class="string">        &#125;.start();        </span></span><br><span class="line"><span class="string">    &#125;  </span></span><br><span class="line"><span class="string">&#125; </span></span><br></pre></td></tr></table></figure><p>其中，map初始化为一个长度为2的数组，loadFactor=0.75，threshold=2*0.75=1，也就是说当put第二个key的时候，map就需要进行resize。</p><p>通过设置断点让线程1和线程2同时debug到transfer方法(3.3小节代码块)的首行。注意此时两个线程已经成功添加数据。放开thread1的断点至transfer方法的“Entry next = e.next;” 这一行；然后放开线程2的的断点，让线程2进行resize。结果如下图。</p><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/7df99266.png" alt="img"></p><p>注意，Thread1的 e 指向了key(3)，而next指向了key(7)，其在线程二rehash后，指向了线程二重组后的链表。</p><p>线程一被调度回来执行，先是执行 newTalbe[i] = e， 然后是e = next，导致了e指向了key(7)，而下一次循环的next = e.next导致了next指向了key(3)。</p><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/4c3c28fb.png" alt="img"></p><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/6c8d086a.png" alt="img"></p><p>e.next = newTable[i] 导致 key(3).next 指向了 key(7)。注意：此时的key(7).next 已经指向了key(3)， 环形链表就这样出现了。</p><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/6eed9aaf.png" alt="img"></p><p>于是，当我们用线程一调用map.get(11)时，悲剧就出现了——Infinite Loop。</p><h1 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h1><p>JDK1.8做了多方面的优化，总体性能优于JDK1.7。具体详见参考资料1</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://tech.meituan.com/2016/06/24/java-hashmap.html">Java 8系列之重新认识HashMap</a></li><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;Java为数据结构中的映射定义了一个接口java.util.Map，此接口主要有四个常用的实现类，分别是HashMap、Hashtable、</summary>
      
    
    
    
    <category term="Java" scheme="https://guoyujian.github.io/categories/Java/"/>
    
    <category term="集合" scheme="https://guoyujian.github.io/categories/Java/%E9%9B%86%E5%90%88/"/>
    
    
    <category term="Java" scheme="https://guoyujian.github.io/tags/Java/"/>
    
    <category term="HashMap" scheme="https://guoyujian.github.io/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>医学影像处理：将NII格式的CT图转换为PNG</title>
    <link href="https://guoyujian.github.io/2022/04/12/%E5%8C%BB%E5%AD%A6%E5%BD%B1%E5%83%8F%E5%A4%84%E7%90%86%EF%BC%9A%E5%B0%86NII%E6%A0%BC%E5%BC%8F%E7%9A%84CT%E5%9B%BE%E8%BD%AC%E6%8D%A2%E4%B8%BAPNG/"/>
    <id>https://guoyujian.github.io/2022/04/12/%E5%8C%BB%E5%AD%A6%E5%BD%B1%E5%83%8F%E5%A4%84%E7%90%86%EF%BC%9A%E5%B0%86NII%E6%A0%BC%E5%BC%8F%E7%9A%84CT%E5%9B%BE%E8%BD%AC%E6%8D%A2%E4%B8%BAPNG/</id>
    <published>2022-04-12T15:04:13.000Z</published>
    <updated>2022-04-12T15:50:57.473Z</updated>
    
    <content type="html"><![CDATA[<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>本文使用Python进行医学影像处理：通过旋转、切片、调整窗宽窗位，将3D NII格式的<strong>肺部</strong>CT影像转为2D PNG格式图像。</p><p>下面介绍流程。</p><p>===</p><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><p>==</p><h2 id="读取NII图像"><a href="#读取NII图像" class="headerlink" title="读取NII图像"></a>读取NII图像</h2><p>一般使用<code>nibabel</code>来读NII格式图像。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> nibabel <span class="keyword">as</span> nib</span><br><span class="line">img = nib.load(img_path)</span><br><span class="line"><span class="comment"># 获得图像的ndarray</span></span><br><span class="line">img_fdata = img.get_fdata()</span><br></pre></td></tr></table></figure><p>==</p><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>将3D图以z轴分片为若干2D图。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(x, y, z) = img.shape</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(z):</span><br><span class="line">silce = img_fdata[:, :, i]</span><br></pre></td></tr></table></figure><p>==</p><h2 id="调整窗宽窗位1"><a href="#调整窗宽窗位1" class="headerlink" title="调整窗宽窗位1"></a>调整窗宽窗位1</h2><p>窗宽窗位的基本概念详见：<a href="https://www.zhihu.com/question/33587197">https://www.zhihu.com/question/33587197</a></p><p>简单来说，不同的窗宽窗位使得不同的组织器官展示的更清楚。</p><p>这里，我处理的是肺部CT，不同部位的对应不同的窗宽窗位。</p><p>==</p><h2 id="调整窗宽窗位2"><a href="#调整窗宽窗位2" class="headerlink" title="调整窗宽窗位2"></a>调整窗宽窗位2</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">center = -<span class="number">500</span> <span class="comment">#肺部的窗宽窗位</span></span><br><span class="line">width = <span class="number">1500</span></span><br><span class="line"><span class="built_in">min</span> = (<span class="number">2</span> * center - width) / <span class="number">2.0</span> + <span class="number">0.5</span></span><br><span class="line"><span class="built_in">max</span> = (<span class="number">2</span> * center + width) / <span class="number">2.0</span> + <span class="number">0.5</span></span><br><span class="line">dFactor = <span class="number">255.0</span> / (<span class="built_in">max</span> - <span class="built_in">min</span>)</span><br><span class="line"></span><br><span class="line">silce = silce - <span class="built_in">min</span></span><br><span class="line">silce =np.trunc( silce * dFactor)</span><br><span class="line"><span class="comment"># 由于RGB格式的要求，这里对不在[0~255]的像素值进行截断</span></span><br><span class="line">silce[silce &lt; <span class="number">0.0</span>] = <span class="number">0</span></span><br><span class="line">silce[silce &gt; <span class="number">255.0</span>] = <span class="number">255</span>  <span class="comment"># 转换为窗位窗位之后的数据</span></span><br></pre></td></tr></table></figure><p>==</p><h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><p>旋转90°让图像“正”过来</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">silce = np.fliplr(np.rot90(silce,-<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>==</p><h2 id="保存PNG"><a href="#保存PNG" class="headerlink" title="保存PNG"></a>保存PNG</h2><p>略</p><p>=== </p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><p>==</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> nibabel <span class="keyword">as</span> nib</span><br><span class="line"><span class="keyword">import</span> imageio  </span><br><span class="line"></span><br><span class="line"><span class="comment">#肺部的窗宽窗位</span></span><br><span class="line">center = -<span class="number">500</span> </span><br><span class="line">width = <span class="number">1500</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nii_to_image</span>(<span class="params">src_path, dst_path</span>):</span><br><span class="line"><span class="keyword">for</span> p, d, f <span class="keyword">in</span> os.walk(src_path):</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(f) &gt; <span class="number">0</span>:</span><br><span class="line"><span class="keyword">for</span> file_name <span class="keyword">in</span> f:</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> file_name.endswith(<span class="string">&quot;.nii&quot;</span>):</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="comment"># 开始读取nii文件</span></span><br><span class="line">img_path = os.path.join(p, file_name)</span><br><span class="line">img = nib.load(img_path)</span><br><span class="line">img_fdata = img.get_fdata()</span><br><span class="line"><span class="comment"># 新建文件夹</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(dst_path):</span><br><span class="line">os.mkdir(dst_path)</span><br><span class="line"><span class="comment"># 转换成窗宽窗位</span></span><br><span class="line"><span class="built_in">min</span> = (<span class="number">2</span> * center - width) / <span class="number">2.0</span> + <span class="number">0.5</span></span><br><span class="line"><span class="built_in">max</span> = (<span class="number">2</span> * center + width) / <span class="number">2.0</span> + <span class="number">0.5</span></span><br><span class="line">dFactor = <span class="number">255.0</span> / (<span class="built_in">max</span> - <span class="built_in">min</span>)</span><br><span class="line"><span class="comment"># 开始转换为图像</span></span><br><span class="line">(x, y, z) = img.shape</span><br><span class="line"><span class="comment"># z是图像的序列</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(z):</span><br><span class="line">silce = img_fdata[:, :, i]</span><br><span class="line"><span class="comment"># 反转，旋转90°</span></span><br><span class="line">silce = np.fliplr(np.rot90(silce,-<span class="number">1</span>)) </span><br><span class="line">silce = silce - <span class="built_in">min</span></span><br><span class="line">silce =np.trunc( silce * dFactor)</span><br><span class="line">silce[silce &lt; <span class="number">0.0</span>] = <span class="number">0</span></span><br><span class="line">silce[silce &gt; <span class="number">255.0</span>] = <span class="number">255</span> </span><br><span class="line"><span class="comment"># maskimg_slice = maskimg_fdata[:,:,i]</span></span><br><span class="line">temp = file_name.replace(<span class="string">&quot;.nii&quot;</span>, <span class="string">&quot;&quot;</span>)+<span class="string">&quot;_&quot;</span> + <span class="string">&#x27;&#123;&#125;.png&#x27;</span>.<span class="built_in">format</span>(i)</span><br><span class="line">imageio.imwrite(os.path.join(dst_path, temp), silce.astype(<span class="string">&#x27;uint8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">src_path = <span class="string">&#x27;NII保存文件夹&#x27;</span></span><br><span class="line">dst_path = <span class="string">&#x27;PNG保存文件夹&#x27;</span></span><br><span class="line">nii_to_image(src_path, dst_path)</span><br></pre></td></tr></table></figure><p>===</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>==</p><ol><li><a href="https://www.zhihu.com/question/33587197">CT的窗宽，窗位到底是什么意思？</a></li><li><a href="https://blog.csdn.net/Zzhouzhou237/article/details/105345048">python nii 图像读取，转换成CT 值，设置窗宽窗位，保存成png 图像</a></li></ol><p>===</p><h1 id="Thanks"><a href="#Thanks" class="headerlink" title="Thanks~"></a>Thanks~</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;目标&quot;&gt;&lt;a href=&quot;#目标&quot; class=&quot;headerlink&quot; title=&quot;目标&quot;&gt;&lt;/a&gt;目标&lt;/h1&gt;&lt;p&gt;本文使用Python进行医学影像处理：通过旋转、切片、调整窗宽窗位，将3D NII格式的&lt;strong&gt;肺部&lt;/strong&gt;CT影像转为2</summary>
      
    
    
    
    <category term="深度学习" scheme="https://guoyujian.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="深度学习" scheme="https://guoyujian.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="图像处理" scheme="https://guoyujian.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>完美解决ChromeDriver与Chrome版本匹配问题</title>
    <link href="https://guoyujian.github.io/2022/04/11/%E5%AE%8C%E7%BE%8E%E8%A7%A3%E5%86%B3ChromeDriver%E4%B8%8EChrome%E7%89%88%E6%9C%AC%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98/"/>
    <id>https://guoyujian.github.io/2022/04/11/%E5%AE%8C%E7%BE%8E%E8%A7%A3%E5%86%B3ChromeDriver%E4%B8%8EChrome%E7%89%88%E6%9C%AC%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98/</id>
    <published>2022-04-11T14:47:58.000Z</published>
    <updated>2022-04-11T14:53:41.897Z</updated>
    
    <content type="html"><![CDATA[<p>在使用Selenium调用Chrome浏览器爬取互联网数据时，会遇到Chrome和ChromeDriver版本不兼容的问题，导致爬取失败。</p><p>一种解决方案是，进行版本匹配。但是随着本机Chrome的更新，每次都需要随之更新ChromeDriver版本。</p><p>更好的方案是，通过使用<code>webdriver-manager</code>来自动匹配ChromeDriver，安装：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install webdriver-manager</span><br></pre></td></tr></table></figure><p>Usage：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> webdriver_manager.chrome <span class="keyword">import</span> ChromeDriverManager</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome(ChromeDriverManager().install())</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://stackoverflow.com/questions/60296873/sessionnotcreatedexception-message-session-not-created-this-version-of-chrome">SessionNotCreatedException: Message: session not created: This version of ChromeDriver only supports Chrome version 81</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在使用Selenium调用Chrome浏览器爬取互联网数据时，会遇到Chrome和ChromeDriver版本不兼容的问题，导致爬取失败。&lt;/p&gt;
&lt;p&gt;一种解决方案是，进行版本匹配。但是随着本机Chrome的更新，每次都需要随之更新ChromeDriver版本。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="网络爬虫" scheme="https://guoyujian.github.io/categories/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"/>
    
    
    <category term="网络爬虫" scheme="https://guoyujian.github.io/tags/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"/>
    
    <category term="Selenium" scheme="https://guoyujian.github.io/tags/Selenium/"/>
    
  </entry>
  
  <entry>
    <title>test_slides</title>
    <link href="https://guoyujian.github.io/2022/04/11/test-slides/"/>
    <id>https://guoyujian.github.io/2022/04/11/test-slides/</id>
    <published>2022-04-11T12:59:15.000Z</published>
    <updated>2022-04-11T13:01:32.660Z</updated>
    
    <content type="html"><![CDATA[<h1 id="这是一个slides测试博客"><a href="#这是一个slides测试博客" class="headerlink" title="这是一个slides测试博客"></a>这是一个slides测试博客</h1><p>===</p><p>它可以把markdown渲染的像幻灯片一样</p><p>==</p><p>还有垂直切换</p><p>==</p><p>还可以切换背景等。</p><p>===</p><p>Have Fun~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;这是一个slides测试博客&quot;&gt;&lt;a href=&quot;#这是一个slides测试博客&quot; class=&quot;headerlink&quot; title=&quot;这是一个slides测试博客&quot;&gt;&lt;/a&gt;这是一个slides测试博客&lt;/h1&gt;&lt;p&gt;===&lt;/p&gt;
&lt;p&gt;它可以把markdow</summary>
      
    
    
    
    
    <category term="测试" scheme="https://guoyujian.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
</feed>
