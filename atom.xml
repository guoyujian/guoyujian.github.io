<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Gmet&#39;s Blog</title>
  
  <subtitle>Eureka!</subtitle>
  <link href="https://gmet233.gitee.io/atom.xml" rel="self"/>
  
  <link href="https://gmet233.gitee.io/"/>
  <updated>2022-07-10T08:45:53.096Z</updated>
  <id>https://gmet233.gitee.io/</id>
  
  <author>
    <name>Met Guo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>分库分表总结</title>
    <link href="https://gmet233.gitee.io/2022/07/10/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E6%80%BB%E7%BB%93/"/>
    <id>https://gmet233.gitee.io/2022/07/10/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E6%80%BB%E7%BB%93/</id>
    <published>2022-07-10T08:45:53.000Z</published>
    <updated>2022-07-10T08:45:53.096Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么要分库分表"><a href="#为什么要分库分表" class="headerlink" title="为什么要分库分表"></a>为什么要分库分表</h1><p>移动互联网时代，海量的用户每天产生海量的数量，比如：用户表、订单表、交易流水表。</p><p>以支付宝用户为例，8亿；微信用户更是10亿。订单表更夸张，比如美团外卖，每天都是几千万的订单。淘宝的历史订单总量应该百亿，甚至千亿级别，这些海量数据远不是一张表能Hold住的。</p><p>事实上MySQL单表可以存储10亿级数据，只是这时候性能比较差，<strong>业界公认MySQL单表容量在1KW以下是最佳状态，因为这时它的BTREE索引树高在3~5之间。</strong></p><p>既然<strong>一张表无法搞定，那么就想办法将数据放到多个地方</strong>，目前比较普遍的方案有3个：</p><blockquote><ol><li>分区；</li><li>分库分表；</li><li>NoSQL/NewSQL；NoSQL比较具有代表性的是MongoDB，es。NewSQL比较具有代表性的是TiDB。</li></ol></blockquote><h2 id="数据库架构演变：从读写分离到分库分表"><a href="#数据库架构演变：从读写分离到分库分表" class="headerlink" title="数据库架构演变：从读写分离到分库分表"></a>数据库架构演变：从读写分离到分库分表</h2><p>刚开始我们只用单机数据库就够了，随后面对越来越多的请求，我们将数据库的<strong>写操作和读操作进行分离</strong>， 使用多个从库副本<strong>（Slaver Replication）</strong>负责读，使用主库<strong>（Master）</strong>负责写， 从库从主库同步更新数据，保持数据一致。架构上就是数据库主从同步。 从库可以水平扩展，所以更多的读请求不成问题。</p><p>但是当用户量级上来后，写请求越来越多，该怎么办？加一个Master是不能解决问题的， 因为数据要保存一致性，写操作需要2个master之间同步，相当于是重复了，而且更加复杂。</p><p>这时就需要用到<strong>分库分表（sharding），对写操作进行切分。</strong></p><h2 id="为什么不NoSQL-NewSQL"><a href="#为什么不NoSQL-NewSQL" class="headerlink" title="为什么不NoSQL/NewSQL?"></a>为什么不NoSQL/NewSQL?</h2><p>首先，为什么不选择第三种方案NoSQL/NewSQL，我认为主要是RDBMS有以下几个优点：</p><blockquote><p>RDBMS：关系型数据库管理系统（Relational Database Management System）</p><ul><li>RDBMS生态完善；</li><li>RDBMS绝对稳定；</li><li>RDBMS的事务特性；</li></ul></blockquote><p>NoSQL/NewSQL作为新生儿，在我们把可靠性当做首要考察对象时，它是无法与RDBMS相提并论的。RDBMS发展几十年，只要有软件的地方，它都是核心存储的首选。</p><p>目前绝大部分公司的核心数据都是：<strong>以RDBMS存储为主，NoSQL/NewSQL存储为辅</strong>！互联网公司又以MySQL为主，国企&amp;银行等不差钱的企业以Oracle/DB2为主！NoSQL/NewSQL宣传的无论多牛逼，就现在各大公司对它的定位，都是RDBMS的补充，而不是取而代之！</p><h2 id="为什么不分区"><a href="#为什么不分区" class="headerlink" title="为什么不分区?"></a>为什么不分区?</h2><p>我们再看分区表方案。了解这个方案之前，先了解它的原理：</p><p>分区：就是把一张表的数据分成N个区块，在逻辑上看最终只是一张表，但底层是由N个物理区块组成的，分区实现比较简单，数据库mysql、oracle等很容易就可支持。</p><blockquote><p><strong>分区表是由多个相关的底层表实现，这些底层表也是由句柄对象表示</strong>，所以我们也可以直接访问各个分区，存储引擎管理分区的各个底层表和管理普通表一样（所有的底层表都必须使用相同的存储引擎），<strong>分区表的索引只是在各个底层表上各自加上一个相同的索引</strong>，从存储引擎的角度来看，底层表和一个普通表没有任何不同，存储引擎也无须知道这是一个普通表还是一个分区表的一部分。</p></blockquote><p>一旦分表，一个库中的表会越来越多</p><blockquote><p>将整个数据库比作图书馆，一张表就是一本书。当要在一本书中查找某项内容时，如果不分章节，查找的效率将会下降。而同理，在数据库中就是分区。</p></blockquote><ul><li><strong>什么时候考虑使用分区</strong>：一张表的查询速度已经慢到影响使用的时候。</li></ul><blockquote><ol><li>sql经过优化</li><li>数据量大</li><li>表中的数据是分段的</li><li>对数据的操作往往只涉及一部分数据，而不是所有的数据</li></ol></blockquote><ul><li><p><strong>分区解决的问题</strong>：主要可以提升查询效率</p></li><li><p><strong>分区的实现方式</strong>（简单）：</p></li></ul><blockquote><p>mysql5 开始支持分区功能</p><p>CREATE TABLE sales (</p><p>id INT AUTO_INCREMENT,</p><p>amount DOUBLE NOT NULL,</p><p>order_day DATETIME NOT NULL,</p><p>PRIMARY KEY(id, order_day)</p><p>) ENGINE=Innodb</p><p>PARTITION BY RANGE(YEAR(order_day)) (</p><p>PARTITION p_2010 VALUES LESS THAN (2010),</p><p>PARTITION p_2011 VALUES LESS THAN (2011),</p><p>PARTITION p_2012 VALUES LESS THAN (2012),</p><p>PARTITION p_catchall VALUES LESS THAN MAXVALUE);</p></blockquote><ul><li>事实上，这个方案也不错，<strong>它对用户屏蔽了sharding的细节，即使查询条件没有sharding column，它也能正常工作（只是这时候性能一般）。</strong></li><li>不过它的缺点很明显：<strong>很多的资源都受到单机的限制，例如连接数，网络吞吐等</strong>！虽然每个分区可以独立存储，但是分区表的总入口还是一个MySQL示例。从而导致它的并发能力非常一般，远远达不到互联网高并发的要求！</li><li>至于网上提到的一些其他缺点比如：无法使用外键，不支持全文索引。我认为这都不算缺点，21世纪的项目如果还是使用外键和数据库的全文索引，我都懒得吐槽了！</li></ul><p>所以，<strong>如果使用分区表，你的业应该具备如下两个特点：</strong></p><blockquote><p>数据不是海量（分区数有限，存储能力就有限）；</p><p>并发能力要求不高；</p></blockquote><h1 id="分库分表概述"><a href="#分库分表概述" class="headerlink" title="分库分表概述"></a>分库分表概述</h1><p><img src="分库分表概述.jpg" alt="分库分表概述"></p><blockquote><p>读写分离：分散数据库读写操作压力</p><p>分库分表：分散存储压力</p></blockquote><h1 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h1><p><img src="适用场景.png" alt="适用场景"></p><ul><li>类似读写分离，分库分表也是确定没有其他优化空间之后才采取的优化方案。</li><li>那如果业务真的发展很快岂不是很快要进行分库分表了？那为何不一开始就设计好呢？</li></ul><p><strong>按照架构设计的“三原则”（简单原则，合适原则，演化原则）</strong>，简单分析一下：</p><blockquote><p>首先，<strong>这里的“如果”事实上发生的概率比较低</strong>，做10个业务有一个业务能活下去就很不错了，更何况快速发展，和中彩票的概率差不多。如果我们每个业务上来就按照淘宝、微信的规模去做架构设计，不但会累死自己，还会害死业务。</p><p>其次，<strong>如果业务真的发展很快，后面进行分库分表也不迟</strong>。因为业务发展好，相应的资源投入就会加大，可以投入更多的人和更多的钱，那业务分库带来的代码和业务复杂问题就可以通过加人来解决，成本问题也可以通过增加资金来解决。</p></blockquote><h1 id="分库分表的方式方法"><a href="#分库分表的方式方法" class="headerlink" title="分库分表的方式方法"></a>分库分表的方式方法</h1><blockquote><p>一般就是<strong>垂直切分和水平切分</strong>，这是一种结果集描述的切分方式，是物理空间上的切分。</p><p>我们从面临的问题，开始解决，阐述： 首先是用户请求量太大，我们就堆机器搞定（这不是本文重点）。</p><p>然后是单个库太大，这时我们要看是因为<strong>表多而导致数据多</strong>，还是因为<strong>单张表里面的数据多</strong>。</p><p>如果是因为表多而数据多，使用垂直切分，根据业务切分成不同的库。</p><p>如果是因为单张表的数据量太大，这时要用水平切分，即把表的数据按<strong>某种规则</strong>切分成多张表，甚至多个库上的多张表。 </p><p><strong>分库分表的顺序应该是先垂直分，后水平分</strong>。 因为垂直分更简单，更符合我们处理现实世界问题的方式。</p></blockquote><h2 id="垂直拆分"><a href="#垂直拆分" class="headerlink" title="垂直拆分"></a>垂直拆分</h2><h3 id="垂直分表"><a href="#垂直分表" class="headerlink" title="垂直分表"></a>垂直分表</h3><blockquote><p>也就是“大表拆小表”，基于列字段进行的。</p><p>一般是表中的字段较多，将不常用的， 数据较大，长度较长（比如text类型字段）的拆分到“扩展表“。</p><p>一般是针对那种几百列的大表，也避免查询时，数据量太大造成的“跨页”问题。</p></blockquote><h4 id="垂直分库"><a href="#垂直分库" class="headerlink" title="垂直分库"></a>垂直分库</h4><blockquote><p>垂直分库针对的是一个系统中的不同业务进行拆分，比如用户User一个库，商品Producet一个库，订单Order一个库。</p><p>切分后，要放在多个服务器上，而不是一个服务器上。</p><p>为什么？ 我们想象一下，一个购物网站对外提供服务，会有用户，商品，订单等的CRUD。没拆分之前， 全部都是落到单一的库上的，这会让数据库的<strong>单库处理能力成为瓶颈</strong>。</p><p>按垂直分库后，如果还是放在一个数据库服务器上， 随着用户量增大，这会让<strong>单个数据库的处理能力成为瓶颈</strong>，还有<strong>单个服务器的磁盘空间，内存，tps等非常吃紧</strong>。 所以我们要拆分到多个服务器上，这样上面的问题都解决了，以后也不会面对单机资源问题。</p><p>数据库业务层面的拆分，和服务的“治理”，“降级”机制类似，也能对不同业务的数据分别的进行管理，维护，监控，扩展等。</p><p>数据库往往最容易成为应用系统的瓶颈，<strong>而数据库本身属于“有状态”的，相对于Web和应用服务器来讲，是比较难实现“横向扩展”的。</strong></p><p>数据库的连接资源比较宝贵且单机处理能力也有限，在高并发场景下，垂直分库一定程度上能够突破IO、连接数及单机硬件资源的瓶颈。</p></blockquote><p><img src="业务分库1.jpg" alt="业务分库1"></p><p><img src="业务分库2.jpg" alt="业务分库2"></p><h2 id="水平拆分"><a href="#水平拆分" class="headerlink" title="水平拆分"></a>水平拆分</h2><h3 id="水平分表"><a href="#水平分表" class="headerlink" title="水平分表"></a>水平分表</h3><blockquote><p>针对数据量巨大的单张表（比如订单表），按照某种规则（<strong>RANGE，HASH取模</strong>等），切分到多张表里面去。 但是这些表还是在同一个库中，所以<strong>库级别的数据库操作还是有IO瓶颈</strong>。不建议采用。</p></blockquote><h3 id="水平分库分表"><a href="#水平分库分表" class="headerlink" title="水平分库分表"></a>水平分库分表</h3><blockquote><p>将单张表的数据切分到多个服务器上去，每个服务器具有相应的库与表，只是表中数据集合不同。 水平分库分表能够有效的缓解单机和单库的性能瓶颈和压力，突破IO、连接数、硬件资源等的瓶颈。</p></blockquote><h3 id="水平分库分表切分规则"><a href="#水平分库分表切分规则" class="headerlink" title="水平分库分表切分规则"></a>水平分库分表切分规则</h3><p><strong>RANGE</strong></p><blockquote><p>从0到10000一个表，10001到20000一个表；</p></blockquote><p><strong>HASH取模</strong></p><blockquote><p>一个商场系统，一般都是将用户，订单作为主表，然后将和它们相关的作为附表，这样不会造成跨库事务之类的问题。 <strong>取用户id，然后hash取模</strong>，分配到不同的数据库上。</p></blockquote><p><strong>地理区域</strong></p><blockquote><p>比如按照华东，华南，华北这样来区分业务，七牛云应该就是如此。</p></blockquote><p><strong>时间</strong></p><blockquote><p>按照时间切分，就是将6个月前，甚至一年前的数据切出去放到另外的一张表，因为随着时间流逝，这些表的数据 被查询的概率变小，所以没必要和“热数据”放在一起，这个也是“冷热数据分离”。</p></blockquote><h2 id="业务分表"><a href="#业务分表" class="headerlink" title="业务分表"></a>业务分表</h2><p><img src="业务分表.png" alt="业务分表"></p><p><img src="业务分表2.jpg" alt="业务分表2"></p><h1 id="分库分表后面临的问题"><a href="#分库分表后面临的问题" class="headerlink" title="分库分表后面临的问题"></a>分库分表后面临的问题</h1><h2 id="事务支持"><a href="#事务支持" class="headerlink" title="事务支持"></a>事务支持</h2><blockquote><p>分库分表后，就成了<strong>分布式事务</strong>了。</p><p>如果依赖数据库本身的分布式事务管理功能去执行事务，将付出高昂的性能代价； 如果由应用程序去协助控制，形成程序逻辑上的事务，又会造成编程方面的负担。</p></blockquote><h2 id="路由问题："><a href="#路由问题：" class="headerlink" title="路由问题："></a>路由问题：</h2><blockquote><p>垂直分表：增加表操作的次数</p><p>水平分表：<strong>路由问题</strong></p></blockquote><p> <img src="路由问题.jpg" alt="路由问题"></p><h2 id="数据库操作问题"><a href="#数据库操作问题" class="headerlink" title="数据库操作问题"></a>数据库操作问题</h2><h3 id="多库结果集合并（group-by，order-by）"><a href="#多库结果集合并（group-by，order-by）" class="headerlink" title="多库结果集合并（group by，order by）"></a>多库结果集合并（group by，order by）</h3><h3 id="跨库join"><a href="#跨库join" class="headerlink" title="跨库join"></a>跨库join</h3><blockquote><p>分库分表后表之间的关联操作将受到限制，我们无法join位于不同分库的表，也无法join分表粒度不同的表， 结果原本一次查询能够完成的业务，可能需要多次查询才能完成。</p><p>粗略的解决方法： 全局表：基础数据，所有库都拷贝一份。 字段冗余：这样有些字段就不用join去查询了。 系统层组装：分别查询出所有，然后组装起来，较复杂。</p></blockquote><p><img src="数据库操作问题.png" alt="数据库操作问题"></p><ul><li>解决方法</li></ul><p><img src="解决方法.png" alt="解决方法"></p><p>类似读写分离，具体实现也是“程序代码封装”和“中间件封装”，但具体实现复杂一些，因为还有要判断SQL中具体操作的表，具体操作（例如count、order by、group by等），根据具体操作做不同的处理。</p><h2 id="多分片（水平切分）返回结果合并（排序）"><a href="#多分片（水平切分）返回结果合并（排序）" class="headerlink" title="多分片（水平切分）返回结果合并（排序）"></a>多分片（水平切分）返回结果合并（排序）</h2><h3 id="①-Select-None-Aggregate-Function的有序记录合并排序"><a href="#①-Select-None-Aggregate-Function的有序记录合并排序" class="headerlink" title="① Select + None Aggregate Function的有序记录合并排序"></a>① Select + None Aggregate Function的有序记录合并排序</h3><blockquote><p>解决思路：对各分片返回的有序记录，进行排序去重合并。此处主要是编写排序去重合并算法。</p></blockquote><h3 id="②-Select-None-Aggregate-Function的无序记录合并"><a href="#②-Select-None-Aggregate-Function的无序记录合并" class="headerlink" title="② Select + None Aggregate Function的无序记录合并"></a>② Select + None Aggregate Function的无序记录合并</h3><blockquote><p>解决思路：对各分片返回的无序记录，进行去重合并。</p><ul><li>优点：实现比较简单。</li><li>缺点：数据量越大，字段越多，去重处理就会越耗时。</li></ul></blockquote><h3 id="③-Select-Aggregate-Function的记录合并（排序）Oracle常用聚合函数：Count、Max、Min、Avg、Sum。"><a href="#③-Select-Aggregate-Function的记录合并（排序）Oracle常用聚合函数：Count、Max、Min、Avg、Sum。" class="headerlink" title="③ Select + Aggregate Function的记录合并（排序）Oracle常用聚合函数：Count、Max、Min、Avg、Sum。"></a>③ Select + Aggregate Function的记录合并（排序）Oracle常用聚合函数：Count、Max、Min、Avg、Sum。</h3><blockquote><ul><li>AF：Max、Min<ul><li>思路：通过算法对各分片返回结果再求max、min值。</li></ul></li><li>AF：Avg、Sum、Count<ul><li>思路：分片间无重复记录或字段时，通过算法对各分片返回结果再求avg、sum、count值。分片间有重复记录或字段时，先对各分片记录去重合并，再通过算法求avg、sum、count值。</li></ul></li></ul></blockquote><p>比如：</p><blockquote><p>select count(*) from user</p><p>select count(deptno) from user;</p><p>select count(distinct deptno) from user;</p></blockquote><h2 id="多分片（水平切分）返回结果分页"><a href="#多分片（水平切分）返回结果分页" class="headerlink" title="多分片（水平切分）返回结果分页"></a>多分片（水平切分）返回结果分页</h2><blockquote><p>解决思路：合并各分片返回结果，逻辑分页。</p><ul><li>优点：  实现简单。</li><li>缺点：  数据量越大，缓存压力就越大。分片数据量越大，查询也会越慢。</li></ul></blockquote><h2 id="多分片（水平切分）查询有分组语法的合并"><a href="#多分片（水平切分）查询有分组语法的合并" class="headerlink" title="多分片（水平切分）查询有分组语法的合并"></a>多分片（水平切分）查询有分组语法的合并</h2><h3 id="①-Group-By-Having-None-Aggregate-Function时"><a href="#①-Group-By-Having-None-Aggregate-Function时" class="headerlink" title="① Group By Having + None Aggregate Function时"></a>① Group By Having + None Aggregate Function时</h3><blockquote><ul><li>Select + None Aggregate Function<ul><li>比如：select job user group by job;</li><li>思路：直接去重（排序）合并。</li></ul></li><li>Select + Aggregate Function<ul><li>比如：select max(sal),job user group by job;</li><li>思路：同Select + Aggregate Function的记录合并（排序）。</li></ul></li></ul></blockquote><h3 id="②-Group-By-Having-Aggregate-Function时"><a href="#②-Group-By-Having-Aggregate-Function时" class="headerlink" title="② Group By Having + Aggregate Function时"></a>② Group By Having + Aggregate Function时</h3><blockquote><p>解决思路：去掉having AF条件查询各分片，然后把数据放到一张表里。再用group by having 聚合函数查询。</p></blockquote><h2 id="分布式数据库架构—排序分组分页参考解决方案"><a href="#分布式数据库架构—排序分组分页参考解决方案" class="headerlink" title="分布式数据库架构—排序分组分页参考解决方案"></a>分布式数据库架构—排序分组分页参考解决方案</h2><blockquote><ul><li>解决方案1：Hadoop + Hive。<ul><li>思路：使用Hadoop HDFS来存储数据，通过Hdoop MapReduce完成数据计算，通过Hive HQL语言使用部分与RDBBS一样的表格查询特性和分布式存储计算特性。</li><li>优点：<ul><li>可以解决问题</li><li>具有并发处理能力</li><li>可以离线处理</li></ul></li><li>缺点： <ul><li>实时性不能保证</li><li>网络延迟会增加</li><li>异常捕获难度增加</li><li>Web应用起来比较复杂</li></ul></li></ul></li><li>解决方案2：总库集中查询。<ul><li>优点：<ul><li>可以解决问题</li><li>实现简单</li></ul></li><li>缺点：<ul><li>总库数据不能太大</li><li>并发压力大</li></ul></li></ul></li></ul></blockquote><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>对于分布式数据库架构来说，排序、分页、分组一直就是一个比较复杂的问题。避免此问题需要好好地设计分库、分表策略。同时根据特定的场景来解决问题。也可以 充分利用海量数据存储（Hadoop-HDFS|Hive|HBse）、搜索引擎（Lucene|Solr）及分布式计算（MapReduce）等技术来 解决问题。</p><p>另外，也可以用NoSQL技术替代关系性数据库来解决问题，比如MogonDB/Redis。</p><h1 id="参考（COPY）资料"><a href="#参考（COPY）资料" class="headerlink" title="参考（COPY）资料"></a>参考（COPY）资料</h1><ol><li><a href="https://blog.csdn.net/fly910905/article/details/87090092">分库分表：应用场景、方式方法、面临问题</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;为什么要分库分表&quot;&gt;&lt;a href=&quot;#为什么要分库分表&quot; class=&quot;headerlink&quot; title=&quot;为什么要分库分表&quot;&gt;&lt;/a&gt;为什么要分库分表&lt;/h1&gt;&lt;p&gt;移动互联网时代，海量的用户每天产生海量的数量，比如：用户表、订单表、交易流水表。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="数据库" scheme="https://gmet233.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库" scheme="https://gmet233.gitee.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>【读书笔记】生而贫穷</title>
    <link href="https://gmet233.gitee.io/2022/06/02/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91%E7%94%9F%E8%80%8C%E8%B4%AB%E7%A9%B7/"/>
    <id>https://gmet233.gitee.io/2022/06/02/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91%E7%94%9F%E8%80%8C%E8%B4%AB%E7%A9%B7/</id>
    <published>2022-06-02T02:04:03.000Z</published>
    <updated>2022-06-02T02:04:03.611Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>第一个Spring应用</title>
    <link href="https://gmet233.gitee.io/2022/05/26/%E7%AC%AC%E4%B8%80%E4%B8%AASpring%E5%BA%94%E7%94%A8/"/>
    <id>https://gmet233.gitee.io/2022/05/26/%E7%AC%AC%E4%B8%80%E4%B8%AASpring%E5%BA%94%E7%94%A8/</id>
    <published>2022-05-26T15:38:02.000Z</published>
    <updated>2022-05-26T16:32:33.625Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本人以前学过Spring，也写过相关业务代码。但是对Spring理解不深刻，故重新认识Spring</p></blockquote><h1 id="初始化Spring项目"><a href="#初始化Spring项目" class="headerlink" title="初始化Spring项目"></a>初始化Spring项目</h1><p>我这里使用的是IDEA初始化Spring项目。</p><p>创建一个项目，并做如下设置，选择下一步。</p><p><img src="image-20220526234222155.png" alt="init"></p><p>配置新项目：</p><p><img src="image-20220526234348424.png" alt="config1"></p><p>选择Spring Boot的版本和插件，选择下一步。</p><p><img src="image-20220526234432034.png" alt="config2"></p><p>配置项目名称等。选择完成。</p><p><img src="image-20220526234505163.png" alt="config3"></p><blockquote><p>这里配置有问题也没关系，在pom.xml文件中做修改即可。</p></blockquote><h1 id="认识Spring项目"><a href="#认识Spring项目" class="headerlink" title="认识Spring项目"></a>认识Spring项目</h1><blockquote><p>本项目上传到了GitHub：<a href="https://github.com/guoyujian/spring-in-action5-code">https://github.com/guoyujian/spring-in-action5-code</a></p></blockquote><h2 id="mvnw和mvnw-cmd"><a href="#mvnw和mvnw-cmd" class="headerlink" title="mvnw和mvnw.cmd"></a>mvnw和mvnw.cmd</h2><p>mvnw和mvnw.cmd是Maven包装器（wrapper）脚本。借助这些脚本，即便你的机器上没有安装Maven，也可以构建项目。</p><h2 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h2><p>下面是我的pom.xml配置</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;version&gt;2.7.0&lt;/version&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>sia<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>taco-cloud<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>taco-cloud<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Taco Cloud Example<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>11<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--以下都是我加的--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>注意几点：</p><ol><li>parent/version标签指定了所有Spring相关包的版本，这样我们就不用在下面的dependency中配置版本。</li><li>packaging指出了打包方式，相比于war，jar更加流行。</li><li>properties/java.version指定了运行的java版本</li><li>dependencies标签下面全是依赖。其实一个最基本的项目是不需要这么多dependency的。可以自行注释掉这些dependency测试一下。</li></ol></blockquote><h2 id="TacoCloudApplication"><a href="#TacoCloudApplication" class="headerlink" title="TacoCloudApplication"></a>TacoCloudApplication</h2><p>这是主类。代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TacoCloudApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(TacoCloudApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中最重要的是@SpringBootApplication注解，这是一个组合注解，它组合了3个其他的注解：</p><ul><li>@SpringBootConfiguration：将该类声明为配置类。尽管这个类目前还没有太多的配置，但是后续我们可以按需添加基于Java的Spring框架配置。这个注解实际上是@Configuration注解的特殊形式。</li><li>@EnableAutoConfiguration：启用Spring Boot的自动配置。我们随后会介绍自动配置的更多功能。就现在来说，我们只需要知道这个注解会告诉Spring Boot自动配置它认为我们会用到的组件。</li><li>@ComponentScan：启用组件扫描。这样我们能够通过像@Component、@Controller、@Service这样的注解声明其他类，Spring会自动发现它们并将它们注册为Spring应用上下文中的组件。</li></ul><h2 id="TacoCloudApplicationTests"><a href="#TacoCloudApplicationTests" class="headerlink" title="TacoCloudApplicationTests"></a>TacoCloudApplicationTests</h2><p>测试类。后面细讲。</p><h2 id="resources"><a href="#resources" class="headerlink" title="resources/"></a>resources/</h2><p>该目录下，有</p><p><code>templates/</code>：存放thymeleaf模板，由于现在前后端分离开发，thymeleaf是用来代替jsp的一个东西，所以这个文件夹和thymeleaf没那么重要。</p><p><code>static/</code>：存放静态资源，图片，JS啥的，同上，不重要</p><p><code>application.properties</code>：Spring的配置文件，可以是yml，重要</p><h1 id="编写简单的Spring应用"><a href="#编写简单的Spring应用" class="headerlink" title="编写简单的Spring应用"></a>编写简单的Spring应用</h1><h2 id="MyController"><a href="#MyController" class="headerlink" title="MyController"></a>MyController</h2><p>在<code>tacos</code>包下面加入MyController，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/home&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">home</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;home&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>该类有一个@Controller注解所以Spring的组件扫描功能会自动发现它，并创建一个HomeController实例作为Spring应用上下文中的bean。实际上，有一些其他的注解与@Controller有着类似的目的（包括@Component、@Service和@Repository）。你可以为HomeController添加上述的任意其他注解，其作用是完全相同的。但是，在这里选择使用@Controller更能描述这个组件在应用中的角色。</p><p>home()是一个简单的控制器方法。它带有@GetMapping注解，表明如果针对<code>/home</code>发送HTTP GET请求，那么这个方法将会处理请求。</p><p>该方法所做的只是返回String类型的home值。这个值将会被解析为视图的逻辑名。视图如何实现取决于多个因素，但是因为Thymeleaf位于类路径中，所以我们可以使用Thymeleaf来定义模板。</p><p>模板名称是由逻辑视图名派生而来的，再加上“/templates/”前缀和“.html”后缀。最终形成的模板路径将是“/templates/home.html”。所以，我们需要将模板放到项目的“/src/main/resources/templates/home.html”目录中。</p><h2 id="home-html"><a href="#home-html" class="headerlink" title="home.html"></a>home.html</h2><p>这块代码很简单：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">hello!</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="编写测试类"><a href="#编写测试类" class="headerlink" title="编写测试类"></a>编写测试类</h2><p>在上面的TacoCloudApplicationTests测试类中编写代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.hamcrest.Matchers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.web.servlet.MockMvc;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.web.servlet.RequestBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@WebMvcTest(MyController.class)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TacoCloudApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MockMvc mvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHomePage</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        mvc.perform(MockMvcRequestBuilders.get(<span class="string">&quot;/home&quot;</span>))</span><br><span class="line">                .andExpect(MockMvcResultMatchers.status().isOk())</span><br><span class="line">                .andExpect(MockMvcResultMatchers.view().name(<span class="string">&quot;home&quot;</span>))</span><br><span class="line">                .andExpect(MockMvcResultMatchers.content().string(Matchers.containsString(<span class="string">&quot;hello&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这个类带有@RunWith(SpringRunner.class)注解。@RunWith是JUnit的注解，它会提供一个测试运行器（runner）来指导JUnit如何运行测试。可以将其想象为给JUnit应用一个插件，以提供自定义的测试行为。在本例中，为JUnit提供的是SpringRunner，这是一个Spring提供的测试运行器，它会创建测试运行所需的Spring应用上下文。</p><p>@WebMvcTest注解。这是Spring Boot所提供的一个特殊测试注解，它会让这个测试在Spring MVC应用的上下文中执行。更具体来讲，在本例中，它会将MyController注册到Spring MVC中，这样的话，我们就可以向它发送请求了。</p><p>测试类被注入了一个MockMvc，能够让测试实现mockup。通过testHomePage()方法，我们定义了针对主页想要执行的测试。它首先使用MockMvc对象对“/home”（根路径）发起HTTP GET请求。对于这个请求，我们设置了如下的预期（assert）：</p><ul><li>响应应该具备HTTP 200 (OK)状态</li><li>视图的逻辑名称应该是home</li><li>渲染后的视图应该包含文本hello</li></ul><blockquote><p>注意，如果Spring版本为2.7.0，这里@Autowired会报错，目前还不知道为什么。</p></blockquote><p>执行这个测试类，发现程序执行成功了。</p><p><img src="image-20220527003138947.png" alt="res"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对本人来说，最大的收获就是如何编写测试类，对Spring应用进行快速测试。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>《Spring 实战（第五版）》</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本人以前学过Spring，也写过相关业务代码。但是对Spring理解不深刻，故重新认识Spring&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;初始化Spring项目&quot;&gt;&lt;a href=&quot;#初始化Spring项目&quot; class=&quot;heade</summary>
      
    
    
    
    <category term="Java" scheme="https://gmet233.gitee.io/categories/Java/"/>
    
    <category term="Springy" scheme="https://gmet233.gitee.io/categories/Java/Springy/"/>
    
    
    <category term="Java" scheme="https://gmet233.gitee.io/tags/Java/"/>
    
    <category term="Spring" scheme="https://gmet233.gitee.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Java8 流（1）</title>
    <link href="https://gmet233.gitee.io/2022/05/22/Java8-%E6%B5%81%EF%BC%881%EF%BC%89/"/>
    <id>https://gmet233.gitee.io/2022/05/22/Java8-%E6%B5%81%EF%BC%881%EF%BC%89/</id>
    <published>2022-05-22T07:08:00.000Z</published>
    <updated>2022-05-22T07:08:00.675Z</updated>
    
    <content type="html"><![CDATA[<h1 id="流是什么"><a href="#流是什么" class="headerlink" title="流是什么"></a>流是什么</h1><p>流是Java API的新成员，它允许你以<strong>声明性</strong>方式处理数据集合（通过查询语句来表达，而不是临时编写一个实现）。就现在来说，你可以把它们看成遍历数据集的高级迭代器。</p><p>此外，流还可以透明的并行处理，你无需写任何多线程代码了！</p><hr><p>在继续介绍之前，先定义一会要使用到的集合对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Dish&gt; menu = Arrays.asList(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Dish</span>(<span class="string">&quot;pork&quot;</span>, <span class="literal">false</span>, <span class="number">800</span>, Dish.Type.MEAT),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Dish</span>(<span class="string">&quot;beef&quot;</span>, <span class="literal">false</span>, <span class="number">700</span>, Dish.Type.MEAT),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Dish</span>(<span class="string">&quot;chicken&quot;</span>, <span class="literal">false</span>, <span class="number">400</span>, Dish.Type.MEAT),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Dish</span>(<span class="string">&quot;french fries&quot;</span>, <span class="literal">true</span>, <span class="number">530</span>, Dish.Type.OTHER),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Dish</span>(<span class="string">&quot;rice&quot;</span>, <span class="literal">true</span>, <span class="number">350</span>, Dish.Type.OTHER),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Dish</span>(<span class="string">&quot;season fruit&quot;</span>, <span class="literal">true</span>, <span class="number">120</span>, Dish.Type.OTHER),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Dish</span>(<span class="string">&quot;pizza&quot;</span>, <span class="literal">true</span>, <span class="number">550</span>, Dish.Type.OTHER),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Dish</span>(<span class="string">&quot;prawns&quot;</span>, <span class="literal">false</span>, <span class="number">300</span>, Dish.Type.FISH),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Dish</span>(<span class="string">&quot;salmon&quot;</span>, <span class="literal">false</span>, <span class="number">450</span>, Dish.Type.FISH) );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Dish对象的声明如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dish</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> vegetarian;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> calories;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Type type;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dish</span><span class="params">(String name, <span class="type">boolean</span> vegetarian, <span class="type">int</span> calories, Type type)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.vegetarian = vegetarian;</span><br><span class="line">        <span class="built_in">this</span>.calories = calories;</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//getter、setter</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Type</span> &#123;MEAT, FISH, OTHER&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="流简介"><a href="#流简介" class="headerlink" title="流简介"></a>流简介</h1><blockquote><p>简短的定义就是“从支持数据处理操作的源生成的元素序列”</p></blockquote><ul><li><strong>元素序列</strong>——就像集合一样，流也提供了一个接口，可以访问特定元素类型的一组有序值。因为集合是数据结构，所以它的主要目的是以特定的时间/空间复杂度存储和访问元素（如ArrayList 与 LinkedList）。但流的目的在于表达计算。<strong>集合讲的是数据，流讲的是计算</strong>。我们会在后面详细解 释这个思想。</li><li><strong>源</strong>——流会使用一个提供数据的源，如集合、数组或输入/输出资源。 请注意，从有序集合生成流时会保留原有的顺序。由列表生成的流，其元素顺序与列表一致。</li><li><strong>数据处理操作</strong>——流的数据处理功能支持类似于数据库的操作，以及函数式编程语言中 的常用操作，如filter、map、reduce、find、match、sort等。流操作可以顺序执行，也可并行执行。</li></ul><p>此外，流操作有两个重要的特点。</p><ul><li><strong>流水线</strong>——很多流操作本身会返回一个流，这样多个操作就可以链接起来，形成一个大的流水线。这让一些优化成为可能，如延迟和短路。流水线的操作可以看作对数据源进行数据库式查询。</li><li><strong>内部迭代</strong>——与使用迭代器显式迭代的集合不同，流的迭代操作是在背后进行的。</li></ul><p>举例：筛选菜单中卡路里高于300的三个菜名</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; res = menu.stream()</span><br><span class="line">    .filter(d -&gt; d.getCalories() &gt; <span class="number">300</span>)</span><br><span class="line">    .map(d -&gt; d.getName())</span><br><span class="line">    .limit(<span class="number">3</span>)</span><br><span class="line">    .collect(Collectors.toList());</span><br><span class="line">System.out.println(res);</span><br></pre></td></tr></table></figure><blockquote><p>在本例中，我们先是对menu调用stream方法，由菜单得到一个流。<strong>数据源</strong>是菜单列表， 它给流提供一个<strong>元素序列</strong>。接下来，对流应用一系列数据处理操作：filter、map、limit 和collect。除了collect之外，所有这些操作都会返回另一个流，这样它们就可以接成一条流水线，于是就可以看作对源的一个查询。最后，collect操作开始处理流水线，并返回结果（它和别的操作不一样，因为它返回的不是流，在这里是一个List）。在调用collect之前，没有任何结果产生，实际上根本就没有从menu里选择元素。你可以这么理解：链中的方法调用都在排队等待，直到调用collect。</p></blockquote><p>过程如下：</p><p><img src="img1.png" alt="流可视化"></p><h1 id="流与集合"><a href="#流与集合" class="headerlink" title="流与集合"></a>流与集合</h1><blockquote><p>简单地说，集合与流之间的差异就在于什么时候进行计算。集合是一个内存中的数据结构， 它包含数据结构中目前所有的值——集合中的每个元素都得先算出来才能添加到集合中。（你可 以往集合里加东西或者删减东西，但是不管什么时候，集合中的每个元素都是放在内存里的，元素 都得先算出来才能成为集合的一部分。）</p><p>相比之下，流则是在概念上固定的数据结构（你不能添加或删除元素），其元素则是按需计 算的。</p></blockquote><ul><li>与集合不同，流只能遍历一次</li><li>集合是外部迭代，而流使用内部迭代——它帮你把迭代做了</li></ul><h1 id="流操作"><a href="#流操作" class="headerlink" title="流操作"></a>流操作</h1><p>stream定义了很多操作，分为两类：</p><ol><li>filter、map和limit可以连成一条流水线；</li><li>collect触发流水线执行并关闭它；</li></ol><p>可以连接起来的流操作称为中间操作，关闭流的操作称为终端操作。</p><p>总而言之，流的使用一般包括三件事：</p><ol><li>一个数据源（如集合）来执行一个查询；</li><li>一个中间操作链，形成一条流的流水线；</li><li>一个中间操作，执行流水线，并能生成结果。</li></ol><h1 id="使用流"><a href="#使用流" class="headerlink" title="使用流"></a>使用流</h1><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p>Streams接口支持filter方法（你现在应该很熟悉了）。该操作会接受一个<a href="https://geek-docs.com/java/java-tutorial/predicate.html">谓词</a>（一个返回 boolean的函数）作为参数，并返回一个包括所有符合谓词的元素的流。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 筛选所有素菜</span></span><br><span class="line">List&lt;Dish&gt; vegetarianMenu = menu.stream() </span><br><span class="line">                .filter(Dish::isVegetarian) </span><br><span class="line">                .collect(toList());</span><br></pre></td></tr></table></figure><h2 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h2><p>和数据库的distinct关键词很像，它会返回一个元素各异（即无重复的，根据流所生成元素的 hashCode和equals方法实现）的流。</p><h2 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h2><p>和数据库的limit关键词很像，该方法会返回一个不超过给定长度的流。</p><h2 id="skip"><a href="#skip" class="headerlink" title="skip"></a>skip</h2><p>流还支持skip(n)方法，返回一个扔掉了前n个元素的流。</p><h2 id="☆map"><a href="#☆map" class="headerlink" title="☆map"></a>☆map</h2><p><strong>对流中每一个元素应用函数</strong>。流支持map方法，这个方法接收一个函数作为参数，这个函数会被应用到流中的每个元素，并将其映 成一个新的元素，（创建新版本而不是修改原始流）例如，下面的代码把方法引用Dish::getName传给了map方法， 来提取流中菜肴的名称：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; dishNames = menu.stream() </span><br><span class="line">                             .map(Dish::getName) </span><br><span class="line">                             .collect(toList());</span><br></pre></td></tr></table></figure><h2 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h2><p>当给定单词列表<code>[&quot;Hello&quot;,&quot;World&quot;]</code>，想要返回各不相同的字符列表<code>[&quot;H&quot;,&quot;e&quot;,&quot;l&quot;, &quot;o&quot;,&quot;W&quot;,&quot;r&quot;,&quot;d&quot;]</code>。如果你使用<code>map(word -&gt; word.split(&quot;&quot;))</code>，你会发现这根本不起作用，这个方法的问题在于，传递给map方法的Lambda（word -&gt; word.split(“”)）为每个单词返回了一个String[]（String 列表）。因此，map返回的流实际上是Stream<String[]>类型的。你真正想要的是用 Stream来表示一个字符流。</p><p>此时你可以使用flatMap。使用flatMap方法的效果是，各个数组并不是分别映射成一个流，而映射成流的内容。所 有使用map(Arrays::stream)时生成的单个流都被合并起来，即扁平化为一个流。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; uniqueCharacters = words.stream() </span><br><span class="line">                                    .map(w -&gt; w.split(<span class="string">&quot;&quot;</span>)) </span><br><span class="line">                                    .flatMap(Arrays::stream) </span><br><span class="line">                                    .distinct() </span><br><span class="line">                                    .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><h2 id="查找与匹配"><a href="#查找与匹配" class="headerlink" title="查找与匹配"></a>查找与匹配</h2><blockquote><p> 另一个常见的数据处理操作是看看数据集中的某些元素是否匹配一个给定的属性， Stream API通过allMatch、anyMatch、noneMatch、findFirst和findAny方法提供了这样的工具。</p></blockquote><h3 id="anyMatch"><a href="#anyMatch" class="headerlink" title="anyMatch"></a>anyMatch</h3><p>anyMatch方法可以解决 “流中是否有一个元素能匹配给定的谓词”。比如，你可以用它来看看菜单里面是否有素食可选择：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">menu.stream().anyMatch(Dish::isVegetarian)</span><br></pre></td></tr></table></figure><p>anyMatch方法返回一个boolean，因此是一个终端操作</p><h3 id="allMatch"><a href="#allMatch" class="headerlink" title="allMatch"></a>allMatch</h3><p>allMatch方法会检查流中的元素是否都能匹配给定的谓词。</p><h3 id="noneMatch"><a href="#noneMatch" class="headerlink" title="noneMatch"></a>noneMatch</h3><p>noneMatch它可以确保流中没有任何元素与给定的谓词匹配。</p><h3 id="findany"><a href="#findany" class="headerlink" title="findany"></a>findany</h3><p>findAny方法将返回当前流中的任意元素，它返回的是<code>Optional&lt;T&gt;</code></p><h3 id="findFirst"><a href="#findFirst" class="headerlink" title="findFirst"></a>findFirst</h3><p>findFirst查找第一个元素</p><h2 id="归约"><a href="#归约" class="headerlink" title="归约"></a>归约</h2><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><p>使用reduce，你可以像下面这样对流中所有的元素求和：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int sum = numbers.stream().reduce(0, (a, b) -&gt; a + b);</span><br></pre></td></tr></table></figure><p>reduce接受两个参数：</p><ul><li>一个初始值，这里是0；</li><li>一个BinaryOperator来将两个元素结合起来产生一个新值，这里我们用的是 lambda (a, b) -&gt; a + b。</li></ul><p>你也很容易把所有的元素相乘，只需要将另一个Lambda：(a, b) -&gt; a * b传递给reduce 操作就可以了：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int product = numbers.stream().reduce(1, (a, b) -&gt; a * b);</span><br></pre></td></tr></table></figure><p>reduce还有一个重载的变体，它不接受初始值，但是会返回一个Optional对象：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Optional&lt;Integer&gt; sum = numbers.stream().reduce((a, b) -&gt; (a + b));</span><br></pre></td></tr></table></figure><blockquote><p>为什么它返回一个Optional呢？考虑流中没有任何元素的情况。reduce操作无 法返回其和，因为它没有初始值。这就是为什么结果被包裹在一个Optional对象里，以表明和可能不存在。</p><p>map和reduce的连接通常称为map-reduce模式，因Google用它来进行网络搜索而出名， 因为它很容易并行化。</p></blockquote><h3 id="中间操作和终端操作表"><a href="#中间操作和终端操作表" class="headerlink" title="中间操作和终端操作表"></a>中间操作和终端操作表</h3><p><img src="img2.png" alt="操作表"></p><h2 id="数值流"><a href="#数值流" class="headerlink" title="数值流"></a>数值流</h2><p>我们在前面看到了可以使用reduce方法计算流中元素的总和。例如，你可以像下面这样计 算菜单的热量：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int calories = menu.stream() </span><br><span class="line">                .map(Dish::getCalories) </span><br><span class="line">                .reduce(0, Integer::sum);</span><br></pre></td></tr></table></figure><p>这段代码的问题是，它有一个暗含的装箱成本。每个Integer都必须拆箱成一个原始类型， 再进行求和。但是Stream为我们提供了更好的解决办法</p><h3 id="原始类型流特化"><a href="#原始类型流特化" class="headerlink" title="原始类型流特化"></a>原始类型流特化</h3><p>Java 8引入了三个原始类型特化流接口来解决这个问题：IntStream、DoubleStream和 LongStream，分别将流中的元素特化为int、long和double，从而避免了暗含的装箱成本。</p><h3 id="映射到数值流"><a href="#映射到数值流" class="headerlink" title="映射到数值流"></a>映射到数值流</h3><p>将流转换为特化版本的常用方法是mapToInt、mapToDouble和mapToLong。这些方法和前 面说的map方法的工作方式一样，只是它们返回的是一个特化流，而不是Stream。</p><p>你可以像下面这样用mapToInt对menu中的卡路里求和：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int calories = menu.stream() </span><br><span class="line">                .mapToInt(Dish::getCalories) </span><br><span class="line">                .sum();</span><br></pre></td></tr></table></figure><blockquote><p>这里，mapToInt会从每道菜中提取热量（用一个Integer表示），并返回一个IntStream （而不是一个Stream）。然后你就可以调用IntStream接口中定义的sum方法，对卡 路里求和了！请注意，如果流是空的，sum默认返回0。IntStream还支持其他的方便方法，如 max、min、average等。</p></blockquote><h3 id="转换回对象流"><a href="#转换回对象流" class="headerlink" title="转换回对象流"></a>转换回对象流</h3><p>同样，一旦有了数值流，你可能会想把它转换回非特化流。例如，IntStream上的操作只能 产生原始整数： IntStream 的 map 操作接受的 Lambda 必须接受 int 并返回 int （一个IntUnaryOperator）。但是你可能想要生成另一类值，比如Dish。为此，你需要访问Stream 接口中定义的那些更广义的操作。要把原始流转换成一般流（每个int都会装箱成一个 Integer），可以使用boxed方法</p><h3 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a>数值范围</h3><p>假设你想要生成1和100之间的所有数值， Java 8引入了两个可以用于IntStream和LongStream的静态方法，帮助生成这种范围： range和rangeClosed。这两个方法都是第一个参数接受起始值，第二个参数接受结束值。但 range是不包含结束值的，而rangeClosed则包含结束值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里的范围是[1,100] 结果为50个</span></span><br><span class="line"><span class="type">int</span> <span class="variable">evenNumbers</span> <span class="operator">=</span> IntStream.rangeClosed(<span class="number">1</span>, <span class="number">100</span>)</span><br><span class="line">                            .filter(n -&gt; n % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                            .count();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的范围是[1,100) 不包含100 结果为49</span></span><br><span class="line"><span class="type">int</span> <span class="variable">evenNumbers2</span> <span class="operator">=</span> IntStream.range(<span class="number">1</span>, <span class="number">100</span>)</span><br><span class="line">                            .filter(n -&gt; n % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                            .count();</span><br></pre></td></tr></table></figure><h3 id="应用：勾股数"><a href="#应用：勾股数" class="headerlink" title="应用：勾股数"></a>应用：勾股数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">生成N个勾股数三元组，例(3,4,5), (5,12,13)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Stream&lt;<span class="type">double</span>[]&gt; stream = IntStream.rangeClosed(<span class="number">1</span>, <span class="number">100</span>) <span class="comment">// 生成1-100的int(a)</span></span><br><span class="line">    .boxed() <span class="comment">//封装为Stream&lt;Integer&gt;才能继续流的操作</span></span><br><span class="line">    .flatMap(a -&gt; IntStream.rangeClosed(a, <span class="number">100</span>) <span class="comment">//// 生成a-100的int(b)</span></span><br><span class="line">             .mapToObj(b -&gt; <span class="keyword">new</span> <span class="title class_">double</span>[]&#123;a, b, Math.sqrt(a * a + b * b)&#125;)) <span class="comment">//生成三元组 a,b,a^2+b^2的开方</span></span><br><span class="line">    .filter(t -&gt; t[<span class="number">2</span>] % <span class="number">1</span> == <span class="number">0</span>); <span class="comment">// 筛选掉非整数</span></span><br><span class="line">stream.limit(<span class="number">4</span>).forEach(t -&gt; System.out.println(t[<span class="number">0</span>] + <span class="string">&quot;, &quot;</span> + t[<span class="number">1</span>] + <span class="string">&quot;, &quot;</span> + t[<span class="number">2</span>])); <span class="comment">//打印前四个</span></span><br></pre></td></tr></table></figure><h2 id="构建流"><a href="#构建流" class="headerlink" title="构建流"></a>构建流</h2><h3 id="由值创建流"><a href="#由值创建流" class="headerlink" title="由值创建流"></a>由值创建流</h3><p>你可以使用静态方法<code>Stream.of</code>，通过显式值创建一个流。它可以接受任意数量的参数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;Java 8 &quot;</span>, <span class="string">&quot;Lambdas &quot;</span>, <span class="string">&quot;In &quot;</span>, <span class="string">&quot;Action&quot;</span>); </span><br></pre></td></tr></table></figure><p>你可以使用empty得到一个空流，如下所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; emptyStream = Stream.empty();</span><br></pre></td></tr></table></figure><h3 id="数组创建流"><a href="#数组创建流" class="headerlink" title="数组创建流"></a>数组创建流</h3><p>你可以使用静态方法<code>Arrays.stream</code>从数组创建一个流。它接受一个数组作为参数。例如， 你可以将一个原始类型int的数组转换成一个IntStream，如下所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] numbers = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;; </span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> Arrays.stream(numbers).sum();</span><br></pre></td></tr></table></figure><h3 id="由文件生成流"><a href="#由文件生成流" class="headerlink" title="由文件生成流"></a>由文件生成流</h3><p>Java中用于处理文件等I/O操作的NIO API（非阻塞I/O）已更新，以便利用Stream API。 java.nio.file.Files中的很多静态方法都会返回一个流。</p><blockquote><p>例如，一个很有用的方法是Files.lines，它会返回一个由指定文件中的各行构成的字符串流。使用你迄今所学的内容， 你可以用这个方法看看一个文件中有多少各不相同的词：</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">uniqueWords</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">Stream&lt;String&gt; lines = Files.lines(Paths.get(<span class="string">&quot;data.txt&quot;</span>), </span><br><span class="line">uniqueWords = lines.flatMap(line -&gt; Arrays.stream(line.split(<span class="string">&quot; &quot;</span>)))</span><br><span class="line">                .distinct() </span><br><span class="line">                .count(); </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="由函数生成无限流"><a href="#由函数生成无限流" class="headerlink" title="由函数生成无限流"></a>由函数生成无限流</h3><p>Stream API提供了两个静态方法来从函数生成流：Stream.iterate和Stream.generate。 这两个操作可以创建所谓的无限流：不像从固定集合创建的流那样有固定大小的流。由iterate 和generate产生的流会用<strong>给定的函数按需创建值</strong>，因此可以无穷无尽地计算下去！一般来说， 应该使用limit(n)来对这种流加以限制</p><h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><p>我们先来看一个iterate的简单例子，然后再解释：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.iterate(<span class="number">0</span>, n -&gt; n + <span class="number">2</span>) </span><br><span class="line">    .limit(<span class="number">10</span>) </span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>iterate方法接受一个初始值（在这里是0），还有一个依次应用在每个产生的新值上的 Lambda（UnaryOperator类型）。这里，我们使用Lambda n -&gt; n + 2，返回的是前一个元 素加上2</p><h4 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h4><p>与iterate方法类似，generate方法也可让你按需生成一个无限流。但generate不是依次 对每个新生成的值应用函数的。它接受一个Supplier类型的Lambda提供新的值。我们先来 看一个简单的用法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.generate(Math::random) </span><br><span class="line">    .limit(<span class="number">5</span>) </span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>这段代码将生成一个流，其中有五个0到1之间的随机双精度数。例如，运行一次得到了下面 的结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0.9410810294106129 </span><br><span class="line">0.6586270755634592 </span><br><span class="line">0.9592859117266873 </span><br><span class="line">0.13743396659487006 </span><br><span class="line">0.3942776037651241</span><br></pre></td></tr></table></figure><p>Math.Random静态方法被用作新值生成器。</p><p>详略。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>《Java8 实战》</li><li><a href="https://github.com/caotinging/Java8Action#%E6%B5%81%E6%98%AF%E4%BB%80%E4%B9%88">《java8实战》学习笔记</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;流是什么&quot;&gt;&lt;a href=&quot;#流是什么&quot; class=&quot;headerlink&quot; title=&quot;流是什么&quot;&gt;&lt;/a&gt;流是什么&lt;/h1&gt;&lt;p&gt;流是Java API的新成员，它允许你以&lt;strong&gt;声明性&lt;/strong&gt;方式处理数据集合（通过查询语句来表达，而不是</summary>
      
    
    
    
    <category term="Java" scheme="https://gmet233.gitee.io/categories/Java/"/>
    
    <category term="Java8" scheme="https://gmet233.gitee.io/categories/Java/Java8/"/>
    
    
    <category term="Java" scheme="https://gmet233.gitee.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>经典内排序算法汇总</title>
    <link href="https://gmet233.gitee.io/2022/05/18/%E7%BB%8F%E5%85%B8%E5%86%85%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/"/>
    <id>https://gmet233.gitee.io/2022/05/18/%E7%BB%8F%E5%85%B8%E5%86%85%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/</id>
    <published>2022-05-18T14:46:51.772Z</published>
    <updated>2022-04-12T14:57:08.874Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文介绍几种经典、常考的内排序算法。</p><p>本文试图建立一个比较标准的快速排序、归并排序、堆排序算法代码。</p><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>了解。</p><h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>每一轮选取未排定的部分中<strong>最小</strong>的部分交换到未排定部分的最开头，经过若干个步骤，就能排定整个数组。即：先选出最小的，再选出第 2 小的，以此类推。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>略</p><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>了解</p><h2 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h2><p>每次将一个数字插入一个有序的数组里，成为一个长度更长的有序数组，有限次操作以后，数组整体有序。</p><p><img src="插入排序.gif" alt="插入排序排序"></p><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><p>略</p><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>了解</p><h2 id="算法思想-2"><a href="#算法思想-2" class="headerlink" title="算法思想"></a>算法思想</h2><p>外层循环每一次经过两两比较，把每一轮未排定部分最大的元素放到了数组的末尾；<br>「冒泡排序」有个特点：在遍历的过程中，提前检测到数组是有序的，从而结束排序，而不像「选择排序」那样，即使输入数据是有序的，「选择排序」依然需要「傻乎乎」地走完所有的流程。</p><h2 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h2><p>略</p><h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p>了解</p><h2 id="算法思想-3"><a href="#算法思想-3" class="headerlink" title="算法思想"></a>算法思想</h2><p>插入排序的优化。在插入排序里，如果靠后的数字较小，它来到前面就得交换多次。「希尔排序」改进了这种做法。带间隔地使用插入排序，直到最后「间隔」为 11 的时候，就是标准的「插入排序」，此时数组里的元素已经「几乎有序」了。</p><h2 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h2><p>略</p><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>重要</p><h2 id="算法思想-4"><a href="#算法思想-4" class="headerlink" title="算法思想"></a>算法思想</h2><p>快速排序每一次都排定一个元素（这个元素呆在了它最终应该呆的位置），然后递归地去排它左边的部分和右边的部分，依次进行下去，直到数组有序。</p><h2 id="实现（递归）"><a href="#实现（递归）" class="headerlink" title="实现（递归）"></a>实现（递归）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//https://mp.weixin.qq.com/s/8ZTMhvHJK_He48PpSt_AmQ</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Quick</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 为了避免出现耗时的极端情况，先随机打乱</span></span><br><span class="line">        shuffle(nums);</span><br><span class="line">        <span class="comment">// 排序整个数组（原地修改）</span></span><br><span class="line">        sort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lo &gt;= hi) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对 nums[lo..hi] 进行切分</span></span><br><span class="line">        <span class="comment">// 使得 nums[lo..p-1] &lt;= nums[p] &lt; nums[p+1..hi]</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> partition(nums, lo, hi);</span><br><span class="line"></span><br><span class="line">        sort(nums, lo, p - <span class="number">1</span>);</span><br><span class="line">        sort(nums, p + <span class="number">1</span>, hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对 nums[lo..hi] 进行切分</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> nums[lo];</span><br><span class="line">        <span class="comment">// 关于区间的边界控制需格外小心，稍有不慎就会出错</span></span><br><span class="line">        <span class="comment">// 我这里把 i, j 定义为开区间，同时定义：</span></span><br><span class="line">        <span class="comment">// [lo, i) &lt;= pivot；(j, hi] &gt; pivot</span></span><br><span class="line">        <span class="comment">// 之后都要正确维护这个边界区间的定义</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo + <span class="number">1</span>, j = hi;</span><br><span class="line">        <span class="comment">// 当 i &gt; j 时结束循环，以保证区间 [lo, hi] 都被覆盖</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; hi &amp;&amp; nums[i] &lt;= pivot) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="comment">// 此 while 结束时恰好 nums[i] &gt; pivot</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; lo &amp;&amp; nums[j] &gt; pivot) &#123;</span><br><span class="line">                j--;</span><br><span class="line">                <span class="comment">// 此 while 结束时恰好 nums[j] &lt;= pivot</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 此时 [lo, i) &lt;= pivot &amp;&amp; (j, hi] &gt; pivot</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= j) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将 pivot 放到合适的位置，即 pivot 左边元素较小，右边元素较大</span></span><br><span class="line">        swap(nums, lo, j);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 洗牌算法，将输入的数组随机打乱</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shuffle</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 生成 [i, n - 1] 的随机数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> i + rand.nextInt(n - i);</span><br><span class="line">            swap(nums, i, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原地交换数组中的两个元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现（非递归）"><a href="#实现（非递归）" class="headerlink" title="实现（非递归）"></a>实现（非递归）</h2><p>暂略</p><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>重要</p><h2 id="算法思想-5"><a href="#算法思想-5" class="headerlink" title="算法思想"></a>算法思想</h2><p>借助额外空间，合并两个有序数组，得到更长的有序数组。</p><h2 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Merge</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于辅助合并有序数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] temp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 先给辅助数组开辟内存空间</span></span><br><span class="line">        temp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="comment">// 排序整个数组（原地修改）</span></span><br><span class="line">        sort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义：将子数组 nums[lo..hi] 进行排序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lo == hi) &#123;</span><br><span class="line">            <span class="comment">// 单个元素不用排序</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这样写是为了防止溢出，效果等同于 (hi + lo) / 2</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 先对左半部分数组 nums[lo..mid] 排序</span></span><br><span class="line">        sort(nums, lo, mid);</span><br><span class="line">        <span class="comment">// 再对右半部分数组 nums[mid+1..hi] 排序</span></span><br><span class="line">        sort(nums, mid + <span class="number">1</span>, hi);</span><br><span class="line">        <span class="comment">// 将两部分有序数组合并成一个有序数组</span></span><br><span class="line">        merge(nums, lo, mid, hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 nums[lo..mid] 和 nums[mid+1..hi] 这两个有序数组合并成一个有序数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> mid, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="comment">// 先把 nums[lo..hi] 复制到辅助数组中</span></span><br><span class="line">        <span class="comment">// 以便合并后的结果能够直接存入 nums</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo; i &lt;= hi; i++) &#123;</span><br><span class="line">            temp[i] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数组双指针技巧，合并两个有序数组</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo, j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> lo; p &lt;= hi; p++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == mid + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 左半边数组已全部被合并</span></span><br><span class="line">                nums[p] = temp[j++];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == hi + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 右半边数组已全部被合并</span></span><br><span class="line">                nums[p] = temp[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp[i] &gt; temp[j]) &#123;</span><br><span class="line">                nums[p] = temp[j++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[p] = temp[i++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>重要</p><h2 id="算法思想-6"><a href="#算法思想-6" class="headerlink" title="算法思想"></a>算法思想</h2><p>将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列。</p><h2 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">// 将数组整理成堆</span></span><br><span class="line">        heapify(nums);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环不变量：区间 [0, i] 堆有序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len - <span class="number">1</span>; i &gt;= <span class="number">1</span>; ) &#123;</span><br><span class="line">            <span class="comment">// 把堆顶元素（当前最大）交换到数组末尾</span></span><br><span class="line">            swap(nums, <span class="number">0</span>, i);</span><br><span class="line">            <span class="comment">// 逐步减少堆有序的部分</span></span><br><span class="line">            i--;</span><br><span class="line">            <span class="comment">// 下标 0 位置下沉操作，使得区间 [0, i] 堆有序</span></span><br><span class="line">            siftDown(nums, <span class="number">0</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将数组整理成堆（堆有序）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">// 只需要从 i = (len - 1) / 2 这个位置开始逐层下移</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (len - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            siftDown(nums, i, len - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k    当前下沉元素的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end  [0, end] 是 nums 的有效部分</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftDown</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span> * k + <span class="number">1</span> &lt;= end) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span> * k + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> &lt;= end &amp;&amp; nums[j + <span class="number">1</span>] &gt; nums[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; nums[k]) &#123;</span><br><span class="line">                swap(nums, j, k);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> index1, <span class="type">int</span> index2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[index1];</span><br><span class="line">        nums[index1] = nums[index2];</span><br><span class="line">        nums[index2] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="排序复杂度比较"><a href="#排序复杂度比较" class="headerlink" title="排序复杂度比较"></a>排序复杂度比较</h1><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/sort.png" alt="图片来源：菜鸟教程/十大经典排序"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://leetcode-cn.com/problems/sort-an-array/solution/fu-xi-ji-chu-pai-xu-suan-fa-java-by-liweiwei1419/">复习基础排序算法</a></li><li><a href="https://www.runoob.com/w3cnote/ten-sorting-algorithm.html">菜鸟教程：十大排序算法</a></li><li>《算法 第四版》</li><li><a href="https://mp.weixin.qq.com/s/8ZTMhvHJK_He48PpSt_AmQ">快速排序的正确理解方式及运用</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&amp;mid=2247495989&amp;idx=1&amp;sn=30e34ac75dd1c724205e9c8b0f488e35&amp;scene=21#wechat_redirect">归并排序的正确理解方式及运用</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文介绍几种经典、常考的内排序算法。&lt;/p&gt;
&lt;p&gt;本文试图建立一个比较标准的快速排序、归并排序、堆排序算法代码。&lt;/p&gt;
&lt;h1 id=&quot;</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://gmet233.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="排序" scheme="https://gmet233.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
    <category term="排序" scheme="https://gmet233.gitee.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java8新特性1：行为参数化</title>
    <link href="https://gmet233.gitee.io/2022/05/05/Java8%E6%96%B0%E7%89%B9%E6%80%A71%EF%BC%9A%E8%A1%8C%E4%B8%BA%E5%8F%82%E6%95%B0%E5%8C%96/"/>
    <id>https://gmet233.gitee.io/2022/05/05/Java8%E6%96%B0%E7%89%B9%E6%80%A71%EF%BC%9A%E8%A1%8C%E4%B8%BA%E5%8F%82%E6%95%B0%E5%8C%96/</id>
    <published>2022-05-05T14:43:20.000Z</published>
    <updated>2022-05-05T15:31:09.939Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在软件工程中，一个众所周知的问题就是，<strong>不管你做什么，用户的需求肯定会变</strong>。<br><strong>行为参数化</strong>就是可以帮助你处理频繁变更的需求的一种软件开发模式。一言以蔽之，它意味着拿出一个代码块，把它准备好却不去执行它。这个代码块以后可以被你程序的其他部分调用，这意味着你可以推迟这块代码的执行。例如，你可以将代码块作为参数传递给另一个方法，稍后再去执行它。这样，这个方法的行为就基于那块代码被参数化了。</p><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><p>通过逐步改进案例，来熟悉什么是“行为参数化”。</p><blockquote><p>需求：农民希望筛选出1. 绿色的苹果，2. 重量大于150的苹果 3….</p></blockquote><h2 id="方案1"><a href="#方案1" class="headerlink" title="方案1"></a>方案1</h2><p>可能的代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据颜色筛选苹果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> apples</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> color</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Apple&gt; <span class="title function_">filterByColor</span><span class="params">(List&lt;Apple&gt; apples, String color)</span> &#123;</span><br><span class="line">    List&lt;Apple&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Apple apple : apples) &#123;</span><br><span class="line">        <span class="keyword">if</span>(apple.getColor().equals(color)) &#123;</span><br><span class="line">            res.add(apple);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据重量筛选苹果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> apples</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weight</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Apple&gt; <span class="title function_">filterByWeight</span><span class="params">(List&lt;Apple&gt; apples, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">    List&lt;Apple&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Apple apple : apples) &#123;</span><br><span class="line">        <span class="keyword">if</span>(apple.getWeight() &gt; weight) &#123;</span><br><span class="line">            res.add(apple);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>农民通过调用来获得答案</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">filterByColor(apples, <span class="string">&quot;green&quot;</span>);</span><br><span class="line">filterByWeight(apples, <span class="number">150</span>);</span><br></pre></td></tr></table></figure><p>这样做打破了<strong>DRY（Don’t RepeatYourself，不要重复自己）的软件工程原则</strong>。这样做出现了大量的重复代码，当你想要修改某些逻辑，比如优化遍历语句时，你需要修改所有方法中的代码。</p><p>另一种方案是，把所有参数都整合到一个方法中去，签名如下：<code>public static List&lt;Apple&gt; filterByColor(List&lt;Apple&gt; apples, String color, int weight)</code></p><p>这样做不仅笨拙，而且面对变化不能做出调整，如果有新的筛选条件，比如产地，大小，形状等怎么办？</p><h2 id="方案2：行为参数化"><a href="#方案2：行为参数化" class="headerlink" title="方案2：行为参数化"></a>方案2：行为参数化</h2><p>让我们后退一步来看看更高层次的抽象。一种可能的解决方案是对你的选择标准建模：你考虑的是苹果，需要根据Apple的某些属性（比如它是绿色的吗？重量超过150克吗？）来返回一个boolean值。我们把它称为<strong>谓词</strong>（即一个返回boolean值的函数）。让我们定义一个接口来对选择标准建模：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ApplePredicate</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Apple apple)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们就可以用ApplePredicate的多个实现代表不同的选择标准：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppleGreenColorPredicate</span> <span class="keyword">implements</span> <span class="title class_">ApplePredicate</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Apple apple)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;green&quot;</span>.equals(apple.getColor());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppleHeavyWeightPredicate</span> <span class="keyword">implements</span> <span class="title class_">ApplePredicate</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Apple apple)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> apple.getWeight() &gt; <span class="number">150</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以把这些标准看作filter方法的不同行为。你刚做的这些和“<strong>策略设计模式</strong>”相关，它让你定义一族算法，把它们封装起来（称为“策略”），然后在运行时选择一个算法。在这里，算法族就是ApplePredicate，不同的策略就是AppleHeavyWeightPredicate和AppleGreenColorPredicate。</p><p>但是，该怎么利用ApplePredicate的不同实现呢？你需要filterApples方法接受ApplePredicate对象，对Apple做条件测试。这就是行为参数化：<strong>让方法接受多种行为（或战略）作为参数</strong>，并在内部使用，来完成不同的行为。这在软件工程上有很大好处：现在你把filterApples方法迭代集合的逻辑与你要应用到集合中每个元素的行为（这里是一个谓词）区分开了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Apple&gt; <span class="title function_">filterApples</span><span class="params">(List&lt;Apple&gt; apples, ApplePredicate p)</span> &#123;</span><br><span class="line">    List&lt;Apple&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Apple apple : apples) &#123;</span><br><span class="line">        <span class="keyword">if</span>(p.test(apple)) &#123;</span><br><span class="line">            res.add(apple);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：这样做有一点缺憾就是，我明明重要的只有一个test方法，但是filterApples只能接受对象，所以我们不得不把test方法封装在ApplePredicate对象中进行传递。后面会使用Lambda表达式进行简化。</p><h2 id="方案2-1：使用匿名类改进"><a href="#方案2-1：使用匿名类改进" class="headerlink" title="方案2-1：使用匿名类改进"></a>方案2-1：使用匿名类改进</h2><p>对于以上代码的调用我们要费很大劲，创建ApplePredicate的两个实现类，然后把这两个类实例化传入到filterApples方法中去。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">filterApples(apples, <span class="keyword">new</span> <span class="title class_">AppleGreenColorPredicate</span>());</span><br></pre></td></tr></table></figure><p>我们可以使用匿名类简化这一流程。以筛选出绿色苹果为例，改进后的代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">filterApples(apples, <span class="keyword">new</span> <span class="title class_">ApplePredicate</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Apple apple)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;green&quot;</span>.equals(apple.getColor());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>但匿名类还不够好：</p><ul><li>笨重：每次实现新的<code>new ApplePredicate()</code>都要写很多模板代码<code>...test...</code></li><li>费解：这里不过多解释</li></ul><p>因此我们可以使用Lambda表达式让代码更干净</p><h2 id="方案2-2：使用Lambda表达式"><a href="#方案2-2：使用Lambda表达式" class="headerlink" title="方案2-2：使用Lambda表达式"></a>方案2-2：使用Lambda表达式</h2><p>使用Lambda表达式让上述代码重写为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">filterApples(apples, (Apple apple) -&gt; <span class="string">&quot;green&quot;</span>.equals(apple.getColor()) );</span><br></pre></td></tr></table></figure><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>将苹果按照重量由大到小排序</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对苹果按重量排序，使用java8 Collections.sort</span></span><br><span class="line"><span class="comment">//使用匿名类</span></span><br><span class="line">Collections.sort(apples, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Apple&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Apple a1, Apple a2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a1.getWeight() - a2.getWeight();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用lambda表达式</span></span><br><span class="line">Collections.sort(apples, (Apple a1, Apple a2) -&gt; a1.getWeight() - a2.getWeight() );</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>《Java 8实战》</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;在软件工程中，一个众所周知的问题就是，&lt;strong&gt;不管你做什么，用户的需求肯定会变&lt;/strong&gt;。&lt;br&gt;&lt;strong&gt;行为参数化</summary>
      
    
    
    
    <category term="Java" scheme="https://gmet233.gitee.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://gmet233.gitee.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Docker 基础知识整理</title>
    <link href="https://gmet233.gitee.io/2022/05/02/Docker-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"/>
    <id>https://gmet233.gitee.io/2022/05/02/Docker-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/</id>
    <published>2022-05-02T15:37:00.000Z</published>
    <updated>2022-05-18T14:32:47.406Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker-能做什么"><a href="#Docker-能做什么" class="headerlink" title="Docker 能做什么"></a>Docker 能做什么</h1><p>以前学习的时候，想要搭建一个Hadoop集群，那就要安装一个VMWare，然后装至少三个虚拟机。每个虚拟机至少20GB以上，有了Docker，你只需要安装一台虚拟机（Linux操作系统），在这台虚拟机上启动多个Docker容器，每个容器只有几百兆。</p><p>Docker将硬件要求和应用环境之间进一步解耦，大大提升了程序🐒的生产力和幸福指数。</p><p>Docker的应用场景包括但不限于：</p><ul><li>本地依赖：快速尝试开源项目而不用操心环境配置。</li><li>搭建环境：同一个Docker配置可以在不同的环境中运行。</li><li>微服务</li><li>扩容：Docker支持水平扩容。</li><li>……</li></ul><h1 id="Docker和虚拟机技术的比较"><a href="#Docker和虚拟机技术的比较" class="headerlink" title="Docker和虚拟机技术的比较"></a>Docker和虚拟机技术的比较</h1><p>自己查。</p><h1 id="Docker核心组件"><a href="#Docker核心组件" class="headerlink" title="Docker核心组件"></a>Docker核心组件</h1><ul><li>Docker客户端：Client</li><li>Docker服务器：Docker daemon</li><li>Docker镜像：Image</li><li>Registry</li><li>Docker容器：Container</li></ul><p><img src="image-20220428230419609.png" alt="Docker架构"></p><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>Docker客户端是执行Docker命令的地方。<code>docker run</code>等等</p><p>Docker客户端也支持REST API</p><h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><p>Docker daemon运行在Docker host上，负责创建、运行、监控容器，构建、存储镜像。</p><p>Docker服务器默认情况下只响应来自本地Host的客户端请求，如果要允许远程客户端请求，则需要修改配置（Google）</p><h2 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h2><p>Docker镜像看成只读模板，通过它可以创建Docker容器。</p><p>例如某个镜像可能包含一个操作系统、一个Apache HTTP Server以及用户开发的Web应用。</p><p>镜像有多种生成方法：（1）从无到有开始创建镜像；（2）下载并使用别人创建好的现成的镜像；（3）在现有镜像上创建新的镜像。可以将镜像的内容和创建步骤描述在一个文本文件（Dockerfile）中，通过执行dockerbuild 命令可以构建出Docker镜像，后面讨论。</p><h2 id="Docker-容器"><a href="#Docker-容器" class="headerlink" title="Docker 容器"></a>Docker 容器</h2><p>Docker容器就是Docker镜像的运行实例。</p><p>如果镜像是软件生命周期的构建和打包阶段，那么容器则是启动和运行阶段。（类似于程序与线程的关系。）</p><h2 id="Registry"><a href="#Registry" class="headerlink" title="Registry"></a>Registry</h2><p>Registry是存放Docker镜像的仓库。</p><h1 id="hello-word"><a href="#hello-word" class="headerlink" title="hello-word"></a>hello-word</h1><p>本节介绍Docker安装到运行一个Container的基本流程。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">官方安装脚本自动安装</span></span><br><span class="line">curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun</span><br></pre></td></tr></table></figure><h2 id="启动Docker服务器"><a href="#启动Docker服务器" class="headerlink" title="启动Docker服务器"></a>启动Docker服务器</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><h2 id="拉取hello-world镜像"><a href="#拉取hello-world镜像" class="headerlink" title="拉取hello-world镜像"></a>拉取hello-world镜像</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull hello-world </span><br></pre></td></tr></table></figure><h2 id="查看image信息"><a href="#查看image信息" class="headerlink" title="查看image信息"></a>查看image信息</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop01 ~]# docker images hello-world</span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED        SIZE</span><br><span class="line">hello-world   latest    feb5d9fea6a5   7 months ago   13.3kB</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="运行hello-world"><a href="#运行hello-world" class="headerlink" title="运行hello-world"></a>运行hello-world</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop01 ~]# docker run hello-world</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="查看Dockerfile"><a href="#查看Dockerfile" class="headerlink" title="查看Dockerfile"></a>查看Dockerfile</h2><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> scratch</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> hello/</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;hello/&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>只有短短三条指令。</p><ol><li>FROM scratch：镜像是从白手起家，从0开始构建。</li><li>COPY hello/：将宿主机上的文件“hello”复制到镜像的根目录。</li><li>CMD[“/hello”]：容器启动时，执行/hello。</li></ol><h1 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h1><h2 id="base-镜像"><a href="#base-镜像" class="headerlink" title="base 镜像"></a>base 镜像</h2><p>hello-world虽然是一个完整的镜像，但它并没有什么实际用途。通常来说，我们希望镜像能提供一个基本的操作系统环境，用户可以根据需要安装和配置软件。这样的镜像我们称作base镜像。</p><p>base镜像有两层含义：（1）不依赖其他镜像，从scratch构建；（2）其他镜像可以以之为基础进行扩展。</p><p>能称作base镜像的通常都是各种Linux发行版的Docker镜像，比如Ubuntu、Debian、CentOS等。</p><p>我们尝试下载并查看centos的镜像：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop01 ~]# docker pull centos</span><br><span class="line">...</span><br><span class="line">[root@hadoop01 ~]# docker images centos</span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED        SIZE</span><br><span class="line">centos       latest    5d0da3dc9764   7 months ago   231MB</span><br></pre></td></tr></table></figure><blockquote><p>为什么一个centos镜像只有200MB？</p><p>答：Linux操作系统由内核空间（bootfs/kernel）和用户空间（rootfs）组成。</p><p>Linux刚启动时会加载bootfs文件系统，之后bootfs会被卸载掉。</p><p>用户空间的文件系统是rootfs，包含我们熟悉的/dev、/proc、/bin等目录。对于base镜像来说，底层直接用Host的kernel，自己只需要提供rootfs就行了。<strong>而对于一个精简的OS, rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了。</strong></p><p>因此，base镜像只是在用户空间与发行版一致，kernel版本与发行版是不同的。镜像的Kernel版本取决于Docker Host（Docker装在哪台机器上，这台机器就是Docker Host）。所以容器只能使用Host的kernel，并且不能修改</p><p>base镜像提供的是最小安装的Linux发行版。</p></blockquote><h2 id="镜像分层"><a href="#镜像分层" class="headerlink" title="镜像分层"></a>镜像分层</h2><p>我们拿一个Dockerfile来举例：</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> debian</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install emacs</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install apach2</span></span><br></pre></td></tr></table></figure><p>上述构建过程如图所示：</p><p><img src="image-20220428234124163.png" alt="构建"></p><p>可以看到，新镜像是从base镜像一层一层叠加生成的。每安装一个软件，就在现有镜像的基础上增加一层。</p><blockquote><p>为什么Docker镜像要采用这种分层结构呢？</p><ul><li>最大的一个好处就是：共享资源。比如：有多个镜像都从相同的base镜像构建而来，那么Docker Host只需在磁盘上保存一份base镜像；同时内存中也只需加载一份base镜像，就可以为所有容器服务了，而且镜像的每一层都可以被共享，我们将在后面更深入地讨论这个特性。</li></ul><p>如果多个容器共享一份基础镜像，当某个容器修改了基础镜像的内容，比如/etc下的文件，这时其他容器的 /etc是否也会被修改？</p><ul><li>答案是不会！修改会被限制在单个容器内。这就是我们接下来要学习的容器Copy-on-Write特性。</li></ul></blockquote><h2 id="Copy-on-Write特性"><a href="#Copy-on-Write特性" class="headerlink" title="Copy-on-Write特性"></a>Copy-on-Write特性</h2><p>对于Dockerfile的每一行构建语句都会增加一层镜像，而当容器启动时，一个新的<strong>可写层</strong>被加载到镜像的顶部。这是特殊的一层，这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。所有对容器的改动，无论添加、删除，还是修改文件都只会发生在容器层中。<strong>只有容器层是可写的，容器层下面的所有镜像层都是只读的。</strong></p><ol><li>添加文件。在容器中创建文件时，新文件被添加到容器层中。</li><li>读取文件。在容器中读取某个文件时，Docker会从上往下依次在各镜像层中查找此文件。一旦找到，打开并读入内存。</li><li>修改文件。在容器中修改已存在的文件时，Docker会从上往下依次在各镜像层中查找此文件。一旦找到，<strong>立即将其复制到容器层</strong>，然后修改之。</li><li>删除文件。在容器中删除文件时，Docker也是从上往下依次在镜像层中查找此文件。找到后，会在容器层中记录下此删除操作。</li></ol><p>只有当需要修改时才复制一份数据，这种特性被称作Copy-on-Write。可见，容器层保存的是镜像变化的部分，不会对镜像本身进行任何修改。</p><p>这样就解释了我们前面提出的问题：容器层记录对镜像的修改，所有镜像层都是只读的，不会被容器修改，所以镜像可以被多个容器共享。</p><h2 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h2><p>Docker提供了两种构建镜像的方法： <code>docker commit</code>命令与Dockerfile构建文件。</p><h3 id="docker-commit（不推荐）"><a href="#docker-commit（不推荐）" class="headerlink" title="docker commit（不推荐）"></a>docker commit（不推荐）</h3><p>docker commit命令是创建新镜像最直观的方法，其过程包含三个步骤：运行容器。修改容器。将容器保存为新的镜像。</p><p>下面的例子将在CentOS base镜像中安装vim并保存为新镜像：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it ubuntu # 启动Container并进入容器</span><br><span class="line">vim # command not found</span><br><span class="line">apt-get install -y vim # 安装vim</span><br><span class="line">vim # 发现命令可以执行成功了</span><br></pre></td></tr></table></figure><p>在新窗口使用命令查看容器：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop01 ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE             COMMAND       CREATED          STATUS          PORTS     NAMES</span><br><span class="line">013be1649d31   centos:7.2.1511   &quot;/bin/bash&quot;   54 seconds ago   Up 53 seconds             frosty_kowalevski</span><br></pre></td></tr></table></figure><p>frosty_kowalevski是Docker为我们的容器随机分配的名字。</p><p>执行docker commit命令将容器保存为镜像，然后查看镜像</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop01 ~]# docker commit frosty_kowalevski centos_test</span><br><span class="line">sha256:5889b0d6ca05e96a7d1ba31dcc732d36b0651ebf7725bf0fb91def9aa2211420</span><br><span class="line">[root@hadoop01 ~]# docker images</span><br><span class="line">REPOSITORY    TAG        IMAGE ID       CREATED         SIZE</span><br><span class="line">centos_test   latest     5889b0d6ca05   6 seconds ago   409MB</span><br><span class="line">httpd         latest     c30a46771695   10 days ago     144MB</span><br><span class="line">hello-world   latest     feb5d9fea6a5   7 months ago    13.3kB</span><br><span class="line">centos        7.2.1511   9aec5c5fe4ba   3 years ago     195MB</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上演示了如何用docker commit创建新镜像。然而，Docker并不建议用户通过这种方式构建镜像。原因如下：</p><ol><li>这是一种手工创建镜像的方式，容易出错，效率低且可重复性弱。比如要在debian base镜像中也加入vi，还得重复前面的所有步骤。</li><li>更重要的：使用者并不知道镜像是如何创建出来的，里面是否有恶意程序。也就是说无法对镜像进行审计，存在安全隐患。</li></ol><p>既然docker commit不是推荐的方法，我们为什么还要花时间学习呢？原因是：即便是用Dockerfile（推荐方法）构建镜像，底层也是docker commit一层一层构建新镜像的。学习docker commit能够帮助我们更加深入地理解构建过程和镜像的分层结构。</p><h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><p>使用Dockerfile创建上一节的centos_test镜像</p><h4 id="编辑Dockerfile文件"><a href="#编辑Dockerfile文件" class="headerlink" title="编辑Dockerfile文件"></a>编辑Dockerfile文件</h4><p>创建一个Dockerfile，内容为</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos:<span class="number">7.2</span>.<span class="number">1511</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum -y install vim</span></span><br></pre></td></tr></table></figure><blockquote><p>注意这里<code>-y</code>必须加，否则在执行yum install时，很可能因为需要用户输入<code>yes</code>而失败</p></blockquote><p>执行build命令，并进行分析：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop01 docker]# pwd</span><br><span class="line">/root/docker</span><br><span class="line">[root@hadoop01 docker]# ls</span><br><span class="line">Dockerfile</span><br><span class="line">[root@hadoop01 docker]# docker build -t centos-vim-dockerfile-image .</span><br><span class="line">Sending build context to Docker daemon  2.048kB</span><br><span class="line">Step 1/2 : FROM centos:7.2.1511</span><br><span class="line"><span class="meta prompt_"> ---&gt; </span><span class="language-bash">9aec5c5fe4ba</span></span><br><span class="line">Step 2/2 : RUN yum install vim</span><br><span class="line"><span class="meta prompt_"> ---&gt; </span><span class="language-bash">Running <span class="keyword">in</span> 1caec46cd6a4</span></span><br><span class="line">Loaded plugins: fastestmirror</span><br><span class="line">……</span><br><span class="line">Successfully built b93576fddd48</span><br><span class="line">Successfully tagged centos-vim-dockerfile-image:latest</span><br></pre></td></tr></table></figure><ol><li>第三行显示文件夹下的所有文件，这里只有我们编写好的Dockerfile，值得注意的是，文件名必须叫“Dockerfile”否则执行docker build时会显示文件不存在。</li><li>第五行执行docker build命令，-t参数指定了镜像的名字，最后的点表示指定docker context为当前目录。</li><li>关于docker context：Docker默认会从build context中查找Dockerfile文件；Docker将build context中的所有文件发送给Docker daemon；Dockerfile中的ADD、COPY等命令可以将build context中的文件添加到镜像。因此不要在docker context加入不需要的文件。</li><li>第7到14行显示了执行docker build的具体过程。</li></ol><p>构建好的镜像可以通过docker history命令查看构建过程：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop01 docker]# docker history centos-vim-dockerfile-image:latest </span><br><span class="line">IMAGE          CREATED         CREATED BY                                      SIZE      COMMENT</span><br><span class="line">b93576fddd48   6 minutes ago   /bin/sh -c yum -y install vim                   214MB     </span><br><span class="line">9aec5c5fe4ba   3 years ago     /bin/sh -c #(nop)  CMD [&quot;/bin/bash&quot;]            0B        </span><br><span class="line">&lt;missing&gt;      3 years ago     /bin/sh -c #(nop)  LABEL license=GPLv2          0B        </span><br><span class="line">&lt;missing&gt;      3 years ago     /bin/sh -c #(nop)  LABEL vendor=CentOS          0B        </span><br><span class="line">&lt;missing&gt;      3 years ago     /bin/sh -c #(nop)  LABEL name=CentOS Base Im…   0B        </span><br><span class="line">&lt;missing&gt;      3 years ago     /bin/sh -c #(nop) ADD file:e76000d9816e4e380…   195MB     </span><br><span class="line">&lt;missing&gt;      3 years ago     /bin/sh -c #(nop)  MAINTAINER The CentOS Pro…   0B        </span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="镜像的缓存特性"><a href="#镜像的缓存特性" class="headerlink" title="镜像的缓存特性"></a>镜像的缓存特性</h4><p>Docker会缓存已有镜像的镜像层，构建新镜像时，如果某镜像层已经存在，就直接使用，无须重新创建。</p><p>例如在之前的Dockerfile中加入一行：</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos:<span class="number">7.2</span>.<span class="number">1511</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum -y install vim</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> <span class="built_in">test</span>/</span></span><br></pre></td></tr></table></figure><p>则在执行的过程中，之前已经运行过相同的RUN指令，这次直接使用缓存中的镜像层</p><h4 id="Dockerfile构建过程"><a href="#Dockerfile构建过程" class="headerlink" title="Dockerfile构建过程"></a>Dockerfile构建过程</h4><p>总结一下通过Dockerfile构建镜像的过程：</p><ol><li>从base镜像运行一个容器。</li><li>执行一条指令，对容器做修改。</li><li>执行类似docker commit的操作，生成一个新的镜像层。</li><li>Docker再基于刚刚提交的镜像运行一个新容器。</li><li>重复2～4步，直到Dockerfile中的所有指令执行完毕。</li></ol><p>从这个过程可以看出，如果Dockerfile由于某种原因执行到某个指令失败了，我们也将能够得到前一个指令成功执行构建出的镜像，这对调试Dockerfile非常有帮助。</p><h4 id="调试Dockerfile"><a href="#调试Dockerfile" class="headerlink" title="调试Dockerfile"></a>调试Dockerfile</h4><p>一句话概括就是：启动失败的前一层构建成功镜像的容器，进入容器，执行失败的语句，从而查看问题所在。</p><h2 id="分发镜像"><a href="#分发镜像" class="headerlink" title="分发镜像"></a>分发镜像</h2><h3 id="docker-tag"><a href="#docker-tag" class="headerlink" title="docker tag"></a>docker tag</h3><p>这里注意tag为lastest，注意docker tag的合并方式。</p><h3 id="使用公共的Registry"><a href="#使用公共的Registry" class="headerlink" title="使用公共的Registry"></a>使用公共的Registry</h3><p>看官方文档去。</p><h1 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h1><h2 id="运行容器的三种方法"><a href="#运行容器的三种方法" class="headerlink" title="运行容器的三种方法"></a>运行容器的三种方法</h2><ul><li>CMD指令</li><li>ENTRYPOINT指令</li><li>在docker run命令行中指定，例如，<code>docker run ubuntu pwd</code></li></ul><h2 id="长期运行容器"><a href="#长期运行容器" class="headerlink" title="长期运行容器"></a>长期运行容器</h2><p>容器在执行完启动时的指令后就会退出。想要让容器保持运行状态，那运行的命令不退出就好了。。</p><h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><p>在容器running时，我们可以进入容器work，有两种方法，</p><ul><li>docker attach</li><li>docker exec</li></ul><p>详细见常用命令总结章节</p><p>docker attach和docker exec区别：</p><ol><li>attach直接进入容器启动命令的终端，不会启动新的进程。</li><li>exec则是在容器中打开新的终端，并且可以启动新的进程。</li><li>如果想直接在终端中查看启动命令的输出，用attach；其他情况使用exec。</li></ol><h2 id="docker-start-stop-restart"><a href="#docker-start-stop-restart" class="headerlink" title="docker start/stop/restart"></a>docker start/stop/restart</h2><p>容器在docker host中实际上是一个进程，通过<code>docker start/stop/restart &lt;container id&gt;</code>命令启动，停止和重启容器。</p><h2 id="docker-pause-unpause"><a href="#docker-pause-unpause" class="headerlink" title="docker pause/unpause"></a>docker pause/unpause</h2><p>通过<code>docker pause/unpause &lt;container id&gt;</code>命令暂停和恢复容器。</p><h2 id="docker-rm"><a href="#docker-rm" class="headerlink" title="docker rm"></a>docker rm</h2><p>通过<code>docker rm &lt;container id&gt;</code>命令删除容器。</p><h2 id="docker生命周期"><a href="#docker生命周期" class="headerlink" title="docker生命周期"></a>docker生命周期</h2><p><img src="image-20220502225040947.png" alt="docker生命周期"></p><h2 id="资源限制"><a href="#资源限制" class="headerlink" title="资源限制"></a>资源限制</h2><p>一个docker host 会运行若干容器，对于容器，Docker也提供了类似的机制避免某个容器因占用太多资源而影响其他容器乃至整个host的性能。</p><p>docker 提供命令以限制容器的内存，CPU，BlockIO（磁盘读写）等。</p><p>具体请查阅相关资料。</p><h2 id="实现容器的底层技术"><a href="#实现容器的底层技术" class="headerlink" title="实现容器的底层技术"></a>实现容器的底层技术</h2><p>cgroup和namespace是最重要的两种技术。cgroup实现资源限额，namespace实现资源隔离。</p><p>Linux使用了6种namespace，分别对应6种资源：Mount、UTS、IPC、PID、Network和User。</p><p>具体用到再说。</p><h1 id="Docker-网络"><a href="#Docker-网络" class="headerlink" title="Docker 网络"></a>Docker 网络</h1><p>4种网络：</p><ul><li>none：封闭网络，对安全性要求高并且不需要联网的应用可以使用none网络。</li><li>host： 连接到host网络的容器共享Docker host的网络栈，容器的网络配置与host完全一样。可以通过 —network=host指定使用host网络。</li><li>bridge：Docker安装时会创建一个命名为docker0的Linuxbridge。如果不指定—network，创建的容器默认都会挂到docker0上。</li><li>user-defined：除了none、host、bridge这三个自动创建的网络，用户也可以根据业务需要创建user-defined网络。</li></ul><h2 id="容器间通信"><a href="#容器间通信" class="headerlink" title="容器间通信"></a>容器间通信</h2><p>待补充</p><h2 id="将容器与外部世界连接"><a href="#将容器与外部世界连接" class="headerlink" title="将容器与外部世界连接"></a>将容器与外部世界连接</h2><p>待补充</p><h1 id="Docker-存储"><a href="#Docker-存储" class="headerlink" title="Docker 存储"></a>Docker 存储</h1><p>待补充</p><h1 id="常用命令总结"><a href="#常用命令总结" class="headerlink" title="常用命令总结"></a>常用命令总结</h1><h2 id="Docker镜像-1"><a href="#Docker镜像-1" class="headerlink" title="Docker镜像"></a>Docker镜像</h2><h3 id="docker-images"><a href="#docker-images" class="headerlink" title="docker  images"></a>docker  images</h3><p>列出镜像</p><p><code>docker images [OPTIONS] [REPOSITORY[:TAG]]</code></p><p>OPTIONS说明：</p><ul><li><strong>-a :</strong>列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）；</li></ul><h3 id="docker-rmi"><a href="#docker-rmi" class="headerlink" title="docker rmi"></a>docker rmi</h3><p><code>docker rmi [OPTIONS] IMAGE [IMAGE...]</code></p><p>删除本地镜像</p><h3 id="docker-build"><a href="#docker-build" class="headerlink" title="docker build"></a>docker build</h3><p>使用 Dockerfile 创建镜像。</p><p><code>docker build [OPTIONS] PATH | URL | -</code></p><p>OPTIONS说明：</p><ul><li><strong>—build-arg=[] :</strong>设置镜像创建时的变量；</li><li><strong>—cpu-shares :</strong>设置 cpu 使用权重；</li><li><strong>-f :</strong>指定要使用的Dockerfile路径；</li><li><strong>—force-rm :</strong>设置镜像过程中删除中间容器；</li><li><strong>—isolation :</strong>使用容器隔离技术；</li><li><strong>-m :</strong>设置内存最大值；</li><li><strong>—memory-swap :</strong>设置Swap的最大值为内存+swap，”-1”表示不限swap；</li><li><strong>—no-cache :</strong>创建镜像的过程不使用缓存；</li><li><strong>—pull :</strong>尝试去更新镜像的新版本；</li><li><strong>—quiet, -q :</strong>安静模式，成功后只输出镜像 ID；</li><li><strong>—rm :</strong>设置镜像成功后删除中间容器；</li><li><strong>—tag, -t:</strong> 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。</li><li><strong>—network:</strong> 默认 default。在构建期间设置RUN指令的网络模式</li></ul><h3 id="docker-history"><a href="#docker-history" class="headerlink" title="docker history"></a>docker history</h3><p>查看指定镜像的创建历史。</p><p><code>docker history [OPTIONS] IMAGE</code></p><hr><h3 id="docker-login"><a href="#docker-login" class="headerlink" title="docker login"></a>docker login</h3><p> 登陆到一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub</p><h3 id="docker-pull"><a href="#docker-pull" class="headerlink" title="docker pull"></a>docker pull</h3><p>拉取镜像</p><h3 id="docker-push"><a href="#docker-push" class="headerlink" title="docker push"></a>docker push</h3><p>推送镜像</p><h3 id="docker-search"><a href="#docker-search" class="headerlink" title="docker search"></a>docker search</h3><p>查找镜像</p><h2 id="Docker-容器-1"><a href="#Docker-容器-1" class="headerlink" title="Docker 容器"></a>Docker 容器</h2><h3 id="docker-run"><a href="#docker-run" class="headerlink" title="docker run"></a>docker run</h3><p><strong>docker run ：</strong>创建一个新的容器并运行一个命令</p><p><code>docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</code></p><p>OPTIONS说明：</p><ul><li><strong>-d:</strong> 后台运行容器，并返回容器ID；</li><li><strong>-i:</strong> 以交互模式运行容器，通常与 -t 同时使用；</li><li><strong>-p:</strong> 指定端口映射，格式为：<strong>主机(宿主)端口:容器端口</strong></li><li><strong>-t:</strong> 为容器重新分配一个伪输入终端，通常与 -i 同时使用；</li><li><strong>—name=”nginx-lb”:</strong> 为容器指定一个名称；</li><li><strong>—dns 8.8.8.8:</strong> 指定容器使用的DNS服务器，默认和宿主一致；</li><li><strong>—dns-search example.com:</strong> 指定容器DNS搜索域名，默认和宿主一致；</li><li><strong>-h “mars”:</strong> 指定容器的hostname；</li><li><strong>-e username=”ritchie”:</strong> 设置环境变量；</li><li><strong>-m :</strong>设置容器使用内存最大值；</li><li><strong>—net=”bridge”:</strong> 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型；</li><li><strong>—expose=[]:</strong> 开放一个端口或一组端口；</li></ul><h3 id="docker-start-stop-restart-1"><a href="#docker-start-stop-restart-1" class="headerlink" title="docker start/stop/restart"></a>docker start/stop/restart</h3><p><strong>docker start</strong> :启动一个或多个已经被停止的容器</p><p><strong>docker stop</strong> :停止一个运行中的容器</p><p><strong>docker restart</strong> :重启容器</p><h3 id="docker-rm-1"><a href="#docker-rm-1" class="headerlink" title="docker rm"></a>docker rm</h3><p><strong>docker rm ：</strong>删除一个或多个容器。</p><h3 id="docker-pause-unpause-1"><a href="#docker-pause-unpause-1" class="headerlink" title="docker pause/unpause"></a>docker pause/unpause</h3><p><strong>docker pause</strong> :暂停容器中所有的进程。</p><p><strong>docker unpause</strong> :恢复容器中所有的进程。</p><h3 id="docker-create"><a href="#docker-create" class="headerlink" title="docker create"></a>docker create</h3><p><strong>docker create ：</strong>创建一个新的容器但不启动它；用法同docker run</p><h3 id="docker-attach"><a href="#docker-attach" class="headerlink" title="docker attach"></a>docker attach</h3><p><strong>docker attach :</strong>连接到正在运行中的容器。</p><p>要attach上去的容器必须正在运行，可以同时连接上同一个container来共享屏幕（与screen命令的attach类似）。</p><h3 id="docker-exec"><a href="#docker-exec" class="headerlink" title="docker exec"></a>docker exec</h3><p><strong>docker exec ：</strong>在运行的容器中执行命令</p><p><code>docker exec [OPTIONS] CONTAINER COMMAND [ARG...]</code></p><p>OPTIONS说明：</p><ul><li><strong>-d :</strong>分离模式: 在后台运行</li><li><strong>-t :</strong>分配一个伪终端</li></ul><h3 id="docker-ps"><a href="#docker-ps" class="headerlink" title="docker ps"></a>docker ps</h3><p>列出容器</p><p><code>docker ps [OPTIONS]</code></p><p>OPTIONS说明：</p><ul><li><strong>-a :</strong>显示所有的容器，包括未运行的。</li><li><strong>-n :</strong>列出最近创建的n个容器。</li><li><strong>-q :</strong>静默模式，只显示容器编号。</li></ul><h3 id="docker-inspect"><a href="#docker-inspect" class="headerlink" title="docker inspect"></a>docker inspect</h3><p><strong>docker inspect :</strong> 获取容器/镜像的元数据。</p><h3 id="docker-top"><a href="#docker-top" class="headerlink" title="docker top"></a>docker top</h3><p>查看容器中运行的进程信息，支持 ps 命令参数。</p><p>容器运行时不一定有/bin/bash终端来交互执行top命令，而且容器还不一定有top命令，可以使用docker top来实现查看container中正在运行的进程。</p><h3 id="docker-logs"><a href="#docker-logs" class="headerlink" title="docker logs"></a>docker logs</h3><p>获取容器的日志</p><h3 id="docker-commit"><a href="#docker-commit" class="headerlink" title="docker commit"></a>docker commit</h3><p>从容器创建一个新的镜像。</p><p><code>docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</code></p><p>OPTIONS说明：</p><ul><li><strong>-a :</strong>提交的镜像作者；</li><li><strong>-c :</strong>使用Dockerfile指令来创建镜像；</li><li><strong>-m :</strong>提交时的说明文字；</li><li><strong>-p :</strong>在commit时，将容器暂停。</li></ul><h3 id="docker-cp"><a href="#docker-cp" class="headerlink" title="docker cp"></a>docker cp</h3><p>用于容器与主机之间的数据拷贝。</p><p>例如：将主机/www/runoob目录拷贝到容器96f7f14e99ab的/www目录下。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker cp /www/runoob 96f7f14e99ab:/www/</span><br></pre></td></tr></table></figure><h2 id="Dockerfile-1"><a href="#Dockerfile-1" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><ul><li>FROM指定base镜像。</li><li>MAINTAINER设置镜像的作者，可以是任意字符串。</li><li>COPY将文件从build context复制到镜像。COPY支持两种形式： COPY src dest与COPY [“src”, “dest”]。注意：src只能指定build context中的文件或目录。</li><li>ADD与COPY类似，从build context复制文件到镜像。不同的是，如果src是归档文件（tar、zip、tgz、xz等），文件会被自动解压到dest。</li><li>ENV设置环境变量，环境变量可被后面的指令使用。</li><li>EXPOSE指定容器中的进程会监听某个端口，Docker可以将该端口暴露出来。我们会在容器网络部分详细讨论。</li><li>VOLUME将文件或目录声明为volume。我们会在容器存储部分详细讨论。</li><li>WORKDIR为后面的RUN、CMD、ENTRYPOINT、ADD或COPY指令设置镜像中的当前工作目录。</li><li>RUN在容器中运行指定的命令。</li><li>CMD容器启动时运行指定的命令。Dockerfile中可以有多个CMD指令，但只有最后一个生效。CMD可以被dockerrun之后的参数替换。</li><li>ENTRYPOINT设置容器启动时运行的命令。Dockerfile中可以有多个ENTRYPOINT指令，但只有最后一个生效。CMD或docker run之后的参数会被当作参数传递给ENTRYPOINT。</li></ul><h3 id="RUN-vs-CMD-vs-ENTRYPOINT"><a href="#RUN-vs-CMD-vs-ENTRYPOINT" class="headerlink" title="RUN vs CMD vs ENTRYPOINT"></a>RUN vs CMD vs ENTRYPOINT</h3><p>略</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>《每天五分钟玩转Docker容器技术》</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Docker-能做什么&quot;&gt;&lt;a href=&quot;#Docker-能做什么&quot; class=&quot;headerlink&quot; title=&quot;Docker 能做什么&quot;&gt;&lt;/a&gt;Docker 能做什么&lt;/h1&gt;&lt;p&gt;以前学习的时候，想要搭建一个Hadoop集群，那就要安装一个VMWa</summary>
      
    
    
    
    <category term="Docker" scheme="https://gmet233.gitee.io/categories/Docker/"/>
    
    
    <category term="Docker" scheme="https://gmet233.gitee.io/tags/Docker/"/>
    
    <category term="容器" scheme="https://gmet233.gitee.io/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>HashMap知识整理</title>
    <link href="https://gmet233.gitee.io/2022/04/21/HashMap%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"/>
    <id>https://gmet233.gitee.io/2022/04/21/HashMap%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/</id>
    <published>2022-04-21T15:28:41.000Z</published>
    <updated>2022-05-18T14:33:56.256Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Java为数据结构中的映射定义了一个接口java.util.Map，此接口主要有四个常用的实现类，分别是HashMap、Hashtable、LinkedHashMap和TreeMap，类继承关系如下图所示：</p><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/f7fe16a2.png" alt="Map类图"></p><ol><li><strong>HashMap</strong>：它根据键的hashCode值存储数据，<strong>遍历顺序不确定</strong>。 HashMap<strong>最多只允许一条记录的key为null</strong>，允许多条记录的value为null。HashMap<strong>非线程安全</strong>，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。</li><li><strong>Hashtable</strong>：Hashtable是遗留类，不再推荐使用。</li><li><strong>LinkedHashMap</strong>：LinkedHashMap是HashMap的一个子类，<strong>保存了记录的插入顺序</strong>，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。</li><li><strong>TreeMap</strong>：TreeMap实现SortedMap接口，能够<strong>把它保存的记录根据键排序</strong>，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator**，否则会在运行时抛出java.lang.ClassCastException类型的异常。</li></ol><p>对于上述四种Map类型的类，要求映射中的key是<strong>不可变对象</strong>。不可变对象是该对象在创建后它的哈希值不会被改变。如果对象的哈希值发生变化，Map对象很可能就定位不到映射的位置了。</p><h1 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h1><p>从结构实现来讲，HashMap是数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下如所示。</p><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/e4a19398.png" alt="HashMap存储结构"></p><h2 id="什么是Node"><a href="#什么是Node" class="headerlink" title="什么是Node"></a>什么是Node</h2><p>源码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> hash;    <span class="comment">//用来定位数组索引位置</span></span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;   <span class="comment">//链表的下一个node</span></span><br><span class="line"></span><br><span class="line">        Node(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123; ... &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> K <span class="title function_">getKey</span><span class="params">()</span>&#123; ... &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">getValue</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">setValue</span><span class="params">(V newValue)</span> &#123; ... &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)。上图中的每个黑色圆点就是一个Node对象。</p><blockquote><p>Map.Entry是Map声明的一个内部接口，此接口为泛型，定义为Entry<K,V>。它表示Map中的一个实体（一个key-value对）。接口中有getKey(), getValue方法。</p></blockquote><h2 id="HashMap存储"><a href="#HashMap存储" class="headerlink" title="HashMap存储"></a>HashMap存储</h2><p>HashMap就是使用哈希表来存储的。哈希表为解决冲突，可以采用开放地址法和链地址法等来解决问题，Java中HashMap采用了<strong>链地址法</strong>。链地址法，简单来说，就是数组加链表的结合。在每个数组元素上都一个链表结构，当数据被Hash后，得到数组下标，把数据放在对应下标元素的链表上。</p><p>对于HashMap来说，调用<code>map.put(key, value)</code>方法时，先通过<code>key.hashCode()</code>得到hashCode值（该方法适用于每个Java对象），在对hashCode值进行Hash运算来确定该键值对在哈希桶数组中的存储位置。如果两个key会定位到相同的位置，表示发生了Hash冲突。</p><p>HashMap的存储效率取决于Hash算法和哈希桶数组的大小。如果哈希桶数组很大，即使较差的Hash算法也会比较分散，如果哈希桶数组数组很小，即使好的Hash算法也会出现较多碰撞，所以就需要在空间成本和时间成本之间权衡，其实就是在根据实际情况确定哈希桶数组的大小，并在此基础上设计好的hash算法减少Hash碰撞。那么通过什么方式来控制map使得Hash碰撞的概率又小，哈希桶数组（Node[] table）占用空间又少呢？答案就是好的<strong>Hash算法</strong>和<strong>扩容机制</strong>。</p><h2 id="HashMap关键变量"><a href="#HashMap关键变量" class="headerlink" title="HashMap关键变量"></a>HashMap关键变量</h2><p>在理解Hash和扩容流程之前，我们得先了解下HashMap的几个字段。从HashMap的默认构造函数源码可知，构造函数就是对下面几个字段进行初始化，源码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="type">int</span> threshold;             <span class="comment">// 所能容纳的key-value对极限 </span></span><br><span class="line"><span class="keyword">final</span> <span class="type">float</span> loadFactor;    <span class="comment">// 负载因子</span></span><br><span class="line"><span class="type">int</span> modCount;  </span><br><span class="line"><span class="type">int</span> size;</span><br></pre></td></tr></table></figure><ul><li>table是哈希桶数组，它默认初始化长度length为16</li><li>loadFactor为负载因子(默认值是0.75)</li><li>threshold是HashMap所能容纳的最大数据量的Node(键值对)个数</li><li>threshold = length * Load factor，也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。</li><li>负载因子的定义公式可知，threshold就是在此Load factor和length(数组长度)对应下允许的<strong>最大元素数目</strong>，超过这个数目就重新resize(扩容)，<strong>扩容后的HashMap容量是之前容量的两倍</strong>。默认的负载因子0.75是对空间和时间效率的一个平衡选择，建议大家不要修改，除非在时间和空间比较特殊的情况下，如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值；相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。</li><li>size就是HashMap中<strong>实际存在的键值对数量</strong>。</li><li>modCount字段主要用来记录HashMap内部结构发生变化的次数（比如扩容， 或者链表变为红黑树），主要用于迭代的快速失败。强调一点，内部结构发生变化指的是结构发生变化，例如put新键值对，但是某个key对应的value值被覆盖不属于结构变化。</li></ul><h2 id="哈希桶数组的设计"><a href="#哈希桶数组的设计" class="headerlink" title="哈希桶数组的设计"></a>哈希桶数组的设计</h2><p>在HashMap中，哈希桶数组table的长度length大小必须为2的n次方(一定是合数)，这是一种<strong>非常规</strong>的设计，常规的设计是把桶的大小设计为素数。相对来说素数导致冲突的概率要小于合数，具体证明可以参考<a href="http://blog.csdn.net/liuqiyao_01/article/details/14475159">这篇文章</a>，Hashtable初始化桶大小为11，就是桶大小设计为素数的应用（Hashtable扩容后不能保证还是素数）。HashMap采用这种非常规设计，主要是<strong>为了在取模和扩容时做优化</strong>。同时为了减少冲突，HashMap定位哈希桶索引位置时，也加入了高位参与运算的过程。</p><p>这里存在一个问题，即使负载因子和Hash算法设计的再合理，也免不了会出现拉链过长的情况（即链表很长），一旦出现拉链过长，则会严重影响HashMap的性能。于是，在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树。而当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入、删除、查找等算法。本文不再对红黑树展开讨论，想了解更多红黑树数据结构的工作原理可以参考<a href="http://blog.csdn.net/v_july_v/article/details/6105630">这篇文章</a>。</p><h1 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h1><h2 id="hash算法"><a href="#hash算法" class="headerlink" title="hash算法"></a>hash算法</h2><p>源码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法一：</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;   <span class="comment">//jdk1.8 &amp; jdk1.7</span></span><br><span class="line">     <span class="type">int</span> h;</span><br><span class="line">     <span class="comment">// h = key.hashCode() 为第一步 取hashCode值</span></span><br><span class="line">     <span class="comment">// h ^ (h &gt;&gt;&gt; 16)  为第二步 高位参与运算</span></span><br><span class="line">     <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line">方法二：</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">indexFor</span><span class="params">(<span class="type">int</span> h, <span class="type">int</span> length)</span> &#123;  <span class="comment">//jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的</span></span><br><span class="line">     <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);  <span class="comment">//第三步 取模运算</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的Hash算法本质上就是三步：<strong>取key的hashCode值、高位运算、取模运算</strong>。</p><p>对于任意给定的对象，只要它的hashCode()返回值相同，那么程序调用方法一所计算得到的Hash码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，<strong>模运算的消耗还是比较大</strong>的，在HashMap中是这样做的：调用方法二来计算该对象应该保存在table数组的哪个索引处。</p><p>这个方法（方法二）非常巧妙，它通过h &amp; (table.length -1)来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n次方时，<strong>h&amp; (length-1)运算等价于对length取模</strong>，也就是h%length，但是&amp;比%具有更高的效率。</p><p>在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。</p><p>下面举例说明下，n为table的长度</p><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/45205ec2.png" alt="hash算法"></p><h2 id="HashMap的put方法"><a href="#HashMap的put方法" class="headerlink" title="HashMap的put方法"></a>HashMap的put方法</h2><p>HashMap的put方法执行过程可以通过下图来理解</p><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/d669d29c.png" alt="HashMap的put方法（1.7，1.8有变化）"></p><ol><li>判断键值对数组table是否为空或长度为0，否则执行resize()进行扩容；（这里可以看出，<code>new HashMap()</code>的时候并不会初始化哈希桶数组，而是当第一次执行put操作的时候才会初始化。）</li><li>根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向6，如果table[i]不为空，转向3</li><li>判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向4，这里的相同指的是hashCode以及equals；</li><li>判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向5；</li><li>遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可； </li><li>插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。</li></ol><p>put方法源码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="comment">// 对key的hashCode()做hash</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">               <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">// 步骤①：tab为空则创建</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 步骤②：计算index，并对null做处理 </span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>) </span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 步骤③：节点key存在，直接覆盖value</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 步骤④：判断该链为红黑树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 步骤⑤：该链为链表</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key,value,<span class="literal">null</span>);</span><br><span class="line">                     <span class="comment">//链表长度大于8转换为红黑树进行处理</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st  </span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                 <span class="comment">// key已经存在直接覆盖value</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) </span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 步骤⑥：超过最大容量 就扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><p>扩容(resize)就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。当然Java里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组，就像我们用一个小桶装水，如果想装更多的水，就得换大水桶。</p><blockquote><p>这里有一个不大不小的质疑，如果所有的size到达了threshold，但是所有的键值对都装在了一个哈希桶中，那么其实其他桶是空的，也是可以继续放更多的键值对，那么此时不能说<HashMap对象内部的数组无法装载更多的元素>，但依然会扩容</p></blockquote><p>我们分析下resize的源码，鉴于JDK1.8融入了红黑树，较复杂，为了便于理解我们仍然使用JDK1.7的代码，好理解一些，本质上区别不大，具体区别后文再说。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(<span class="type">int</span> newCapacity)</span> &#123;   <span class="comment">//传入新的容量</span></span><br><span class="line">    Entry[] oldTable = table;    <span class="comment">//引用扩容前的Entry数组</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> oldTable.length;         </span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;  <span class="comment">//扩容前的数组大小如果已经达到最大(2^30)了</span></span><br><span class="line">        threshold = Integer.MAX_VALUE; <span class="comment">//修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> <span class="title class_">Entry</span>[newCapacity];  <span class="comment">//初始化一个新的Entry数组</span></span><br><span class="line">    transfer(newTable);                         <span class="comment">//！！将数据转移到新的Entry数组里</span></span><br><span class="line">    table = newTable;                           <span class="comment">//HashMap的table属性引用新的Entry数组</span></span><br><span class="line">    threshold = (<span class="type">int</span>)(newCapacity * loadFactor);<span class="comment">//修改阈值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Entry[] newTable)</span> &#123;</span><br><span class="line">    Entry[] src = table;                   <span class="comment">//src引用了旧的Entry数组</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; src.length; j++) &#123; <span class="comment">//遍历旧的Entry数组</span></span><br><span class="line">        Entry&lt;K,V&gt; e = src[j];             <span class="comment">//取得旧Entry数组的每个元素</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            src[j] = <span class="literal">null</span>;<span class="comment">//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash, newCapacity); <span class="comment">//！！重新计算每个元素在数组中的位置</span></span><br><span class="line">                e.next = newTable[i]; <span class="comment">//标记[1]，这句不太理解</span></span><br><span class="line">                newTable[i] = e;      <span class="comment">//将元素放在数组上</span></span><br><span class="line">                e = next;             <span class="comment">//访问下一个Entry链上的元素</span></span><br><span class="line">            &#125; <span class="keyword">while</span> (e != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>newTable[i]的引用赋给了e.next，也就是使用了单链表的<strong>头插</strong>入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素终会被放到Entry链的尾部(如果发生了hash冲突的话），这一点和Jdk1.8有区别，下文详解。在旧数组中同一条Entry链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。</p><p>下面举个例子说明下扩容过程。假设了我们的hash算法就是简单的用key mod 一下表的大小（也就是数组的长度）。其中的哈希桶数组table的size=2， 所以key = 3、7、5，put顺序依次为 5、7、3。在mod 2以后都冲突在table[1]这里了。这里假设负载因子 loadFactor=1，即当键值对的实际大小size 大于 table的实际大小时进行扩容。接下来的三个步骤是哈希桶数组 resize成4，然后所有的Node重新rehash的过程。</p><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/b2330062.png" alt="JDK7 HashMap扩容"></p><p>下面我们讲解下JDK1.8做了哪些优化。经过观测可以发现，我们使用的是<strong>2次幂</strong>的扩展(指长度扩为原来2倍)，所以，<strong>元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置</strong>。看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。</p><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/4d8022db.png" alt="img"></p><p>元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：</p><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/d773f86e.png" alt="img"></p><p>因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，<strong>只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”</strong>，可以看看下图为16扩充为32的resize示意图：</p><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/3cc9813a.png" alt="img"></p><p>这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。有一点注意区别，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，<strong>JDK1.8不会倒置</strong>。有兴趣的同学可以研究下JDK1.8的resize源码，写的很赞，如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没超过最大值，就扩充为原来的2倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算新的resize上限</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;，&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 把每个bucket都移动到新的buckets中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// 链表优化重hash的代码块</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 原索引</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 原索引+oldCap</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 原索引放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 原索引+oldCap放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><h2 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h2><p>在多线程使用场景中，应该尽量避免使用线程不安全的HashMap，而使用线程安全的ConcurrentHashMap。那么为什么说HashMap是线程不安全的，下面举例子说明在并发的多线程使用场景中使用HashMap可能造成死循环。代码例子如下(便于理解，仍然使用JDK1.7的环境)：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapInfiniteLoop</span> &#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;Integer,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer,String&gt;(<span class="number">2</span>，<span class="number">0.75f</span>);  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        map.put(<span class="number">5</span>， <span class="string">&quot;C&quot;</span>);  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;Thread1&quot;</span>) &#123;  </span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;  </span><br><span class="line">                map.put(<span class="number">7</span>, <span class="string">&quot;B&quot;</span>);  </span><br><span class="line">                System.out.println(map);  </span><br><span class="line">            &#125;;  </span><br><span class="line">        &#125;.start();  </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;Thread2&quot;</span>) &#123;  </span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;  </span><br><span class="line">                map.put(<span class="number">3</span>, <span class="string">&quot;A);  </span></span><br><span class="line"><span class="string">                System.out.println(map);  </span></span><br><span class="line"><span class="string">            &#125;;  </span></span><br><span class="line"><span class="string">        &#125;.start();        </span></span><br><span class="line"><span class="string">    &#125;  </span></span><br><span class="line"><span class="string">&#125; </span></span><br></pre></td></tr></table></figure><p>其中，map初始化为一个长度为2的数组，loadFactor=0.75，threshold=2*0.75=1，也就是说当put第二个key的时候，map就需要进行resize。</p><p>通过设置断点让线程1和线程2同时debug到transfer方法(3.3小节代码块)的首行。注意此时两个线程已经成功添加数据。放开thread1的断点至transfer方法的“Entry next = e.next;” 这一行；然后放开线程2的的断点，让线程2进行resize。结果如下图。</p><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/7df99266.png" alt="img"></p><p>注意，Thread1的 e 指向了key(3)，而next指向了key(7)，其在线程二rehash后，指向了线程二重组后的链表。</p><p>线程一被调度回来执行，先是执行 newTalbe[i] = e， 然后是e = next，导致了e指向了key(7)，而下一次循环的next = e.next导致了next指向了key(3)。</p><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/4c3c28fb.png" alt="img"></p><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/6c8d086a.png" alt="img"></p><p>e.next = newTable[i] 导致 key(3).next 指向了 key(7)。注意：此时的key(7).next 已经指向了key(3)， 环形链表就这样出现了。</p><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/6eed9aaf.png" alt="img"></p><p>于是，当我们用线程一调用map.get(11)时，悲剧就出现了——Infinite Loop。</p><h1 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h1><p>JDK1.8做了多方面的优化，总体性能优于JDK1.7。具体详见参考资料1</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://tech.meituan.com/2016/06/24/java-hashmap.html">Java 8系列之重新认识HashMap</a></li><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;Java为数据结构中的映射定义了一个接口java.util.Map，此接口主要有四个常用的实现类，分别是HashMap、Hashtable、</summary>
      
    
    
    
    <category term="Java" scheme="https://gmet233.gitee.io/categories/Java/"/>
    
    <category term="集合" scheme="https://gmet233.gitee.io/categories/Java/%E9%9B%86%E5%90%88/"/>
    
    
    <category term="Java" scheme="https://gmet233.gitee.io/tags/Java/"/>
    
    <category term="HashMap" scheme="https://gmet233.gitee.io/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>医学影像处理：将NII格式的CT图转换为PNG</title>
    <link href="https://gmet233.gitee.io/2022/04/12/%E5%8C%BB%E5%AD%A6%E5%BD%B1%E5%83%8F%E5%A4%84%E7%90%86%EF%BC%9A%E5%B0%86NII%E6%A0%BC%E5%BC%8F%E7%9A%84CT%E5%9B%BE%E8%BD%AC%E6%8D%A2%E4%B8%BAPNG/"/>
    <id>https://gmet233.gitee.io/2022/04/12/%E5%8C%BB%E5%AD%A6%E5%BD%B1%E5%83%8F%E5%A4%84%E7%90%86%EF%BC%9A%E5%B0%86NII%E6%A0%BC%E5%BC%8F%E7%9A%84CT%E5%9B%BE%E8%BD%AC%E6%8D%A2%E4%B8%BAPNG/</id>
    <published>2022-04-12T15:04:13.000Z</published>
    <updated>2022-04-12T15:50:57.473Z</updated>
    
    <content type="html"><![CDATA[<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>本文使用Python进行医学影像处理：通过旋转、切片、调整窗宽窗位，将3D NII格式的<strong>肺部</strong>CT影像转为2D PNG格式图像。</p><p>下面介绍流程。</p><p>===</p><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><p>==</p><h2 id="读取NII图像"><a href="#读取NII图像" class="headerlink" title="读取NII图像"></a>读取NII图像</h2><p>一般使用<code>nibabel</code>来读NII格式图像。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> nibabel <span class="keyword">as</span> nib</span><br><span class="line">img = nib.load(img_path)</span><br><span class="line"><span class="comment"># 获得图像的ndarray</span></span><br><span class="line">img_fdata = img.get_fdata()</span><br></pre></td></tr></table></figure><p>==</p><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>将3D图以z轴分片为若干2D图。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(x, y, z) = img.shape</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(z):</span><br><span class="line">silce = img_fdata[:, :, i]</span><br></pre></td></tr></table></figure><p>==</p><h2 id="调整窗宽窗位1"><a href="#调整窗宽窗位1" class="headerlink" title="调整窗宽窗位1"></a>调整窗宽窗位1</h2><p>窗宽窗位的基本概念详见：<a href="https://www.zhihu.com/question/33587197">https://www.zhihu.com/question/33587197</a></p><p>简单来说，不同的窗宽窗位使得不同的组织器官展示的更清楚。</p><p>这里，我处理的是肺部CT，不同部位的对应不同的窗宽窗位。</p><p>==</p><h2 id="调整窗宽窗位2"><a href="#调整窗宽窗位2" class="headerlink" title="调整窗宽窗位2"></a>调整窗宽窗位2</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">center = -<span class="number">500</span> <span class="comment">#肺部的窗宽窗位</span></span><br><span class="line">width = <span class="number">1500</span></span><br><span class="line"><span class="built_in">min</span> = (<span class="number">2</span> * center - width) / <span class="number">2.0</span> + <span class="number">0.5</span></span><br><span class="line"><span class="built_in">max</span> = (<span class="number">2</span> * center + width) / <span class="number">2.0</span> + <span class="number">0.5</span></span><br><span class="line">dFactor = <span class="number">255.0</span> / (<span class="built_in">max</span> - <span class="built_in">min</span>)</span><br><span class="line"></span><br><span class="line">silce = silce - <span class="built_in">min</span></span><br><span class="line">silce =np.trunc( silce * dFactor)</span><br><span class="line"><span class="comment"># 由于RGB格式的要求，这里对不在[0~255]的像素值进行截断</span></span><br><span class="line">silce[silce &lt; <span class="number">0.0</span>] = <span class="number">0</span></span><br><span class="line">silce[silce &gt; <span class="number">255.0</span>] = <span class="number">255</span>  <span class="comment"># 转换为窗位窗位之后的数据</span></span><br></pre></td></tr></table></figure><p>==</p><h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><p>旋转90°让图像“正”过来</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">silce = np.fliplr(np.rot90(silce,-<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>==</p><h2 id="保存PNG"><a href="#保存PNG" class="headerlink" title="保存PNG"></a>保存PNG</h2><p>略</p><p>=== </p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><p>==</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> nibabel <span class="keyword">as</span> nib</span><br><span class="line"><span class="keyword">import</span> imageio  </span><br><span class="line"></span><br><span class="line"><span class="comment">#肺部的窗宽窗位</span></span><br><span class="line">center = -<span class="number">500</span> </span><br><span class="line">width = <span class="number">1500</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nii_to_image</span>(<span class="params">src_path, dst_path</span>):</span><br><span class="line"><span class="keyword">for</span> p, d, f <span class="keyword">in</span> os.walk(src_path):</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(f) &gt; <span class="number">0</span>:</span><br><span class="line"><span class="keyword">for</span> file_name <span class="keyword">in</span> f:</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> file_name.endswith(<span class="string">&quot;.nii&quot;</span>):</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="comment"># 开始读取nii文件</span></span><br><span class="line">img_path = os.path.join(p, file_name)</span><br><span class="line">img = nib.load(img_path)</span><br><span class="line">img_fdata = img.get_fdata()</span><br><span class="line"><span class="comment"># 新建文件夹</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(dst_path):</span><br><span class="line">os.mkdir(dst_path)</span><br><span class="line"><span class="comment"># 转换成窗宽窗位</span></span><br><span class="line"><span class="built_in">min</span> = (<span class="number">2</span> * center - width) / <span class="number">2.0</span> + <span class="number">0.5</span></span><br><span class="line"><span class="built_in">max</span> = (<span class="number">2</span> * center + width) / <span class="number">2.0</span> + <span class="number">0.5</span></span><br><span class="line">dFactor = <span class="number">255.0</span> / (<span class="built_in">max</span> - <span class="built_in">min</span>)</span><br><span class="line"><span class="comment"># 开始转换为图像</span></span><br><span class="line">(x, y, z) = img.shape</span><br><span class="line"><span class="comment"># z是图像的序列</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(z):</span><br><span class="line">silce = img_fdata[:, :, i]</span><br><span class="line"><span class="comment"># 反转，旋转90°</span></span><br><span class="line">silce = np.fliplr(np.rot90(silce,-<span class="number">1</span>)) </span><br><span class="line">silce = silce - <span class="built_in">min</span></span><br><span class="line">silce =np.trunc( silce * dFactor)</span><br><span class="line">silce[silce &lt; <span class="number">0.0</span>] = <span class="number">0</span></span><br><span class="line">silce[silce &gt; <span class="number">255.0</span>] = <span class="number">255</span> </span><br><span class="line"><span class="comment"># maskimg_slice = maskimg_fdata[:,:,i]</span></span><br><span class="line">temp = file_name.replace(<span class="string">&quot;.nii&quot;</span>, <span class="string">&quot;&quot;</span>)+<span class="string">&quot;_&quot;</span> + <span class="string">&#x27;&#123;&#125;.png&#x27;</span>.<span class="built_in">format</span>(i)</span><br><span class="line">imageio.imwrite(os.path.join(dst_path, temp), silce.astype(<span class="string">&#x27;uint8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">src_path = <span class="string">&#x27;NII保存文件夹&#x27;</span></span><br><span class="line">dst_path = <span class="string">&#x27;PNG保存文件夹&#x27;</span></span><br><span class="line">nii_to_image(src_path, dst_path)</span><br></pre></td></tr></table></figure><p>===</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>==</p><ol><li><a href="https://www.zhihu.com/question/33587197">CT的窗宽，窗位到底是什么意思？</a></li><li><a href="https://blog.csdn.net/Zzhouzhou237/article/details/105345048">python nii 图像读取，转换成CT 值，设置窗宽窗位，保存成png 图像</a></li></ol><p>===</p><h1 id="Thanks"><a href="#Thanks" class="headerlink" title="Thanks~"></a>Thanks~</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;目标&quot;&gt;&lt;a href=&quot;#目标&quot; class=&quot;headerlink&quot; title=&quot;目标&quot;&gt;&lt;/a&gt;目标&lt;/h1&gt;&lt;p&gt;本文使用Python进行医学影像处理：通过旋转、切片、调整窗宽窗位，将3D NII格式的&lt;strong&gt;肺部&lt;/strong&gt;CT影像转为2</summary>
      
    
    
    
    <category term="深度学习" scheme="https://gmet233.gitee.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="深度学习" scheme="https://gmet233.gitee.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="图像处理" scheme="https://gmet233.gitee.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>完美解决ChromeDriver与Chrome版本匹配问题</title>
    <link href="https://gmet233.gitee.io/2022/04/11/%E5%AE%8C%E7%BE%8E%E8%A7%A3%E5%86%B3ChromeDriver%E4%B8%8EChrome%E7%89%88%E6%9C%AC%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98/"/>
    <id>https://gmet233.gitee.io/2022/04/11/%E5%AE%8C%E7%BE%8E%E8%A7%A3%E5%86%B3ChromeDriver%E4%B8%8EChrome%E7%89%88%E6%9C%AC%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98/</id>
    <published>2022-04-11T14:47:58.000Z</published>
    <updated>2022-04-11T14:53:41.897Z</updated>
    
    <content type="html"><![CDATA[<p>在使用Selenium调用Chrome浏览器爬取互联网数据时，会遇到Chrome和ChromeDriver版本不兼容的问题，导致爬取失败。</p><p>一种解决方案是，进行版本匹配。但是随着本机Chrome的更新，每次都需要随之更新ChromeDriver版本。</p><p>更好的方案是，通过使用<code>webdriver-manager</code>来自动匹配ChromeDriver，安装：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install webdriver-manager</span><br></pre></td></tr></table></figure><p>Usage：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> webdriver_manager.chrome <span class="keyword">import</span> ChromeDriverManager</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome(ChromeDriverManager().install())</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://stackoverflow.com/questions/60296873/sessionnotcreatedexception-message-session-not-created-this-version-of-chrome">SessionNotCreatedException: Message: session not created: This version of ChromeDriver only supports Chrome version 81</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在使用Selenium调用Chrome浏览器爬取互联网数据时，会遇到Chrome和ChromeDriver版本不兼容的问题，导致爬取失败。&lt;/p&gt;
&lt;p&gt;一种解决方案是，进行版本匹配。但是随着本机Chrome的更新，每次都需要随之更新ChromeDriver版本。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="网络爬虫" scheme="https://gmet233.gitee.io/categories/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"/>
    
    
    <category term="网络爬虫" scheme="https://gmet233.gitee.io/tags/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"/>
    
    <category term="Selenium" scheme="https://gmet233.gitee.io/tags/Selenium/"/>
    
  </entry>
  
  <entry>
    <title>test_slides</title>
    <link href="https://gmet233.gitee.io/2022/04/11/test-slides/"/>
    <id>https://gmet233.gitee.io/2022/04/11/test-slides/</id>
    <published>2022-04-11T12:59:15.000Z</published>
    <updated>2022-04-11T13:01:32.660Z</updated>
    
    <content type="html"><![CDATA[<h1 id="这是一个slides测试博客"><a href="#这是一个slides测试博客" class="headerlink" title="这是一个slides测试博客"></a>这是一个slides测试博客</h1><p>===</p><p>它可以把markdown渲染的像幻灯片一样</p><p>==</p><p>还有垂直切换</p><p>==</p><p>还可以切换背景等。</p><p>===</p><p>Have Fun~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;这是一个slides测试博客&quot;&gt;&lt;a href=&quot;#这是一个slides测试博客&quot; class=&quot;headerlink&quot; title=&quot;这是一个slides测试博客&quot;&gt;&lt;/a&gt;这是一个slides测试博客&lt;/h1&gt;&lt;p&gt;===&lt;/p&gt;
&lt;p&gt;它可以把markdow</summary>
      
    
    
    
    
    <category term="测试" scheme="https://gmet233.gitee.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>基于ResNet的树叶分类任务</title>
    <link href="https://gmet233.gitee.io/2022/04/04/%E5%9F%BA%E4%BA%8EResNet%E7%9A%84%E6%A0%91%E5%8F%B6%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/"/>
    <id>https://gmet233.gitee.io/2022/04/04/%E5%9F%BA%E4%BA%8EResNet%E7%9A%84%E6%A0%91%E5%8F%B6%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/</id>
    <published>2022-04-04T03:16:17.000Z</published>
    <updated>2022-04-04T09:17:56.792Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本文任务、数据集来源于《动手学深度学习》课程中的树叶分类竞赛。详见参考资料1</p><p>本文代码主要参考kaggle用户nekokiku给出的resnet baseline。详见参考资料2</p><p>通过本次竞赛和代码可以学习到：</p><ul><li>简单的PyTorch深度学习项目代码、结构是怎样的</li><li>如何继承PyTorch中的Dataset, DataLoader实现自己的Dataset, DataLoader类</li><li>如何使用PyTorch快速实现ResNet模型。</li></ul></blockquote><h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><p>分析baseline code，总结一下深度学习的代码流程。</p><ol><li>处理数据：包括元数据和图像数据。比如看看数据的样子，标签的分布，unique 标签的数量等。</li><li>实现自己的Dataset、DataLoader类</li><li>CPU OR GPU</li><li>定义模型</li><li>定义超参数：学习率等</li><li>train&amp;valid</li><li>使用训练好的模型进行预测。</li></ol><h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p>针对本次任务项目结构如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">leaves_classification_competition/</span><br><span class="line">└─data/</span><br><span class="line">    └─classify-leaves/</span><br><span class="line">        └─images/</span><br><span class="line">└─train.csv</span><br><span class="line">└─test.csv</span><br><span class="line">└─script.ipynb</span><br></pre></td></tr></table></figure><p><code>data/</code>目录下是本次任务用到的数据。将从kaggle上下载的数据压缩包解压到本文件夹。</p><p><code>script.ipynb</code>是代码脚本。</p><p>在更大的训练中，代码应该拆分为各种<code>.py</code>文件。</p><h1 id="baseline"><a href="#baseline" class="headerlink" title="baseline"></a>baseline</h1><h2 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 首先导入包</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset, DataLoader</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> torchvision.models <span class="keyword">as</span> models</span><br><span class="line"><span class="comment"># This is for the progress bar.</span></span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br></pre></td></tr></table></figure><h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><p>看一看train.csv长什么样</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DATA_BASE_PATH = <span class="string">&#x27;./data/classify-leaves/&#x27;</span></span><br><span class="line"><span class="comment"># label文件</span></span><br><span class="line">labels_df = pd.read_csv(os.path.join(DATA_BASE_PATH, <span class="string">&#x27;train.csv&#x27;</span>))</span><br><span class="line">labels_df.head()</span><br><span class="line"><span class="comment"># len(labels_df)</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">labels_df.describe()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 把树叶的标签去重映射为数值</span></span><br><span class="line">leaves_labels = <span class="built_in">sorted</span>(<span class="built_in">list</span>(<span class="built_in">set</span>(labels_df[<span class="string">&#x27;label&#x27;</span>])))</span><br><span class="line">n_classes = <span class="built_in">len</span>(leaves_labels)</span><br><span class="line">class2num = <span class="built_in">dict</span>(<span class="built_in">zip</span>(leaves_labels, <span class="built_in">range</span>(n_classes)))</span><br><span class="line">class2num</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#x27;abies_concolor&#x27;: 0,</span><br><span class="line"> &#x27;abies_nordmanniana&#x27;: 1,</span><br><span class="line"> &#x27;acer_campestre&#x27;: 2,</span><br><span class="line">……</span><br><span class="line"> &#x27;zelkova_serrata&#x27;: 175&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 转换成key为数字，val为树叶类型，方便预测。</span></span><br><span class="line">num2class = &#123;v:k <span class="keyword">for</span> k, v <span class="keyword">in</span> class2num.items()&#125;</span><br><span class="line">num2class</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;0: &#x27;abies_concolor&#x27;,</span><br><span class="line"> 1: &#x27;abies_nordmanniana&#x27;,</span><br><span class="line"> 2: &#x27;acer_campestre&#x27;,</span><br><span class="line"> 3: &#x27;acer_ginnala&#x27;,</span><br><span class="line"> 4: &#x27;acer_griseum&#x27;,</span><br><span class="line">……</span><br><span class="line"> 175: &#x27;zelkova_serrata&#x27;&#125;</span><br></pre></td></tr></table></figure><h2 id="实现Dataset"><a href="#实现Dataset" class="headerlink" title="实现Dataset"></a>实现Dataset</h2><p>继承Dataset类，实现自己的Dataset。继承之后，需要实现三个函数</p><ul><li><code>__init__</code>：传入必要的参数，初始化；</li><li><code>__getitem__</code>：返回item，如果是train或者valid则返回img和label，如果是test则返回img</li><li><code>__len__</code>：数据集长度</li><li>更多参见参考资料3</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 继承Dataset类。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LeaveDataSet</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, csv_path, img_path, mode=<span class="string">&#x27;train&#x27;</span>, valid_ratio = <span class="number">0.2</span>, resize_height = <span class="number">256</span>, resize_width = <span class="number">256</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">          csv_path: label文件路径</span></span><br><span class="line"><span class="string">          img_path: 图片存放路径</span></span><br><span class="line"><span class="string">          mode: 训练模式还是测试模式</span></span><br><span class="line"><span class="string">          valid_ratio: 验证集比例</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.img_path = img_path</span><br><span class="line">        self.mode = mode</span><br><span class="line">        self.data_info = pd.read_csv(csv_path)</span><br><span class="line">        self.data_len = <span class="built_in">len</span>(self.data_info)</span><br><span class="line">        self.train_len = <span class="built_in">int</span>(self.data_len * (<span class="number">1</span> - valid_ratio))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> mode == <span class="string">&#x27;train&#x27;</span>:</span><br><span class="line">            <span class="comment"># 为啥要转成nparray</span></span><br><span class="line">            self.train_image = np.asarray(self.data_info.iloc[:self.train_len, <span class="number">0</span>])</span><br><span class="line">            self.train_label = np.asarray(self.data_info.iloc[:self.train_len, <span class="number">1</span>])</span><br><span class="line">            <span class="comment"># 为了在不同模式下统一变量</span></span><br><span class="line">            self.image_arr = self.train_image</span><br><span class="line">            self.label_arr = self.train_label</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> mode == <span class="string">&#x27;valid&#x27;</span>:</span><br><span class="line">            self.valid_image = np.asarray(self.data_info.iloc[self.train_len:,<span class="number">0</span>])</span><br><span class="line">            self.valid_label = np.asarray(self.data_info.iloc[self.train_len:,<span class="number">1</span>])</span><br><span class="line">            self.image_arr = self.valid_image</span><br><span class="line">            self.label_arr = self.valid_label</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.test_image = np.asarray(self.data_info.iloc[:,<span class="number">0</span>])</span><br><span class="line">            self.image_arr = self.test_image</span><br><span class="line">            <span class="comment">#test 没有label</span></span><br><span class="line">        self.real_len = <span class="built_in">len</span>(self.image_arr)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Finished reading the &#123;&#125; set of Leaves Dataset. (&#123;&#125; samples found)&quot;</span>.<span class="built_in">format</span>(mode, self.real_len))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, index</span>):</span><br><span class="line"></span><br><span class="line">        single_image_name = self.image_arr[index]</span><br><span class="line">        img_as_img = Image.<span class="built_in">open</span>(os.path.join(self.img_path, single_image_name))</span><br><span class="line">        <span class="keyword">if</span> self.mode == <span class="string">&#x27;train&#x27;</span>:</span><br><span class="line">            transform = transforms.Compose([</span><br><span class="line">                transforms.Resize((<span class="number">224</span>, <span class="number">224</span>)),</span><br><span class="line">                transforms.RandomHorizontalFlip(p=<span class="number">0.5</span>),   <span class="comment">#随机水平翻转 选择一个概率</span></span><br><span class="line">                transforms.ToTensor()</span><br><span class="line">            ])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># valid和test不做数据增强</span></span><br><span class="line">            transform = transforms.Compose([</span><br><span class="line">                transforms.Resize((<span class="number">224</span>, <span class="number">224</span>)),</span><br><span class="line">                transforms.ToTensor()</span><br><span class="line">            ])</span><br><span class="line">        img_as_img = transform(img_as_img)</span><br><span class="line">        <span class="comment"># 先不做图像裁剪，增强和灰度处理</span></span><br><span class="line">        <span class="keyword">if</span> self.mode == <span class="string">&#x27;test&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> img_as_img</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            label = self.label_arr[index]</span><br><span class="line">            <span class="comment"># label转数字</span></span><br><span class="line">            number_label = class2num[label]</span><br><span class="line">            <span class="keyword">return</span> img_as_img, number_label</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.real_len</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">生成dataset对象</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">train_csv_path = <span class="string">&#x27;./data/classify-leaves/train.csv&#x27;</span></span><br><span class="line">test_csv_path = <span class="string">&#x27;./data/classify-leaves/test.csv&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># csv文件中已经images的路径了，因此这里只到上一级目录</span></span><br><span class="line"></span><br><span class="line">img_path = <span class="string">&#x27;./data/classify-leaves/&#x27;</span></span><br><span class="line"></span><br><span class="line">train_dataset = LeaveDataSet(train_csv_path, img_path, mode=<span class="string">&#x27;train&#x27;</span>)</span><br><span class="line">test_dataset = LeaveDataSet(train_csv_path, img_path, mode=<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line">valid_dataset = LeaveDataSet(train_csv_path, img_path, mode=<span class="string">&#x27;valid&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Finished reading the train set of Leaves Dataset (14681 samples found)</span><br><span class="line">Finished reading the test set of Leaves Dataset (18353 samples found)</span><br><span class="line">Finished reading the valid set of Leaves Dataset (3672 samples found)</span><br></pre></td></tr></table></figure><h2 id="实现Dataloader"><a href="#实现Dataloader" class="headerlink" title="实现Dataloader"></a>实现Dataloader</h2><p>定义train，valid，test的dataloader，参数详见参考资料4</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义 data loader</span></span><br><span class="line"><span class="comment"># dataloader 参数详解：https://blog.csdn.net/qq_36653505/article/details/84728855</span></span><br><span class="line"></span><br><span class="line">train_loader = DataLoader(</span><br><span class="line">    dataset=train_dataset,</span><br><span class="line">    batch_size=<span class="number">8</span>,</span><br><span class="line">    shuffle=<span class="literal">False</span>,</span><br><span class="line">    num_workers=<span class="number">5</span> <span class="comment"># 使用nums_workers个线程读数据</span></span><br><span class="line">)</span><br><span class="line">valid_loader = DataLoader(</span><br><span class="line">    dataset=valid_dataset,</span><br><span class="line">    batch_size=<span class="number">8</span>,</span><br><span class="line">    shuffle=<span class="literal">False</span>,</span><br><span class="line">    num_workers=<span class="number">5</span></span><br><span class="line">)</span><br><span class="line">test_loader = DataLoader(</span><br><span class="line">    dataset=test_dataset,</span><br><span class="line">    batch_size=<span class="number">8</span>,</span><br><span class="line">    shuffle=<span class="literal">False</span>,</span><br><span class="line">    num_workers=<span class="number">5</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="获取GPU"><a href="#获取GPU" class="headerlink" title="获取GPU"></a>获取GPU</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># CPU OR GPU</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_device</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;cuda&#x27;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&#x27;cpu&#x27;</span></span><br><span class="line"></span><br><span class="line">device = get_device()</span><br><span class="line"><span class="built_in">print</span>(device)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cuda</span><br></pre></td></tr></table></figure><h2 id="定义模型"><a href="#定义模型" class="headerlink" title="定义模型"></a>定义模型</h2><p>这里模型使用resnet34</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义resnet34</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">num_classes: 传入分类任务的类别数，由上面的数据可知，一共有176种树叶，所以一会调用该函数返回模型时，传入的num_classes参数为176</span></span><br><span class="line"><span class="string">use_pretrained: 是否使用预训练模型。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">res_model</span>(<span class="params">num_classes, feature_extract = <span class="literal">False</span>, use_pretrained = <span class="literal">False</span></span>):</span><br><span class="line">    model_ft = models.resnet34(pretrained=use_pretrained)</span><br><span class="line">    <span class="comment"># set_parameter_requires_grad(model_ft, feature_extract)</span></span><br><span class="line">    <span class="comment"># 这里是想要把原始模型的最后一层全连接层替换掉，替换成输出类别为num_classes的全连接层。</span></span><br><span class="line">    <span class="comment"># 为了做到这一点我们需要先知道原始模型的全连接层的输入feature维度。</span></span><br><span class="line">    num_ftrs = model_ft.fc.in_features</span><br><span class="line">    model_ft.fc = nn.Sequential(nn.Linear(num_ftrs, num_classes))</span><br><span class="line">    <span class="keyword">return</span> model_ft</span><br></pre></td></tr></table></figure><h2 id="定义超参数"><a href="#定义超参数" class="headerlink" title="定义超参数"></a>定义超参数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 超参数</span></span><br><span class="line">lr = <span class="number">3e-4</span> <span class="comment">#学习率</span></span><br><span class="line">weight_decay = <span class="number">1e-3</span></span><br><span class="line">num_epoch = <span class="number">50</span> <span class="comment">#迭代轮数</span></span><br><span class="line">model_path = <span class="string">&#x27;./pre_res_model.ckpt&#x27;</span> <span class="comment"># 模型保存位置</span></span><br></pre></td></tr></table></figure><h2 id="train-amp-valid"><a href="#train-amp-valid" class="headerlink" title="train&amp;valid"></a>train&amp;valid</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 模型初始化，并放到具体的设备中</span></span><br><span class="line">model = res_model(<span class="number">176</span>)</span><br><span class="line"><span class="comment"># 将模型放到device上。</span></span><br><span class="line">model = model.to(device)</span><br><span class="line">model.device = device <span class="comment"># 这行代码貌似没什么用</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分类任务使用交叉熵损失作为评估标准</span></span><br><span class="line">criterion = nn.CrossEntropyLoss()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Adam优化器</span></span><br><span class="line">optimizer = torch.optim.Adam(model.parameters(), lr = lr, weight_decay= weight_decay)</span><br><span class="line"></span><br><span class="line">n_epochs = num_epoch</span><br><span class="line"></span><br><span class="line">best_acc = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(n_epochs):</span><br><span class="line">    <span class="comment"># ------- train --------</span></span><br><span class="line">    <span class="comment"># 训练的时候，要调用该函数，使模型处于训练模式</span></span><br><span class="line">    model.train()</span><br><span class="line">    <span class="comment"># 记录每次使用一个batch训练后，模型的损失和精确率。</span></span><br><span class="line">    train_loss = []</span><br><span class="line">    train_accs = []</span><br><span class="line">    <span class="comment"># tqdm是一个显示进度条的工具包，不用管。</span></span><br><span class="line">    <span class="keyword">for</span> batch <span class="keyword">in</span> tqdm(train_loader):</span><br><span class="line">        <span class="comment"># A batch consists of image data and corresponding labels.</span></span><br><span class="line">        imgs, labels = batch</span><br><span class="line">        <span class="comment"># 把数据都放到同一个device上</span></span><br><span class="line">        imgs = imgs.to(device)</span><br><span class="line">        labels = labels.to(device)</span><br><span class="line"></span><br><span class="line">        logits = model(imgs)</span><br><span class="line">        <span class="comment"># 计算模型输出和真实label之间的损失，反向传播。。</span></span><br><span class="line">        loss = criterion(logits, labels)</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">        <span class="comment">#这行code不是很懂，大概就是统计预测正确标签的占比</span></span><br><span class="line">        <span class="comment"># 弄明白：https://csbwang.github.io/dl_ch2#2161</span></span><br><span class="line">        acc = (logits.argmax(dim = -<span class="number">1</span>) == labels).<span class="built_in">float</span>().mean()</span><br><span class="line">        </span><br><span class="line">        train_loss.append(loss.item())</span><br><span class="line">        train_accs.append(acc)</span><br><span class="line">    <span class="comment"># 计算本次epoch后的loss和acc</span></span><br><span class="line">    train_loss = <span class="built_in">sum</span>(train_loss) / <span class="built_in">len</span>(train_loss)</span><br><span class="line">    train_acc = <span class="built_in">sum</span>(train_accs) / <span class="built_in">len</span>(train_accs)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;[ Train | <span class="subst">&#123;epoch + <span class="number">1</span>:03d&#125;</span>/<span class="subst">&#123;n_epochs:03d&#125;</span> ] loss = <span class="subst">&#123;train_loss:<span class="number">.5</span>f&#125;</span>, acc = <span class="subst">&#123;train_acc:<span class="number">.5</span>f&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="comment"># ------- valid --------</span></span><br><span class="line">    <span class="comment"># 验证时，把模型调成评估模式</span></span><br><span class="line">    model.<span class="built_in">eval</span>()  <span class="comment"># eval具体是做什么?</span></span><br><span class="line"></span><br><span class="line">    valid_loss = []</span><br><span class="line">    valid_accs = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> batch <span class="keyword">in</span> tqdm(valid_loader):</span><br><span class="line">        imgs, labels = batch</span><br><span class="line">        <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">            logits = model(imgs.to(device))</span><br><span class="line">        loss = criterion(logits, labels.to(device))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># acc = (logits.argmax(dim = -1) == labels).float().mean()</span></span><br><span class="line">        acc = (logits.argmax(dim = -<span class="number">1</span>) == labels.to(device)).<span class="built_in">float</span>().mean()</span><br><span class="line"></span><br><span class="line">        valid_loss.append(loss.item())</span><br><span class="line">        valid_accs.append(acc)</span><br><span class="line">    </span><br><span class="line">    valid_loss = <span class="built_in">sum</span>(valid_loss) / <span class="built_in">len</span>(valid_loss)</span><br><span class="line">    valid_acc = <span class="built_in">sum</span>(valid_accs) / <span class="built_in">len</span>(valid_accs)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;[ Valid | <span class="subst">&#123;epoch + <span class="number">1</span>:03d&#125;</span>/<span class="subst">&#123;n_epochs:03d&#125;</span> ] loss = <span class="subst">&#123;valid_loss:<span class="number">.5</span>f&#125;</span>, acc = <span class="subst">&#123;valid_acc:<span class="number">.5</span>f&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果在验证集得到的acc大于已知最好的acc，则保存模型。</span></span><br><span class="line">    <span class="keyword">if</span> valid_acc &gt; best_acc:</span><br><span class="line">        best_acc = valid_acc</span><br><span class="line">        torch.save(model.state_dict(), model_path)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;saving model with acc &#123;:.3f&#125;&#x27;</span>.<span class="built_in">format</span>(best_acc))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>//控制台输出</p><h2 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h2><p>上面就是训练过程，下面用训练好的模型进行预测</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">################ </span></span><br><span class="line">saveFileName = <span class="string">&#x27;./data/classify-leaves/submission.csv&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## predict</span></span><br><span class="line">model = res_model(<span class="number">176</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># create model and load weights from checkpoint</span></span><br><span class="line">model = model.to(device)</span><br><span class="line">model.load_state_dict(torch.load(model_path))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Make sure the model is in eval mode.</span></span><br><span class="line"><span class="comment"># Some modules like Dropout or BatchNorm affect if the model is in training mode.</span></span><br><span class="line">model.<span class="built_in">eval</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Initialize a list to store the predictions.</span></span><br><span class="line">predictions = []</span><br><span class="line"><span class="comment"># Iterate the testing set by batches.</span></span><br><span class="line"><span class="keyword">for</span> batch <span class="keyword">in</span> tqdm(test_loader):</span><br><span class="line">    </span><br><span class="line">    imgs = batch</span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        logits = model(imgs.to(device))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Take the class with greatest logit as prediction and record it.</span></span><br><span class="line">    predictions.extend(logits.argmax(dim=-<span class="number">1</span>).cpu().numpy().tolist())</span><br><span class="line"></span><br><span class="line">preds = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> predictions:</span><br><span class="line">    preds.append(num2class[i])</span><br><span class="line"></span><br><span class="line">test_data = pd.read_csv(test_path)</span><br><span class="line">test_data[<span class="string">&#x27;label&#x27;</span>] = pd.Series(preds)</span><br><span class="line">submission = pd.concat([test_data[<span class="string">&#x27;image&#x27;</span>], test_data[<span class="string">&#x27;label&#x27;</span>]], axis=<span class="number">1</span>)</span><br><span class="line">submission.to_csv(saveFileName, index=<span class="literal">False</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Done!!!!!!!!!!!!!!!!!!!!!!!!!!!&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="改进模型"><a href="#改进模型" class="headerlink" title="改进模型"></a>改进模型</h1><p>//TODO</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>初学深度学习，代码上犯了很多细节上的错误。其次，很多细节问题不明白，例如，优化器？各种计算公式等。以后要弄懂。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://www.bilibili.com/video/BV1z64y1o7iz">第二部分完结竞赛：图片分类【动手学深度学习v2】</a></li><li><a href="https://www.kaggle.com/code/nekokiku/simple-resnet-baseline">nekokiku/simple-resnet-baseline</a></li><li><a href="https://blog.csdn.net/leviopku/article/details/99958182">Pytorch中的dataset类——创建适应任意模型的数据集接口</a></li><li><a href="https://blog.csdn.net/qq_36653505/article/details/84728855">Pytorch 中的数据类型 torch.utils.data.DataLoader 参数详解</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本文任务、数据集来源于《动手学深度学习》课程中的树叶分类竞赛。详见参考资料1&lt;/p&gt;
&lt;p&gt;本文代码主要参考kag</summary>
      
    
    
    
    <category term="深度学习" scheme="https://gmet233.gitee.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="动手学深度学习" scheme="https://gmet233.gitee.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="深度学习" scheme="https://gmet233.gitee.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>复现ResNet50（PyTorch）</title>
    <link href="https://gmet233.gitee.io/2022/03/29/%E5%A4%8D%E7%8E%B0ResNet50%EF%BC%88PyTorch%EF%BC%89/"/>
    <id>https://gmet233.gitee.io/2022/03/29/%E5%A4%8D%E7%8E%B0ResNet50%EF%BC%88PyTorch%EF%BC%89/</id>
    <published>2022-03-29T13:45:17.000Z</published>
    <updated>2022-03-30T13:47:01.221Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本篇博客介绍了 ResNet50 网络 PyTorch 复现（复现代码为 PyTorch 源码）</p></blockquote><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>Residual Net：残差网络。</p><p>将靠前若干层的某一层数据输出直接跳过多层引入到后面数据层的输入部分。意味着后面的特征层的内容会有一部分由其前面的某一层线性贡献。</p><p><img src="image-20220329215711900.png" alt="残差块"></p><p>深度残差网络的设计是为了克服由于网络深度加深而产生的学习效率变低与准确率无法有效提升的问题。</p><p>下面这张图来自参考文献[1]，给出了ResNet18、ResNet34、ResNet50、ResNet101、ResNet152的块结构。</p><p><img src="image-20220329220108463.png" alt="ResNet-XX 网络结构"></p><p>根据该图，我们可以画出ResNet50的网络结构，</p><p><img src="image-20220329220245960.png" alt="ResNet-50 网络结构"></p><p>由上述网络结构可以看到，ResNet包含两种Block：分别为<strong>Conv Block</strong>和<strong>Identity Block</strong>。</p><ul><li><strong>Conv Block</strong>输入和输出的维度（通道数和size）是不一样的，所以相同的Conv Block不能连续串联，它的作用是改变网络的维度；</li><li><strong>Identity Block</strong>输入维度和输出维度（通道数和size）相同，可以串联，用于加深网络的。</li></ul><p>下面是两种块的结构：</p><p><img src="image-20220329221454060.png" alt="Conv Block"></p><p><img src="image-20220329221531582.png" alt="Identity Block"></p><p>这两种块的区别在于残差边是否卷积。如果经过$1*1$卷积。经过卷积的是Conv Block，直连的是Identity Block。</p><p>稍后用一个类<code>Bottleneck</code>实现这两种块。</p><p>下面参考PyTorch框架源码，对 ResNet50  一步步复现。</p><h1 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h1><h2 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br></pre></td></tr></table></figure><h2 id="ResNet50-生成函数"><a href="#ResNet50-生成函数" class="headerlink" title="ResNet50 生成函数"></a>ResNet50 生成函数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">resnet50</span>(<span class="params">pretrained = <span class="literal">False</span>, **kwargs</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    Constructs a ResNet-50 model.</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        pretrained:(bool): If True, return a model pretrained on ImageNet</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    model = ResNet(Bottleneck, [<span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>], **kwargs)</span><br><span class="line">    <span class="keyword">if</span> pretrained:</span><br><span class="line">        <span class="comment"># model.load_state_dict(model_zoo.load_url(model_urls[&#x27;resnet50&#x27;]))</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">return</span> model</span><br><span class="line"></span><br><span class="line">net = resnet50()</span><br></pre></td></tr></table></figure><p>通过 <code>model = ResNet(Bottleneck, [3, 4, 6, 3], **kwargs)</code> 构造网络结构，主要分成两个部分即 <code>Bottleneck</code>和 <code>[3,4,6,3]</code> 由这两个参数共同决定了ResNet50的网络结构 ，当<code>pretrained</code>为<code>True</code>时，model加载ImageNet中预训练的参数。（这块本篇文章先不考虑）</p><p><code>[3,4,6,3]</code>对应于上图中ResNet50中 conv2_x中有三个（$1<em>1, 64$，$3</em>3, 64$，$1<em>1, 256$）卷积层的堆叠 ，同理conv3_x中有4个（$1</em>1, 128$，$3<em>3, 128$，$1</em>1, 512$）卷积层的堆叠，ResNet50将卷积层分为4个大层，<code>[3,4,6,3]</code>代表每一个大层中$1<em>1$，$3</em>3$，$1<em>1$卷积层组合的重复次数总共1（第一个卷积层）+1（第一个池化层）+（3+4+6+3）</em>3 = 50层。</p><p>这里<code>Bottleneck</code>类，就是一个基础块。对应上图（$1<em>1$，$3</em>3$，$1*1$）的三个卷积层组合。</p><h2 id="ResNet类"><a href="#ResNet类" class="headerlink" title="ResNet类"></a>ResNet类</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ResNet</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_make_layer</span>(<span class="params">self, block, planes, blocks, stride=<span class="number">1</span></span>):</span><br><span class="line">        downsample = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> stride != <span class="number">1</span> <span class="keyword">or</span> self.inplanes != planes * block.expansion:</span><br><span class="line">            downsample = nn.Sequential(</span><br><span class="line">                nn.Conv2d(self.inplanes, planes * block.expansion,</span><br><span class="line">                kernel_size=<span class="number">1</span>, stride=stride, bias=<span class="literal">False</span>),</span><br><span class="line">                nn.BatchNorm2d(planes * block.expansion)</span><br><span class="line">            )</span><br><span class="line">        layers = []</span><br><span class="line">        layers.append(block(self.inplanes, planes, stride, downsample))</span><br><span class="line">        self.inplanes = planes * block.expansion</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, blocks): <span class="comment"># for (blocks - 1)</span></span><br><span class="line">            layers.append(block(self.inplanes, planes))</span><br><span class="line">        <span class="keyword">return</span> nn.Sequential(*layers)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, block, layers, num_classes = <span class="number">1000</span></span>):</span><br><span class="line">        self.inplanes = <span class="number">64</span></span><br><span class="line">        <span class="built_in">super</span>(ResNet, self).__init__() <span class="comment"># ?</span></span><br><span class="line">        self.conv1 = nn.Conv2d(<span class="number">3</span>, <span class="number">64</span>, kernel_size=<span class="number">7</span>, stride=<span class="number">2</span>, padding=<span class="number">3</span>, bias=<span class="literal">False</span>)</span><br><span class="line">        self.bn1 = nn.BatchNorm2d(<span class="number">64</span>)</span><br><span class="line">        self.relu = nn.ReLU(inplace=<span class="literal">True</span>)</span><br><span class="line">        self.maxpool = nn.MaxPool2d(kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>, padding=<span class="number">1</span>)</span><br><span class="line">        self.layer1 = self._make_layer(block, <span class="number">64</span>, layers[<span class="number">0</span>])</span><br><span class="line">        self.layer2 = self._make_layer(block, <span class="number">128</span>, layers[<span class="number">1</span>], stride=<span class="number">2</span>)</span><br><span class="line">        self.layer3 = self._make_layer(block, <span class="number">256</span>, layers[<span class="number">2</span>], stride=<span class="number">2</span>)</span><br><span class="line">        self.layer4 = self._make_layer(block, <span class="number">512</span>, layers[<span class="number">3</span>], stride=<span class="number">2</span>)</span><br><span class="line">        self.avgpool = nn.AvgPool2d(<span class="number">7</span>, stride=<span class="number">1</span>)</span><br><span class="line">        <span class="comment">#因为最后feature map在输入为224时，经过layer4之后大小为7*7，此时经过nn.AvgPool2d(7, stride=1)大小变为1*1，再经过全连接层时，self.fc = nn.Linear(512 * block.expansion, num_classes) 前者是输出的所有channel数目，实际应该为channel*1*1，后者为分类数</span></span><br><span class="line">        self.fc = nn.Linear(<span class="number">512</span> * block.expansion, num_classes)</span><br><span class="line"><span class="comment"># ?</span></span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> self.modules():</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(m, nn.Conv2d):</span><br><span class="line">                nn.init.kaiming_normal_(m.weight, mode=<span class="string">&#x27;fan_out&#x27;</span>, nonlinearity=<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">isinstance</span>(m, nn.BatchNorm2d):</span><br><span class="line">                nn.init.constant_(m.weight, <span class="number">1</span>)</span><br><span class="line">                nn.init.constant_(m.bias, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">       self.avgpool = nn.AvgPool2d(<span class="number">7</span>, stride=<span class="number">1</span>)</span><br><span class="line">  x = self.avgpool(x)  </span><br><span class="line"></span><br><span class="line">  x = x.view(x.size(<span class="number">0</span>), -<span class="number">1</span>)     </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="comment"># 首先对输入进行7*7的卷积</span></span><br><span class="line">        x = self.conv1(x)</span><br><span class="line">        x = self.bn1(x)</span><br><span class="line">        x = self.relu(x)</span><br><span class="line">        <span class="comment"># 然后对x进行3*3的最大池化</span></span><br><span class="line">        x = self.maxpool(x)</span><br><span class="line"><span class="comment"># 接着进入四个layer/stage</span></span><br><span class="line">        x = self.layer1(x)</span><br><span class="line">        x = self.layer2(x)</span><br><span class="line">        x = self.layer3(x)</span><br><span class="line">        x = self.layer4(x)</span><br><span class="line"><span class="comment">#最后平均池化</span></span><br><span class="line"></span><br><span class="line">        x = self.avgpool(x)</span><br><span class="line">        <span class="comment"># 将数据拉伸成batchsize * channel * 1 * 1 ?</span></span><br><span class="line">        x = x.view(x.size(<span class="number">0</span>), -<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 如果输入大小不为224  那么相应的可以修改AvgPool2d 或者在全连接层第一个参数中乘上最终的width 和height</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><p>ResNet 是由<code>__init__</code>和<code>forward</code>构成，为了方便分析这里首先分析<code>__init__</code>函数。</p><h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><p>在<code>__init__</code>中，最重要的是<code>_make_layer</code>函数，以<code>layer1</code>为例，block为Bottleneck，planes=64（即channel数目）blocks=3 （<code>[3,4,6,3]</code>分别代表每一层的blocks数目）这里要注意<code>layer1</code>的stride为1，其他layer的stride为2。</p><p>对于<code>layer1</code>而言，<code>inplanes=64</code>， <code>planes=64</code>， <code>block.expansion=4</code>，因此需要经过downsample才能够使得残差和经过该层的feature map能够相加，downsample即为右路部分。（可以看<code>Bottleneck</code>的实现）</p><h3 id="forward"><a href="#forward" class="headerlink" title="forward"></a>forward</h3><p>见上面的代码注释。</p><h2 id="Bottleneck"><a href="#Bottleneck" class="headerlink" title="Bottleneck"></a>Bottleneck</h2><p>接着我们看一下Bottleneck的实现。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    Block的各个plane值：</span></span><br><span class="line"><span class="string">        inplanes：输出block的之前的通道数</span></span><br><span class="line"><span class="string">        planes：在block中间处理的时候的通道数（这个值是输出维度的1/4）</span></span><br><span class="line"><span class="string">        midplane*self.expansion：输出的维度</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bottleneck</span>(nn.Module):</span><br><span class="line">    <span class="comment">#每个stage中维度拓展的倍数</span></span><br><span class="line">    expansion = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1 * 1卷积核不改变feature map的大小，3 * 3卷积核padding=1&amp;&amp;stride=1也不改变输入feature map的大小，因此经过一个Bottleneck组成的卷积层组操作后feature map大小不会改变</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, inplanes, planes, stride = <span class="number">1</span>, downsample=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(Bottleneck, self).__init__()</span><br><span class="line">        self.conv1 = nn.Conv2d(inplanes, planes, kernel_size=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">        self.bn1 = nn.BatchNorm2d(planes)</span><br><span class="line">        self.conv2 = nn.Conv2d(planes, planes, kernel_size=<span class="number">3</span>, stride=stride, padding=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">        self.bn2 = nn.BatchNorm2d(planes)</span><br><span class="line">        self.conv3 = nn.Conv2d(planes, planes * self.expansion, kernel_size=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">        self.bn3 = nn.BatchNorm2d(planes * self.expansion)</span><br><span class="line">        self.relu = nn.ReLU(inplace= <span class="literal">True</span>)</span><br><span class="line">        self.downsample = downsample</span><br><span class="line">        self.stride = stride</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        residual = x</span><br><span class="line">        out = self.conv1(x)</span><br><span class="line">        out = self.bn1(out)</span><br><span class="line">        out = self.conv2(out)</span><br><span class="line">        out = self.bn2(out)</span><br><span class="line">        out = self.conv3(out)</span><br><span class="line">        out = self.bn3(out)</span><br><span class="line">        <span class="keyword">if</span> self.downsample <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            residual = self.downsample(x)</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        out += residual</span><br><span class="line">        out = self.relu(out)</span><br><span class="line">        <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure><p>其中当<code>downsample</code>为None时，残差边直连，此时为Identify Block，当<code>downsample</code>不为None时，残差边进行卷积再相加，此时为Conv Block。</p><blockquote><p>为什么要先卷积再相加呢？</p><p>因为feature map的大小不变 但是在经过Bottleneck 之后channel变成了原来的四倍，因此想要和原始的feature map相加需要将原始的feature map也变为原来的四倍 ，downsample作用是residual+当前feature map时将维度统一。</p></blockquote><h1 id="从输入到layers"><a href="#从输入到layers" class="headerlink" title="从输入到layers"></a>从输入到layers</h1><p>首先输入(3, 224, 224)，即三个通道，224<em>224像素的输入，经过一个输出通道数为64的7\</em>7卷积层，一个3*3池化，得到(64, 56, 56)。然后将其输入到layer1、2、3、4。</p><blockquote><p>解释一下为什么是(64, 56, 56)</p><p>因为ResNet接受的图像大小为224 * 224 经过第一层卷积层<code>self.conv1 = nn.Conv2d(3, 64, kernel_size=7, stride=2, padding=3, bias=False)</code></p><script type="math/tex; mode=display">floor((224-7+3*2)/2)+1=112</script><p>经过第一层池化之后，<code>self.maxpool = nn.MaxPool2d(kernel_size=3, stride=2, padding=1)</code></p><script type="math/tex; mode=display">floor((112+2*1-3)/2)+1=56</script><p>因此在输入到Bottleneck之前得到一个64(channel), 56(height)，56(weight)大小的feature map。</p></blockquote><h2 id="layer1-Bottleneck1"><a href="#layer1-Bottleneck1" class="headerlink" title="layer1/Bottleneck1"></a>layer1/Bottleneck1</h2><p>输入 ：[batch_size,64,56,56]</p><p>调用<code>_make_layer(block, 64, layers[0])</code>构造了layer1，此时<code>self.inplanes</code>为64，<code>planes * block.expansion</code>=64 <em> 4，不相等（之所以要二者相等，是因为在<code>Bottleneck</code>主体分支最后一个卷积层会将<code>channel</code>变为`planes</em>block.expansion<code>，如果</code>inplanes<code>（实际就是输入的channel）与之不相等则不可相加因此构造右路</code>downsample` （1*1卷积核的卷积层扩展channel+BN层）</p><p><img src="20181108104951863.png" alt="主体分支"></p><p><img src="20181108105037539.png" alt="downsample分支"></p><p>更新 inplanes=64*4=256</p><h2 id="layer1-Bottleneck2"><a href="#layer1-Bottleneck2" class="headerlink" title="layer1/Bottleneck2"></a>layer1/Bottleneck2</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">self.conv1 = nn.Conv2d(<span class="number">256</span>, <span class="number">64</span>, kernel_size=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">self.bn1 = nn.BatchNorm2d(<span class="number">64</span>)</span><br><span class="line">self.conv2 = nn.Conv2d(<span class="number">64</span>, <span class="number">64</span>, kernel_size=<span class="number">3</span>, stride=stride, padding=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">self.bn2 = nn.BatchNorm2d(<span class="number">64</span>)</span><br><span class="line">self.conv3 = nn.Conv2d(<span class="number">64</span>,<span class="number">256</span>, kernel_size=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">self.bn3 = nn.BatchNorm2d(planes * self.expansion)</span><br><span class="line">self.relu = nn.ReLU(inplace=<span class="literal">True</span>)</span><br><span class="line">self.downsample = <span class="literal">None</span></span><br><span class="line">self.stride = <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="layer1-Bottleneck3"><a href="#layer1-Bottleneck3" class="headerlink" title="layer1/Bottleneck3"></a>layer1/Bottleneck3</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">self.conv1 = nn.Conv2d(<span class="number">256</span>, <span class="number">64</span>, kernel_size=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">self.bn1 = nn.BatchNorm2d(<span class="number">64</span>)</span><br><span class="line">self.conv2 = nn.Conv2d(<span class="number">64</span>, <span class="number">64</span>, kernel_size=<span class="number">3</span>, stride=stride,padding=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">self.bn2 = nn.BatchNorm2d(<span class="number">64</span>)</span><br><span class="line">self.conv3 = nn.Conv2d(<span class="number">64</span>,<span class="number">256</span>, kernel_size=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">self.bn3 = nn.BatchNorm2d(planes * self.expansion)</span><br><span class="line">self.relu = nn.ReLU(inplace=<span class="literal">True</span>)</span><br><span class="line">self.downsample = <span class="literal">None</span></span><br><span class="line">self.stride = <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="layer2-Bottleneck1"><a href="#layer2-Bottleneck1" class="headerlink" title="layer2/Bottleneck1"></a>layer2/Bottleneck1</h2><p>此时<code>stride</code>=2，<code>self.inplanes</code>=256， <code>planes * block.expansion</code>=128*4，需要生成downsample层</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">downsample = nn.Sequential(</span><br><span class="line">nn.Conv2d(<span class="number">256</span>, <span class="number">512</span>,kernel_size=<span class="number">1</span>, stride=<span class="number">2</span>, bias=<span class="literal">False</span>),</span><br><span class="line">nn.BatchNorm2d(<span class="number">512</span>),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>生成第一个Bottleneck的主干</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">self.conv1 = nn.Conv2d(<span class="number">256</span>, <span class="number">128</span>, kernel_size=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">self.bn1 = nn.BatchNorm2d(planes)</span><br><span class="line"><span class="comment"># 此时feature map 大小由56变成28</span></span><br><span class="line">self.conv2 = nn.Conv2d(<span class="number">128</span>, <span class="number">128</span>, kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>, padding=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">self.bn2 = nn.BatchNorm2d(planes)</span><br><span class="line">self.conv3 = nn.Conv2d(<span class="number">128</span>, <span class="number">512</span>, kernel_size=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">self.bn3 = nn.BatchNorm2d(planes * self.expansion)</span><br><span class="line">self.relu = nn.ReLU(inplace=<span class="literal">True</span>)</span><br><span class="line">self.downsample = downsample</span><br><span class="line">self.stride = stride</span><br></pre></td></tr></table></figure><p>更新inplanes=512</p><h2 id="layer2-Bottleneck234"><a href="#layer2-Bottleneck234" class="headerlink" title="layer2/Bottleneck234"></a>layer2/Bottleneck234</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">self.conv1 = nn.Conv2d(<span class="number">512</span>, <span class="number">128</span>, kernel_size=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">self.bn1 = nn.BatchNorm2d(<span class="number">64</span>)</span><br><span class="line">self.conv2 = nn.Conv2d(<span class="number">128</span>, <span class="number">128</span>, kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>,padding=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">self.bn2 = nn.BatchNorm2d(<span class="number">64</span>)</span><br><span class="line">self.conv3 = nn.Conv2d(<span class="number">128</span>,<span class="number">256</span>, kernel_size=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">self.bn3 = nn.BatchNorm2d(planes * self.expansion)</span><br><span class="line">self.relu = nn.ReLU(inplace=<span class="literal">True</span>)</span><br><span class="line">self.downsample = <span class="literal">None</span></span><br><span class="line">self.stride = <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="layer3-4"><a href="#layer3-4" class="headerlink" title="layer3/4"></a>layer3/4</h2><p>对于layer3和layer4同理。</p><h2 id="打印完整的网络结构"><a href="#打印完整的网络结构" class="headerlink" title="打印完整的网络结构"></a>打印完整的网络结构</h2><p>最后，我们打印完整的网络结构：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">net</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ResNet(</span><br><span class="line">  (conv1): Conv2d(3, 64, kernel_size=(7, 7), stride=(2, 2), padding=(3, 3), bias=False)</span><br><span class="line">  (bn1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">  (relu): ReLU(inplace=True)</span><br><span class="line">  (maxpool): MaxPool2d(kernel_size=3, stride=2, padding=1, dilation=1, ceil_mode=False)</span><br><span class="line">  (layer1): Sequential(</span><br><span class="line">    (0): Bottleneck(</span><br><span class="line">      (conv1): Conv2d(64, 64, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)</span><br><span class="line">      (bn2): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv3): Conv2d(64, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn3): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (relu): ReLU(inplace=True)</span><br><span class="line">      (downsample): Sequential(</span><br><span class="line">        (0): Conv2d(64, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">        (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">    (1): Bottleneck(</span><br><span class="line">      (conv1): Conv2d(256, 64, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)</span><br><span class="line">      (bn2): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv3): Conv2d(64, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn3): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (relu): ReLU(inplace=True)</span><br><span class="line">    )</span><br><span class="line">    (2): Bottleneck(</span><br><span class="line">      (conv1): Conv2d(256, 64, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)</span><br><span class="line">      (bn2): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv3): Conv2d(64, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn3): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (relu): ReLU(inplace=True)</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">  (layer2): Sequential(</span><br><span class="line">    (0): Bottleneck(</span><br><span class="line">      (conv1): Conv2d(256, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv2): Conv2d(128, 128, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False)</span><br><span class="line">      (bn2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv3): Conv2d(128, 512, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn3): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (relu): ReLU(inplace=True)</span><br><span class="line">      (downsample): Sequential(</span><br><span class="line">        (0): Conv2d(256, 512, kernel_size=(1, 1), stride=(2, 2), bias=False)</span><br><span class="line">        (1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">    (1): Bottleneck(</span><br><span class="line">      (conv1): Conv2d(512, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv2): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)</span><br><span class="line">      (bn2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv3): Conv2d(128, 512, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn3): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (relu): ReLU(inplace=True)</span><br><span class="line">    )</span><br><span class="line">    (2): Bottleneck(</span><br><span class="line">      (conv1): Conv2d(512, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv2): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)</span><br><span class="line">      (bn2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv3): Conv2d(128, 512, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn3): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (relu): ReLU(inplace=True)</span><br><span class="line">    )</span><br><span class="line">    (3): Bottleneck(</span><br><span class="line">      (conv1): Conv2d(512, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv2): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)</span><br><span class="line">      (bn2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv3): Conv2d(128, 512, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn3): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (relu): ReLU(inplace=True)</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">  (layer3): Sequential(</span><br><span class="line">    (0): Bottleneck(</span><br><span class="line">      (conv1): Conv2d(512, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False)</span><br><span class="line">      (bn2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv3): Conv2d(256, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn3): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (relu): ReLU(inplace=True)</span><br><span class="line">      (downsample): Sequential(</span><br><span class="line">        (0): Conv2d(512, 1024, kernel_size=(1, 1), stride=(2, 2), bias=False)</span><br><span class="line">        (1): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">    (1): Bottleneck(</span><br><span class="line">      (conv1): Conv2d(1024, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)</span><br><span class="line">      (bn2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv3): Conv2d(256, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn3): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (relu): ReLU(inplace=True)</span><br><span class="line">    )</span><br><span class="line">    (2): Bottleneck(</span><br><span class="line">      (conv1): Conv2d(1024, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)</span><br><span class="line">      (bn2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv3): Conv2d(256, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn3): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (relu): ReLU(inplace=True)</span><br><span class="line">    )</span><br><span class="line">    (3): Bottleneck(</span><br><span class="line">      (conv1): Conv2d(1024, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)</span><br><span class="line">      (bn2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv3): Conv2d(256, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn3): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (relu): ReLU(inplace=True)</span><br><span class="line">    )</span><br><span class="line">    (4): Bottleneck(</span><br><span class="line">      (conv1): Conv2d(1024, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)</span><br><span class="line">      (bn2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv3): Conv2d(256, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn3): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (relu): ReLU(inplace=True)</span><br><span class="line">    )</span><br><span class="line">    (5): Bottleneck(</span><br><span class="line">      (conv1): Conv2d(1024, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)</span><br><span class="line">      (bn2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv3): Conv2d(256, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn3): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (relu): ReLU(inplace=True)</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">  (layer4): Sequential(</span><br><span class="line">    (0): Bottleneck(</span><br><span class="line">      (conv1): Conv2d(1024, 512, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv2): Conv2d(512, 512, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False)</span><br><span class="line">      (bn2): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv3): Conv2d(512, 2048, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn3): BatchNorm2d(2048, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (relu): ReLU(inplace=True)</span><br><span class="line">      (downsample): Sequential(</span><br><span class="line">        (0): Conv2d(1024, 2048, kernel_size=(1, 1), stride=(2, 2), bias=False)</span><br><span class="line">        (1): BatchNorm2d(2048, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">    (1): Bottleneck(</span><br><span class="line">      (conv1): Conv2d(2048, 512, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv2): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)</span><br><span class="line">      (bn2): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv3): Conv2d(512, 2048, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn3): BatchNorm2d(2048, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (relu): ReLU(inplace=True)</span><br><span class="line">    )</span><br><span class="line">    (2): Bottleneck(</span><br><span class="line">      (conv1): Conv2d(2048, 512, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv2): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)</span><br><span class="line">      (bn2): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv3): Conv2d(512, 2048, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn3): BatchNorm2d(2048, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (relu): ReLU(inplace=True)</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">  (avgpool): AvgPool2d(kernel_size=7, stride=1, padding=0)</span><br><span class="line">  (fc): Linear(in_features=2048, out_features=1000, bias=True)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>He K, Zhang X, Ren S, et al. Deep residual learning for image recognition[C]//Proceedings of the IEEE conference on computer vision and pattern recognition. 2016: 770-778.</li><li><a href="https://blog.csdn.net/a940902940902/article/details/83858694">ResNet结构分析</a></li><li><a href="https://www.bilibili.com/video/BV1154y1S7WC">史上最详细ResNet50复现解析（面向小白）</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本篇博客介绍了 ResNet50 网络 PyTorch 复现（复现代码为 PyTorch 源码）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="深度学习" scheme="https://gmet233.gitee.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="ResNet" scheme="https://gmet233.gitee.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/ResNet/"/>
    
    
    <category term="深度学习" scheme="https://gmet233.gitee.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="ResNet" scheme="https://gmet233.gitee.io/tags/ResNet/"/>
    
  </entry>
  
  <entry>
    <title>【笔记】BFS 算法解题套路框架</title>
    <link href="https://gmet233.gitee.io/2022/03/09/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91BFS-%E7%AE%97%E6%B3%95%E8%A7%A3%E9%A2%98%E5%A5%97%E8%B7%AF%E6%A1%86%E6%9E%B6/"/>
    <id>https://gmet233.gitee.io/2022/03/09/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91BFS-%E7%AE%97%E6%B3%95%E8%A7%A3%E9%A2%98%E5%A5%97%E8%B7%AF%E6%A1%86%E6%9E%B6/</id>
    <published>2022-03-09T14:08:06.000Z</published>
    <updated>2022-03-09T14:09:12.964Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文FROM《labuladong 算法秘籍》</p></blockquote><h1 id="什么是-BFS"><a href="#什么是-BFS" class="headerlink" title="什么是 BFS"></a>什么是 BFS</h1><p>BFS(Breadth First Search)，广度优先搜索，起源于<strong>树的层次遍历</strong>。其核心是利用<strong>队列</strong>这种数据结构。</p><p>BFS 的核心思想应该不难理解的，就是把⼀些问题抽象成图，从⼀个点开始，向四周开始扩散。 </p><h1 id="BFS-的应用场景"><a href="#BFS-的应用场景" class="headerlink" title="BFS 的应用场景"></a>BFS 的应用场景</h1><p>BFS 算法常见于求最值的场景，因为 BFS 的算法逻辑保证了算法第⼀次到达目标时的代价是最小的（？）。</p><p>举例⼀下 BFS 出现的常见场景好吧，问题的本质就是让你在⼀幅「图」中找到从起点 start 到终点 target 的最近距离。</p><p>这个广义的描述可以有各种变体，比如走迷宫，有的格子是围墙不能走，从起点到终点的最短距离是多少？如果这个迷宫带「传送门」可以瞬间传送呢？再比如说两个单词，要求你通过某些替换，把其中一个变成另一个，每次只能替换一个字符，最少要替换几次？再比如说连连看游戏，两个方块消除的条件不仅仅是图案相同，还得保证两个方块之间的最短连线不能多于两个拐点。你玩连连看，点击两个坐标，游戏是如何判断它俩的最短连线有几个拐点的？</p><h1 id="BFS-框架代码"><a href="#BFS-框架代码" class="headerlink" title="BFS 框架代码"></a>BFS 框架代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算从起点 start 到终点 target 的最近距离</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">BFS</span><span class="params">(Node start, Node target)</span> &#123;</span><br><span class="line">    Queue&lt;Node&gt; q; <span class="comment">// 核心数据结构</span></span><br><span class="line">    Set&lt;Node&gt; visited; <span class="comment">// 避免走回头路</span></span><br><span class="line">    </span><br><span class="line">    q.offer(start); <span class="comment">// 将起点加入队列</span></span><br><span class="line">    visited.add(start);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 记录扩散的步数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (q not empty) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> q.size();</span><br><span class="line">        <span class="comment">/* 将当前队列中的所有节点向四周扩散 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> q.poll();</span><br><span class="line">            <span class="comment">/* 划重点：这里判断是否到达终点 */</span></span><br><span class="line">            <span class="keyword">if</span> (cur is target)</span><br><span class="line">                <span class="keyword">return</span> step;</span><br><span class="line">            <span class="comment">/* 将 cur 的相邻节点加入队列 */</span></span><br><span class="line">            <span class="keyword">for</span> (Node x : cur.adj()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x not in visited) &#123;</span><br><span class="line">                    q.offer(x);</span><br><span class="line">                    visited.add(x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 划重点：更新步数在这里 */</span></span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>队列 <code>q</code> 就不说了，BFS 的核心数据结构；<code>cur.adj()</code> 泛指 <code>cur</code> 相邻的节点，比如说二维数组中，<code>cur</code> 上下左右四面的位置就是相邻节点；<code>visited</code> 的主要作用是防止走回头路，大部分时候都是必须的，但是像一般的二叉树结构，没有子节点到父节点的指针，不会走回头路就不需要 <code>visited</code>。</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p>LeetCode 111、752</p><h1 id="双向BFS（了解）"><a href="#双向BFS（了解）" class="headerlink" title="双向BFS（了解）"></a>双向BFS（了解）</h1><p>传统的 BFS 框架就是从起点开始向四周扩散，遇到终点时停止；而双向 BFS 则是从起点和终点同时开始扩散，当两边有交集的时候停止。</p><h1 id="BFS-与-DFS"><a href="#BFS-与-DFS" class="headerlink" title="BFS 与 DFS"></a>BFS 与 DFS</h1><blockquote><p>这部分不是很懂，后面再看</p></blockquote><p>BFS 相对 DFS 的最主要的区别是：BFS 找到的路径⼀定是最短的，但代价就是空间复杂度可能比 DFS 大很多。</p><p><strong>1、为什么 BFS 可以找到最短距离，DFS 不行吗</strong>？</p><p>首先，你看 BFS 的逻辑，<code>depth</code> 每增加一次，队列中的所有节点都向前迈一步，这保证了第一次到达终点的时候，走的步数是最少的。</p><p>DFS 不能找最短路径吗？其实也是可以的，但是时间复杂度相对高很多。你想啊，DFS 实际上是靠递归的堆栈记录走过的路径，你要找到最短路径，肯定得把二叉树中所有树杈都探索完才能对比出最短的路径有多长对不对？而 BFS 借助队列做到一次一步「齐头并进」，是可以在不遍历完整棵树的条件下找到最短距离的。</p><p>形象点说，DFS 是线，BFS 是面；DFS 是单打独斗，BFS 是集体行动。这个应该比较容易理解吧。</p><p><strong>2、既然 BFS 那么好，为啥 DFS 还要存在</strong>？</p><p>BFS 可以找到最短距离，但是空间复杂度高，而 DFS 的空间复杂度较低。</p><p>还是拿刚才我们处理二叉树问题的例子，假设给你的这个二叉树是满二叉树，节点数为 <code>N</code>，对于 DFS 算法来说，空间复杂度无非就是递归堆栈，最坏情况下顶多就是树的高度，也就是 <code>O(logN)</code>。</p><p>但是你想想 BFS 算法，队列中每次都会储存着二叉树一层的节点，这样的话最坏情况下空间复杂度应该是树的最底层节点的数量，也就是 <code>N/2</code>，用 Big O 表示的话也就是 <code>O(N)</code>。</p><p>由此观之，BFS 还是有代价的，一般来说在找最短路径的时候使用 BFS，其他时候还是 DFS 使用得多一些（主要是递归代码好写）。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://labuladong.gitee.io/algo/4/30/113/">BFS 算法解题套路框架</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文FROM《labuladong 算法秘籍》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;什么是-BFS&quot;&gt;&lt;a href=&quot;#什么是-BFS&quot; class=&quot;headerlink&quot; title=&quot;什么是 BFS&quot;&gt;&lt;/a&gt;什么是 BFS</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://gmet233.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="BFS" scheme="https://gmet233.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/BFS/"/>
    
    
    <category term="算法" scheme="https://gmet233.gitee.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="BFS" scheme="https://gmet233.gitee.io/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>什么是端到端（end-to-end）的学习模型</title>
    <link href="https://gmet233.gitee.io/2022/03/07/%E4%BB%80%E4%B9%88%E6%98%AF%E7%AB%AF%E5%88%B0%E7%AB%AF%EF%BC%88end-to-end%EF%BC%89%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B/"/>
    <id>https://gmet233.gitee.io/2022/03/07/%E4%BB%80%E4%B9%88%E6%98%AF%E7%AB%AF%E5%88%B0%E7%AB%AF%EF%BC%88end-to-end%EF%BC%89%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B/</id>
    <published>2022-03-07T12:25:03.000Z</published>
    <updated>2022-03-07T12:25:29.762Z</updated>
    
    <content type="html"><![CDATA[<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p><strong>端到端的学习模型</strong>是指将原始数据不做任何的预处理直接将原始数据输入到模型当中，最后得到的输出结果与期望结果有误差，这误差在反向传播模型的各层中，将参数进行优化，一直到期望结果结束。<strong>非端到端</strong>是将原始数据进行标注，得到具有特征的处理后的数据，然后在作为输入，这样的弊端是如果提取数据特征时出现错误，将无法调整。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://www.its203.com/article/qq_42514225/108835224?2022-03-07">什么是端到端的学习模型</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;&gt;&lt;/a&gt;正文&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;端到端的学习模型&lt;/strong&gt;是指将原始数据不做任何的预处理直接将原始数据输入到模型当中，最后得到的输出结果与期望结果有</summary>
      
    
    
    
    <category term="机器学习" scheme="https://gmet233.gitee.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="机器学习" scheme="https://gmet233.gitee.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>最大M对齐子集</title>
    <link href="https://gmet233.gitee.io/2022/03/01/%E6%9C%80%E5%A4%A7M%E5%AF%B9%E9%BD%90%E5%AD%90%E9%9B%86/"/>
    <id>https://gmet233.gitee.io/2022/03/01/%E6%9C%80%E5%A4%A7M%E5%AF%B9%E9%BD%90%E5%AD%90%E9%9B%86/</id>
    <published>2022-03-01T13:52:37.000Z</published>
    <updated>2022-03-01T13:53:34.808Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>有 N 个点位于一条线上，编号从 0 到 N-1 ，其坐标在数组 A 中给出。对于每个I (0 ≤ l &lt;N)，直线上点数 I 的坐标为 A[l] 。点的坐标可能相同。</p><p>对于给定的整数 M ，如果子集内任意两个点之间的距离可被M整除，则称这些点的子集为M<strong>对齐</strong>。您的任务是查找给定 N 个点集的最大 M 对齐子集的大小。</p><p>例如，考虑整数 M=3 和数组 A，如下所示：</p><blockquote><p>A[0] = -3  A[1] = -2  A[2] = 1  A[3] = 0  A[4] = 8  A[5] = 7  A[6] = 1</p></blockquote><p>包含编号为1、2、5和6的点的子集，坐标分别为-2、1、7和1，是3对齐子集的示例，因为：</p><ul><li>编号为1和2的点之间的距离为abs(A[1] - A[2]) = 3，</li><li>从5号点到编号1和2的点的距离分别为9和6，</li><li>从6号点到编号为1、2和5的点的距离分别为3、0和6，</li></ul><p>这些距离都可以被 M=3 整除。此子集的大小为4，并且没有更大的3对齐子集。</p><p>编写一个函数:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">solution</span><span class="params">(<span class="type">int</span>[] A, <span class="type">int</span> M)</span>;</span><br></pre></td></tr></table></figure><p>给定一个由 N 个整数和一个整数 M 组成的数组 A，返回最大 M 对齐子集的大小。</p><p>例如，给定 M=3 且 A=[-3，-2，1，0，8，7，1]，函数应返回4，如上所述；</p><p>给定 M=8 且 A=[7，1，11，8,4，10]，函数应返回1。</p><h1 id="解"><a href="#解" class="headerlink" title="解"></a>解</h1><p>把所有按 M 的余数存成一组就可以，<strong>同组的刚好把余数消掉就是距离整除</strong>。返回最大即为所求。</p><p><strong>注意</strong>：余数为负的，需要转为最小正余数（+M）</p><h2 id="Java实现"><a href="#Java实现" class="headerlink" title="Java实现"></a>Java实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">solution</span><span class="params">(<span class="type">int</span>[] A, <span class="type">int</span> M)</span>&#123;</span><br><span class="line">    <span class="comment">//remainders[i] = j, 表示余数为i的频次是j</span></span><br><span class="line">    <span class="type">int</span>[] remainders = <span class="keyword">new</span> <span class="title class_">int</span>[M];</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 记录最大的频次</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> A.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">remainder</span> <span class="operator">=</span> A[i] % M;</span><br><span class="line">        <span class="keyword">if</span>(remainder &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            remainder += M;</span><br><span class="line">        &#125;</span><br><span class="line">        remainders[remainder] ++;</span><br><span class="line">        ans = Math.max(ans, remainders[remainder]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;有 N 个点位于一条线上，编号从 0 到 N-1 ，其坐标在数组 A 中给出。对于每个I (0 ≤ l &amp;lt;N)，直线上点数 I 的坐标</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://gmet233.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="数论" scheme="https://gmet233.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/"/>
    
    
    <category term="算法" scheme="https://gmet233.gitee.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数论" scheme="https://gmet233.gitee.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>求数字1在所有不超过N的十进制正整数中出现的次数</title>
    <link href="https://gmet233.gitee.io/2022/03/01/%E6%B1%82%E6%95%B0%E5%AD%971%E5%9C%A8%E6%89%80%E6%9C%89%E4%B8%8D%E8%B6%85%E8%BF%87N%E7%9A%84%E5%8D%81%E8%BF%9B%E5%88%B6%E6%AD%A3%E6%95%B4%E6%95%B0%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/"/>
    <id>https://gmet233.gitee.io/2022/03/01/%E6%B1%82%E6%95%B0%E5%AD%971%E5%9C%A8%E6%89%80%E6%9C%89%E4%B8%8D%E8%B6%85%E8%BF%87N%E7%9A%84%E5%8D%81%E8%BF%9B%E5%88%B6%E6%AD%A3%E6%95%B4%E6%95%B0%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</id>
    <published>2022-03-01T13:51:19.000Z</published>
    <updated>2022-03-01T13:52:07.445Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>写一个函数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">solution</span><span class="params">(<span class="type">int</span> N)</span>;</span><br></pre></td></tr></table></figure><p>即给定一个整数N，返回数字1在所有不超过 N 的正整数的十进制表示中出现的次数。</p><p>例如，给定N = 13，该函数应返回6，因为：</p><ul><li>所有不超过13的正整数是1、2、3、4、5、6、7、8、9、10、11、12 和13；</li><li>数字1共出现六次：一次在数字1中，一次在数字10中，两次在数字11中，一次在数字12中，一次在数字13中。</li></ul><p>N 是[0.. 100,000,000]范围内的整数。</p><h1 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h1><p>暴力求解：遍历每一个数，对每一个数求1的个数，然后加起来得和。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">solution</span><span class="params">(<span class="type">int</span> N)</span><span class="comment">//统计1-n中1的个数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=i; j&gt;<span class="number">0</span>; j/=<span class="number">10</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(j%<span class="number">10</span>==<span class="number">1</span>)</span><br><span class="line">ans ++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法时间复杂度：$O(nlgn)$</p><h1 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h1><p>考虑两位数。将一个正整数中1的个数分成两部分，一部分是个位上出现1的数目f1(n)，一部分是十位上出现1的数目f2(n) 。</p><p>n=10， f1(10)=1（1-10个位出现的1的个数为1），f2(10)=1（1-10个位出现的1的十数为1）。</p><p>举一些代表性的数：</p><div class="table-container"><table><thead><tr><th>n</th><th>f1(n)</th><th>f2(n)</th><th>f(n)</th></tr></thead><tbody><tr><td>10</td><td>1</td><td>1</td><td>2</td></tr><tr><td>11</td><td>2</td><td>2</td><td>4</td></tr><tr><td>12</td><td>2</td><td>3</td><td>5</td></tr><tr><td>13</td><td>2</td><td>4</td><td>6</td></tr><tr><td>20</td><td>2</td><td>10</td><td>12</td></tr><tr><td>21</td><td>3</td><td>10</td><td>13</td></tr><tr><td>22</td><td>3</td><td>10</td><td>13</td></tr><tr><td>23</td><td>3</td><td>10</td><td>13</td></tr><tr><td>30</td><td>3</td><td>10</td><td>13</td></tr><tr><td>31</td><td>4</td><td>10</td><td>14</td></tr><tr><td>32</td><td>4</td><td>10</td><td>14</td></tr><tr><td>33</td><td>4</td><td>10</td><td>14</td></tr></tbody></table></div><p>先来看十位，当十位上的数为1时，</p><div class="table-container"><table><thead><tr><th>n</th><th>f2(n)</th></tr></thead><tbody><tr><td>10</td><td>1</td></tr><tr><td>11</td><td>2</td></tr><tr><td>12</td><td>3</td></tr><tr><td>13</td><td>4</td></tr></tbody></table></div><p>f2(n)=当前数个位数字+1；</p><p>当十位上的数大于1时，</p><div class="table-container"><table><thead><tr><th>n</th><th>f2(n)</th></tr></thead><tbody><tr><td>20</td><td>10</td></tr><tr><td>21</td><td>10</td></tr><tr><td>22</td><td>10</td></tr><tr><td>23</td><td>10</td></tr><tr><td>30</td><td>10</td></tr><tr><td>31</td><td>10</td></tr><tr><td>32</td><td>10</td></tr><tr><td>33</td><td>10</td></tr></tbody></table></div><p>f2(n) = 10，也就是说此时十位上1的数目仅仅和十位有关系，也就是<strong>十位的位因子</strong>10。</p><p>再来看个位，当个位上的数为1的时候</p><div class="table-container"><table><thead><tr><th>n</th><th>f1(n)</th></tr></thead><tbody><tr><td>11</td><td>2</td></tr><tr><td>21</td><td>3</td></tr><tr><td>31</td><td>4</td></tr></tbody></table></div><p>f1(n) = 当前数十位数字+1；</p><p>当个位上的数大于1时，</p><div class="table-container"><table><thead><tr><th>n</th><th>f1(n)</th></tr></thead><tbody><tr><td>22</td><td>3</td></tr><tr><td>23</td><td>3</td></tr><tr><td>32</td><td>4</td></tr><tr><td>33</td><td>4</td></tr></tbody></table></div><p>f1(n) = 当前数十位数字+1；</p><p>还有当个位上的数等于0时，</p><div class="table-container"><table><thead><tr><th>n</th><th>f1(n)</th></tr></thead><tbody><tr><td>10</td><td>1</td></tr><tr><td>20</td><td>2</td></tr><tr><td>30</td><td>3</td></tr></tbody></table></div><p>f1(n) = 当前数十位数字。</p><p>这还不够，我们还没有分析两位数以上的数字，根据上面的分析，我们将当前位分为三种情况：=0，=1，&gt;1。</p><p>当百位上的数字是0的时候，假设n=12013。此时1-12013的所有整数中，百位上出现1的数是100~199，1100~1199，2100~2199……11100~11199。也就是12个100，1200个。也就是说此时百位上1的数目是由高位（12）决定的，而且等于高位（12）* 当前位因子（100）。</p><p>当百位上的数字是1的时候，假设n=12113。此时1-12113的所有整数中，百位上出现1的数是100~199，1100~1199，2100~2199……11100~11199，12100~12113。也就是13个100，1300个。也就是说此时百位上1的数目是由高位（12）决定的，而且等于（高位（12）+1）* 当前位因子（100）。</p><p>还有一个小问题就是如何求一个数的高位和低位，还有当前位。这和当前位的位因子有关系。</p><p>对于12345，假设当前位是百位（100），则</p><ul><li>低位数字：12345 - (12345 / 100) *100 = 45</li><li>高位数字：12345 / (100 * 10) = 12</li><li>当前位数字：12345 / 100 = 123，123 % 10 = 3。</li></ul><p>以上分析可以写出完整代码。</p><h2 id="Java实现"><a href="#Java实现" class="headerlink" title="Java实现"></a>Java实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">solution</span><span class="params">(<span class="type">int</span> N)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">lowNum</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 当前位的低位的数字</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">currNum</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 当前位数字</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">highNum</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 当前位的高位的数字</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">factor</span> <span class="operator">=</span> <span class="number">1</span>; factor &lt;= N; factor *= <span class="number">10</span>) &#123; <span class="comment">// 位因子</span></span><br><span class="line">        lowNum = N - (N / factor) * factor;</span><br><span class="line">        currNum = (N / factor) % <span class="number">10</span>;</span><br><span class="line">        highNum = N / (factor * <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span>(currNum == <span class="number">0</span>) &#123;</span><br><span class="line">            ans += highNum * factor;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(currNum == <span class="number">1</span>) &#123;</span><br><span class="line">            ans += highNum * factor + lowNum +<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans += (highNum + <span class="number">1</span>) * factor;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度只与N的位数有关，为$O(lgn)$。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://blog.csdn.net/liangbopirates/article/details/9323727">求1-N中十进制正整数1的个数</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;写一个函数&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://gmet233.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://gmet233.gitee.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【不会做】矩阵路径形成的最大整数</title>
    <link href="https://gmet233.gitee.io/2022/03/01/%E3%80%90%E4%B8%8D%E4%BC%9A%E5%81%9A%E3%80%91%E7%9F%A9%E9%98%B5%E8%B7%AF%E5%BE%84%E5%BD%A2%E6%88%90%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B4%E6%95%B0/"/>
    <id>https://gmet233.gitee.io/2022/03/01/%E3%80%90%E4%B8%8D%E4%BC%9A%E5%81%9A%E3%80%91%E7%9F%A9%E9%98%B5%E8%B7%AF%E5%BE%84%E5%BD%A2%E6%88%90%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B4%E6%95%B0/</id>
    <published>2022-03-01T13:47:55.000Z</published>
    <updated>2022-03-01T13:50:26.391Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>您将获得一个由 N 行和 M 列组成的板。电路板的每个字段（其实就是数组中的一个坐标点，作者注）都包含一个数字 (0-9)。</p><p>您希望查找由四个相邻字段组成的路径。如果两个字段共享一个共同点，则它们是相邻的。此外，路径中的字段应该是不同的（不能两次访问同一字段）。</p><p>路径的四位数字（按您访问它们的顺序）创建一个 整数。通过这种方式可以实现的最大整数是多少?</p><p>编写函数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">solution</span> <span class="params">(<span class="type">int</span>[][] board)</span> ;</span><br></pre></td></tr></table></figure><p>给定表示为由 N 行和 M 列组成的整数矩阵的板，则返回在长度为 4 的路径中连接值时可以实现的最大整数。<br>例子：给定以下板（N=3, M=5） :</p><p><img src="image-20220228105252210.png" alt="图1"></p><p>该函数应返回9121。您可以选择以下路径（第一 个字段用红色表示)：</p><p><img src="image-20220228105416502.png" alt="图2"></p><h1 id="解"><a href="#解" class="headerlink" title="解"></a>解</h1><p>知道用回溯或者BFS，但是代码写不出来。😓</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;您将获得一个由 N 行和 M 列组成的板。电路板的每个字段（其实就是数组中的一个坐标点，作者注）都包含一个数字 (0-9)。&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://gmet233.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="回溯" scheme="https://gmet233.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF/"/>
    
    
    <category term="算法" scheme="https://gmet233.gitee.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="回溯" scheme="https://gmet233.gitee.io/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>个人比较喜欢的健身动作</title>
    <link href="https://gmet233.gitee.io/2022/02/28/%E4%B8%AA%E4%BA%BA%E6%AF%94%E8%BE%83%E5%96%9C%E6%AC%A2%E7%9A%84%E5%81%A5%E8%BA%AB%E5%8A%A8%E4%BD%9C/"/>
    <id>https://gmet233.gitee.io/2022/02/28/%E4%B8%AA%E4%BA%BA%E6%AF%94%E8%BE%83%E5%96%9C%E6%AC%A2%E7%9A%84%E5%81%A5%E8%BA%AB%E5%8A%A8%E4%BD%9C/</id>
    <published>2022-02-28T15:31:17.000Z</published>
    <updated>2022-03-03T12:52:44.478Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文整理一下个人比较喜欢健身动作。并备注动作要点</p></blockquote><h1 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h1><h2 id="平板支撑"><a href="#平板支撑" class="headerlink" title="平板支撑"></a>平板支撑</h2><p>改善的平板支撑：</p><ol><li>身体后移</li><li>骨盆后倾：收紧臀部，感觉上向后顶</li><li>纠正身体位置。肩膀用力向前推，上肢离地更远。</li></ol><p>新手先做到第二点延长到60秒，再两点一起做。</p><p>禁忌：</p><ol><li>手臂后缩</li><li>提臀或者臀太低。相反要用力收紧骨盆</li></ol><h1 id="臀腿"><a href="#臀腿" class="headerlink" title="臀腿"></a>臀腿</h1><h2 id="深蹲"><a href="#深蹲" class="headerlink" title="深蹲"></a>深蹲</h2><p>使用弹力带加大深蹲的阻力。</p><h2 id="单腿罗马尼亚硬拉"><a href="#单腿罗马尼亚硬拉" class="headerlink" title="单腿罗马尼亚硬拉"></a>单腿罗马尼亚硬拉</h2><p>锻炼臀肌、腘绳肌，锻炼单腿站立的稳定性，膝关节得稳定性。</p><p>视频：<a href="https://www.bilibili.com/video/BV1Ci4y1R72o?spm_id_from=333.999.0.0">https://www.bilibili.com/video/BV1Ci4y1R72o?spm_id_from=333.999.0.0</a></p><h1 id="背部"><a href="#背部" class="headerlink" title="背部"></a>背部</h1><h2 id="引体向上"><a href="#引体向上" class="headerlink" title="引体向上"></a>引体向上</h2><p>如果做不来可以使用弹力绳辅助。</p><h1 id="前锯肌"><a href="#前锯肌" class="headerlink" title="前锯肌"></a>前锯肌</h1><p>待整理：<a href="https://www.bilibili.com/video/BV1qq4y1k7oP?spm_id_from=333.999.0.0">https://www.bilibili.com/video/BV1qq4y1k7oP?spm_id_from=333.999.0.0</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://www.bilibili.com/video/BV1SP4y1j71R?spm_id_from=333.999.0.0">核心太弱，肚子肯定大（3个技巧快速改善）</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文整理一下个人比较喜欢健身动作。并备注动作要点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;核心&quot;&gt;&lt;a href=&quot;#核心&quot; class=&quot;headerlink&quot; title=&quot;核心&quot;&gt;&lt;/a&gt;核心&lt;/h1&gt;&lt;h2 id=&quot;平板支撑&quot;&gt;</summary>
      
    
    
    
    <category term="方法论" scheme="https://gmet233.gitee.io/categories/%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
    <category term="健身" scheme="https://gmet233.gitee.io/categories/%E6%96%B9%E6%B3%95%E8%AE%BA/%E5%81%A5%E8%BA%AB/"/>
    
    
    <category term="健身" scheme="https://gmet233.gitee.io/tags/%E5%81%A5%E8%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>Keep上不错的课程合集</title>
    <link href="https://gmet233.gitee.io/2022/02/28/Keep%E4%B8%8A%E4%B8%8D%E9%94%99%E7%9A%84%E8%AF%BE%E7%A8%8B%E5%90%88%E9%9B%86/"/>
    <id>https://gmet233.gitee.io/2022/02/28/Keep%E4%B8%8A%E4%B8%8D%E9%94%99%E7%9A%84%E8%AF%BE%E7%A8%8B%E5%90%88%E9%9B%86/</id>
    <published>2022-02-28T15:24:57.000Z</published>
    <updated>2022-03-27T06:16:18.005Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文整理了一些适合自己的Keep课程，这些课程都亲自做过一遍。</p><p>本文会不断更新。</p></blockquote><div class="table-container"><table><thead><tr><th>课程名称</th><th>课程链接</th><th>难度</th><th>部位</th><th>器械</th><th>感受</th></tr></thead><tbody><tr><td>HIIT - 腹肌塑造</td><td><a href="https://show.gotokeep.com/course/607fefaa1310a35004149bc4">https://show.gotokeep.com/course/607fefaa1310a35004149bc4</a></td><td>3</td><td>腹部</td><td>不需要</td><td>挺累的，但是不难。做完腹部有明显酸痛</td></tr><tr><td>哑铃全方位胸部刺激-罗洪Ric</td><td><a href="https://show.gotokeep.com/course/6051a1b41310a33405483f53">https://show.gotokeep.com/course/6051a1b41310a33405483f53</a></td><td>4</td><td>胸部</td><td>哑铃</td><td>很有感觉。</td></tr><tr><td>哑铃手臂轰炸</td><td><a href="https://show.gotokeep.com/course/59ddde95a29e342161e42290">https://show.gotokeep.com/course/59ddde95a29e342161e42290</a></td><td>3</td><td>手臂</td><td>哑铃</td><td>练了好几次，快没感觉了，可能需要加大重量</td></tr><tr><td>跃动燃脂强化</td><td><a href="https://show.gotokeep.com/course/5b1e349aa29e343df182c7c0">https://show.gotokeep.com/course/5b1e349aa29e343df182c7c0</a></td><td>4</td><td>全身</td><td>不需要</td><td>挺累的。。</td></tr><tr><td>家庭哑铃增肌特训 · 强力臀腿</td><td><a href="https://show.gotokeep.com/course/601696ae627efb1bdd12ae13">https://show.gotokeep.com/course/601696ae627efb1bdd12ae13</a></td><td>3</td><td>臀腿</td><td>哑铃</td><td>忘记了。</td></tr><tr><td>核心功能强化</td><td><a href="https://show.gotokeep.com/course/5b90af2da29e342ee240c94f">https://show.gotokeep.com/course/5b90af2da29e342ee240c94f</a></td><td>4</td><td>腰腹</td><td>不需要</td><td>和“HIIT - 腹肌塑造”有点重复</td></tr></tbody></table></div>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文整理了一些适合自己的Keep课程，这些课程都亲自做过一遍。&lt;/p&gt;
&lt;p&gt;本文会不断更新。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;课程名</summary>
      
    
    
    
    <category term="方法论" scheme="https://gmet233.gitee.io/categories/%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
    <category term="健身" scheme="https://gmet233.gitee.io/categories/%E6%96%B9%E6%B3%95%E8%AE%BA/%E5%81%A5%E8%BA%AB/"/>
    
    
    <category term="健身" scheme="https://gmet233.gitee.io/tags/%E5%81%A5%E8%BA%AB/"/>
    
  </entry>
  
</feed>
