<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Gmet&#39;s Blog</title>
  
  <subtitle>Eureka!</subtitle>
  <link href="https://guoyujian.github.io/atom.xml" rel="self"/>
  
  <link href="https://guoyujian.github.io/"/>
  <updated>2024-01-20T07:14:38.602Z</updated>
  <id>https://guoyujian.github.io/</id>
  
  <author>
    <name>Met Guo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Kruskal算法与力扣1135</title>
    <link href="https://guoyujian.github.io/2024/01/20/Kruskal%E7%AE%97%E6%B3%95%E4%B8%8E%E5%8A%9B%E6%89%A31135/"/>
    <id>https://guoyujian.github.io/2024/01/20/Kruskal%E7%AE%97%E6%B3%95%E4%B8%8E%E5%8A%9B%E6%89%A31135/</id>
    <published>2024-01-20T07:01:01.000Z</published>
    <updated>2024-01-20T07:14:38.602Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍图的最小生成树算法Kruskal 算法。</p><p>阅读之前需要先了解</p><ul><li>图和树数据结构</li><li>加权图、生成树、最小生成树</li><li>Kruskal 算法基本思想</li></ul><p>在Kruskal 算法中，需要保证每次新加入的边不会让树变成图，即不能让树包含环。那么 Union-Find 算法就是帮你干这个事儿的。</p><p>像下面这样添加边会出现环：</p><p><img src="1.png" alt="图片"></p><p>而这样添加边则不会出现环：</p><p><img src="2.png" alt="图片"></p><p>总结一下规律就是：</p><p><strong>对于添加的这条边，如果该边的两个节点本来就在同一连通分量里，那么添加这条边会产生环；反之，如果该边的两个节点不在同一连通分量里，则添加这条边不会产生环</strong>。</p><p>而判断两个节点是否连通（是否在同一个连通分量中）就是 Union-Find 算法的拿手绝活。</p><p>力扣第 1135 题「最低成本联通所有城市」，这是一道标准的最小生成树问题：</p><p><img src="640.png" alt="图片"></p><p>每座城市相当于图中的节点，连通城市的成本相当于边的权重，连通所有城市的最小成本即是最小生成树的权重之和。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"><span class="keyword">from</span> union_find <span class="keyword">import</span> UF  <span class="comment"># 自实现的union-find算法，详略</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minimumCost</span>(<span class="params">self, n: <span class="built_in">int</span>, connections:<span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 城市编号从1开始，所以初始化大小为1+n</span></span><br><span class="line">        uf = UF(n+<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 按权重排序</span></span><br><span class="line">        connections.sort(<span class="keyword">lambda</span> x : x[<span class="number">2</span>])</span><br><span class="line">        mst = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> u, v, weight <span class="keyword">in</span> connections:</span><br><span class="line">            <span class="comment">#如果产生环，则不能加入mst</span></span><br><span class="line">            <span class="keyword">if</span> uf.connected(u, v):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 如果没有产生环，则属于最小生成树</span></span><br><span class="line">            mst += weight</span><br><span class="line">            uf.union(u, v)</span><br><span class="line">        <span class="comment"># 保证所有节点都被连通</span></span><br><span class="line">        <span class="comment"># 按理uf.count() == 1说明所有节点被连通</span></span><br><span class="line">        <span class="comment"># 但因为节点0没有被使用，所以0会额外占用一个连通分量</span></span><br><span class="line">        <span class="keyword">return</span> mst <span class="keyword">if</span> uf.count() == <span class="number">2</span> <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h1><ol><li><a href="https://mp.weixin.qq.com/s/dJ9gqR3RVoeGnATlpMG39w">东哥带你刷图论第五期：Kruskal 最小生成树算法</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文介绍图的最小生成树算法Kruskal 算法。&lt;/p&gt;
&lt;p&gt;阅读之前需要先了解&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;图和树数据结构&lt;/li&gt;
&lt;li&gt;加权图、生成树、最小生成树&lt;/li&gt;
&lt;li&gt;Kruskal 算法基本思想&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在Kruskal 算法中，</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://guoyujian.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="图" scheme="https://guoyujian.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE/"/>
    
    
    <category term="Kruskal 算法" scheme="https://guoyujian.github.io/tags/Kruskal-%E7%AE%97%E6%B3%95/"/>
    
    <category term="力扣1135" scheme="https://guoyujian.github.io/tags/%E5%8A%9B%E6%89%A31135/"/>
    
    <category term="图" scheme="https://guoyujian.github.io/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>Union-Find并查集算法（Python实现）</title>
    <link href="https://guoyujian.github.io/2023/12/24/Union-Find%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%AE%97%E6%B3%95%EF%BC%88Python%E5%AE%9E%E7%8E%B0%EF%BC%89/"/>
    <id>https://guoyujian.github.io/2023/12/24/Union-Find%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%AE%97%E6%B3%95%EF%BC%88Python%E5%AE%9E%E7%8E%B0%EF%BC%89/</id>
    <published>2023-12-24T01:37:00.000Z</published>
    <updated>2023-12-24T01:39:52.705Z</updated>
    
    <content type="html"><![CDATA[<p>这是并查集算法的Python实现：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UF</span>:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    并查集算法</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        初始化数据结构</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 初始化连通分量数量</span></span><br><span class="line">        self._count = n</span><br><span class="line">        <span class="comment"># 初始化双亲节点</span></span><br><span class="line">        self._parent = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="comment"># self.size[x]表示以x为根节点的节点数量</span></span><br><span class="line">        self._size = [<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self, x : <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        find root of x</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">while</span> self._parent[x] != x:</span><br><span class="line">            <span class="comment"># 路经压缩，将当前节点的双亲节点设为其双亲节点的双亲节点</span></span><br><span class="line">            self._parent[x] = self._parent[self._parent[x]]</span><br><span class="line">            x = self._parent[x]</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">union</span>(<span class="params">self, p: <span class="built_in">int</span>, q: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        union p and q</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 找到p和q的根节点</span></span><br><span class="line">        rootP = self.find(p)</span><br><span class="line">        rootQ = self.find(q)</span><br><span class="line">        <span class="keyword">if</span> rootP == rootQ:</span><br><span class="line">            <span class="comment"># 如果根节点相等，则pq本就联通</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 将小集合合并到大集合中，平衡性优化</span></span><br><span class="line">        <span class="keyword">if</span> self._size[rootP] &gt; self._size[rootQ]:</span><br><span class="line"></span><br><span class="line">            self._parent[rootQ] = rootP</span><br><span class="line">            self._size[rootP] += self._size[rootQ]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self._parent[rootP] = rootQ</span><br><span class="line">            self._size[rootQ] += self._size[rootP]</span><br><span class="line">        self._count -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">count</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        返回联通数</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> self._count</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">connected</span>(<span class="params">self, p, q</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        判断pq是否联通</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> self.find(q) == self.find(p)</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>参考：<a href="https://zhuanlan.zhihu.com/p/98406740">https://zhuanlan.zhihu.com/p/98406740</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这是并查集算法的Python实现：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://guoyujian.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="并查集算法" scheme="https://guoyujian.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Python" scheme="https://guoyujian.github.io/tags/Python/"/>
    
    <category term="算法" scheme="https://guoyujian.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="并查集" scheme="https://guoyujian.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
    <category term="UnionFind" scheme="https://guoyujian.github.io/tags/UnionFind/"/>
    
  </entry>
  
  <entry>
    <title>subprocess执行java命令残留进程解决</title>
    <link href="https://guoyujian.github.io/2023/12/07/subprocess%E6%89%A7%E8%A1%8Cjava%E5%91%BD%E4%BB%A4%E6%AE%8B%E7%95%99%E8%BF%9B%E7%A8%8B%E8%A7%A3%E5%86%B3/"/>
    <id>https://guoyujian.github.io/2023/12/07/subprocess%E6%89%A7%E8%A1%8Cjava%E5%91%BD%E4%BB%A4%E6%AE%8B%E7%95%99%E8%BF%9B%E7%A8%8B%E8%A7%A3%E5%86%B3/</id>
    <published>2023-12-07T08:42:12.000Z</published>
    <updated>2023-12-07T08:51:07.103Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题简述"><a href="#问题简述" class="headerlink" title="问题简述"></a>问题简述</h1><blockquote><p>需求是通过Python执行命令java -java springboot-demo.jar</p><p>于是，我使用subprocess.Popen()来启停。但是我发现在关闭子进程后，java进程并没有正确关闭。</p><p>这是由于上面的方法实际原理是另外开启一个cmd命令来运行java -jar命令，后面用popen.terminate()也只能关闭cmd的命令，cmd命令被kill掉后，java进程由系统来托管，从而导致java进程并没有正确关闭。</p></blockquote><h1 id="Bug复现"><a href="#Bug复现" class="headerlink" title="Bug复现"></a>Bug复现</h1><p>执行代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"><span class="comment"># 执行java -jar</span></span><br><span class="line">t = subprocess.Popen([<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;springboot-demo.jar&quot;</span>])</span><br><span class="line"><span class="comment"># Popen是异步的，所以需要等待几秒，再关闭</span></span><br><span class="line">time.sleep(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 关闭子进程</span></span><br><span class="line">t.terminate()</span><br><span class="line"><span class="comment"># 等待关闭结束</span></span><br><span class="line">t.wait()</span><br></pre></td></tr></table></figure><p>发现残留的java进程</p><p><img src="image.png" alt="image"></p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我的解决思路是，稍微修改java代码，在执行java -jar命令后，将java进程id（pid）暴露出来。</p><p>当需要关闭程序时，读取暴露出来的java进程id，使用kill命令，将进程杀死。</p><h2 id="详述"><a href="#详述" class="headerlink" title="详述"></a>详述</h2><p>首先修改java代码，我使用的代码框架是springboot，所以在springboot的启动类上修改如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringbootDemoApplication</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">SpringApplication</span> <span class="variable">application</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpringApplication</span>(SpringbootDemoApplication.class);</span><br><span class="line"><span class="comment">// 获取jar包执行的路径</span></span><br><span class="line"><span class="type">ApplicationHome</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ApplicationHome</span>(SpringbootDemoApplication.class);</span><br><span class="line"><span class="type">File</span> <span class="variable">source</span> <span class="operator">=</span> h.getSource();</span><br><span class="line">System.out.println(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt;&lt; jar 执行目录：&quot;</span> + source.getParentFile().toString() + <span class="string">&quot; &gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">app_pid_file</span> <span class="operator">=</span> source.getParentFile().toString() + <span class="string">&quot;\\app.pid&quot;</span>;</span><br><span class="line">application.addListeners(<span class="keyword">new</span> <span class="title class_">ApplicationPidFileWriter</span>(app_pid_file)); <span class="comment">// 把进程号放到这个文件中</span></span><br><span class="line">application.run();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，</p><ul><li>source.getParentFile().toString()可以获得jar包所在的目录。</li><li>application.addListeners(new ApplicationPidFileWriter(app_pid_file));将在jar包同级目录下生成app.pid的文件，该文件中写入了springboot运行的进程号</li></ul><p>然后修改Python代码</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">JAR_DIR = <span class="string">&#x27;XXX&#x27;</span> <span class="comment"># jar包所在目录</span></span><br><span class="line"><span class="comment"># 执行java -jar</span></span><br><span class="line">t = subprocess.Popen([<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, os.path.join(<span class="string">f&quot;<span class="subst">&#123;JAR_DIR&#125;</span>&quot;</span>, <span class="string">&quot;springboot-demo.jar&quot;</span>])</span><br><span class="line"><span class="comment"># Popen是异步的，所以需要等待几秒，再关闭</span></span><br><span class="line">time.sleep(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 关闭子进程</span></span><br><span class="line">t.terminate()</span><br><span class="line"><span class="comment"># 等待关闭结束</span></span><br><span class="line">t.wait()</span><br><span class="line"><span class="comment"># 关闭java进程</span></span><br><span class="line">app_pid_file_path = os.path.join(JAR_DIR, <span class="string">&quot;app.pid&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> os.path.exists(app_pid_file_path):</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(app_pid_file_path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">pid = f.read()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;正在关闭java 进程, pid： <span class="subst">&#123;<span class="built_in">int</span>(pid)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># 在windows系统下执行杀死进程的命令，其他系统可能命令不同</span></span><br><span class="line">subprocess.run([<span class="string">&quot;cmd&quot;</span>, <span class="string">&quot;/c&quot;</span>, <span class="string">&quot;taskkill&quot;</span>, <span class="string">&quot;/pid&quot;</span>, <span class="string">f&#x27;<span class="subst">&#123;<span class="built_in">int</span>(pid)&#125;</span>&#x27;</span>, <span class="string">&quot;-f&quot;</span>])</span><br><span class="line">os.remove(app_pid_file_path) <span class="comment"># 删除app.pid文件</span></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>无</p><h1 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h1><ol><li><a href="https://blog.csdn.net/skyli114/article/details/127324383">subprocess.Popen执行程序以及关闭进程</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;问题简述&quot;&gt;&lt;a href=&quot;#问题简述&quot; class=&quot;headerlink&quot; title=&quot;问题简述&quot;&gt;&lt;/a&gt;问题简述&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;需求是通过Python执行命令java -java springboot-demo.jar&lt;/p&gt;</summary>
      
    
    
    
    <category term="Python" scheme="https://guoyujian.github.io/categories/Python/"/>
    
    
    <category term="Python" scheme="https://guoyujian.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>CC+Open3d解决大型点云数据加载和计算问题</title>
    <link href="https://guoyujian.github.io/2023/11/29/CC-Open3d%E8%A7%A3%E5%86%B3%E5%A4%A7%E5%9E%8B%E7%82%B9%E4%BA%91%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD%E5%92%8C%E8%AE%A1%E7%AE%97%E9%97%AE%E9%A2%98/"/>
    <id>https://guoyujian.github.io/2023/11/29/CC-Open3d%E8%A7%A3%E5%86%B3%E5%A4%A7%E5%9E%8B%E7%82%B9%E4%BA%91%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD%E5%92%8C%E8%AE%A1%E7%AE%97%E9%97%AE%E9%A2%98/</id>
    <published>2023-11-29T10:28:41.000Z</published>
    <updated>2023-11-29T10:32:24.268Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>雷达扫描的点云数据量往往很大，而其中存在大量不需要的点。</p><p>例如我只需要某个小模型的点云，但雷达将周围的环境也一并扫描进来了，这些环境点云我并不需要。</p><p>现在我需要测量这个小模型的某些属性。（比如长宽）</p><p>此时如果直接在全部点云数据下进行测量，将这些点云加载出来都是一个很大的问题。在我的机器上，使用Cloud Compare载入1.3亿数量级的点云数据直接卡死。</p><p>通常情况下，可以通过体素降采样的方式（例如体素值为2dm）极大缩小点云的数量，但我的需求是希望计算小模型的长宽，其误差不超过5cm。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>因此我的做法如图所示：</p><p><img src="未命名绘图.drawio-20231129175149-u5ss8y9.png" alt="未命名绘图.drawio">​​</p><ol><li>首先为了能够将点云展示出来，我要极大的下采样点云，这里我取参数为0.2（2dm），得到下采样后的点云1</li><li>使用CC加载点云1，并可视化裁剪点云，得到裁剪立方体的参数，包括立方体的中心，长宽高，旋转等</li><li>使用上一步的得到的参数去裁剪原始点云，极大的减少了点云数量</li><li>将裁减后的点云下采样，为了保证精度，这次下采样率为0.01（1cm），得到点云2</li><li>可视化点云2，并进行测量，得到结果。</li></ol><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><h2 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h2><p>编写python脚本并导入到CC，执行该脚本，将点云1加载到CC中</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pycc</span><br><span class="line"><span class="keyword">import</span> cccorelib</span><br><span class="line"></span><br><span class="line">cc = pycc.GetInstance()</span><br><span class="line"><span class="keyword">import</span> open3d <span class="keyword">as</span> o3d</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># open PointCloud with 139032791 points.</span></span><br><span class="line">pcd: o3d.geometry.PointCloud = o3d.io.read_point_cloud(<span class="string">r&quot;origin.pcd&quot;</span>)</span><br><span class="line"><span class="comment"># 调整合适的降采样率</span></span><br><span class="line">pcd = pcd.voxel_down_sample(<span class="number">0.2</span>) <span class="comment">#</span></span><br><span class="line">points = np.asarray(pcd.points)</span><br><span class="line"></span><br><span class="line">xs = points[:, <span class="number">0</span>]</span><br><span class="line">ys = points[:, <span class="number">1</span>]</span><br><span class="line">zs = points[:, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">pc = pycc.ccPointCloud(xs, ys, zs)</span><br><span class="line"><span class="comment"># load</span></span><br><span class="line">cc.addToDB(pc)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h2><p>在CC中对点云进行切片，得到想要的部分点云的裁剪立方体参数。</p><p><img src="image-20231129175946-c305vb2.png" alt="裁剪前"></p><p><img src="image-20231129180213-3vc0ov2.png" alt="裁剪后">​</p><p>如图分别是裁剪前后的效果图，裁剪后的红框里是裁剪立方体的参数。复制下来后面要用到。</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">transformation matrix:</span><br><span class="line">0.987671196461 -0.156546846032 0.000000000000 3.480050563812</span><br><span class="line">0.156546846032 0.987671196461 0.000000000000 -3.573182106018</span><br><span class="line">0.000000000000 0.000000000000 1.000001311302 2.071678161621</span><br><span class="line">0.000000000000 0.000000000000 0.000000000000 1.000000000000</span><br><span class="line"></span><br><span class="line">长宽高：</span><br><span class="line">X: 6.21198273</span><br><span class="line">Y: 13.27857590</span><br><span class="line">Z: 9.57320881</span><br></pre></td></tr></table></figure><h2 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h2><p>由上述的参数可以知道该立方体的中心点是<code>(3.480050563812, -3.573182106018, 2.071678161621)</code>​，旋转矩阵为</p><script type="math/tex; mode=display">\begin{bmatrix}0.987671196461&-0.156546846032&0.000000000000\\0.156546846032&0.987671196461&0.000000000000\\0.000000000000&0.000000000000&1.000001311302\\\end{bmatrix}</script><p>长宽高为<code>(6.21198273, 13.27857590, 9.57320881)</code>​</p><p>因此可以写代码使用open3d来裁剪原始点云：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pcd: o3d.geometry.PointCloud = o3d.io.read_point_cloud(<span class="string">r&quot;origin.pcd&quot;</span>)</span><br><span class="line">   <span class="comment"># 画一个&quot;盒子&quot;，将盒子外的点云去掉，</span></span><br><span class="line">   obx = o3d.geometry.OrientedBoundingBox(</span><br><span class="line">       np.array([<span class="number">3.480050563812</span>, -<span class="number">3.573182106018</span>, <span class="number">2.071678161621</span>]), <span class="comment"># center</span></span><br><span class="line">       np.array([</span><br><span class="line">           [<span class="number">0.987671196461</span>, -<span class="number">0.156546846032</span>, <span class="number">0.000000000000</span>],</span><br><span class="line">           [<span class="number">0.156546846032</span>, <span class="number">0.987671196461</span>, <span class="number">0.000000000000</span>],</span><br><span class="line">           [<span class="number">0.000000000000</span>, <span class="number">0.000000000000</span>, <span class="number">1.000001311302</span>]</span><br><span class="line">       ]), <span class="comment"># rotation</span></span><br><span class="line">       np.array([<span class="number">6.21198273</span>, <span class="number">13.27857590</span>, <span class="number">9.57320881</span>]) <span class="comment"># width, depth, height</span></span><br><span class="line">   )</span><br><span class="line">   pcd_cropped = pcd.crop(obx) <span class="comment"># 裁剪后的点云</span></span><br><span class="line">pcd_cropped = pcd_cropped.voxel_down_sample(<span class="number">0.01</span>) <span class="comment"># 第二次降采样</span></span><br><span class="line">   o3d.io.write_point_cloud(<span class="string">&#x27;cropped.pcd&#x27;</span>, pcd_cropped) <span class="comment"># save </span></span><br></pre></td></tr></table></figure><h2 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h2><p>经过这些步骤后，点云数据量从1.3亿降到了840万。将这个<code>cropped.pcd</code>​拿到CC中打开，并测量。（图略）</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文方法既解决了大规模点云数据加载卡死、操作困难的问题，又能精确得到计算结果。</p><p>不过流程可以再优化，更自动化一些。</p><h1 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h1><p>无</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;雷达扫描的点云数据量往往很大，而其中存在大量不需要的点。&lt;/p&gt;
&lt;p&gt;例如我只需要某个小模型的点云，但雷达将周围的环境也一并扫描进来了，这</summary>
      
    
    
    
    <category term="点云数据处理" scheme="https://guoyujian.github.io/categories/%E7%82%B9%E4%BA%91%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    
    
    <category term="CloudCompare" scheme="https://guoyujian.github.io/tags/CloudCompare/"/>
    
    <category term="Point Cloud" scheme="https://guoyujian.github.io/tags/Point-Cloud/"/>
    
  </entry>
  
  <entry>
    <title>CloudCompare常用操作及Python插件</title>
    <link href="https://guoyujian.github.io/2023/11/28/CloudCompare%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%8F%8APython%E6%8F%92%E4%BB%B6/"/>
    <id>https://guoyujian.github.io/2023/11/28/CloudCompare%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%8F%8APython%E6%8F%92%E4%BB%B6/</id>
    <published>2023-11-28T06:14:52.000Z</published>
    <updated>2023-11-28T06:30:06.169Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>最近在做点云处理相关的工作，这里找到了一个非常好用的开源软件CloudCompare（下称CC）。这里对我的常用操作进行总结，并介绍CC的Python插件，该插件可以实现自定义的点云操作实现，极大地扩展了CC的功能。</p></blockquote><h1 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h1><h2 id="点云按高程赋色"><a href="#点云按高程赋色" class="headerlink" title="点云按高程赋色"></a>点云按高程赋色</h2><p>打开的点云没有颜色，很难看且很难操作，为了让点云更有立体感，可以按高程对点云进行赋色。</p><p><code>Edit -&gt; Colors -&gt; Height Ramp</code></p><p><img src="wps1-20231128113644-3f440qp.jpg" alt="img"></p><p>CC也可以按照其他轴进行赋色</p><p><code>Edit -&gt; Scalar fields -&gt; export coordinate to SF</code>， 选择x/y/z轴</p><p><img src="wps2-20231128113644-ecarnyw.jpg" alt="img"></p><p><img src="wps3-20231128113644-ibdm0ik.jpg" alt="img"></p><h2 id="使用多边形对点云裁剪"><a href="#使用多边形对点云裁剪" class="headerlink" title="使用多边形对点云裁剪"></a>使用多边形对点云裁剪</h2><p><a href="https://blog.csdn.net/qq_32867925/article/details/124187166">https://blog.csdn.net/qq_32867925/article/details/124187166</a></p><h2 id="计算点云中两个点之间的距离"><a href="#计算点云中两个点之间的距离" class="headerlink" title="计算点云中两个点之间的距离"></a>计算点云中两个点之间的距离</h2><p><a href="https://blog.csdn.net/qq_36686437/article/details/122224036">https://blog.csdn.net/qq_36686437/article/details/122224036</a></p><h2 id="下采样"><a href="#下采样" class="headerlink" title="下采样"></a>下采样</h2><p><a href="https://blog.csdn.net/qq_27353621/article/details/124008810">https://blog.csdn.net/qq_27353621/article/details/124008810</a></p><h2 id="统计滤波"><a href="#统计滤波" class="headerlink" title="统计滤波"></a>统计滤波</h2><p><a href="https://blog.csdn.net/qq_36686437/article/details/120011047">https://blog.csdn.net/qq_36686437/article/details/120011047</a></p><p>CC好像没有实现半径滤波，需要自行实现</p><h2 id="计算体积"><a href="#计算体积" class="headerlink" title="计算体积"></a>计算体积</h2><p><a href="https://www.cnblogs.com/codeAndlearn/p/12317673.html">https://www.cnblogs.com/codeAndlearn/p/12317673.html</a></p><p>CC计算的并非是点云的凸包体积，CC好像没有实现凸包体积计算，需要自行实现</p><h2 id="创建球并移动，计算球和球之间的距离"><a href="#创建球并移动，计算球和球之间的距离" class="headerlink" title="创建球并移动，计算球和球之间的距离"></a>创建球并移动，计算球和球之间的距离</h2><p>有时需要计算两点之间的距离，但是这两点虽然代表点云但并不在点云集合中，需要自定义位置。我们可以创建两个球，然后将它们拖动到指定位置，然后再计算距离。</p><p>首先，创建球</p><p><code>File -&gt; Primitive Factory</code>，选择sphere，确定位置和半径</p><p><img src="wps4-20231128113644-n938rmx.jpg?lastModify=1701152207" alt="img"></p><p>然后拖动球：选中球，并点选下图图标。鼠标右键拖动。</p><p><img src="wps5-20231128113644-mbw49ys.jpg" alt="img"></p><p>将两个球拖动到合适的位置，计算距离</p><p><img src="wps6-20231128113644-oc6tpfo.jpg?lastModify=1701152207" alt="img"></p><h2 id="更多操作"><a href="#更多操作" class="headerlink" title="更多操作"></a>更多操作</h2><p>这里有人总结了CC的操作，非常全面。</p><p><a href="https://blog.csdn.net/qq_36686437/article/details/120100839">https://blog.csdn.net/qq_36686437/article/details/120100839</a></p><h1 id="CC-Python插件"><a href="#CC-Python插件" class="headerlink" title="CC-Python插件"></a>CC-Python插件</h1><h2 id="前置条件-Win10"><a href="#前置条件-Win10" class="headerlink" title="前置条件(Win10)"></a>前置条件(Win10)</h2><p>使用该插件需要安装最新版的CC，我安装的版本是2.13</p><p><img src="image-20231128114621-bo1kz5e.png" alt="image"></p><p>在安装时，记得勾选</p><p><img src="image-20231128114706-bwwrkfk.png" alt="image"></p><blockquote><p>Windows是直接带有这个插件的，而MacOS下安装该插件需要自己去编译插件代码并安装。</p><p>这是插件代码的文档：<a href="https://tmontaigu.github.io/CloudCompare-PythonPlugin/">https://tmontaigu.github.io/CloudCompare-PythonPlugin/</a></p><p>包括如何编译源码&amp;Useage</p></blockquote><p>安装完成后，记得更新一下pip：</p><p>进入安装目录下<code>CloudCompare/plugins/Python</code>，执行<code>.\python.exe -m pip install --upgrade pip</code></p><h2 id="使用插件示例"><a href="#使用插件示例" class="headerlink" title="使用插件示例"></a>使用插件示例</h2><p>有些点云文件巨大，加载进来会很慢，我这里先将点云降采样之后才把他加载到CC中。</p><p>为了方便，我需要安装open3d</p><p>打开Python Manager： <code>Plugins -&gt; Python Plugins -&gt; Package Manager</code></p><p><img src="image-20231128120020-x27frq0.png" alt="image">点击install，输入open3d 进行安装。</p><p><img src="image-20231128120130-6obtvph.png" alt="image"></p><p>打开Show REPL： <code>Plugins -&gt; Python Plugins -&gt; Show REPL</code></p><p>红框输入指令</p><p><img src="image-20231128120448-c9cul9e.png" alt="image"></p><p>以下是我输入的指令</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pycc</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> cccorelib</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cc = pycc.GetInstance()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> open3d <span class="keyword">as</span> o3d</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pcd = o3d.io.read_point_cloud(<span class="string">&#x27;C:/Users/Administrator/Desktop/merged_room.pcd&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pcd = pcd.voxel_down_sample(<span class="number">0.5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>points = np.asarray(pcd.points)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>xs = points[:, <span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ys = points[:, <span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>zs = points[:, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pc = pycc.ccPointCloud(xs, ys, zs)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cc.addToDB(pc)</span><br></pre></td></tr></table></figure><p>至此可以看到CC场景中已经加载了点云</p><p><img src="image-20231128120849-90hz4hw.png" alt="image"></p><p>我们可以用插件实现前面CC未实现的诸多功能。更多用法可以参考前文提到的插件的官方文档。</p><h1 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;最近在做点云处理相关的工作，这里找到了一个非常好用的开源软件CloudCompare（下称CC）。这里对我的常用操</summary>
      
    
    
    
    <category term="点云数据处理" scheme="https://guoyujian.github.io/categories/%E7%82%B9%E4%BA%91%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    
    
    <category term="CloudCompare" scheme="https://guoyujian.github.io/tags/CloudCompare/"/>
    
    <category term="Point Cloud" scheme="https://guoyujian.github.io/tags/Point-Cloud/"/>
    
  </entry>
  
  <entry>
    <title>CPU密集型任务的后端实现方法比较总结</title>
    <link href="https://guoyujian.github.io/2023/10/19/CPU%E5%AF%86%E9%9B%86%E5%9E%8B%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%90%8E%E7%AB%AF%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E6%AF%94%E8%BE%83%E6%80%BB%E7%BB%93/"/>
    <id>https://guoyujian.github.io/2023/10/19/CPU%E5%AF%86%E9%9B%86%E5%9E%8B%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%90%8E%E7%AB%AF%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E6%AF%94%E8%BE%83%E6%80%BB%E7%BB%93/</id>
    <published>2023-10-19T14:38:32.000Z</published>
    <updated>2023-10-19T14:49:55.040Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>先介绍下整体系统框架，系统分为前端和后端，二者通过websocket协议进行通信。通过请求数据中的code字段来响应不同的操作。</p><p><img src="前后端通信.png" alt="前后端通信"></p><p><img src="时序图.png" alt="时序图"></p><p><img src="后端处理一次请求的流程图.png" alt="后端处理一次请求的流程图"></p><p>以上介绍整体的软件逻辑。此外，后端使用Python的asyncio来实现异步编程。</p><p>例如，实现将数据插入到数据库并将数据发送到前端：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">insert_data2db(data)</span><br><span class="line">ws_send(websocket, data)</span><br></pre></td></tr></table></figure><p>此时程序是顺序执行的。异步版本如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> insert_data2db(data)</span><br><span class="line"><span class="keyword">await</span> ws_send(websocket, data)</span><br></pre></td></tr></table></figure><p>此时，程序不会等待insert_data2db完成，直接继续执行ws_send方法。两者区别如下草图：</p><p><img src="同步异步.png" alt="同步异步"></p><p>这种异步的方式在IO-Bound Task中好用。但是对于CPU-Bound Task优化效果不大（甚至会有反效果）</p><p>此外，如果后一个操作需要用到前一个操作的结果，这个代码实际是顺序执行的。</p><h1 id="主要代码结构（伪）"><a href="#主要代码结构（伪）" class="headerlink" title="主要代码结构（伪）"></a>主要代码结构（伪）</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">ws_send</span>(<span class="params">websocket, data</span>)</span><br><span class="line"><span class="keyword">await</span> websocket.send(data)</span><br></pre></td></tr></table></figure><p>首先是通过websocket连接将数据发送回前端的通用方法</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">dealPointCloudData</span>(<span class="params">websocket, request_data</span>):</span><br><span class="line">code = request_data[<span class="string">&#x27;code&#x27;</span>]</span><br><span class="line"><span class="keyword">if</span> code == <span class="number">0</span>:</span><br><span class="line"><span class="comment"># 心跳</span></span><br><span class="line"><span class="keyword">await</span> ws_send(websocket, response_heartbeat_data)</span><br><span class="line"><span class="keyword">elif</span> code == <span class="number">1</span>:</span><br><span class="line"><span class="keyword">await</span> func1()</span><br><span class="line"><span class="keyword">elif</span> code == <span class="number">2</span>:</span><br><span class="line"><span class="keyword">await</span> func2(websocket, request_data)</span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure><p>其次，是分发请求的方法dealPointCloudData，它有两个参数，websocket连接和request_data前端发来的数据。</p><p>最后，主程序中会起一个websocket服务器，服务器会将连接发送到dispatch方法，dispatch方法会轮询每一个websocket连接的消息，并交给dealPointCloudData处理。伪代码如下。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">server = websockets.serve(dispatch, ip, port)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">dispatch</span>(<span class="params">websocket_conn</span>):</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">for</span> message <span class="keyword">in</span> websocket:  <span class="comment"># recv message from a websocket client.</span></span><br><span class="line">msg_dict = parse_json(message)</span><br><span class="line"><span class="keyword">await</span> dealPointCloudData(websocket, msg_dict)</span><br></pre></td></tr></table></figure><h1 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h1><p>目前，当code==2时，需要处理一个计算任务。request_data参数中有一个文件夹路径，该计算任务是读取文件夹下的所有文件内容，将文件内容进行merge，最终生成一个完整的文件。流程如下：</p><p><img src="计算流程.png" alt="计算流程"></p><p>伪代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func2</span>(<span class="params">websocket, request_data</span>):</span><br><span class="line">total = init()</span><br><span class="line">file_list = get_file_list(request_data) <span class="comment"># 从request_data中取出文件夹，</span></span><br><span class="line"><span class="keyword">for</span> i, file_path <span class="keyword">in</span> <span class="built_in">enumerate</span>(file_list):</span><br><span class="line">obj = read_file_as_obj(file_path)</span><br><span class="line">total = merge(total, obj)</span><br><span class="line"><span class="keyword">await</span> ws_send(websocket, <span class="string">&#x27;进度：...&#x27;</span>) <span class="comment"># 本次merge结束后向前端发送进度</span></span><br><span class="line">save2file(total)</span><br><span class="line"><span class="keyword">await</span> ws_send(websocket, finish_flag)</span><br></pre></td></tr></table></figure><p>由于func2主要时间花费在一个for循环中， 每次for循环中都有一个耗时的计算任务merge。merge是一个同步方法</p><p>所以func2中虽然使用了await异步编程，但整体来看，还是个同步处理程序。</p><p>这就导致一个严重的问题，就是当单线程执行func2进行长时间计算的时候，新的心跳包请求-响应会被阻塞掉。如图</p><p><img src="心跳响应阻塞.png" alt="心跳响应阻塞"></p><p>如果阻塞的时间过长，前后端就会失去本次连接。</p><p>针对该问题，我尝试了几种解决方法。</p><h1 id="尝试"><a href="#尝试" class="headerlink" title="尝试"></a>尝试</h1><h2 id="1-开启线程执行计算（merge）"><a href="#1-开启线程执行计算（merge）" class="headerlink" title="1 开启线程执行计算（merge）"></a>1 开启线程执行计算（merge）</h2><p>func2函数中开启一个新的线程执行计算，并返回数据。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func2</span>(<span class="params">websocket, request_data</span>):</span><br><span class="line">    t = DealPcdsThread(websocket, other_params)</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure><p>DealPcdsThread线程类的实现如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DealPcdsThread</span>(threading.Thread):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    处理pcd文件夹的线程</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, websocket, request_data</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        file_list = get_file_list(request_data)</span><br><span class="line">        self.websocket = websocket</span><br><span class="line">        self.file_list = file_list </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        asyncio.run(self.merge()) <span class="comment"># 在线程中开启新的事件循环来执行协程函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">self</span>):</span><br><span class="line">        total = init()</span><br><span class="line">file_list = get_file_list(request_data) <span class="comment"># 从request_data中取出文件夹，</span></span><br><span class="line"><span class="keyword">for</span> i, file_path <span class="keyword">in</span> <span class="built_in">enumerate</span>(file_list):</span><br><span class="line">obj = read_file_as_obj(file_path)</span><br><span class="line">total = merge(total, obj)</span><br><span class="line">log.info(<span class="string">f&#x27;...&#x27;</span>)</span><br><span class="line"><span class="keyword">await</span> ws_send(websocket, <span class="string">&#x27;进度：...&#x27;</span>) <span class="comment"># 本次merge结束后向前端发送进度</span></span><br><span class="line">save2file(total)</span><br><span class="line"><span class="keyword">await</span> ws_send(websocket, finish_flag)</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>浏览器控制台日志如图：</p><p><img src="控制台日志.png" alt="控制台日志"></p><p>这说明在处理计算任务时，主线程没有阻塞，心跳包能够正常返回，和预期一致。</p><p>本来问题到这里就解决了，但是在实际测试中又发现了其他问题。</p><h3 id="问题1-前端显示不流畅"><a href="#问题1-前端显示不流畅" class="headerlink" title="问题1: 前端显示不流畅"></a>问题1: 前端显示不流畅</h3><p><img src="合成进度条.gif" alt="合成进度条"></p><p>如图可以看到进度条卡在2.21%后，过了几秒非常迅速的蹦到了40.79%。但是后台的日志打印是“流畅的”，即没有类似的停顿。</p><p>猜测可能是和异步有关，毕竟在<code>await ws_send()</code>​后直接返回了，事件循环选择了某个时间点统一发送这些请求。</p><p>一开始还以为是计算线程失去了CPU的控制权导致的，后来一想可能性不大，一方面占用时间应该在很短的时间，我应该感觉不到，另一方面，后台日志打印流畅。</p><h3 id="问题2-后台报错"><a href="#问题2-后台报错" class="headerlink" title="问题2: 后台报错"></a>问题2: 后台报错</h3><p>在执行计算的过程，出现报错如下图</p><p><img src="报错.png" alt="报错"></p><p>该报错我搜索了很久也没有找到解决方案，在加上该报错不会导致任务失败，也不会有其他影响。所以搁置了。</p><p>该方案是目前最好的解决方案，我也尝试了很多其他解决方案。这里也一并列出。</p><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p>方案2与方案1相同，同样是开启新线程执行合并，只是新的事件循环有主线程创建，而非在新线程中创建。测试这两种方法表现一致。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func2</span>(<span class="params">websocket, request_data</span>):</span><br><span class="line">new_loop: AbstractEventLoop = asyncio.new_event_loop()</span><br><span class="line">    <span class="comment"># 定义</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start_loop</span>(<span class="params">loop: AbstractEventLoop</span>):</span><br><span class="line">        asyncio.set_event_loop(loop)</span><br><span class="line">        loop.run_forever()</span><br><span class="line">    <span class="comment">#通过当前线程开启新的线程启动事件循环</span></span><br><span class="line">    t = threading.Thread(target=start_loop, args= (new_loop,))</span><br><span class="line">    t.start()</span><br><span class="line">    asyncio.run_coroutine_threadsafe(</span><br><span class="line">        DealPcdsThread(websocket, request_data).merge(),</span><br><span class="line">        new_loop</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><p>使用asyncio.run_in_executor将任务放到线程池中运行</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func2</span>(<span class="params">websocket, request_data</span>):</span><br><span class="line"><span class="comment"># 4.4 使用asyncio.run_in_executor将任务放到线程池中运行。效果和4.2一样</span></span><br><span class="line">loop: AbstractEventLoop = asyncio.get_event_loop()</span><br><span class="line"><span class="keyword">await</span> loop.run_in_executor(<span class="literal">None</span>, DealPcdsThread(websocket, request_data).run)</span><br><span class="line"><span class="comment"># await asyncio.to_thread(DealPcdsNoThread.run, loop) # new py3.9</span></span><br></pre></td></tr></table></figure><p>测试说明，这种方法会阻塞主线程，导致心跳包无法及时响应。。</p><h2 id="4"><a href="#4" class="headerlink" title="4"></a>4</h2><p>为了加快计算的速度，想到尝试开启新的进程执行计算。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Process(target=merge, args=(websocket, request_data)).start()</span><br></pre></td></tr></table></figure><p>但是没想到，进程之间传递的Python对象必须可以被序列化（pickle）才可以，而websocket对象不能被序列化，所以这种方法无效。</p><h2 id="5"><a href="#5" class="headerlink" title="5"></a>5</h2><p>最后一种，同样也是开启一个新的线程，不过target传入的是异步计算方法（虽然是异步的，但是内部确是同步的。。。）</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">threading.Thread(target=<span class="keyword">await</span> DealPcdsThread(websocket, request_data).merge()).start()</span><br></pre></td></tr></table></figure><p>这种方法也会阻塞主线程。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>在实验过程中，我发现凡是开启新线程并且新线程中使用新的事件循环来处理发送请求都可以让主线程不阻塞。例如方案1、2</p><p>但是如果只开新线程，而事件循环依然使用主线程loop的话，不能解决主线程阻塞的问题。例如方案3、5</p><h1 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h1><ol><li>用<code>concurrent.futures.ThreadPoolExecutor</code>​替换threading。<code>concurrent.futures.ThreadPoolExecutor</code>​提供了一个高层级接口用来向后台线程推送任务而不会阻塞调用方线程的执行，同时仍然能够在需要时获取任务的结果。</li><li>先读出所有的文件到内存中，放到一个数组里，再开启多进程对这个数组的点云数据进行reduce。利用多核加快合并速度？</li><li>其实我觉得最好的方式是，开启一个线程执行计算任务，线程类中有一个指示进度的变量。在主线程中使用一个协程每隔X秒获取一次进度并将其发送给前端。但是这种方式无法做到实时。</li><li>什么时候Python可以去掉GIL的限制，让这种计算密集型任务能够充分利用多核CPU。。。😢</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;先介绍下整体系统框架，系统分为前端和后端，二者通过websocket协议进行通信。通过请求数据中的code字段来响应不同的操作。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="Python" scheme="https://guoyujian.github.io/categories/Python/"/>
    
    
    <category term="Python" scheme="https://guoyujian.github.io/tags/Python/"/>
    
    <category term="asyncio" scheme="https://guoyujian.github.io/tags/asyncio/"/>
    
    <category term="websocket" scheme="https://guoyujian.github.io/tags/websocket/"/>
    
  </entry>
  
  <entry>
    <title>Python 面试题</title>
    <link href="https://guoyujian.github.io/2023/10/07/Python-%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://guoyujian.github.io/2023/10/07/Python-%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2023-10-07T14:48:30.000Z</published>
    <updated>2023-10-07T14:50:39.894Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记一次Python面试被问到的题</p></blockquote><h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=&#123;<span class="number">1</span>:<span class="number">2</span>,<span class="number">2</span>:<span class="number">3</span>&#125;</span><br><span class="line">b=a</span><br><span class="line">b.pop(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><p>问：a的输出是什么？</p><p>答：<code>&#123;2:3&#125;</code>​</p><h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b=[[]]*<span class="number">2</span>; b[<span class="number">0</span>].append(<span class="number">1</span>); <span class="built_in">print</span>(b)</span><br><span class="line">a=[]; b=[a]*<span class="number">2</span>; b[<span class="number">0</span>].append(<span class="number">1</span>); <span class="built_in">print</span>(b)</span><br><span class="line">a=[]; b=[a, a]; b[<span class="number">0</span>].append(<span class="number">1</span>); <span class="built_in">print</span>(b)</span><br><span class="line">b=[[], []]; b[<span class="number">0</span>].append(<span class="number">1</span>); <span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure><p>问：这四个<code>b</code>​的输出是什么？</p><p>答：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[[1], [1]]</span><br><span class="line">[[1], [1]]</span><br><span class="line">[[1], [1]]</span><br><span class="line">[[1], []]</span><br></pre></td></tr></table></figure><h1 id="3"><a href="#3" class="headerlink" title="3"></a>3</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a=&quot;123&quot;; b=a; b=b[:-1]; </span><br><span class="line">print(a, b)</span><br></pre></td></tr></table></figure><p>问：输出？</p><p>答：<code>123 12</code>​</p><h1 id="4"><a href="#4" class="headerlink" title="4"></a>4</h1><p>比较以下两段代码的执行效率和内存开销</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">res = 1</span><br><span class="line">for num in [1,2,3,4]+[6,7,8,9]:</span><br><span class="line">    res *= num</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import itertools</span><br><span class="line">res = 1</span><br><span class="line">for num in itertools.chain([1,2,3,4], [6,7,8,9]):</span><br><span class="line">    res *= num</span><br></pre></td></tr></table></figure><p><a href="https://docs.python.org/3/library/itertools.html">https://docs.python.org/3/library/itertools.html</a></p><p>答：首先第一个代码需要将两个列表和并为一个列表，而第二段代码是直接遍历两个列表，其次itertools.chain返回的是一个生成器，所以第二个代码的执行效率高，内存开销小。</p><h1 id="5"><a href="#5" class="headerlink" title="5"></a>5</h1><p>What is the difference between tuple() and list[]？loop over tuple and list，which one is more effective？</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if var in [&quot;xxx&quot;, &quot;yyy&quot;]:</span><br><span class="line">if var in (&quot;xxx&quot;, &quot;yyy&quot;):</span><br><span class="line">if var in &#123;&quot;xxx&quot;, &quot;yyy&quot;&#125;:</span><br></pre></td></tr></table></figure><p>Which one above is more efficitive? Note: The value after ‘in’ is a constant.</p><p>时间复杂度：tuple O(?) list O(?) set O(?)</p><p>答：tuple是不可变对象，list是可变对象。由于tuple不可变，所以申请内存为连续定长内存，而list类似于一个链表。</p><p>所以在loop中，tuple is more effective.</p><p><code>if var in &#123;&quot;xxx&quot;, &quot;yyy&quot;&#125;</code>​ is more effective. 因为集合查询时间复杂度为O(1)，tuple和list为O(N)</p><h1 id="6"><a href="#6" class="headerlink" title="6"></a>6</h1><p>Python class中变量名和函数名前缀单下划线和双下划线(后缀没有下划线)分别是什么？For example,</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class A:</span><br><span class="line">   def _method1(): pass   // What&#x27;s the meaning of _</span><br><span class="line">   def __method2(): pass  // What&#x27;s the meaning of __</span><br></pre></td></tr></table></figure><p> What’s the difference among the concepts protected, public, and private?</p><p>答：变量前没有下划线的为public<br>变量前有单下划线为protected，这种变量只能在本类或者其子类中调用（如果你想在其他地方调用也可以，但是会有警告）<br>变量前有双下划线为private，这种变量只能在本类中调用（在其他地方调用会报错）</p><h1 id="7"><a href="#7" class="headerlink" title="7"></a>7</h1><p>在用mongo等非关系型数据库的时候，我们不希望把脏数据、空数据存进数据库，造成后面的混乱。写一个函数(Python3)，删除json dict里面的空数据，包括空dict，空list，空string，None。假设输入的Python dict从合法json读取, 即key必为string, value可以是number/string/list/dict。例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;a&quot;: [1,0,&quot;c&quot;, &#123;&quot;x&quot;:1&#125;]&#125; -&gt; &#123;&quot;a&quot;: [1,0,&quot;c&quot;, &#123;&quot;x&quot;:1&#125;]&#125;</span><br><span class="line">&#123;&quot;a&quot;:[1,None]&#125; -&gt; &#123;&quot;a&quot;: [1]&#125;</span><br><span class="line">&#123;&quot;a&quot;: &#123;&quot;a&quot;:[None, &quot;&quot;, &#123;&#125;,&#123;&quot;x&quot;:None&#125;]&#125;&#125; -&gt; None</span><br></pre></td></tr></table></figure><p>答：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">clean_json</span>(<span class="params">data: (<span class="params"><span class="built_in">dict</span>,<span class="built_in">list</span>,<span class="built_in">int</span>,<span class="built_in">float</span>,<span class="built_in">str</span>,<span class="literal">None</span></span>)</span>):</span><br><span class="line">    <span class="comment"># put your code here</span></span><br><span class="line">    <span class="keyword">if</span> data <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> data == <span class="string">&#x27;&#x27;</span> <span class="keyword">or</span> data == <span class="built_in">dict</span>() <span class="keyword">or</span> data == []:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(data) == <span class="built_in">list</span>:</span><br><span class="line">        data1 = [item <span class="keyword">for</span> item <span class="keyword">in</span> data <span class="keyword">if</span> clean_json(item) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>] <span class="comment"># 复制一份出来</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data1:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> data1</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(data) == <span class="built_in">dict</span>:</span><br><span class="line">        data1 = &#123;k: clean_json(v) <span class="keyword">for</span> k, v <span class="keyword">in</span> data.items() <span class="keyword">if</span> clean_json(v) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>&#125; <span class="comment"># 复制一份出来</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data1:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> data1</span><br><span class="line">    <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure><p>注意：不能直接对原数组or字典作删除操作，会报错！</p><p>例如</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> l:</span><br><span class="line">    <span class="keyword">if</span> l[i] == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">del</span> l[i] <span class="comment"># do not do this</span></span><br></pre></td></tr></table></figure><p>‍</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;记一次Python面试被问到的题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;1&quot;&gt;&lt;a href=&quot;#1&quot; class=&quot;headerlink&quot; title=&quot;1&quot;&gt;&lt;/a&gt;1&lt;/h1&gt;&lt;figure class=&quot;highlight p</summary>
      
    
    
    
    <category term="Python" scheme="https://guoyujian.github.io/categories/Python/"/>
    
    <category term="基础" scheme="https://guoyujian.github.io/categories/Python/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Python" scheme="https://guoyujian.github.io/tags/Python/"/>
    
    <category term="面试" scheme="https://guoyujian.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Python open3d点云相关操作（持续更新）</title>
    <link href="https://guoyujian.github.io/2023/09/16/Python-open3d%E7%82%B9%E4%BA%91%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/"/>
    <id>https://guoyujian.github.io/2023/09/16/Python-open3d%E7%82%B9%E4%BA%91%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/</id>
    <published>2023-09-16T14:26:37.000Z</published>
    <updated>2023-09-16T14:28:04.353Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Prerequisite"><a href="#Prerequisite" class="headerlink" title="Prerequisite"></a>Prerequisite</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">!pip install open3d</span><br><span class="line">!pip install scipy</span><br><span class="line"><span class="keyword">import</span> open3d <span class="keyword">as</span> o3d</span><br><span class="line"><span class="keyword">from</span> scipy.spatial.transform <span class="keyword">import</span> Rotation <span class="keyword">as</span> R</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><h2 id="读和写点云文件"><a href="#读和写点云文件" class="headerlink" title="读和写点云文件"></a>读和写点云文件</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">point_cloud = o3d.io.read_point_cloud(file_path) <span class="comment"># 支持的格式pcd、pts等</span></span><br><span class="line"><span class="comment"># type(point_cloud) == open3d.cpu.pybind.geometry.PointCloud</span></span><br><span class="line"></span><br><span class="line">o3d.io.write_point_cloud(point_cloud, file_path) </span><br></pre></td></tr></table></figure><h2 id="读取点云对象中点的坐标"><a href="#读取点云对象中点的坐标" class="headerlink" title="读取点云对象中点的坐标"></a>读取点云对象中点的坐标</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.asarray(point_cloud.points)</span><br></pre></td></tr></table></figure><h2 id="将点坐标赋值到点云对象"><a href="#将点坐标赋值到点云对象" class="headerlink" title="将点坐标赋值到点云对象"></a>将点坐标赋值到点云对象</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># points = np.array([[...]])</span></span><br><span class="line"></span><br><span class="line">point_cloud.points = o3d.utility.Vector3dVector(points)</span><br></pre></td></tr></table></figure><h2 id="创建点云对象"><a href="#创建点云对象" class="headerlink" title="创建点云对象"></a>创建点云对象</h2><p>创建一个空的点云对象</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pc = o3d.geometry.PointCloud()</span><br></pre></td></tr></table></figure><h2 id="合并点云对象"><a href="#合并点云对象" class="headerlink" title="合并点云对象"></a>合并点云对象</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 直接+</span></span><br><span class="line">pc += point_cloud</span><br></pre></td></tr></table></figure><h2 id="点云平移"><a href="#点云平移" class="headerlink" title="点云平移"></a>点云平移</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">point_cloud.translate(translation)  <span class="comment"># 应用平移,translation 是平移向量</span></span><br></pre></td></tr></table></figure><h2 id="点云旋转"><a href="#点云旋转" class="headerlink" title="点云旋转"></a>点云旋转</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">point_cloud.rotate(rotation_matrix, center = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>))  <span class="comment"># 应用旋转, rotation_matrix是旋转矩阵</span></span><br></pre></td></tr></table></figure><p>这里需要注意第二个参数center是指定旋转中心，如果不传，默认旋转中心是点云的质心。</p><p>而一般来说，旋转中心为原点</p><h2 id="点云上色"><a href="#点云上色" class="headerlink" title="点云上色"></a>点云上色</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">point_cloud.paint_uniform_color([<span class="number">0</span>, <span class="number">0</span>, <span class="number">1.0</span>]) <span class="comment"># 传入的三个值分别是rgb</span></span><br></pre></td></tr></table></figure><h2 id="点云展示"><a href="#点云展示" class="headerlink" title="点云展示"></a>点云展示</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">o3d.visualization.draw_geometries([point_cloud])</span><br></pre></td></tr></table></figure><h2 id="四元数转旋转矩阵"><a href="#四元数转旋转矩阵" class="headerlink" title="四元数转旋转矩阵"></a>四元数转旋转矩阵</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">quaternion = np.array([ori_x, ori_y, ori_z, ori_w])  <span class="comment"># 定义四元数</span></span><br><span class="line">rotation_matrix = R.from_quat(quaternion).as_matrix()</span><br></pre></td></tr></table></figure><p>注意四元数顺序是xyzw，在有些地方顺序是wxyz</p><h2 id="点云下采样"><a href="#点云下采样" class="headerlink" title="点云下采样"></a>点云下采样</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">point_cloud = point_cloud.voxel_down_sample()</span><br></pre></td></tr></table></figure><p>这里需要注意</p><ol><li>需要接收返回值</li><li>下采样是指只保留某一大小立方体内的一个点。voxel_down_sample方法有个默认值参数，为0.05。这个参数就表示立方体的大小，因此这个数越大，下采样的强度越强，保留的点就越少。</li></ol><h2 id="统计滤波"><a href="#统计滤波" class="headerlink" title="统计滤波"></a>统计滤波</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">point_cloud.remove_statistical_outlier(nb_neighbors=<span class="number">20</span>, std_ratio=<span class="number">2.0</span>)</span><br></pre></td></tr></table></figure><p>该方法可以去掉距离点云密集处很远的点。该方法有两个参数</p><ol><li>nb_neighbors允许指定要考虑多少个邻居，以便计算给定点的平均距离。</li><li>std_ratio允许基于跨点云的平均距离的标准偏差来设置阈值级别。此数字越低，过滤器将越具有攻击性。</li></ol><h2 id="筛选点云中的点"><a href="#筛选点云中的点" class="headerlink" title="筛选点云中的点"></a>筛选点云中的点</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># indices_to_keep =[0,1,2...] 点的索引</span></span><br><span class="line">point_cloud = point_cloud.select_by_index(indices_to_keep)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Prerequisite&quot;&gt;&lt;a href=&quot;#Prerequisite&quot; class=&quot;headerlink&quot; title=&quot;Prerequisite&quot;&gt;&lt;/a&gt;Prerequisite&lt;/h2&gt;&lt;figure class=&quot;highlight python&quot;&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Python numpy对三维点的操作汇总（持续更新）</title>
    <link href="https://guoyujian.github.io/2023/09/16/Python-numpy%E5%AF%B9%E4%B8%89%E7%BB%B4%E7%82%B9%E7%9A%84%E6%93%8D%E4%BD%9C%E6%B1%87%E6%80%BB%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/"/>
    <id>https://guoyujian.github.io/2023/09/16/Python-numpy%E5%AF%B9%E4%B8%89%E7%BB%B4%E7%82%B9%E7%9A%84%E6%93%8D%E4%BD%9C%E6%B1%87%E6%80%BB%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/</id>
    <published>2023-09-16T14:04:30.000Z</published>
    <updated>2023-09-16T14:05:50.824Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Prerequisite"><a href="#Prerequisite" class="headerlink" title="Prerequisite"></a>Prerequisite</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><h2 id="将一个列表中的点或者其他对象转换成一个numpy-ndarray对象"><a href="#将一个列表中的点或者其他对象转换成一个numpy-ndarray对象" class="headerlink" title="将一个列表中的点或者其他对象转换成一个numpy.ndarray对象"></a>将一个列表中的点或者其他对象转换成一个numpy.ndarray对象</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">points = np.asarray([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]])</span><br></pre></td></tr></table></figure><h2 id="查看numpy-ndarray的形状"><a href="#查看numpy-ndarray的形状" class="headerlink" title="查看numpy.ndarray的形状"></a>查看numpy.ndarray的形状</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">##  n : numpy.ndarray </span></span><br><span class="line">n.shape </span><br></pre></td></tr></table></figure><h2 id="计算点到原点的欧几里得距离"><a href="#计算点到原点的欧几里得距离" class="headerlink" title="计算点到原点的欧几里得距离"></a>计算点到原点的欧几里得距离</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># points like array([[x1,y1,z1],[x2,y2,z2],[x3,y3,z3]])</span></span><br><span class="line">distances = np.linalg.norm(points, axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><code>np.linalg.norm(x, ord=None, axis=None, keepdims=False)</code>​求范数</p><p>x：是输入的矩阵or向量</p><p>ord：计算的范数类型。ord=2计算L2范数，即欧几里得距离，ord=1计算L1范数。</p><p>axis：轴，axis=0按列计算，axis=1按行计算</p><h2 id="选择欧几里得距离符合一定范围内的点"><a href="#选择欧几里得距离符合一定范围内的点" class="headerlink" title="选择欧几里得距离符合一定范围内的点"></a>选择欧几里得距离符合一定范围内的点</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获得点距离原点的欧几里得距离大于0.1小于70的点索引</span></span><br><span class="line">np.where((distances &gt;= <span class="number">0.01</span>) &amp; (distances &lt;= <span class="number">70</span>))[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#筛选这些点</span></span><br><span class="line">points[np.where((distances &gt;= <span class="number">0.01</span>) &amp; (distances &lt;= <span class="number">70</span>))]</span><br></pre></td></tr></table></figure><p><a href="https://www.delftstack.com/zh/howto/numpy/python-numpy.where-multiple-conditions/#%e5%9c%a8-python-%e4%b8%ad%e4%bd%bf%e7%94%a8-numpylogical_or-%e5%87%bd%e6%95%b0%e5%ae%9e%e7%8e%b0-numpywhere-%e5%a4%9a%e4%b8%aa%e6%9d%a1%e4%bb%b6">https://www.delftstack.com/zh/howto/numpy/python-numpy.where-multiple-conditions/#%e5%9c%a8-python-%e4%b8%ad%e4%bd%bf%e7%94%a8-numpylogical_or-%e5%87%bd%e6%95%b0%e5%ae%9e%e7%8e%b0-numpywhere-%e5%a4%9a%e4%b8%aa%e6%9d%a1%e4%bb%b6</a></p><h2 id="对点进行旋转"><a href="#对点进行旋转" class="headerlink" title="对点进行旋转"></a>对点进行旋转</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 给定一个3*3的旋转矩阵 rotation_matrix， 对点points进行旋转，获得旋转后的点坐标。</span></span><br><span class="line">np.dot(points, rotation_matrix.T)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意这里需要对旋转矩阵做了转置，<strong><em>推导一下</em></strong>​<strong>。</strong></p><p>np.dot矩阵乘法，他的用法是？和np.<code>matmul</code>​的区别？</p><h2 id="对点进行平移"><a href="#对点进行平移" class="headerlink" title="对点进行平移"></a>对点进行平移</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 给定一个平移向量translation_vector， 对点points进行平移，获得旋转后的点坐标。</span></span><br><span class="line">points + translation_vector</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Prerequisite&quot;&gt;&lt;a href=&quot;#Prerequisite&quot; class=&quot;headerlink&quot; title=&quot;Prerequisite&quot;&gt;&lt;/a&gt;Prerequisite&lt;/h2&gt;&lt;figure class=&quot;highlight python&quot;&gt;</summary>
      
    
    
    
    <category term="Python" scheme="https://guoyujian.github.io/categories/Python/"/>
    
    
    <category term="Python" scheme="https://guoyujian.github.io/tags/Python/"/>
    
    <category term="numpy" scheme="https://guoyujian.github.io/tags/numpy/"/>
    
  </entry>
  
  <entry>
    <title>你的项目中有什么亮点？如何回答才能得到面试官的好感</title>
    <link href="https://guoyujian.github.io/2023/09/04/%E4%BD%A0%E7%9A%84%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%9C%89%E4%BB%80%E4%B9%88%E4%BA%AE%E7%82%B9%EF%BC%9F%E5%A6%82%E4%BD%95%E5%9B%9E%E7%AD%94%E6%89%8D%E8%83%BD%E5%BE%97%E5%88%B0%E9%9D%A2%E8%AF%95%E5%AE%98%E7%9A%84%E5%A5%BD%E6%84%9F/"/>
    <id>https://guoyujian.github.io/2023/09/04/%E4%BD%A0%E7%9A%84%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%9C%89%E4%BB%80%E4%B9%88%E4%BA%AE%E7%82%B9%EF%BC%9F%E5%A6%82%E4%BD%95%E5%9B%9E%E7%AD%94%E6%89%8D%E8%83%BD%E5%BE%97%E5%88%B0%E9%9D%A2%E8%AF%95%E5%AE%98%E7%9A%84%E5%A5%BD%E6%84%9F/</id>
    <published>2023-09-04T15:17:53.000Z</published>
    <updated>2023-09-04T15:22:09.604Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>针对本<a href="https://www.bilibili.com/video/BV1DM4y1L7cL/?buvid=9aa5bffff7ad0aee7573c7ed265b7b41&amp;is_story_h5=false&amp;mid=KneIq6dZPkIx5y%2FvWilBwA%3D%3D&amp;p=1&amp;plat_id=116&amp;share_from=ugc&amp;share_medium=iphone&amp;share_plat=ios&amp;share_session_id=B0B2A8E9-DA79-44E5-ADF6-4ECC9B19D812&amp;share_source=WEIXIN&amp;share_tag=s_i&amp;timestamp=1693623913&amp;unique_k=A5vAgCl&amp;up_id=1031543543&amp;vd_source=53d8e50bea64fe70bc50c86af86d28e1">视频</a>做的笔记</p></blockquote><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>请你说一下你项目中的亮点。几乎每个准备去面试的同学都会被这个问题困扰，我羡慕。</p><p>很简单，就是 CRUD 没有亮点怎么办？没有做过分布式的项目，哪有什么亮点，我之前做的都是单体项目，实在想不出有什么亮点，大家对于这个问题的<strong>误解</strong>在于，一定要项目足够好才有亮点。其实面试官在问这个问题的时候是想了解你在项目中的成果和能力，我们可以从几个维度去准备。</p><ol><li>解决复杂问题的能力。你可以描述你在项目中解决过哪一些特别复杂或者有挑战性的问题，可以是技术问题，也可以是业务问题。比如说通过引入 Kafka 这个消息队列，优化了程序的效率，使得我们能够在高峰期处理百万级的消息。</li><li>做了一些提高效率的工作，比如说重构代码，优化数据库查询效率。引入异步线程，优化了代码的效率。开发了一个公共组件，提升了团队的开发效率。比如优化了一个复杂的 MySQL 语句，提高了数据库的查询效率，使得查询效率整体提升了 10 倍。</li><li>突出团队协作和沟通方面的能力。比如说在项目中承担的核心开发或者团队小组长的角色，通过一系列的管理手段，按时完成了项目交付和提高了质量保障等等。比如我带领我的团队完成了这个项目，我负责分配任务，协调团队的成员工作以及解决团队中出现的问题。在我的管理下，我们成功的按时完成了项目，得到了客户的高度评价。</li><li>最后，我们还可以突出学习能力，比如项目里面要用到一个新的技术，这个技术之前没有用过，但是项目交付的时间比较紧，所以我大概花了 3 天时间在网上找了各种资料学习，在实际落地的时候还遇到了一些自己解决不了的问题，后面在 GitHub 的 issue 上找到解决方案，最后按期完成了项目的交付。</li></ol><p>因此，对于项目中的亮点，你们可以从对业务设计的深度思考，问题解决的能力，或者对某个特定技术的深度理解，团队协作沟通等方面去准备，从而让面试官看到你在项目中的思考和总结，而不是一个只会 CRUD的工具人。以上就是我的理解。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;针对本&lt;a href=&quot;https://www.bilibili.com/video/BV1DM4y1L7cL/?buvid=9aa5bffff7ad0aee7573c7ed265b7b41&amp;amp;is_story_h5=false&amp;amp;mi</summary>
      
    
    
    
    
    <category term="面试技巧" scheme="https://guoyujian.github.io/tags/%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>Python asyncio异步编程入门</title>
    <link href="https://guoyujian.github.io/2023/09/03/Python-asyncio%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"/>
    <id>https://guoyujian.github.io/2023/09/03/Python-asyncio%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/</id>
    <published>2023-09-03T09:36:21.000Z</published>
    <updated>2023-09-03T09:40:56.212Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>针对<a href="https://www.bilibili.com/video/BV1oa411b7c9/?spm_id_from=333.337.search-card.all.click&amp;vd_source=53d8e50bea64fe70bc50c86af86d28e1">该视频</a>的一篇笔记</p><p>先决条件：协程、并发</p></blockquote><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>这次讲的是asyncio最新的用法，然后是Python 3. 7 以上才支持的，也是推荐大家学新不学旧。</p><p>asyncio并不能提升你的运算速度，它比较适合处理那些需要等待的任务^（应用场景）^，最典型的就是网络的通讯</p><p>那 asyncio的<strong>运算核心</strong>其实就是一个event loop，它就像一个大脑，它面对着很多可以执行的任务，然后决定执行哪个任务。那在 Python 的asyncio里，同时执行的任务只能有一个，它不存在系统级的上下文切换，它跟线程不一样，它需要每一个任务主动告诉event loop，我这边结束了，你可以让别的任务开始了。因此它有一个<strong>好处</strong>，就是不存在竞争冒险这样的问题，你可以明确的知道我每一个任务什么时候停止运算了。</p><p>那想要使用asyncio第一件事就是理解什么叫coroutine，什么叫task。</p><p>coroutine在 Python 的语境里，我们一般会指两种东西，一个是coroutine function，一个是coroutine object。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>( <span class="string">&#x27;world&#x27;</span>)</span><br><span class="line"></span><br><span class="line">coro = main()</span><br></pre></td></tr></table></figure><p>这个 async def main 就是一个coroutine function。Python 里面所有async def main开头的东西都叫coroutine function，它定义了一个 coroutine 的过程。那 Python 一般的函数，当我们调用它的时候，它返回的是这个函数的返回值，对不对？但是所有的 coroutine function，当你调用的时候，它返回的是一个coroutine object，它的本质跟生成器函数有些像。</p><p>就是当你在调用main的时候，它并不会运行 main 里面的程序，它只会返回一个coroutine object。</p><p>好，那怎么运行coroutine的代码？我们需要<strong>两件事</strong>，第一是进入async的模式，也就是进入这个 event loop，开始控制整个程序的状态。第二就是把coroutine变成task。</p><p>我们先说如何进入 async 模式，那我们正常写Python代码运行的时候，如果我们管它叫 synchronized 模式的话，那么在 synchronize 模式下切换到 asynchronized 模式，切换到让这个 event loop 开始控制一切。基本上我们只用一个入口函数叫做asyncio.run，那 asyncio.run，它的参数是一个coroutine，它会做两件事儿，第一它会建立起这个 event loop，第二它会把这个 coroutine 变成这个 event loop 里面的一个task，那 event loop 建立之后，他就会去找哪个 task 可以执行，那当然只有一个task，所以它就会开始运行 run 给进来的这个coroutine。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>( <span class="string">&#x27;world&#x27;</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p>我们试一下，大家可以看到它先 print 了hello，然后等了 1 秒钟，然后 print 了world，那这个asyncio.run就是我们从 synchronize 模式变到 asynchronize 模式的入口，它的参数是一个coroutine。</p><p>那只有一个 task 是没有什么意思的，对不对？我们刚才也说过， event loop 的核心是它有很多很多个task，然后它来决定哪个 task 要运行。所以我们很重要的一件事情是，当我们已经处于 async 模式下的时候，我们如何增加task？接下来我们就介绍几个把coroutine变成task，让它可以排队执行的方法。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">say_after</span>(<span class="params">delay, what</span>):</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(delay)</span><br><span class="line">    <span class="built_in">print</span>(what)</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;started at <span class="subst">&#123;time.strftime(<span class="string">&#x27;%x&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> say_after(<span class="number">1</span>, <span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> say_after(<span class="number">2</span>,<span class="string">&quot;world&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;finished at <span class="subst">&#123;time.strftime(<span class="string">&#x27;%x&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">        </span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p>大家看，我们有一个 say_after 函数，它显然是一个coroutine，对不对？它前面是async def，那实际上asyncio.sleep，它返回的东西也是一个 core routine，那这里就涉及到了<strong>第一个把coroutine变成 task 的方法</strong>，就是用await。</p><p>那么当你 await 一个<strong>coroutine</strong>的时候（上述代码第8行），发生了如下几件事，第一，这个coroutine被包装成一个task，并且被告诉了 event loop，说这块儿有一个新的task。第二，它会告诉 event loop，我现在这个 task （main）需要等到say_after task 完成之后，我才能继续它，建立了这么一个依赖关系。第三，它会 yield 出去，也就是它会告诉 event loop，我这个 task 现在干不了了，你先让别的 task 干活去吧。最后当 event loop 再次安排它运行的时候，它会把 say after 这个say_after 里面真正的返回值拿出来保存起来。当然现在我们这里await前面没有写，因为我们的 say after 是没有返回值的，好，那我们运行一下这段程序，我们可以看到差不多间隔一秒 print 一个hello，然后在两秒钟之后 print 了一个world。</p><p>我们来还原一下整个过程发生了一个什么事情。首先 asyncio.run把这个main作为一个 task 给放到了 event loop 里。 event loop 寻找task，他发现只有一个 task main，然后他就开始让这个 task main运行。may 你在运行的时候，首先 print 了一个 start at，然后它运行了 say_after 这个coroutine function，得到了一个coroutine object。await 把这个coroutine object变成了一个task，放回了 event loop 里，同时告诉 event loop 我需要等待它，然后把控制权交还给了 event loop。</p><p>现在 event loop 里面有两个task，一个是main，一个是这个 say_after，但是main运行不了， main说我要等这个 say after，那event loop，就让这个say_after先运行。</p><p><code>await asyncio.sleep(delay)</code>​ 这里其实做了一个很相似的事情，也是把它变成了一个task，然后告诉 event loop 说我得等这个 sleep 完成了我才能运行。然后 await 又把这个控制权转回给了 event loop。</p><p>event loop 一看现在有三个 task 对不对？有一个main，有一个 say_after，还有一个sleep，那这个 sleep 会告诉 event loop 说我一秒钟之后我就好了，所以这个 event loop 就等了一秒钟。一秒钟之后这个 sleep 就完成了。然后 event loop 看现在有两个task，一个main，一个 say after，这个 main 要等 say_after，但是这个 say after 等的东西已经完成了，于是 event loop 就说 say_after 你来运行吧，然后 say_after printed 一个what，然后 say_after 也完成了。于是又把控制权交还给 event loop。</p><p>event loop 一看，哎，现在只有一个 task 了，就成 main 了，然后再把控制权给main，这个时候 main就把第一个 say_after 完成了，然后再做第二个 say_after 做同样的事，又等了 2 秒之后它完成，所以整个过程用了 3 秒。</p><p>那在这个过程中，所有控制权的返回都是显式的，就是<strong>​ event loop 并没有办法强行的从一个 task 里边拿回控制权，必须要这个 task 主动把控制权交回去。</strong>交回去的方式有两种，第一个是await，会交回，第二个，当这个函数运行完毕之后，它会交回。所以说如果你有一个 task 里面有一个死循环，你的整个 event loop 就卡死了。</p><p>好，那刚才的运行过程中你可能发现了一个问题，对不对？这个 hello 要等 1 秒，这个 world 要等 2 秒，它俩为啥不能一起等呢？这就应该是我们协程的意义，对不对？在你第一个 hello 等 1 秒的时候，为什么这个 event loop 不能直接让这个 world 运行，然后你俩一起等着， 2 秒之后不就结束了吗？那这个呢？就是我们直接用 await 把一个 cooutine 变成 task 可能遇到的问题，因为 await 需要做的事太多了，它要变成task，它变成 task 之后会主动把控制权交出去，还需要等，这样后面的代码必须要等到它完成之后才能变成一个task。  </p><p>那为了解决这个问题， asyncio给我们提供了 create task 函数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">say_after</span>(<span class="params">delay, what</span>):</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(delay)</span><br><span class="line">    <span class="built_in">print</span>(what)</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    task1 = asyncio.create_task(say_after(<span class="number">1</span>,<span class="string">&quot;hello&quot;</span>))</span><br><span class="line">    task2 = asyncio.create_task(say_after(<span class="number">2</span>,<span class="string">&#x27;world&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;started at <span class="subst">&#123;time.strftime( <span class="string">&#x27;%x&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> task1</span><br><span class="line">    <span class="keyword">await</span> task2</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;finished at <span class="subst">&#123;time.strftime(<span class="string">&#x27;%x&#x27;</span>)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>我们看这里用到的 create_task 函数，这个函数的参数也是一个coroutine。依然记住这个 say_after 调用之后返回的是一个coroutine，它不会运行任何 coroutine 里面的代码，那这个 create_task 函数会把这个coroutine变成一个task，并且把这个 task 注册到 event loop 里面。也就是说它分担了刚才 await 的一部分功能，它把它包装成了一个task，然后告诉 event loop 说OK，这个 task 已经可以开始执行了，但是现在 event loop 并没有办法执行这个task，因为控制权还在 main 的手里，对不对？那这个时候 main 趁着自己有控制权，他就做了第二个task。</p><p>task 2 也是告诉 main 这还有一个新的task，这叫 say_after 2 也可以运行了，那在这儿之后他才开始 await task_1 await task_2 那我们之前说过 await 后面是一个coroutine的时候，它有那么多个功能对不对？把它变成一个task，然后把控制权交出去，等它拿返回值。那当 await 后面是一个 task 而不是一个coroutine 的时候，它就省略了把 coroutine变成 task 这一步，它就只是告诉 event loop 我需要这个 task 完成，我把控制权交还给你，并且在控制权回来的时候，从这个 task 里面提取所需要的返回值。</p><p>好，我们跑一下这个程序试一下。我们看这一次这个程序就只用了 2 秒钟，因为当它 await task 1的时候， event loop 里面实际上已经有了 3 个task，是 main、task 1和 task 2。当 task 1跟 event loop 说完说我要等一秒钟才能完成，之后 event loop 闲来无事就能发现，这有一个 task 2 还可以执行，于是他又执行了 task 2，再跟他说我要两秒钟之后才能结束，这样两个 task 就可以同时进行等待了。</p><p>这也就是为什么asyncio很适合解决一些网络通讯的问题，因为网络通讯很多时间是在等待上的，也就是我们所谓的IO task，就是我真正的运算挺少的，我就是等他的回复，那等待的这个时间就可以其他的任务去干活。那这个函数我们没有涉及coroutine的return，所以我们把这个函数稍微修改一下。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">say_after</span>(<span class="params">delay, what</span>):</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(delay)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;(what) - (delay)&quot;</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    task1 = asyncio.create_task(say_after(<span class="number">1</span>, <span class="string">&quot;he11o&quot;</span>))</span><br><span class="line">    task2 = asyncio.create_task(say_after(<span class="number">2</span>, <span class="string">&quot;world&quot;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;started at <span class="subst">&#123;time.strftime( <span class="string">&#x27;%x&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">    ret1 = <span class="keyword">await</span> task1</span><br><span class="line">    ret2 = <span class="keyword">await</span> task2</span><br><span class="line">    <span class="built_in">print</span>(ret1)</span><br><span class="line">    <span class="built_in">print</span>(ret2)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;finished at <span class="subst">&#123;time.strftime( <span class="string">&#x27;%x&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p>我们看我们把函数修改了一下，主要就是告诉大家怎么拿到coroutine的 return。那当你要拿这个返回值的时候，一定是一个 variable 等于 await task，而不是一个 variable 等于 task。我们之前强调过， await 有一个功能是把这个 task 或者coroutine的这个返回值拿出来，如果你不用 await 是拿不到这个值的。</p><p>那有的人看到这可能说了，那如果我有很多 task 呢？我有，比如说 10 个task，我就写 10 行 await task 吗？这是不是太蠢了？正因如此， asyncio给我们提供了一个函数叫做gather。我们看 gather 这个函数，它不是一个coroutine，但是它会返回一个叫做 future 的东西，这个 future 也是可以用 await 的，那 gather 这个函数作用，首先它的参数是若干个 coroutine或者task，这俩都可以，甚至可以是future，也就是 gather 的 return 值。它还可以接着gather，那如果是coroutine的话，它首先会把它包装成task，并且注册到 event loop 里，然后它会返回一个 future 值。当你 await 这个 future 的时候，你就相当于告诉 event loop，我要等待这里面每一个 task 都完成，我才可以继续，同时会把这些 task 的 return 值放到一个 list 里，然后返回来。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">say_after</span>(<span class="params">delay, what</span>):</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(delay)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;(what) - <span class="subst">&#123;delay&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;started at <span class="subst">&#123;time.strftime( <span class="string">&#x27;%x&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">    ret = <span class="keyword">await</span> asyncio.gather(say_after(<span class="number">1</span>, <span class="string">&#x27;hello&#x27;</span>),</span><br><span class="line">                               say_after(<span class="number">2</span>, <span class="string">&quot;world&quot;</span>))</span><br><span class="line">    <span class="built_in">print</span>(ret)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;finished at <span class="subst">&#123;time.strftime( <span class="string">&#x27;%x&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p>我们看一下这程序的结果，可以看到这次的这个 return value 是一个list，里面分别是 hello和world，<strong>那么这个 list 顺序和里面 task 的顺序是一致的</strong>，这样呢，我们就不用一个个 task await 了。</p><p>那 gather 还有一个好处就是如果你给的是coroutine的话，它会把每一个coroutine首先都变成task，也就是说我们可以不用自己手动先去建立这些 task 了。我们看一下上述代码结果，可以看到这种方式在拿到了正确的返回值的同时，它也只用了 2 秒。因为 gather 首先把这两个 coroutine 都变成了task，然后在 main 做 await 的时候才把控制权交回给了 event loop，这样 event loop 在分配哪一个 task 可以工作的时候，它就有更多的 task 可以分配了。</p><p>尽管asyncio里面还有不少的功能，但是掌握了这几个，基本上你就理解了asyncio的核心理念了。那我再强调一下前面提到过的几个重点。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>要建立一个 event loop 的概念，上面儿有一个 event loop 作为大脑，下面是若干可执行的task。 task 是没有办法控制 event loop 去执行某一个 task 的，它只能告诉 event loop 说我在等这个task。最终是由 event loop 来决定下面要运行哪个task，而 event loop 一旦开始运行task，就必须要 task 显示的把控制权交还给 event loop。交还控制权的方式由 await 和函数运行完毕。所以尽管我们会说这种协程的方式是并发的，但是同时刻实际上只有一段代码在跑，它只是想办法再利用这些代码中间的等待时间。所以如果你的代码里面并没有等待这件事的话，协程对你的代码是没有帮助的。</li><li>务必分清什么是coroutine，什么是task。 coroutine 只有变成了 task 才开始被执行。要能知道什么时候 coroutine 被隐式的变成了task，在你直接await coroutine 的时候，给你放到 gather 里的时候，你放进去的都是coroutine，但是它们会偷偷把它变成 task 执行coroutine，不变成 task 是没有办法执行的。</li><li>最后拿到一个 coroutine 的返回值是需要用 await 的。一个变量等于 await xxx。</li></ol><p>‍</p><p>‍</p><p>‍</p><p>‍</p><p>‍</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;针对&lt;a href=&quot;https://www.bilibili.com/video/BV1oa411b7c9/?spm_id_from=333.337.search-card.all.click&amp;amp;vd_source=53d8e50bea64</summary>
      
    
    
    
    <category term="Python" scheme="https://guoyujian.github.io/categories/Python/"/>
    
    <category term="异步编程" scheme="https://guoyujian.github.io/categories/Python/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Python" scheme="https://guoyujian.github.io/tags/Python/"/>
    
    <category term="asyncio" scheme="https://guoyujian.github.io/tags/asyncio/"/>
    
    <category term="异步编程" scheme="https://guoyujian.github.io/tags/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统学习资料</title>
    <link href="https://guoyujian.github.io/2023/02/28/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"/>
    <id>https://guoyujian.github.io/2023/02/28/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/</id>
    <published>2023-02-28T14:21:37.000Z</published>
    <updated>2023-02-28T14:23:58.466Z</updated>
    
    <content type="html"><![CDATA[<p>source:<a href="https://gist.github.com/ascrutae/7fbc3681ff6e7f68fc908e196eac980e">https://gist.github.com/ascrutae/7fbc3681ff6e7f68fc908e196eac980e</a></p><script src="https://gist.github.com/ascrutae/7fbc3681ff6e7f68fc908e196eac980e.js"></script><p>source2: <a href="https://zhuanlan.zhihu.com/p/372646991">https://zhuanlan.zhihu.com/p/372646991</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;source:&lt;a href=&quot;https://gist.github.com/ascrutae/7fbc3681ff6e7f68fc908e196eac980e&quot;&gt;https://gist.github.com/ascrutae/7fbc3681ff6e7f68fc908</summary>
      
    
    
    
    <category term="分布式" scheme="https://guoyujian.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="学习路线" scheme="https://guoyujian.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
    
    <category term="分布式" scheme="https://guoyujian.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>思源笔记基本使用</title>
    <link href="https://guoyujian.github.io/2023/02/26/%E6%80%9D%E6%BA%90%E7%AC%94%E8%AE%B0%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>https://guoyujian.github.io/2023/02/26/%E6%80%9D%E6%BA%90%E7%AC%94%E8%AE%B0%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</id>
    <published>2023-02-26T09:49:50.000Z</published>
    <updated>2023-02-26T09:52:22.850Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>思源笔记是一款很好的管理知识库的软件。支持本地（免费）和云端（付费）两种模式。</p><p>不仅支持markdown语法，还有更多实用功能。这里进行基本的使用介绍。</p><h1 id="支持markdown语法"><a href="#支持markdown语法" class="headerlink" title="支持markdown语法"></a>支持markdown语法</h1><p>略</p><h1 id="支持新建多级文档"><a href="#支持新建多级文档" class="headerlink" title="支持新建多级文档"></a>支持新建多级文档</h1><p><img src="image-20230226161146934.png" alt="image-20230226161146934"></p><h1 id="设置标签、笔记图标和题头图"><a href="#设置标签、笔记图标和题头图" class="headerlink" title="设置标签、笔记图标和题头图"></a>设置标签、笔记图标和题头图</h1><p>将鼠标放置到笔记开头，出现的三个icon分别对应，添加标签，设置图标和设置题头图。</p><p><img src="image-20230226161241016.png" alt="image-20230226161241016"></p><p>设置之后的效果为：</p><p><img src="image-20230226161340368.png" alt="image-20230226161340368"></p><h1 id="内容块合并"><a href="#内容块合并" class="headerlink" title="内容块合并"></a>内容块合并</h1><p>内容块是思源的基础。块和块之间可以进行合并等操作。</p><p><img src="1.gif" alt="动画"></p><h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><p>思源笔记可以制作模板，导出导入模板。让笔记标准化。</p><h1 id="挂件"><a href="#挂件" class="headerlink" title="挂件"></a>挂件</h1><p>在【设置】-【集市】-【挂件】中进行下载。</p><p>目前看到比较好用的挂件有</p><ul><li>superdraw： 可以让实现随意涂写的挂件</li><li>drawio：实现画流程图的挂件</li><li>思维导图：可以插入思维导图的挂件</li></ul><p>其他的自行研究。这里以drawio为例。他的效果是这样的。</p><p><img src="image-20230226163445070.png" alt="image-20230226163445070"></p><h1 id="导入pdf并进行阅览"><a href="#导入pdf并进行阅览" class="headerlink" title="导入pdf并进行阅览"></a>导入pdf并进行阅览</h1><p>通过拖拽导入pdf，点击进行阅览</p><p><img src="image-20230226163828335.png" alt="image-20230226163828335"></p><p>不仅如此，在pdf中可以进行选中和标注。将标注作为“引用链接”复制回笔记。点击“引用链接”可以直接打开pdf，并跳转到标注的位置。</p><p><img src="image-20230226164254104.png" alt="image-20230226164254104"></p><h1 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h1><p>直接复制粘贴导出的是markdown格式的内容</p><p>也可以直接选择导出模式，导出不同平台的格式。目前支持知乎、微信公众号等。</p><p><img src="2.gif" alt="动画"></p><h1 id="剪藏"><a href="#剪藏" class="headerlink" title="剪藏"></a>剪藏</h1><p>通过chrome插件进行web页面的笔记剪藏</p><p>类似有道云笔记的功能。</p><p>这里需要对token进行配置。token在【设置】【关于】中查看</p><h1 id="网络图片转到本地"><a href="#网络图片转到本地" class="headerlink" title="网络图片转到本地"></a>网络图片转到本地</h1><p><img src="image-20230226164816361.png" alt="image-20230226164816361"></p><h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><p>当前块可以引用其他笔记的内容，输入两个左括号触发。</p><p>继续输入关键词，选中引用的内容即可。</p><p>鼠标悬浮在引用链接上，可以对引用的内容进行预览。</p><p>具体效果如下。</p><p><img src="3.gif" alt="动画"></p><p>链接分为正向链接和反向连接。</p><p>正向链接就是查看链接引用了哪些内容块</p><p>反向链接就是查看哪些内容块被引用了。</p><p>点击右下角的【反向链接】图标查看</p><p><img src="image-20230226165621640.png" alt="image-20230226165621640"></p><p>在连接中你可以右键输入锚文本修改引用链接的文本</p><p><img src="image-20230226165718183.png" alt="image-20230226165718183"></p><h1 id="闪卡"><a href="#闪卡" class="headerlink" title="闪卡"></a>闪卡</h1><h2 id="制作闪卡"><a href="#制作闪卡" class="headerlink" title="制作闪卡"></a>制作闪卡</h2><p>闪卡用于背诵某些内容。制作闪卡的流程如下。</p><p>标记需要背诵的内容，选择块【添加到卡包】，创建卡包并添加。</p><p><img src="image-20230226170647766.png" alt="image-20230226170647766"></p><p><img src="image-20230226170750105.png" alt="image-20230226170750105"></p><p><img src="image-20230226170852763.png" alt="image-20230226170852763"></p><h2 id="复习闪卡"><a href="#复习闪卡" class="headerlink" title="复习闪卡"></a>复习闪卡</h2><p>选择【闪卡】</p><p><img src="image-20230226170933812.png" alt="image-20230226170933812"></p><p>选择卡包就可以看到待复习的闪卡了。</p><p><img src="image-20230226171010071.png" alt="image-20230226171010071"></p><h1 id="图表"><a href="#图表" class="headerlink" title="图表"></a>图表</h1><p>输入<code>/</code>，选择插入Chart</p><p><img src="image-20230226171217053.png" alt="image-20230226171217053"></p><p>这里输入代码即可插入chart，其格式为echarts的json格式代码。</p><p>这里有两种方式</p><ol><li>使用JS编写图表</li><li>使用<a href="https://tushuo.baidu.com/">百度图说</a>，可视化制作图表，然后复制图表代码。</li></ol><p>这里使用第二种方式。</p><p>进入百度图说，创建图表，修改数据，点击【显示代码】</p><p><img src="image-20230226171700714.png" alt="image-20230226171700714"></p><p>复制代码后粘贴到思源的图标代码中，就可以看到图表啦</p><p><img src="image-20230226171753886.png" alt="image-20230226171753886"></p><h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><p>输入<code>/</code>，选择插入flowchart</p><p>这里支持两种语法格式：</p><ol><li>flowchart.js</li><li>plantUML</li></ol><h1 id="Graphviz"><a href="#Graphviz" class="headerlink" title="Graphviz"></a>Graphviz</h1><p>输入<code>/</code>，选择插入Graphviz</p><p>支持的语法格式为dot语法。具体可以参考<a href="">网站</a>进行绘制。在软件工程、数据库和机器学习方面用的多，效果如下。</p><p><img src="image-20230226172409698.png" alt="image-20230226172409698"></p><h1 id="Mermaid"><a href="#Mermaid" class="headerlink" title="Mermaid"></a>Mermaid</h1><p>输入<code>/</code>，选择插入Mermaid</p><p>Mermaid和Graphviz 类似。Mermaid可以绘制流程图等数十种图。</p><p>打开<a href="https://mermaid.js.org/">官网</a>，选择右上角的【live editor】进行实时编辑。</p><p><img src="image-20230226172909167.png" alt="image-20230226172909167"></p><p>复制代码即可在思源笔记中看到效果</p><p><img src="image-20230226172955029.png" alt="image-20230226172955029"></p><h1 id="MindMap"><a href="#MindMap" class="headerlink" title="MindMap"></a>MindMap</h1><p>mindmap是脑图。</p><p>输入<code>/</code>，选择插入MindMap</p><p>之后进行编辑</p><p><img src="image-20230226173129422.png" alt="image-20230226173129422"></p><h1 id="多媒体"><a href="#多媒体" class="headerlink" title="多媒体"></a>多媒体</h1><p>思源支持多媒体数据的插入，包括视频、链接、iframe</p><p>这里插入一个视频为例：</p><p>输入<code>/</code>，选择插入iframe链接，复制视频url链接。效果如下</p><p><img src="image-20230226173429042.png" alt="image-20230226173429042"></p><h1 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h1><ol><li><a href="https://www.bilibili.com/video/BV1bv4y1r7tA/?spm_id_from=333.788&amp;vd_source=53d8e50bea64fe70bc50c86af86d28e1">https://www.bilibili.com/video/BV1bv4y1r7tA/?spm_id_from=333.788&amp;vd_source=53d8e50bea64fe70bc50c86af86d28e1</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;思源笔记是一款很好的管理知识库的软件。支持本地（免费）和云端（付费）两种模式。&lt;/p&gt;
&lt;p&gt;不仅支持markdown语法，还有更多实用功能</summary>
      
    
    
    
    <category term="工具箱" scheme="https://guoyujian.github.io/categories/%E5%B7%A5%E5%85%B7%E7%AE%B1/"/>
    
    
    <category term="siyuan" scheme="https://guoyujian.github.io/tags/siyuan/"/>
    
    <category term="思源" scheme="https://guoyujian.github.io/tags/%E6%80%9D%E6%BA%90/"/>
    
    <category term="教程" scheme="https://guoyujian.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="知识库工具" scheme="https://guoyujian.github.io/tags/%E7%9F%A5%E8%AF%86%E5%BA%93%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>软件行业就业方向调研</title>
    <link href="https://guoyujian.github.io/2023/02/25/%E8%BD%AF%E4%BB%B6%E8%A1%8C%E4%B8%9A%E5%B0%B1%E4%B8%9A%E6%96%B9%E5%90%91%E8%B0%83%E7%A0%94/"/>
    <id>https://guoyujian.github.io/2023/02/25/%E8%BD%AF%E4%BB%B6%E8%A1%8C%E4%B8%9A%E5%B0%B1%E4%B8%9A%E6%96%B9%E5%90%91%E8%B0%83%E7%A0%94/</id>
    <published>2023-02-25T06:44:32.000Z</published>
    <updated>2023-02-25T06:44:32.469Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>本文调研了目前软件行业的就业方向。用于个人选择合适的就业岗位使用。主要调研了软件行业有哪些就业方向，针对这些方向又调研了</p><ol><li>职位岗位</li><li>目前需求：多还是少，为什么</li><li>前景如何：好还是坏，还是不明；从国内和国外两个角度；未来发展评估</li><li>企业：有哪些企业在做，龙头企业有哪些，从国内外两方面</li><li>细分领域：比如自然语言处理有对话领域blabla</li><li>特点：难度，特点</li><li>技术路线：整理该方向的技术路线图，对该方向的技术栈进行简单介绍</li><li>职业规划：方向职业的前进路线，初级-中级，blabla</li><li>是否利于出国：国外的需求是否更旺盛，是否更容易出国</li></ol><h1 id="调研方式"><a href="#调研方式" class="headerlink" title="调研方式"></a>调研方式</h1><p>本文汇总的软件行业就业方向的调研方式是，通过知乎、bilibili、谷歌、YouTube、微信公众号、GitHub等平台，使用以下几组关键词：【就业、职业】【程序员、码农、软件行业】【方向、前景、规划、赛道】，时间选取近两年，进行搜索，总结相关视频、文章、评论等内容。</p><p>先搜集整理可能的软件行业方向，再根据将这些软件行业方向作为关键词，二次搜索。</p><p>PS由于国内广告太多，很多话都不太可信。。</p><h1 id="开发方向-前端"><a href="#开发方向-前端" class="headerlink" title="开发方向-前端"></a>开发方向-前端</h1><h2 id="职位岗位"><a href="#职位岗位" class="headerlink" title="职位岗位"></a>职位岗位</h2><p>无</p><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>和后端差不多。</p><h2 id="前景"><a href="#前景" class="headerlink" title="前景"></a>前景</h2><blockquote><p>Web这种还是挺有生命力的，但是，一切都是在变化，有可能若干年后一个技术变革，Web就丧失优势变得门可罗雀了，所以呢，各位同仁，要有心理准备。</p></blockquote><p>同质化</p><h2 id="企业"><a href="#企业" class="headerlink" title="企业"></a>企业</h2><p>不局限于互联网，但是互联网的技术更新，更有竞争力。</p><h2 id="应用领域"><a href="#应用领域" class="headerlink" title="应用领域"></a>应用领域</h2><p>主要是移动端、PC端的前端开发，还有游戏，后端（NodeJS）以及其他（桌面端）</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li>越来越工具化、工程化</li><li>知识琐碎，门槛低</li><li>出效果快、激励周期短</li></ol><h2 id="技术路线"><a href="#技术路线" class="headerlink" title="技术路线"></a>技术路线</h2><p><img src="png-FrontEnd-by-StuQ.png" alt="png-FrontEnd-by-StuQ.png"></p><p>前端发展经历了三个阶段:</p><ol><li>原生html、js、css</li><li>封装库、jquery</li><li>组件化开发：node</li></ol><h2 id="职业规划"><a href="#职业规划" class="headerlink" title="职业规划"></a>职业规划</h2><div class="table-container"><table><thead><tr><th>职称</th><th>职责</th><th>年限(仅供参考)</th></tr></thead><tbody><tr><td>初级工程师</td><td>能在导师的帮助(详细设计, 关键点实现)下完成简单任务</td><td>0</td></tr><tr><td>中级工程师(开发)</td><td>能在导师的协助(概要设计, 关键点说明)下<strong>独立完成</strong>复杂任务</td><td>1+</td></tr><tr><td>高级工程师(研发)</td><td><strong>能高质量高效率地独立完成任务</strong></td><td>5+</td></tr><tr><td>资深/首席/专家/架构</td><td>全局观, 既有广度又有深度, 在某个专业领域有一席之地</td><td>8+</td></tr></tbody></table></div><h2 id="出国"><a href="#出国" class="headerlink" title="出国"></a>出国</h2><p>无</p><h1 id="开发方向-后端"><a href="#开发方向-后端" class="headerlink" title="开发方向-后端"></a>开发方向-后端</h1><h2 id="职位岗位-1"><a href="#职位岗位-1" class="headerlink" title="职位岗位"></a>职位岗位</h2><p>根据语言不同分为很多，例如，Java、Go等。</p><p>去某公司做后端开发，不一定对他们用到的语言和框架很熟练，会其中一部分就够了，很多都是在工作中学的。</p><h2 id="需求-1"><a href="#需求-1" class="headerlink" title="需求"></a>需求</h2><p>前后端差不多。</p><h2 id="前景-1"><a href="#前景-1" class="headerlink" title="前景"></a>前景</h2><p>随时间变化很大。目前不明。</p><h2 id="企业-1"><a href="#企业-1" class="headerlink" title="企业"></a>企业</h2><p>不局限于互联网，但是互联网的技术更新，更有竞争力。</p><h2 id="应用领域-1"><a href="#应用领域-1" class="headerlink" title="应用领域"></a>应用领域</h2><p>领域广泛。</p><h2 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h2><ol><li>注重功能性和稳定性</li><li>门类分支多：业务、算法、架构。。。</li><li>难以学深，容易瓶颈。这主要是小公司业务量不够&amp;大公司构建技术壁垒，小公司的后端开发容易和大公司拉开差距</li><li>后端的工作范畴很广：设计api、架构、数据库、业务逻辑、高可用等</li><li>非常考验《系统设计》的能力</li></ol><h2 id="RoadMap"><a href="#RoadMap" class="headerlink" title="RoadMap"></a>RoadMap</h2><p>以Java为例</p><p>图片来源：<a href="https://github.com/s4kibs4mi/java-developer-roadmap/blob/master/i18n/zh-CN/ReadMe-zh-CN.md">https://github.com/s4kibs4mi/java-developer-roadmap/blob/master/i18n/zh-CN/ReadMe-zh-CN.md</a></p><p><img src="java-developer-roadmap-zh-CN.png" alt="Roadmap"></p><h2 id="出国-1"><a href="#出国-1" class="headerlink" title="出国"></a>出国</h2><p>无</p><h1 id="小结：前端后端对比"><a href="#小结：前端后端对比" class="headerlink" title="小结：前端后端对比"></a>小结：前端后端对比</h1><h2 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h2><p>需求、工资、前景都差不多</p><p>职业发展规划差不多</p><div class="table-container"><table><thead><tr><th>职称</th><th>职责</th><th>年限(仅供参考)</th></tr></thead><tbody><tr><td>初级工程师</td><td>能在导师的帮助(详细设计, 关键点实现)下完成简单任务</td><td>0</td></tr><tr><td>中级工程师(开发)</td><td>能在导师的协助(概要设计, 关键点说明)下<strong>独立完成</strong>复杂任务</td><td>1+</td></tr><tr><td>高级工程师(研发)</td><td><strong>能高质量高效率地独立完成任务</strong></td><td>5+</td></tr><tr><td>资深/首席/专家/架构</td><td>全局观, 既有广度又有深度, 在某个专业领域有一席之地</td><td>8+</td></tr></tbody></table></div><h2 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h2><blockquote><p><strong>后端要学的技术太多了</strong>，而前端相对来说就少多了，压力自然少很多，而且后端也需要学一些前端技术，有的公司就有这样的需求，考虑到地中海干涸问题，肯定选前端，而且对于后面的发展，比如<strong>转型走管理架构什么的，前端基本没有优势</strong>。但是由于<strong>前端技术难度和学习成本不是太大</strong>，而且随着经验积累，即便到了四十多岁也可以继续开发，而后端再继续撸代码就难多了，因为本来前端逻辑代码不是太多，即便是使用node做前后端分离，前端复杂逻辑也不是太多，而且前端现在有很多脚手架和插件，都可以直接拿来用。而后端就不一样了，性能，并发，算法，各种优化，服务器问题等等，都是后端考虑的，虽然随着各种技术的出现，现在后端也开发没有以前费劲了，但是要知道底层原理和源码你还是要去翻，各种问题还是主要在后端这解决的。</p></blockquote><p>评论：</p><p>前端四十多岁也可以继续开发，存疑。随着前端技术的发展，也可能技术难度up，四十多岁不能继续开发。</p><h2 id="怎么选"><a href="#怎么选" class="headerlink" title="怎么选"></a>怎么选</h2><ul><li>兴趣、现状：你了解哪个多一点就选哪个</li><li>职业背景</li><li>年龄</li></ul><h1 id="开发方向-全栈"><a href="#开发方向-全栈" class="headerlink" title="开发方向-全栈"></a>开发方向-全栈</h1><h2 id="RoadMap-1"><a href="#RoadMap-1" class="headerlink" title="RoadMap"></a>RoadMap</h2><p>来源：<a href="https://github.com/easychen/stack-roadmap">https://github.com/easychen/stack-roadmap</a></p><p><img src="方糖全栈路线图.jpg" alt="img"></p><h2 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h2><p>最大特点就是，<strong>难度高</strong></p><p>特点之二是，美国全栈岗位多，后面再根据个人细分领域。<strong>可能利于出国</strong>。</p><p><strong>不适合应届生</strong></p><p>依据是2019年stack-overflow的调查问卷，程序员岗位分布：</p><p><img src="image-20230223000029-erjot3z.png" alt="image"></p><h1 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h1><p>翻译过来叫质量保证，在国外主要指的是测试，tester。在国内还有另一种不同于测试的质量保证。这点需要注意，招聘时的QA究竟指的是质量保证还是测试工程师。</p><h2 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h2><ol><li>分成两种，手工测试和自动化测试。</li><li>自动化测试需要写代码，需要懂一两门自动化测试语言和框架。</li><li>手工测试，对开发能力和写代码能力没有要求，但是需要有开发的经验。这类岗位基本被淘汰掉了。</li></ol><h2 id="RoadMap-2"><a href="#RoadMap-2" class="headerlink" title="RoadMap"></a>RoadMap</h2><p><a href="https://github.com/yangzige/qa-roadmap/blob/main/roadmap/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF.md">https://github.com/yangzige/qa-roadmap/blob/main/roadmap/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF.md</a></p><h1 id="人工智能-CV方向"><a href="#人工智能-CV方向" class="headerlink" title="人工智能-CV方向"></a>人工智能-CV方向</h1><p>2015-2020是黄金期，找工作比较容易。2020以后赚钱的业务挖掘的差不多了，<strong>对学历和论文的要求高</strong>。</p><p>CV岗位比开发岗<strong>少很多</strong>。</p><h2 id="前景-2"><a href="#前景-2" class="headerlink" title="前景"></a>前景</h2><p>今后会走向“平衡”。人话就是不温不火</p><h2 id="应用领域-2"><a href="#应用领域-2" class="headerlink" title="应用领域"></a>应用领域</h2><p><img src="640.png" alt="图片"></p><ul><li>自动驾驶领域：比较火</li><li>工业视觉领域：应用潜力大</li><li>智慧医疗：有前景但比较困难</li></ul><h2 id="RoadMap-3"><a href="#RoadMap-3" class="headerlink" title="RoadMap"></a>RoadMap</h2><p>没找到比较好的。基本就是Python、PyTorch、数字图象处理，深度学习那一套。。</p><h1 id="人工智能-NLP方向"><a href="#人工智能-NLP方向" class="headerlink" title="人工智能-NLP方向"></a>人工智能-NLP方向</h1><blockquote><p>自然语言处理(<em>NLP</em>)是人工智能技术的王冠，它推动着当代科技的持续发展和重大突破，并越来越多地应用于各行各业；它有着十分重要的实用价值，也有着革命性的理论</p></blockquote><h2 id="前景-3"><a href="#前景-3" class="headerlink" title="前景"></a>前景</h2><p>前景广阔。之前比较卷，现在因为ChatGPT的出现，续了一口气</p><h2 id="应用领域-3"><a href="#应用领域-3" class="headerlink" title="应用领域"></a>应用领域</h2><p>对话、问答。</p><h2 id="RoadMap-4"><a href="#RoadMap-4" class="headerlink" title="RoadMap"></a>RoadMap</h2><p><a href="https://github.com/graykode/nlp-roadmap">https://github.com/graykode/nlp-roadmap</a></p><h1 id="人工智能-其他"><a href="#人工智能-其他" class="headerlink" title="人工智能-其他"></a>人工智能-其他</h1><p>人工智能还包括其他方向，例如推荐算法。</p><h1 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h1><h2 id="职位岗位-2"><a href="#职位岗位-2" class="headerlink" title="职位岗位"></a>职位岗位</h2><p>大数据是一个比较笼统的方向，既可以做大数据开发方向，也可以做数据挖掘等算法方向，也有商业智能BI。。。</p><p>具体方向有以下：</p><ol><li>ETL/数仓工程师：负责数仓建设，偏脚本开发以及SQL开发。</li><li>大数据开发工程师：负责数据计算，偏离线。实时代码开发。</li><li>大数据分析师：负责数据挖掘分析、偏业务分析/SQL</li><li>大数据算法工程师：算法建模、基于人工智能建模。往往是和推荐算法相关。</li><li>大数据BI工程师：偏报表和SQL开发。</li></ol><p>不同方向的学习路线和技能都有所不同。</p><h2 id="需求-2"><a href="#需求-2" class="headerlink" title="需求"></a>需求</h2><p>没有Java那么卷，但是岗位也没有那么多。</p><h2 id="前景-4"><a href="#前景-4" class="headerlink" title="前景"></a>前景</h2><h2 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h2><ol><li>大数据开发需要学习的组件非常多。也比较难。</li><li>ETL/数仓的工作比较基础。</li><li>大数据分析和算法主要偏算法相关。</li></ol><h2 id="RoadMap-5"><a href="#RoadMap-5" class="headerlink" title="RoadMap."></a>RoadMap.</h2><p>学习可以从SQL入手。</p><p><a href="https://github.com/TeamStuQ/skill-map/blob/master/data/map-BigDataEngineer.md">https://github.com/TeamStuQ/skill-map/blob/master/data/map-BigDataEngineer.md</a></p><h2 id="一篇有用的文章"><a href="#一篇有用的文章" class="headerlink" title="一篇有用的文章"></a>一篇有用的文章</h2><p>想学大数据，大数据开发以后的前景怎么样，家里人对这方面了解不深，不太同意转行？ - 云原生研习社的回答 - 知乎 <a href="https://www.zhihu.com/question/509912345/answer/2664371834">https://www.zhihu.com/question/509912345/answer/2664371834</a></p><h1 id="UX-UI"><a href="#UX-UI" class="headerlink" title="UX/UI"></a>UX/UI</h1><p>UX是User Experience（用户体验）的缩写，指的是围绕用户，以用户在使用过程中的主观感受为出发点，力求更简单高效地满足用户需求。 UX设计师的职责简单来说就是为用户设计友好的产品体验，他更关注产品的易用性、实用性、高效性及价值体现。</p><p>UI的全名是User Interface，中文是「使用者介面」的意思。介面指的是APP、網頁等，可以與使用者互動的媒介。如同字面上的意思，UI著重的是使用者介面的呈現，如：視覺美感、設計美學、便利性、風格呈現，細節更包含了字型、字體大小、顏色、標誌、按鍵、動畫效果等。UI的呈現，會影響到使用者的使用感受，以及順暢性。</p><p>其他略。</p><h1 id="数据采集"><a href="#数据采集" class="headerlink" title="数据采集"></a>数据采集</h1><p>爬虫方向。不想说。。</p><h1 id="数据挖掘"><a href="#数据挖掘" class="headerlink" title="数据挖掘"></a>数据挖掘</h1><blockquote><p>广义上说，任何从数据库中挖掘信息的过程都叫做数据挖掘。从这点看来，数据挖掘就是BI（商业智能）。但从技术术语上说，数据挖掘(Data Mining)特指的是：源数据经过清洗和转换等成为适合于挖掘的数据集。数据挖掘在这种具有固定形式的数据集上完成知识的提炼，最后以合适的知识模式用于进一步分析决策工作。从这种狭义的观点上，我们可以定义：数据挖掘是从特定形式的数据集中提炼知识的过程。数据挖掘往往针对特定的数据、特定的问题，选择一种或者多种挖掘算法，找到数据下面隐藏的规律，这些规律往往被用来预测、支持决策。</p></blockquote><p>可以放到大数据的数据挖掘的相关岗位来看。</p><h2 id="应用领域-4"><a href="#应用领域-4" class="headerlink" title="应用领域"></a>应用领域</h2><p>情报检索、数据分析、模式识别</p><h1 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h1><p>可以放到大数据的数据存储的相关岗位来看。</p><p>主要研究各种数据库存储。</p><h2 id="有用的文章"><a href="#有用的文章" class="headerlink" title="有用的文章"></a>有用的文章</h2><p><a href="https://github.com/wx-chevalier/Database-Series">https://github.com/wx-chevalier/Database-Series</a></p><h1 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h1><h2 id="前景-5"><a href="#前景-5" class="headerlink" title="前景"></a>前景</h2><p>前景很好。</p><h2 id="有用的文章-1"><a href="#有用的文章-1" class="headerlink" title="有用的文章"></a>有用的文章</h2><p><a href="https://github.com/LiuBoyu/blockchain">https://github.com/LiuBoyu/blockchain</a></p><p><a href="https://github.com/xianfeng92/Love-Ethereum">https://github.com/xianfeng92/Love-Ethereum</a></p><h2 id="应用领域-5"><a href="#应用领域-5" class="headerlink" title="应用领域"></a>应用领域</h2><p>区块链+物联网</p><h1 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h1><p>略，不感兴趣。但是和区块链息息相关。</p><h1 id="游戏开发"><a href="#游戏开发" class="headerlink" title="游戏开发"></a>游戏开发</h1><h1 id="VR"><a href="#VR" class="headerlink" title="VR"></a>VR</h1><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="素质要求"><a href="#素质要求" class="headerlink" title="素质要求"></a>素质要求</h2><p>这部分是除了细分方向之外的，对软件行业从业者的共同要求：</p><ol><li>涉猎其它领域的专业知识，丰富自己的知识体系、提高自己的综合素质，争取在自己的专业领域有所积累，然后再做扩展。<strong>不要把自己的知识体系局限于自己的岗位上</strong></li><li><strong>终身学习</strong></li><li>技术观：不要排斥其他技术</li><li>产品观：有产品常识</li><li>数据观：对数据敏感</li><li>知其然知其所以然，会使用轮子，也要研究轮子。</li></ol><h2 id="美国硕士博士CS专业分类"><a href="#美国硕士博士CS专业分类" class="headerlink" title="美国硕士博士CS专业分类"></a>美国硕士博士CS专业分类</h2><p><img src="image-20230223090322289.png" alt="image-20230223090322289"></p><p><img src="image-20230223090346670.png" alt="image-20230223090346670"></p><h2 id="计算机科学的主要分支"><a href="#计算机科学的主要分支" class="headerlink" title="计算机科学的主要分支"></a>计算机科学的主要分支</h2><p><img src="815c0d5aed01530b7cf11d0c9061ec70.png" alt="815c0d5aed01530b7cf11d0c9061ec70.png"></p><h1 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h1><p>这篇文章非常浅薄，没有仔细分析各个行业的现状和情况。只是罗列了一些资料。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h1&gt;&lt;p&gt;本文调研了目前软件行业的就业方向。用于个人选择合适的就业岗位使用。主要调研了软件行业有哪些就业方向，针对这些方向又调研了&lt;/p&gt;
&lt;ol&gt;
</summary>
      
    
    
    
    <category term="软件行业" scheme="https://guoyujian.github.io/categories/%E8%BD%AF%E4%BB%B6%E8%A1%8C%E4%B8%9A/"/>
    
    
  </entry>
  
  <entry>
    <title>Visual Attention Network</title>
    <link href="https://guoyujian.github.io/2023/02/04/Visual-Attention-Network/"/>
    <id>https://guoyujian.github.io/2023/02/04/Visual-Attention-Network/</id>
    <published>2023-02-04T03:31:37.000Z</published>
    <updated>2023-02-04T03:55:16.229Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是论文《Visual Attention Network》的学习笔记</p><p>我在该模型上执行一个分类任务，发现该模型的效果要优于我实验的其他模型（包括resnet50、densenet121、efficientNet-b0、swin-tiny）</p><p>所以在此记录一下，笔记大多是抄的，出处在Refs上表明，如有侵权请联系我。</p><p><a href="https://arxiv.org/abs/2202.09741">论文地址</a>   <a href="https://github.com/Visual-Attention-Network">代码地址</a></p></blockquote><p>‍</p><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="自注意力机制"><a href="#自注意力机制" class="headerlink" title="自注意力机制"></a>自注意力机制</h2><p><a href="https://zhuanlan.zhihu.com/p/265108616">Attention注意力机制与self-attention自注意力机制</a></p><p><a href="https://www.jiqizhixin.com/articles/100902">什么是自注意力机制？</a></p><h2 id="空间相关性和通道相关性1"><a href="#空间相关性和通道相关性1" class="headerlink" title="空间相关性和通道相关性1"></a>空间相关性和通道相关性<sup><a href="#fn_1" id="reffn_1">1</a></sup></h2><p>从维度的角度看，卷积核可以看成是一个空间维(宽和高)和通道维的组合，而<strong>卷积操作则可以视为空间相关性和通道相关性的联合映射</strong>。从inception的1x1卷积来看，<strong>卷积中的空间相关性和通道相关性是可以解耦的，将它们分开进行映射，可能会达到更好的效果。</strong></p><p>深度可分离卷积是在1x1卷积基础上的一种创新。主要包括两个部分：深度卷积和1x1卷积。深度卷积的目的在于对输入的每一个通道都单独使用一个卷积核对其进行卷积，也就是通道分离后再组合。1x1卷积的目的则在于加强深度。下面以一个例子来看一下深度可分离卷积。</p><p>假设我们用128个$3 \times3 \times3$的滤波器对一个 $7 \times7 \times3$的输入进行卷积，可得到$5 \times5 \times128$的输出,其计算量为$5 \times5 \times128 \times3 \times3 \times3=86400$。如下图所示：</p><p><img src="image-20230204110644-zz7yeyj.png" alt="image">​</p><p>现在看如何使用深度可分离卷积来实现同样的结果。深度可分离卷积的第一步是深度卷积。这里的深度卷积，就是分别用3个$3 \times3 \times1$的滤波器对输入的3个通道分别做卷积，也就是说要做3次卷积，每次卷积都有一个$5 \times5 \times1$的输出，组合在一起便是$5 \times5 \times3$的输出。现在为了拓展深度达到128，我们需要执行深度可分离卷积的第二步：1x1卷积。现在我们用128个$1 \times1 \times3$的滤波器对$5 \times5 \times3$进行卷积，就可以得到$5 \times5 \times128$的输出。完整过程如下图所示：</p><p><img src="image-20230204111234-3ia5cu3.png" alt="image">​</p><p>那么我们来看一下深度可分离卷积的计算量如何。第一步深度卷积的计算量：$5 \times5 \times1 \times3 \times3 \times1 \times3=675$。第二步1x1卷积的计算量：$5 \times5 \times128 \times1 \times1 \times3=9600$，合计计算量为10275次。可见，相同的卷积计算输出，深度可分离卷积要比常规卷积节省12倍的计算成本。</p><blockquote><p>典型的应用深度可分离卷积的网络模型包括xception和mobilenet等。本质上而言，xception就是应用了深度可分离卷积的inception网络。</p></blockquote><h1 id="正文2"><a href="#正文2" class="headerlink" title="正文2"></a>正文<sup><a href="#fn_2" id="reffn_2">2</a></sup></h1><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>图像的二维性质给在计算机视觉中应用自注意力带来了三个挑战：</p><ol><li>将图像处理为一维序列，忽略了其二维结构。</li><li>二次复杂度对于高分辨率的图像来说太贵了。</li><li>它只捕捉了空间适应性，而忽略了通道适应性</li></ol><p>在本文中，作者提出了一种新的大核注意(LKA)模块，以使自注意的自适应和长程相关，同时避免了上述问题。作者进一步介绍了一种基于LKA的新的神经网络，即视觉注意网络(VAN)。VAN虽然非常简单和高效，但在包括图像分类、目标检测、语义分割、实例分割等广泛的实验中，它以很大的优势优于最先进的transfomer和卷积神经网络。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="LCK"><a href="#LCK" class="headerlink" title="LCK"></a>LCK</h3><p>卷积神经网络(CNNs)利用局部上下文信息和平移不变性，大大提高了神经网络的效率。自AlexNet以来，cnn迅速成为计算机视觉的主要主流框架。为了进一步提高效率，研究人员投入了大量的精力，使cnn成为更深的和更轻的。作者的工作与MobileNet有相似之处，MobileNet将标准卷积解耦为两部分，即深度卷积和逐点卷积(也就是1×1Conv)。作者的方法将卷积分解为三个部分：深度卷积、深度空洞卷积和逐点卷积。得益于这种分解，作者的方法更适合于有效地分解大的核卷积。作者还在该方法中引入了注意机制来获得自适应特性。</p><p><img src="v2-467f001629900492069a79a14d2dc757_720w.webp" alt="img"></p><p>彩色网格表示卷积核的位置，黄色网格表示中心点。从图中可以看出，13×13卷积分解为5×5深度卷积，5×5深度空洞卷积，膨胀速率3和1×1卷积</p><p><img src="v2-d22b7728ed41dd3491530ad8a94fbe19_720w.webp" alt="img"></p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">class AttentionModule(nn.Module):</span><br><span class="line">    def __init__(self, dim):</span><br><span class="line">        super().__init__()</span><br><span class="line">        self.conv0 = nn.Conv2d(dim, dim, 5, padding=2, groups=dim)#深度卷积</span><br><span class="line">        self.conv_spatial = nn.Conv2d(dim, dim, 7, stride=1, padding=9, groups=dim, dilation=3)#深度空洞卷积</span><br><span class="line">        self.conv1 = nn.Conv2d(dim, dim, 1)#逐点卷积</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def forward(self, x):</span><br><span class="line">        u = x.clone()        </span><br><span class="line">        attn = self.conv0(x)</span><br><span class="line">        attn = self.conv_spatial(attn)</span><br><span class="line">        attn = self.conv1(attn)</span><br><span class="line"></span><br><span class="line">        return u * attn   #注意力操作</span><br><span class="line">     </span><br><span class="line">class SpatialAttention(nn.Module):</span><br><span class="line">    def __init__(self, d_model):</span><br><span class="line">        super().__init__()</span><br><span class="line"></span><br><span class="line">        self.proj_1 = nn.Conv2d(d_model, d_model, 1)</span><br><span class="line">        self.activation = nn.GELU()</span><br><span class="line">        self.spatial_gating_unit = AttentionModule(d_model)  #注意力操作</span><br><span class="line">        self.proj_2 = nn.Conv2d(d_model, d_model, 1)</span><br><span class="line"></span><br><span class="line">    def forward(self, x):</span><br><span class="line">        shorcut = x.clone()</span><br><span class="line">        x = self.proj_1(x)</span><br><span class="line">        x = self.activation(x)</span><br><span class="line">        x = self.spatial_gating_unit(x)  #注意力操作</span><br><span class="line">        x = self.proj_2(x)</span><br><span class="line">        x = x + shorcut   #残差连接</span><br><span class="line">        return x</span><br><span class="line"></span><br><span class="line">class Block(nn.Module):</span><br><span class="line">    def __init__(self, dim, mlp_ratio=4., drop=0.,drop_path=0., act_layer=nn.GELU):</span><br><span class="line">        super().__init__()</span><br><span class="line">        self.norm1 = nn.BatchNorm2d(dim)</span><br><span class="line">        self.attn = SpatialAttention(dim)</span><br><span class="line">        self.drop_path = DropPath(drop_path) if drop_path &gt; 0. else nn.Identity()</span><br><span class="line"></span><br><span class="line">        self.norm2 = nn.BatchNorm2d(dim)</span><br><span class="line">        mlp_hidden_dim = int(dim * mlp_ratio)</span><br><span class="line">        self.mlp = Mlp(in_features=dim, hidden_features=mlp_hidden_dim, act_layer=act_layer, drop=drop)</span><br><span class="line">        layer_scale_init_value = 1e-2            </span><br><span class="line">        self.layer_scale_1 = nn.Parameter(</span><br><span class="line">            layer_scale_init_value * torch.ones((dim)), requires_grad=True)</span><br><span class="line">        self.layer_scale_2 = nn.Parameter(</span><br><span class="line">            layer_scale_init_value * torch.ones((dim)), requires_grad=True)</span><br><span class="line"></span><br><span class="line">        self.apply(self._init_weights)</span><br><span class="line"></span><br><span class="line">    def _init_weights(self, m):</span><br><span class="line">        if isinstance(m, nn.Linear):</span><br><span class="line">            trunc_normal_(m.weight, std=.02)</span><br><span class="line">            if isinstance(m, nn.Linear) and m.bias is not None:</span><br><span class="line">                nn.init.constant_(m.bias, 0)</span><br><span class="line">        elif isinstance(m, nn.LayerNorm):</span><br><span class="line">            nn.init.constant_(m.bias, 0)</span><br><span class="line">            nn.init.constant_(m.weight, 1.0)</span><br><span class="line">        elif isinstance(m, nn.Conv2d):</span><br><span class="line">            fan_out = m.kernel_size[0] * m.kernel_size[1] * m.out_channels</span><br><span class="line">            fan_out //= m.groups</span><br><span class="line">            m.weight.data.normal_(0, math.sqrt(2.0 / fan_out))</span><br><span class="line">            if m.bias is not None:</span><br><span class="line">                m.bias.data.zero_()</span><br><span class="line"></span><br><span class="line">    def forward(self, x):</span><br><span class="line">        x = x + self.drop_path(self.layer_scale_1.unsqueeze(-1).unsqueeze(-1) * self.attn(self.norm1(x)))#drop_path分支中，每个batch有概率使样本在self.attn或者mlp不会”执行“，会以0直接传递。</span><br><span class="line">        x = x + self.drop_path(self.layer_scale_2.unsqueeze(-1).unsqueeze(-1) * self.mlp(self.norm2(x)))</span><br><span class="line">        return </span><br></pre></td></tr></table></figure><p>作者提出对大核卷积操作进行分解来捕获长程关系。大核卷积可分为三个部分：空间局部卷积（深度卷积）、空间远程卷积（深度空洞卷积）和通道卷积（1×1卷积）。所以，可以将K×K卷积分解为K/d×K/d的深度空洞卷积，(2d−1)×(2d−1)的深度卷积和1×1卷积。通过上述分解，可以用轻微的计算代价和参数来捕获长程关系。在得到长程关系后，可以估计一个点的重要性并生成注意力图。</p><p><img src="v2-f2a083b057051de4ae3a87fd77138a8e_720w.webp" alt="img"></p><p><img src="v2-6109ccc0466efee70bf7ac2324513a09_720w.webp" alt="img"></p><p>作者提出的LKA结合了卷积和自注意力的优点。它考虑了局部上下文信息、大的感受野和动态过程。此外，LKA不仅实现了空间维度的自适应性，而且还实现了通道维度的自适应性。值得注意的是，在深度神经网络中，不同的通道往往代表不同的对象，而通道维度的适应性对视觉任务也很重要。</p><h3 id="VAN"><a href="#VAN" class="headerlink" title="VAN"></a>VAN</h3><p>VAN具有简单的层次结构，即输出空间分辨率降低的四个阶段序列，分别为H/4×W/4、H/8×W/8、H/16×W/16和H/32×W/32。H和W是输入图像的高度和宽度。随着分辨率的降低，输出通道的数量也在不断增加。输出通道Ci的变化如下表所示。 首先对输入值进行下采样，并使用步幅数来控制下采样率。下采样后，一个stage中的所有层保持相同的输出大小，即空间分辨率和通道数量。然后，批量归一化、GELU激活函数、大核注意和卷积前馈网络依次堆叠，提取特征。最后，在每个阶段结束时应用一个层归一化。根据参数和计算成本，设计了 VAN-Tiny, VAN-Small, VAN-Base and VAN-Large四种结构。</p><p><img src="v2-9c29743630133af223ffb0b9d3c592f0_720w.webp" alt="img"></p><p><img src="v2-f3d5e05ccc5b5d1691c26fc3d8daafcd_720w.webp" alt="img"></p><p>对21×21卷积的不同方式参数的比较。X，Y和our分别提供了标准卷积，mobilenet]和van的分解。输入和输出具有相同大小的H×W×C</p><p><img src="v2-f39da3202b78c90cd02669ff5039e8a9_720w.webp" alt="img"></p><p>默认情况下，本文的LKA采用5×5深度卷积，7×7深度卷积与膨胀率为3的空洞卷积和1×1卷积来近似21×21卷积。在这种设置下，VAN可以有效地获取局部信息和长程联系。作者分别使用7×7和3×3步幅卷积进行4×和2×的降采样。</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>作者在ImageNet-1K图像分类数据集、COCO目标检测数据集和ADE20K语义分割数据集上进行了定量实验。此外，作者通过在ImageNet验证集上使用Grad-CAM来可视化类激活映射(CAM)。</p><h3 id="图像分类"><a href="#图像分类" class="headerlink" title="图像分类"></a>图像分类</h3><p><img src="https://pic2.zhimg.com/80/v2-2fefbe89e8e7da997c3683528fbb2535_720w.webp" alt="img"></p><p>VAN与其他mlp、cnn和ViTs的比较。VAN优于其他参数相似，计算成本相似的cnn(ResNet[29]，ResNeXt[90]，ConvNeXt[53]等)，ViTs(DeiT[74]、PVT[83]、Swin-Transformer[52]等)和MLPs(MLP-Mixer[72]，ResMLP[73]，gMLP[46]等)。作者在每个类别中选择了一个具有代表性的网络进行讨论。ConvNeXt[53]是一种特殊的CNN，它吸收了vit的一些优势，如大的感受野（7×7卷积）和先进的训练策略(300个epoch、数据增强等)。VAN和ConvNeXt[53]相比，VAN-base比CoNvNeXt-t多出0.7%(82.8%vs.82.1%)，因为VAN具有更大的感受域和自适应能力。Swin-Transformer是一种著名的ViT变体，采用局部注意力和移动窗口的方式。由于VAN对二维结构信息非常友好，具有较大的感受野，并在通道维度上实现了自适应性，VAN-Base超过Swin-T1.5%(82.8%vs.81.3%)。对于MLPs，选择gMLP[46]。VAN-Base超过gMLP-S[46]3.2%(82.8%vs.79.6%)。也可以看出，在小型模型上面VAN的表现更加出色。</p><h3 id="目标检测"><a href="#目标检测" class="headerlink" title="目标检测"></a>目标检测</h3><p><img src="v2-c04b7aef7af9212da50e947198ea0179_720w.webp" alt="img"></p><p><img src="v2-ac6fd9136c34fa6ebfce940f20b6a318_720w.webp" alt="img"></p><p><img src="v2-f0a76550ee33afe78ff4d4458f544c25_720w.webp" alt="img"></p><h3 id="语义分割"><a href="#语义分割" class="headerlink" title="语义分割"></a>语义分割</h3><p><img src="v2-5675289d453da40b8f33f28c1966aa44_720w.webp" alt="img"></p><h3 id="消融实验"><a href="#消融实验" class="headerlink" title="消融实验"></a>消融实验</h3><p><img src="v2-1f9970a60d196d053e6433e7bbcca814_720w.webp" alt="img"></p><p>DW-D-Conv提供了深度空洞卷积，这在捕获LKA中的长程依赖性中发挥了作用。</p><p>DW-Conv可以利用图像的局部上下文信息。</p><p>注意力机制的引入可以看作是使网络实现了自适应特性。受益于此，VAN-Tiny实现了约1.1%（74.3%对75.4%）的改善。</p><p>1×1Conv捕获了通道维度中的关系。结合注意机制，引入了通道维度的自适应性。提高了0.8%(74.1%vs.75.4%)，证明了通道维度自适应性的必要性。</p><h3 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h3><p><img src="v2-84a72be357178fade018043de0213190_720w.webp" alt="img"></p><p>可视化结果。所有的图像都来自于ImageNet验证集中的不同类别。CAM采用VAN-Base模型和Grad-CAM产生。左：原始图像，右：类激活图</p><p>结果显示，VAN-Base可以清晰地聚焦于目标对象。因此，可视化直观地证明了VAN的有效性。</p><p>‍</p><h1 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h1><blockquote id="fn_1"><sup>1</sup>. <a href="https://baidinghub.github.io/2020/04/03/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9F%A5%E8%AF%86%E7%B3%BB%E5%88%97%28%E4%BA%8C%29%20%E5%90%84%E7%A7%8D%E5%8D%B7%E7%A7%AF%E5%BD%A2%E5%BC%8F/">深度学习知识系列(二) 各种卷积形式</a><a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a></blockquote><blockquote id="fn_2 "><sup>2 </sup>. <a href="https://zhuanlan.zhihu.com/p/474526444">【ARXIV2202】Visual Attention Network</a><a href="#reffn_2 " title="Jump back to footnote [2 ] in the text."> &#8617;</a></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文是论文《Visual Attention Network》的学习笔记&lt;/p&gt;
&lt;p&gt;我在该模型上执行一个分类任务，发现该模型的效果要优于我实验的其他模型（包括resnet50、densenet121、efficientNet-b0、swin-t</summary>
      
    
    
    
    <category term="深度学习" scheme="https://guoyujian.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="深度学习" scheme="https://guoyujian.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="计算机视觉" scheme="https://guoyujian.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
  </entry>
  
  <entry>
    <title>Spring AOP Demo</title>
    <link href="https://guoyujian.github.io/2022/12/04/Spring-AOP-Demo/"/>
    <id>https://guoyujian.github.io/2022/12/04/Spring-AOP-Demo/</id>
    <published>2022-12-04T07:17:15.000Z</published>
    <updated>2022-12-04T07:21:08.814Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文不涉及Spring AOP原理</p></blockquote><h1 id="Spring-AOP-简介"><a href="#Spring-AOP-简介" class="headerlink" title="Spring AOP 简介"></a>Spring AOP 简介</h1><p>面向切面编程（AOP）是 Spring 最为重要的功能之一了，在数据库事务中切面编程被广泛使用。</p><h2 id="AOP-即-Aspect-Oriented-Program-面向切面编程"><a href="#AOP-即-Aspect-Oriented-Program-面向切面编程" class="headerlink" title="AOP 即 Aspect Oriented Program 面向切面编程"></a>AOP 即 Aspect Oriented Program 面向切面编程</h2><p>首先，在面向切面编程的思想里面，把功能分为核心业务功能，和周边功能。</p><ul><li><strong>所谓的核心业务</strong>​，比如登陆，增加数据，删除数据都叫核心业务</li><li><strong>所谓的周边功能</strong>​，比如性能统计，日志，事务管理等等</li></ul><p>周边功能在 Spring 的面向切面编程AOP思想里，即被定义为切面</p><p>在面向切面编程AOP的思想里面，核心业务功能和切面功能分别独立进行开发，然后把切面功能和核心业务功能 “编织” 在一起，这就叫AOP</p><h2 id="AOP-的目的"><a href="#AOP-的目的" class="headerlink" title="AOP 的目的"></a>AOP 的目的</h2><p>AOP能够将那些与业务无关，​<strong>却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来</strong>​，便于​<strong>减少系统的重复代码</strong>​，​<strong>降低模块间的耦合度</strong>​，并​<strong>有利于未来的可拓展性和可维护性</strong>​。</p><h2 id="AOP-当中的概念："><a href="#AOP-当中的概念：" class="headerlink" title="AOP 当中的概念："></a>AOP 当中的概念：</h2><ul><li>切入点（Pointcut）<br>在哪些类，哪些方法上切入（​<strong>where</strong>​）</li><li>通知（Advice）<br>在方法执行的什么实际（<strong>when:</strong>方法前/方法后/方法前后）做什么（<strong>what:</strong>增强的功能）</li><li>切面（Aspect）<br>切面 = 切入点 + 通知，通俗点就是：<strong>在什么时机，什么地方，做什么增强！</strong></li><li>织入（Weaving）<br>把切面加入到对象，并创建出代理对象的过程。（由 Spring 来完成）</li></ul><h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><h2 id="需求说明"><a href="#需求说明" class="headerlink" title="需求说明"></a>需求说明</h2><p>为了更好的说明 AOP 的概念，我们来举一个实际中的例子来说明：</p><p><img src="image-20221204123653-p1e00ow.png" alt="image">​</p><p>在上面的例子中，包租婆的核心业务就是签合同，收房租，那么这就够了，灰色框起来的部分都是重复且边缘的事，交给中介商就好了，这就是 <strong>AOP 的一个思想：让关注点代码与业务代码分离！</strong></p><h2 id="代码实现（使用注解）"><a href="#代码实现（使用注解）" class="headerlink" title="代码实现（使用注解）"></a>代码实现（使用注解）</h2><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><p>Spring Boot使用AOP需要添加spring-boot-starter-aop依赖，如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>不需要再添加aspectjweaver的依赖了，因为spring-boot-starter-aop包含了aspectjweaver，并且版本是较新的版本，如果在添加老版本（如1.5.4）启动会报错。</p><h3 id="编写核心业务Bean"><a href="#编写核心业务Bean" class="headerlink" title="编写核心业务Bean"></a>编写核心业务Bean</h3><p>也就是连接点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.test_spring.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LandlordService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rent</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;房东：谈合同&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;房东：收房租&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="创建切面"><a href="#创建切面" class="headerlink" title="创建切面"></a>创建切面</h3><p>Spring采用@AspectJ注解对POJO进行标注，该注解表明该类不仅仅是一个POJO，还是一个切面。切面是切点和通知的结合，那么定义一个切面就需要编写切点和通知。在代码中，只需要添加@Aspect注解即可。</p><h3 id="定义切点"><a href="#定义切点" class="headerlink" title="定义切点"></a>定义切点</h3><p>切点是通过<strong>@Pointcut</strong>注解和切点表达式定义的。</p><p>@Pointcut注解可以在一个切面内定义<strong>可重用</strong>的切点。</p><p>由于Spring切面粒度最小是达到方法级别，而execution表达式可以用于明确指定方法返回类型，类名，方法名和参数名等与方法相关的部件，并且实际中，大部分需要使用AOP的业务场景也只需要达到方法级别即可，因而execution表达式的使用是最为广泛的。如图是execution表达式的语法：</p><p>execution表示在方法执行的时候触发。以“​<em>”开头，表明方法返回值类型为任意类型。然后是全限定的类名和方法名，“</em>​”可以表示任意类和任意方法。对于方法参数列表，可以使用“..”表示参数为任意类型。如果需要多个表达式，可以使用“&amp;&amp;”、“||”和“!”完成与、或、非的操作。</p><p><img src="image-20221204150048-bd0mj1f.png" alt="image">​</p><h3 id="定义通知"><a href="#定义通知" class="headerlink" title="定义通知"></a>定义通知</h3><blockquote><p>通知有五种类型，分别是：</p><p>前置通知（@Before）：在目标方法调用之前调用通知</p><p>后置通知（@After）：在目标方法完成之后调用通知</p><p>环绕通知（@Around）：在被通知的方法调用之前和调用之后执行自定义的方法</p><p>返回通知（@AfterReturning）：在目标方法成功执行之后调用通知</p><p>异常通知（@AfterThrowing）：在目标方法抛出异常之后调用通知</p></blockquote><p>本例中，分别使用前置通知实现“看房”和“谈价格”功能，使用后置通知实现“交钥匙”功能。这样一个切面就定义完成，下面是代码</p><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.test_spring.aspect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.After;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Broker</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.example.test_spring.service.LandlordService.rent())&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointCut</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;pointCut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beforeRent</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;中间商：带租客看房&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;中间商：谈价格&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After(&quot;pointCut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterRent</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;中间商：交钥匙&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSpringApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> SpringApplication.run(TestSpringApplication.class, args);</span><br><span class="line">        <span class="type">LandlordService</span> <span class="variable">bean</span> <span class="operator">=</span> context.getBean(LandlordService.class);</span><br><span class="line">        bean.rent();</span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="image-20221204150759-y1b4f1u.png" alt="image">​</p><h2 id="环绕通知"><a href="#环绕通知" class="headerlink" title="环绕通知"></a>环绕通知</h2><p>看到上述的需求也可以使用环绕通知，他会在方法执行前后执行。</p><p>改写<code>Broker.java</code>​代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.test_spring.aspect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.JoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Broker</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.example.test_spring.service.LandlordService.rent())&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointCut</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    @Before(&quot;pointCut()&quot;)</span></span><br><span class="line"><span class="comment">//    public void beforeRent() &#123;</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;中间商：带租客看房&quot;);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;中间商：谈价格&quot;);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    @After(&quot;pointCut()&quot;)</span></span><br><span class="line"><span class="comment">//    public void afterRent() &#123;</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;中间商：交钥匙&quot;);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;pointCut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">aroundRent</span><span class="params">(ProceedingJoinPoint point)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;中间商：带租客看房&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;中间商：谈价格&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            point.proceed();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;中间商：交钥匙&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行测试代码，结果依然正确</p><h1 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h1><ol><li><a href="https://www.jianshu.com/p/994027425b44">Spring(4)——面向切面编程（AOP模块）</a></li><li><a href="https://www.cnblogs.com/sgh1023/p/13363679.html">Spring Boot使用AOP的正确姿势</a>​</li></ol><p>‍</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文不涉及Spring AOP原理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Spring-AOP-简介&quot;&gt;&lt;a href=&quot;#Spring-AOP-简介&quot; class=&quot;headerlink&quot; title=&quot;Spring AOP 简介&quot;</summary>
      
    
    
    
    <category term="Java" scheme="https://guoyujian.github.io/categories/Java/"/>
    
    <category term="Spring" scheme="https://guoyujian.github.io/categories/Java/Spring/"/>
    
    
    <category term="Java" scheme="https://guoyujian.github.io/tags/Java/"/>
    
    <category term="Spring" scheme="https://guoyujian.github.io/tags/Spring/"/>
    
    <category term="面向切面编程" scheme="https://guoyujian.github.io/tags/%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/"/>
    
    <category term="AOP" scheme="https://guoyujian.github.io/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>使用docker部署redis并实现外部访问</title>
    <link href="https://guoyujian.github.io/2022/11/23/%E4%BD%BF%E7%94%A8docker%E9%83%A8%E7%BD%B2redis%E5%B9%B6%E5%AE%9E%E7%8E%B0%E5%A4%96%E9%83%A8%E8%AE%BF%E9%97%AE/"/>
    <id>https://guoyujian.github.io/2022/11/23/%E4%BD%BF%E7%94%A8docker%E9%83%A8%E7%BD%B2redis%E5%B9%B6%E5%AE%9E%E7%8E%B0%E5%A4%96%E9%83%A8%E8%AE%BF%E9%97%AE/</id>
    <published>2022-11-23T14:13:11.000Z</published>
    <updated>2022-11-23T14:26:33.656Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装之前环境部署"><a href="#安装之前环境部署" class="headerlink" title="安装之前环境部署"></a>安装之前环境部署</h1><p>关闭linux防火墙</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure><p>如果你使用的是云服务器，务必进入云服务器,给6379端口放行</p><h1 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h1><h2 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull redis:latest</span><br></pre></td></tr></table></figure><h2 id="从官网下载redis配置文件"><a href="#从官网下载redis配置文件" class="headerlink" title="从官网下载redis配置文件"></a>从官网下载redis配置文件</h2><p><code>wget http://download.redis.io/redis-stable/redis.conf</code></p><h2 id="创建一个文件夹用于保存此文件"><a href="#创建一个文件夹用于保存此文件" class="headerlink" title="创建一个文件夹用于保存此文件"></a>创建一个文件夹用于保存此文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /root/redis</span><br><span class="line"><span class="built_in">mv</span> /root/redis.conf  /root/redis</span><br></pre></td></tr></table></figure><h2 id="更改redis-conf的配置"><a href="#更改redis-conf的配置" class="headerlink" title="更改redis.conf的配置"></a>更改redis.conf的配置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /root/redis/redis.conf</span><br></pre></td></tr></table></figure><p>将redis.conf文件下列参数更改</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#bind 127.0.0.1 #允许远程连接(注释或者改为bind 0.0.0.0) </span></span><br><span class="line">protected-mode no    <span class="comment">#保护模式</span></span><br><span class="line">appendonly <span class="built_in">yes</span> <span class="comment">#持久化</span></span><br></pre></td></tr></table></figure><h2 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -p 6379:6379 --name redis -v /root/redis/redis.conf:/etc/redis/redis.conf -v /root/redis/data:/data -d redis redis-server /etc/redis/redis.conf </span><br></pre></td></tr></table></figure><p>参数说明:</p><ul><li>-p 6379:6379：把容器内的6379端口映射到宿主机6379端口</li><li>–name redis：设置容器名称为redis</li><li>-v /root/redis/redis.conf:/etc/redis/redis.conf：把主机配置好的redis.conf放到容器内的这个位置中</li><li>-v /root/redis/data:/data：把redis持久化的数据在宿主机内显示，做数据备份</li><li>-d：redis后台运行</li><li>redis-server /etc/redis/redis.conf：这个是关键配置，让redis不是无配置启动，而是按照这个redis.conf的配置启动</li></ul><h2 id="完成测试"><a href="#完成测试" class="headerlink" title="完成测试"></a>完成测试</h2><p>查看容器是否启动：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p>进入容器，检查是否可以启动redis-cli</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@Met-Guo:~<span class="comment"># docker exec -it 56 bash # 56为容器id</span></span><br><span class="line">root@5601af5f1f67:/data<span class="comment"># redis-cli</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name 50</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line"><span class="string">&quot;50&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exit</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在宿主机安装Redis Desktop Manager客户端，并配置</p><p><img src="image-20221123222544338.png" alt="截图"></p><p>成功。</p><h1 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h1><ol><li><a href="https://blog.csdn.net/weixin_46186045/article/details/117387772">docker 部署redis外部访问该注意的地方你都知道吗</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;安装之前环境部署&quot;&gt;&lt;a href=&quot;#安装之前环境部署&quot; class=&quot;headerlink&quot; title=&quot;安装之前环境部署&quot;&gt;&lt;/a&gt;安装之前环境部署&lt;/h1&gt;&lt;p&gt;关闭linux防火墙&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;</summary>
      
    
    
    
    <category term="redis" scheme="https://guoyujian.github.io/categories/redis/"/>
    
    
    <category term="redis安装" scheme="https://guoyujian.github.io/tags/redis%E5%AE%89%E8%A3%85/"/>
    
    <category term="docker" scheme="https://guoyujian.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>SSH三步解决免密登录</title>
    <link href="https://guoyujian.github.io/2022/11/07/SSH%E4%B8%89%E6%AD%A5%E8%A7%A3%E5%86%B3%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/"/>
    <id>https://guoyujian.github.io/2022/11/07/SSH%E4%B8%89%E6%AD%A5%E8%A7%A3%E5%86%B3%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/</id>
    <published>2022-11-07T14:29:07.000Z</published>
    <updated>2022-11-07T14:33:39.446Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h1><ol><li><a href="https://blog.csdn.net/jeikerxiao/article/details/84105529">SSH 三步解决免密登录</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Refs&quot;&gt;&lt;a href=&quot;#Refs&quot; class=&quot;headerlink&quot; title=&quot;Refs&quot;&gt;&lt;/a&gt;Refs&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/jeikerxiao/article/detail</summary>
      
    
    
    
    <category term="Linux" scheme="https://guoyujian.github.io/categories/Linux/"/>
    
    <category term="开发工具" scheme="https://guoyujian.github.io/categories/Linux/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="开发工具" scheme="https://guoyujian.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>FATE使用遇到的问题汇总</title>
    <link href="https://guoyujian.github.io/2022/11/04/FATE%E4%BD%BF%E7%94%A8%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <id>https://guoyujian.github.io/2022/11/04/FATE%E4%BD%BF%E7%94%A8%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</id>
    <published>2022-11-03T16:11:41.000Z</published>
    <updated>2022-11-03T16:13:55.018Z</updated>
    
    <content type="html"><![CDATA[<p>本文汇总在使用和开发FATE时遇到的各类问题，以及给出可能的解决方案。</p><h1 id="flow-init"><a href="#flow-init" class="headerlink" title="flow init"></a>flow init</h1><h2 id="问题状态"><a href="#问题状态" class="headerlink" title="问题状态"></a>问题状态</h2><p>已解决</p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>首次进入fate-client时，提示需要执行flow init，否则有关flow的命令都执行不了。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p><code>flow init --ip &lt;docker容器宿主机ip&gt; --port 9380</code></p><p>‍</p><h1 id="ModuleNotFoundError-No-module-named-‘-lzma’"><a href="#ModuleNotFoundError-No-module-named-‘-lzma’" class="headerlink" title="ModuleNotFoundError: No module named ‘_lzma’"></a>ModuleNotFoundError: No module named ‘_lzma’</h1><h2 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h2><p>执行任务时，nn模块报错：ModuleNotFoundError: No module named ‘_lzma’</p><p><img src="image-20220927210914-c8pbaiz.png" alt="image.png"></p><h2 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h2><p>在fate-flow container安装相关的包即可（guest、host和arbiter都要安装）。安装教程：<a href="https://github.com/ultralytics/yolov5/issues/1298">https://github.com/ultralytics/yolov5/issues/1298</a></p><p>这里需要修改路径</p><p><img src="image-20220928115429-n9l4hgw.png" alt="image.png"></p><h1 id="找不到文件：No-such-file-or-directory-‘-data-projects-fate-work-mnist-fed-mnist-train-part2-config-yaml’"><a href="#找不到文件：No-such-file-or-directory-‘-data-projects-fate-work-mnist-fed-mnist-train-part2-config-yaml’" class="headerlink" title="找不到文件：No such file or directory: ‘/data/projects/fate/work/mnist_fed/mnist_train_part2/config.yaml’"></a>找不到文件：<strong>No such file or directory: ‘/data/projects/fate/work/mnist_fed/mnist_train_part2/config.yaml’</strong></h1><h2 id="问题状态-1"><a href="#问题状态-1" class="headerlink" title="问题状态"></a>问题状态</h2><p>已解决</p><h2 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h2><p>在执行任务时，reader组件报错：</p><p><img src="image-20220927205925-34fvaot.png" alt="image.png"></p><p>这是由于我把数据保存在了fate-client，而fate读取数据是在fate-flow container导致的。</p><h2 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h2><p>由于fate-client和fate-flow两个容器中的examples文件夹挂载到docker底层同一处存储。所以把数据放到examples下，把配置修改为新的文件路径即可。</p><h1 id="开发新的FATE-FLOW-API"><a href="#开发新的FATE-FLOW-API" class="headerlink" title="开发新的FATE-FLOW API"></a>开发新的FATE-FLOW API</h1><p>这里是已有的API：<a href="https://federatedai.github.io/FATE-Flow/latest/zh/swagger/">https://federatedai.github.io/FATE-Flow/latest/zh/swagger/</a></p><p>FATE的HTTP接口都是基于flask框架编写的。</p><p>开发步骤如下：</p><ol><li>进入FATE-FLOW容器</li><li>cd /data/projects/fate/fateflow/python/fate_flow/apps</li><li>新建python文件，命名为xxx_app.py，编写新的接口。</li><li>重启FLOW容器</li></ol><h1 id="修改代码导致docker-container没起来"><a href="#修改代码导致docker-container没起来" class="headerlink" title="修改代码导致docker container没起来"></a>修改代码导致docker container没起来</h1><p>修改FATE-FLOW的代码后，由于代码有bug，导致容器起不来，又导致不能进入容器修改代码的死循环，怎么办？</p><p>查看docker容器的启动日志，确定出错的代码，docker cp拷贝出来需要修改的代码，再拷贝回去。</p><p>‍</p><h1 id="实际训练的epoch小于配置的max-iter"><a href="#实际训练的epoch小于配置的max-iter" class="headerlink" title="实际训练的epoch小于配置的max_iter"></a>实际训练的epoch小于配置的max_iter</h1><p>查看自己是否在配置文件中配置了：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;early_stop&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;early_stop&quot;</span><span class="punctuation">:</span> <span class="string">&quot;diff&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;eps&quot;</span><span class="punctuation">:</span> <span class="number">0.0001</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p>这里的意思是，如果两个epoch得到的loss之差小于0.0001时则停止训练。</p><h1 id="memory-error"><a href="#memory-error" class="headerlink" title="memory error"></a>memory error</h1><p>根据实践经验，memory error 还有dataloader worker pid之类的错误，均是由于内存不够引起的。调小batch size，或者增加硬件配置</p><p>‍</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文汇总在使用和开发FATE时遇到的各类问题，以及给出可能的解决方案。&lt;/p&gt;
&lt;h1 id=&quot;flow-init&quot;&gt;&lt;a href=&quot;#flow-init&quot; class=&quot;headerlink&quot; title=&quot;flow init&quot;&gt;&lt;/a&gt;flow init&lt;/h1&gt;&lt;h</summary>
      
    
    
    
    <category term="联邦学习" scheme="https://guoyujian.github.io/categories/%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="联邦学习" scheme="https://guoyujian.github.io/tags/%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>FATE横向联邦学习：肺炎的多模态任务的联邦学习</title>
    <link href="https://guoyujian.github.io/2022/11/04/FATE%E6%A8%AA%E5%90%91%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0%EF%BC%9A%E8%82%BA%E7%82%8E%E7%9A%84%E5%A4%9A%E6%A8%A1%E6%80%81%E4%BB%BB%E5%8A%A1%E7%9A%84%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0/"/>
    <id>https://guoyujian.github.io/2022/11/04/FATE%E6%A8%AA%E5%90%91%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0%EF%BC%9A%E8%82%BA%E7%82%8E%E7%9A%84%E5%A4%9A%E6%A8%A1%E6%80%81%E4%BB%BB%E5%8A%A1%E7%9A%84%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-11-03T16:10:23.000Z</published>
    <updated>2022-11-03T16:11:17.397Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>多模态最近比较火</p><p>多模态任务的input和算法FATE不支持，因此需要开发新的dataloader和算法组件。</p><p>本篇就以肺炎多模态任务为例，介绍如何开发新的FATE机器学习组件</p><p>官方文档在这里：<a href="https://fate.readthedocs.io/en/latest/develop/develop_guide/#develop-an-algorithm-component-of-fate">https://fate.readthedocs.io/en/latest/develop/develop_guide/#develop-an-algorithm-component-of-fate</a></p></blockquote><h1 id="baseline"><a href="#baseline" class="headerlink" title="baseline"></a>baseline</h1><p>本任务将开发基于肺部X光图像和描述文字正确判断是否患有肺炎的二分类算法。</p><p>数据集输入由两部分组成。一部分为肺部X光扫描图像，另一部分为对图像的描述文字。数据标签分为0和1，分别对应正常和患有肺炎两类标签。</p><h2 id="本地代码复现"><a href="#本地代码复现" class="headerlink" title="本地代码复现"></a>本地代码复现</h2><ol><li>baseline 代码在这里：<a href="https://github.com/AxelAllen/Multimodal-BERT-in-Medical-Image-and-Text-Classification">https://github.com/AxelAllen/Multimodal-BERT-in-Medical-Image-and-Text-Classification</a></li><li>将其clone到本地，按照README.md的提示，将NLMCXR_png_frontal图像文件夹放到data目录下。执行data/preparations.ipynb生成元数据。</li><li>执行run_mmbt.ipynb</li><li>执行完毕后，会在根目录下生成mmbt_output_findings_10epochs_n文件夹，里面保存有模型拟合后的梯度和评估结果。</li></ol><h2 id="阅读代码"><a href="#阅读代码" class="headerlink" title="阅读代码"></a>阅读代码</h2><p>这里要弄清楚代码的整套流程，主要是超参、使用的算法、训练、数据处理和加载，模型如何评估这几步。这里只展示核心代码</p><h3 id="超参"><a href="#超参" class="headerlink" title="超参"></a>超参</h3><div class="table-container"><table><thead><tr><th>参数</th><th>值</th></tr></thead><tbody><tr><td>Epoch</td><td>10</td></tr><tr><td>Bacth_size</td><td>16/32</td></tr><tr><td>Optimizer</td><td>AdamW</td></tr><tr><td>LR</td><td>5e-5</td></tr><tr><td>Loss</td><td>CrossEntropyLoss</td></tr><tr><td>Metrics</td><td>Accuracy</td></tr></tbody></table></div><blockquote><p>有趣的是，如果batch size = 4，模型无法训练处任何结果。</p></blockquote><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 部分code</span></span><br><span class="line"></span><br><span class="line">transformer_config = AutoConfig.from_pretrained(args.config_name <span class="keyword">if</span> args.config_name <span class="keyword">else</span> args.model_name, num_labels=num_labels)</span><br><span class="line">tokenizer = AutoTokenizer.from_pretrained(</span><br><span class="line">        args.tokenizer_name <span class="keyword">if</span> args.tokenizer_name <span class="keyword">else</span> args.model_name,</span><br><span class="line">        do_lower_case=<span class="literal">True</span>,</span><br><span class="line">        cache_dir=<span class="literal">None</span>,</span><br><span class="line">    )</span><br><span class="line">transformer = AutoModel.from_pretrained(args.model_name, config=transformer_config, cache_dir=<span class="literal">None</span>)</span><br><span class="line">img_encoder = ImageEncoderDenseNet(num_image_embeds=args.num_image_embeds)</span><br><span class="line">multimodal_config = MMBTConfig(transformer, img_encoder, num_labels=num_labels, modal_hidden_size=<span class="number">1024</span>)</span><br><span class="line">model = MMBTForClassification(transformer_config, multimodal_config)</span><br></pre></td></tr></table></figure><p>使用MMBT模型: 用于图像和文本分类的有监督多模态双向Transformer。</p><ul><li>图像编码器使用的ChexNet，这是一个针对X光胸片肺炎检测的模型；</li><li>文本编码器使用的预训练的BERT模型：bert-base-uncased。</li></ul><p>整体网络结构如图</p><p><img src="image-20221102150400-2suo5cw.png" alt="image">​</p><p>‍</p><h3 id="data-loader"><a href="#data-loader" class="headerlink" title="data loader"></a>data loader</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 部分code</span></span><br><span class="line">dataset = JsonlDataset(path, img_dir, tokenizer, img_transforms, labels, wandb_config.max_seq_length -</span><br><span class="line">                       wandb_config.num_image_embeds - <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">train_dataloader = DataLoader(</span><br><span class="line">    train_dataset,</span><br><span class="line">    sampler=train_sampler,</span><br><span class="line">    batch_size=args.train_batch_size,</span><br><span class="line">    collate_fn=collate_fn</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="train"><a href="#train" class="headerlink" title="train"></a>train</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 部分code</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> train_iterator:</span><br><span class="line">    epoch_iterator = tqdm(train_dataloader, desc=<span class="string">&quot;Training Batch Iteration&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> step, batch <span class="keyword">in</span> <span class="built_in">enumerate</span>(epoch_iterator):</span><br><span class="line"></span><br><span class="line">        batch = <span class="built_in">tuple</span>(t.to(args.device) <span class="keyword">for</span> t <span class="keyword">in</span> batch)</span><br><span class="line">        labels = batch[<span class="number">5</span>]</span><br><span class="line">        input_ids = batch[<span class="number">0</span>]</span><br><span class="line">        input_modal = batch[<span class="number">2</span>]</span><br><span class="line">        attention_mask = batch[<span class="number">1</span>]</span><br><span class="line">        modal_start_tokens = batch[<span class="number">3</span>]</span><br><span class="line">        modal_end_tokens = batch[<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">        outputs = model(</span><br><span class="line">            input_modal,</span><br><span class="line">            input_ids=input_ids,</span><br><span class="line">            modal_start_tokens=modal_start_tokens,</span><br><span class="line">            modal_end_tokens=modal_end_tokens,</span><br><span class="line">            attention_mask=attention_mask,</span><br><span class="line">            token_type_ids=<span class="literal">None</span>,</span><br><span class="line">            modal_token_type_ids=<span class="literal">None</span>,</span><br><span class="line">            position_ids=<span class="literal">None</span>,</span><br><span class="line">            modal_position_ids=<span class="literal">None</span>,</span><br><span class="line">            head_mask=<span class="literal">None</span>,</span><br><span class="line">            inputs_embeds=<span class="literal">None</span>,</span><br><span class="line">            labels=labels,</span><br><span class="line">            return_dict=<span class="literal">True</span></span><br><span class="line">        )</span><br><span class="line">        logits = outputs.logits</span><br><span class="line">        loss = outputs.loss</span><br><span class="line">        loss.backward()</span><br></pre></td></tr></table></figure><h3 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 部分代码</span></span><br><span class="line">result = evaluate(args, model, tokenizer, evaluate=<span class="literal">True</span>, test=<span class="literal">True</span>, prefix=prefix)</span><br></pre></td></tr></table></figure><h1 id="开发新组件"><a href="#开发新组件" class="headerlink" title="开发新组件"></a>开发新组件</h1><p>当我们已经在本地跑通代码，并明确算法之后，就可以开发新的组件，将算法联邦化。</p><p>这里官方文档写的很清楚，我大概复述一下</p><h3 id="Step-1-Define-the-python-parameter-object-to-be-used-by-this-component"><a href="#Step-1-Define-the-python-parameter-object-to-be-used-by-this-component" class="headerlink" title="Step 1. Define the python parameter object to be used by this component"></a>Step 1. Define the python parameter object to be used by this component</h3><ol><li>Open a new python file called <code>xxx_param.py</code>​, where xxx stands for your component’s name. Place this file in the folder <code>python/federatedm/param/</code>​. The class object defined in <code>xxx_param.py</code>​ should inherit the <code>BaseParam</code>​ class declared in <code>python/federatedml/param/base_param.py</code>​</li><li>The <code>__init__</code>​ method of your parameter class should specify all parameters that the component uses.</li><li>Override and implement the <code>check</code>​ interface method of BaseParam. The <code>check</code>​ method is used to validate the parameter variables.</li><li><code>python/federatedml/param/__init__.py</code>​列表<code>__all__</code>​增加你的组件名称，并导入。</li></ol><p>我这里组件名称叫homo_mm，所以创建的python文件名为homo_mm_param.py。由于和homo_nn很像，所以直接讲homo_nn_param.py复制过来，将里面的“nn”改成“mm”。</p><p>第四步增加了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> federatedml.param.homo_mm_param <span class="keyword">import</span> HomoMMParam</span><br><span class="line">...</span><br><span class="line">__all__ = [... <span class="string">&quot;HomoMMParam&quot;</span>, ...]</span><br></pre></td></tr></table></figure><p>python/federatedml/param/<strong>init</strong>.py</p><h3 id="Step-2-Define-the-meta-file-of-the-new-component"><a href="#Step-2-Define-the-meta-file-of-the-new-component" class="headerlink" title="Step 2. Define the meta file of the new component"></a>Step 2. Define the meta file of the new component</h3><ol><li>Define component meta python file under <code>python/federatedml/components/</code>​, name it as <code>xxx.py</code>​, where xxx stands for the algorithm component being developed.</li><li>Implement the meta file.</li></ol><p>我这里组件名称叫homo_mm，所以创建的python文件名为homo_mm.py。由于和homo_nn很像，所以直接讲homo_nn.py复制过来，将里面的“nn”改成“mm”。</p><h3 id="Step-3-Define-the-transfer-variable-object-of-this-module-Optional"><a href="#Step-3-Define-the-transfer-variable-object-of-this-module-Optional" class="headerlink" title="Step 3. Define the transfer variable object of this module. (Optional)"></a>Step 3. Define the transfer variable object of this module. (Optional)</h3><p>这里不需要</p><h3 id="Step-4-Create-the-component-which-inherits-the-class-model-base​"><a href="#Step-4-Create-the-component-which-inherits-the-class-model-base​" class="headerlink" title="Step 4. Create the component which inherits the class model_base​"></a>Step 4. Create the component which inherits the class <code>model_base</code>​</h3><p>现在就可以将<code>python/federatedml/nn/homo_nn</code>​复制一份，修改为homo_mm，修改_torch.py文件</p><p>详略。</p><h3 id="additional"><a href="#additional" class="headerlink" title="additional"></a>additional</h3><p>需要注意在<code>python/federatedml/nn/backend/pytorch/data.py</code>​新建新的dataset。并在_torch中的make_dataset创建，这里可以参照VisionDataSet</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MMDataSet</span>(<span class="title class_ inherited__">DatasetMixIn</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_num_labels</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_num_features</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_keys</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._keys</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">as_data_instance</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">from</span> federatedml.feature.instance <span class="keyword">import</span> Instance</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">_as_instance</span>(<span class="params">x</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(x, np.number):</span><br><span class="line">                <span class="keyword">return</span> Instance(label=x.tolist())</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> Instance(label=x)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> computing_session.parallelize(</span><br><span class="line">            data=<span class="built_in">zip</span>(self._keys, <span class="built_in">map</span>(_as_instance, self.targets)),</span><br><span class="line">            include_key=<span class="literal">True</span>,</span><br><span class="line">            partition=<span class="number">1</span>,</span><br><span class="line">        )</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,train_data_path, is_train=<span class="literal">True</span>, expected_label_type=np.float32,**kwargs</span>):</span><br><span class="line"><span class="comment"># 这里必须加上，否则会卡在标签对齐且不报错</span></span><br><span class="line">        <span class="keyword">if</span> is_train:</span><br><span class="line">            HomoLabelEncoderClient().label_alignment([<span class="string">&quot;fake&quot;</span>])</span><br><span class="line"></span><br><span class="line">        tokenizer = AutoTokenizer.from_pretrained(</span><br><span class="line">            <span class="string">&quot;bert-base-uncased&quot;</span>,</span><br><span class="line">            do_lower_case=<span class="literal">True</span>,</span><br><span class="line">            cache_dir=<span class="literal">None</span>,</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        labels = [<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">        labels2id = &#123;<span class="string">&#x27;0&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;1&#x27;</span>: <span class="number">1</span>&#125;</span><br><span class="line">        self.labels2id = labels2id</span><br><span class="line">        self.data = [json.loads(line) <span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">open</span>(os.path.join(train_data_path, <span class="string">&quot;meta.jsonl&quot;</span>))]</span><br><span class="line"></span><br><span class="line">        self.targets = [ item[<span class="string">&#x27;label&#x27;</span>] <span class="keyword">for</span> item <span class="keyword">in</span> self.data]</span><br><span class="line">        self.img_data_dir = os.path.join(train_data_path, <span class="string">&#x27;images&#x27;</span>)</span><br><span class="line">        self.tokenizer = tokenizer</span><br><span class="line">        self.labels = labels</span><br><span class="line">        self.n_classes = <span class="built_in">len</span>(labels)</span><br><span class="line">        self.max_seq_length = <span class="number">300</span> - <span class="number">3</span> - <span class="number">2</span></span><br><span class="line">        self.transforms = torchvision.transforms.Compose(</span><br><span class="line">            [</span><br><span class="line">                torchvision.transforms.Resize(<span class="number">256</span>),</span><br><span class="line">                torchvision.transforms.CenterCrop(<span class="number">224</span>),</span><br><span class="line">                torchvision.transforms.ToTensor(),</span><br><span class="line">                torchvision.transforms.Normalize(</span><br><span class="line">                    mean=[<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>],</span><br><span class="line">                    std=[<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>]</span><br><span class="line">                )</span><br><span class="line">            ]</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        key_dic = []</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">id</span> <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.data)):</span><br><span class="line">            key_dic.append(<span class="built_in">id</span>)</span><br><span class="line">        self._keys = key_dic</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, index</span>):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        sentence = torch.LongTensor(self.tokenizer.encode(self.data[index][<span class="string">&quot;text&quot;</span>], add_special_tokens=<span class="literal">True</span>))</span><br><span class="line">        start_token, sentence, end_token = sentence[<span class="number">0</span>], sentence[<span class="number">1</span>:-<span class="number">1</span>], sentence[-<span class="number">1</span>]</span><br><span class="line">        sentence = sentence[:self.max_seq_length]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.n_classes &gt; <span class="number">2</span>:</span><br><span class="line">            <span class="comment"># multiclass</span></span><br><span class="line">            label = torch.zeros(self.n_classes)</span><br><span class="line">            label[self.labels.index(self.data[index][<span class="string">&quot;label&quot;</span>])] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            label = torch.LongTensor([self.labels.index(self.data[index][<span class="string">&quot;label&quot;</span>])])</span><br><span class="line"></span><br><span class="line">        image = Image.<span class="built_in">open</span>(os.path.join(self.img_data_dir, self.data[index][<span class="string">&quot;img&quot;</span>])).convert(<span class="string">&quot;RGB&quot;</span>)</span><br><span class="line">        image = self.transforms(image)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="string">&quot;image_start_token&quot;</span>: start_token,</span><br><span class="line">            <span class="string">&quot;image_end_token&quot;</span>: end_token,</span><br><span class="line">            <span class="string">&quot;sentence&quot;</span>: sentence,</span><br><span class="line">            <span class="string">&quot;image&quot;</span>: image,</span><br><span class="line">            <span class="string">&quot;label&quot;</span>: label,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.data)</span><br><span class="line">    <span class="comment"># 标签名称和标签index的对应，例如&#123;&quot;阴性&quot;:0, &quot;阳性&quot;:1&#125;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_label_align_mapping</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.labels2id</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果Job仍然跑不起来，可以通过FATE-BOARD日志排错。</p><p>‍</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;多模态最近比较火&lt;/p&gt;
&lt;p&gt;多模态任务的input和算法FATE不支持，因此需要开发新的dataloader和算法组件。&lt;/p&gt;
&lt;p&gt;本篇就以肺炎多模态任务为例，介绍如何开发新的FATE机器学习组件&lt;/p&gt;
&lt;p&gt;官方文档在这里：&lt;a hre</summary>
      
    
    
    
    <category term="联邦学习" scheme="https://guoyujian.github.io/categories/%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="联邦学习" scheme="https://guoyujian.github.io/tags/%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
