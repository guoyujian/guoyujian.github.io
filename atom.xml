<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Gmet&#39;s Blog</title>
  
  <subtitle>Eureka!</subtitle>
  <link href="https://gmet233.gitee.io/atom.xml" rel="self"/>
  
  <link href="https://gmet233.gitee.io/"/>
  <updated>2022-05-05T15:31:09.939Z</updated>
  <id>https://gmet233.gitee.io/</id>
  
  <author>
    <name>Met Guo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java8新特性1：行为参数化</title>
    <link href="https://gmet233.gitee.io/2022/05/05/Java8%E6%96%B0%E7%89%B9%E6%80%A71%EF%BC%9A%E8%A1%8C%E4%B8%BA%E5%8F%82%E6%95%B0%E5%8C%96/"/>
    <id>https://gmet233.gitee.io/2022/05/05/Java8%E6%96%B0%E7%89%B9%E6%80%A71%EF%BC%9A%E8%A1%8C%E4%B8%BA%E5%8F%82%E6%95%B0%E5%8C%96/</id>
    <published>2022-05-05T14:43:20.000Z</published>
    <updated>2022-05-05T15:31:09.939Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在软件工程中，一个众所周知的问题就是，<strong>不管你做什么，用户的需求肯定会变</strong>。<br><strong>行为参数化</strong>就是可以帮助你处理频繁变更的需求的一种软件开发模式。一言以蔽之，它意味着拿出一个代码块，把它准备好却不去执行它。这个代码块以后可以被你程序的其他部分调用，这意味着你可以推迟这块代码的执行。例如，你可以将代码块作为参数传递给另一个方法，稍后再去执行它。这样，这个方法的行为就基于那块代码被参数化了。</p><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><p>通过逐步改进案例，来熟悉什么是“行为参数化”。</p><blockquote><p>需求：农民希望筛选出1. 绿色的苹果，2. 重量大于150的苹果 3….</p></blockquote><h2 id="方案1"><a href="#方案1" class="headerlink" title="方案1"></a>方案1</h2><p>可能的代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据颜色筛选苹果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> apples</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> color</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Apple&gt; <span class="title function_">filterByColor</span><span class="params">(List&lt;Apple&gt; apples, String color)</span> &#123;</span><br><span class="line">    List&lt;Apple&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Apple apple : apples) &#123;</span><br><span class="line">        <span class="keyword">if</span>(apple.getColor().equals(color)) &#123;</span><br><span class="line">            res.add(apple);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据重量筛选苹果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> apples</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weight</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Apple&gt; <span class="title function_">filterByWeight</span><span class="params">(List&lt;Apple&gt; apples, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">    List&lt;Apple&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Apple apple : apples) &#123;</span><br><span class="line">        <span class="keyword">if</span>(apple.getWeight() &gt; weight) &#123;</span><br><span class="line">            res.add(apple);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>农民通过调用来获得答案</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">filterByColor(apples, <span class="string">&quot;green&quot;</span>);</span><br><span class="line">filterByWeight(apples, <span class="number">150</span>);</span><br></pre></td></tr></table></figure><p>这样做打破了<strong>DRY（Don’t RepeatYourself，不要重复自己）的软件工程原则</strong>。这样做出现了大量的重复代码，当你想要修改某些逻辑，比如优化遍历语句时，你需要修改所有方法中的代码。</p><p>另一种方案是，把所有参数都整合到一个方法中去，签名如下：<code>public static List&lt;Apple&gt; filterByColor(List&lt;Apple&gt; apples, String color, int weight)</code></p><p>这样做不仅笨拙，而且面对变化不能做出调整，如果有新的筛选条件，比如产地，大小，形状等怎么办？</p><h2 id="方案2：行为参数化"><a href="#方案2：行为参数化" class="headerlink" title="方案2：行为参数化"></a>方案2：行为参数化</h2><p>让我们后退一步来看看更高层次的抽象。一种可能的解决方案是对你的选择标准建模：你考虑的是苹果，需要根据Apple的某些属性（比如它是绿色的吗？重量超过150克吗？）来返回一个boolean值。我们把它称为<strong>谓词</strong>（即一个返回boolean值的函数）。让我们定义一个接口来对选择标准建模：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ApplePredicate</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Apple apple)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们就可以用ApplePredicate的多个实现代表不同的选择标准：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppleGreenColorPredicate</span> <span class="keyword">implements</span> <span class="title class_">ApplePredicate</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Apple apple)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;green&quot;</span>.equals(apple.getColor());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppleHeavyWeightPredicate</span> <span class="keyword">implements</span> <span class="title class_">ApplePredicate</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Apple apple)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> apple.getWeight() &gt; <span class="number">150</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以把这些标准看作filter方法的不同行为。你刚做的这些和“<strong>策略设计模式</strong>”相关，它让你定义一族算法，把它们封装起来（称为“策略”），然后在运行时选择一个算法。在这里，算法族就是ApplePredicate，不同的策略就是AppleHeavyWeightPredicate和AppleGreenColorPredicate。</p><p>但是，该怎么利用ApplePredicate的不同实现呢？你需要filterApples方法接受ApplePredicate对象，对Apple做条件测试。这就是行为参数化：<strong>让方法接受多种行为（或战略）作为参数</strong>，并在内部使用，来完成不同的行为。这在软件工程上有很大好处：现在你把filterApples方法迭代集合的逻辑与你要应用到集合中每个元素的行为（这里是一个谓词）区分开了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Apple&gt; <span class="title function_">filterApples</span><span class="params">(List&lt;Apple&gt; apples, ApplePredicate p)</span> &#123;</span><br><span class="line">    List&lt;Apple&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Apple apple : apples) &#123;</span><br><span class="line">        <span class="keyword">if</span>(p.test(apple)) &#123;</span><br><span class="line">            res.add(apple);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：这样做有一点缺憾就是，我明明重要的只有一个test方法，但是filterApples只能接受对象，所以我们不得不把test方法封装在ApplePredicate对象中进行传递。后面会使用Lambda表达式进行简化。</p><h2 id="方案2-1：使用匿名类改进"><a href="#方案2-1：使用匿名类改进" class="headerlink" title="方案2-1：使用匿名类改进"></a>方案2-1：使用匿名类改进</h2><p>对于以上代码的调用我们要费很大劲，创建ApplePredicate的两个实现类，然后把这两个类实例化传入到filterApples方法中去。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">filterApples(apples, <span class="keyword">new</span> <span class="title class_">AppleGreenColorPredicate</span>());</span><br></pre></td></tr></table></figure><p>我们可以使用匿名类简化这一流程。以筛选出绿色苹果为例，改进后的代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">filterApples(apples, <span class="keyword">new</span> <span class="title class_">ApplePredicate</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Apple apple)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;green&quot;</span>.equals(apple.getColor());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>但匿名类还不够好：</p><ul><li>笨重：每次实现新的<code>new ApplePredicate()</code>都要写很多模板代码<code>...test...</code></li><li>费解：这里不过多解释</li></ul><p>因此我们可以使用Lambda表达式让代码更干净</p><h2 id="方案2-2：使用Lambda表达式"><a href="#方案2-2：使用Lambda表达式" class="headerlink" title="方案2-2：使用Lambda表达式"></a>方案2-2：使用Lambda表达式</h2><p>使用Lambda表达式让上述代码重写为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">filterApples(apples, (Apple apple) -&gt; <span class="string">&quot;green&quot;</span>.equals(apple.getColor()) );</span><br></pre></td></tr></table></figure><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>将苹果按照重量由大到小排序</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对苹果按重量排序，使用java8 Collections.sort</span></span><br><span class="line"><span class="comment">//使用匿名类</span></span><br><span class="line">Collections.sort(apples, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Apple&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Apple a1, Apple a2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a1.getWeight() - a2.getWeight();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用lambda表达式</span></span><br><span class="line">Collections.sort(apples, (Apple a1, Apple a2) -&gt; a1.getWeight() - a2.getWeight() );</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>《Java 8实战》</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;在软件工程中，一个众所周知的问题就是，&lt;strong&gt;不管你做什么，用户的需求肯定会变&lt;/strong&gt;。&lt;br&gt;&lt;strong&gt;行为参数化</summary>
      
    
    
    
    <category term="Java" scheme="https://gmet233.gitee.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://gmet233.gitee.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Docker 基础知识整理</title>
    <link href="https://gmet233.gitee.io/2022/05/02/Docker-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"/>
    <id>https://gmet233.gitee.io/2022/05/02/Docker-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/</id>
    <published>2022-05-02T15:37:00.000Z</published>
    <updated>2022-05-18T14:32:47.406Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker-能做什么"><a href="#Docker-能做什么" class="headerlink" title="Docker 能做什么"></a>Docker 能做什么</h1><p>以前学习的时候，想要搭建一个Hadoop集群，那就要安装一个VMWare，然后装至少三个虚拟机。每个虚拟机至少20GB以上，有了Docker，你只需要安装一台虚拟机（Linux操作系统），在这台虚拟机上启动多个Docker容器，每个容器只有几百兆。</p><p>Docker将硬件要求和应用环境之间进一步解耦，大大提升了程序🐒的生产力和幸福指数。</p><p>Docker的应用场景包括但不限于：</p><ul><li>本地依赖：快速尝试开源项目而不用操心环境配置。</li><li>搭建环境：同一个Docker配置可以在不同的环境中运行。</li><li>微服务</li><li>扩容：Docker支持水平扩容。</li><li>……</li></ul><h1 id="Docker和虚拟机技术的比较"><a href="#Docker和虚拟机技术的比较" class="headerlink" title="Docker和虚拟机技术的比较"></a>Docker和虚拟机技术的比较</h1><p>自己查。</p><h1 id="Docker核心组件"><a href="#Docker核心组件" class="headerlink" title="Docker核心组件"></a>Docker核心组件</h1><ul><li>Docker客户端：Client</li><li>Docker服务器：Docker daemon</li><li>Docker镜像：Image</li><li>Registry</li><li>Docker容器：Container</li></ul><p><img src="image-20220428230419609.png" alt="Docker架构"></p><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>Docker客户端是执行Docker命令的地方。<code>docker run</code>等等</p><p>Docker客户端也支持REST API</p><h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><p>Docker daemon运行在Docker host上，负责创建、运行、监控容器，构建、存储镜像。</p><p>Docker服务器默认情况下只响应来自本地Host的客户端请求，如果要允许远程客户端请求，则需要修改配置（Google）</p><h2 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h2><p>Docker镜像看成只读模板，通过它可以创建Docker容器。</p><p>例如某个镜像可能包含一个操作系统、一个Apache HTTP Server以及用户开发的Web应用。</p><p>镜像有多种生成方法：（1）从无到有开始创建镜像；（2）下载并使用别人创建好的现成的镜像；（3）在现有镜像上创建新的镜像。可以将镜像的内容和创建步骤描述在一个文本文件（Dockerfile）中，通过执行dockerbuild 命令可以构建出Docker镜像，后面讨论。</p><h2 id="Docker-容器"><a href="#Docker-容器" class="headerlink" title="Docker 容器"></a>Docker 容器</h2><p>Docker容器就是Docker镜像的运行实例。</p><p>如果镜像是软件生命周期的构建和打包阶段，那么容器则是启动和运行阶段。（类似于程序与线程的关系。）</p><h2 id="Registry"><a href="#Registry" class="headerlink" title="Registry"></a>Registry</h2><p>Registry是存放Docker镜像的仓库。</p><h1 id="hello-word"><a href="#hello-word" class="headerlink" title="hello-word"></a>hello-word</h1><p>本节介绍Docker安装到运行一个Container的基本流程。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">官方安装脚本自动安装</span></span><br><span class="line">curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun</span><br></pre></td></tr></table></figure><h2 id="启动Docker服务器"><a href="#启动Docker服务器" class="headerlink" title="启动Docker服务器"></a>启动Docker服务器</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><h2 id="拉取hello-world镜像"><a href="#拉取hello-world镜像" class="headerlink" title="拉取hello-world镜像"></a>拉取hello-world镜像</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull hello-world </span><br></pre></td></tr></table></figure><h2 id="查看image信息"><a href="#查看image信息" class="headerlink" title="查看image信息"></a>查看image信息</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop01 ~]# docker images hello-world</span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED        SIZE</span><br><span class="line">hello-world   latest    feb5d9fea6a5   7 months ago   13.3kB</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="运行hello-world"><a href="#运行hello-world" class="headerlink" title="运行hello-world"></a>运行hello-world</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop01 ~]# docker run hello-world</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="查看Dockerfile"><a href="#查看Dockerfile" class="headerlink" title="查看Dockerfile"></a>查看Dockerfile</h2><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> scratch</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> hello/</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;hello/&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>只有短短三条指令。</p><ol><li>FROM scratch：镜像是从白手起家，从0开始构建。</li><li>COPY hello/：将宿主机上的文件“hello”复制到镜像的根目录。</li><li>CMD[“/hello”]：容器启动时，执行/hello。</li></ol><h1 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h1><h2 id="base-镜像"><a href="#base-镜像" class="headerlink" title="base 镜像"></a>base 镜像</h2><p>hello-world虽然是一个完整的镜像，但它并没有什么实际用途。通常来说，我们希望镜像能提供一个基本的操作系统环境，用户可以根据需要安装和配置软件。这样的镜像我们称作base镜像。</p><p>base镜像有两层含义：（1）不依赖其他镜像，从scratch构建；（2）其他镜像可以以之为基础进行扩展。</p><p>能称作base镜像的通常都是各种Linux发行版的Docker镜像，比如Ubuntu、Debian、CentOS等。</p><p>我们尝试下载并查看centos的镜像：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop01 ~]# docker pull centos</span><br><span class="line">...</span><br><span class="line">[root@hadoop01 ~]# docker images centos</span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED        SIZE</span><br><span class="line">centos       latest    5d0da3dc9764   7 months ago   231MB</span><br></pre></td></tr></table></figure><blockquote><p>为什么一个centos镜像只有200MB？</p><p>答：Linux操作系统由内核空间（bootfs/kernel）和用户空间（rootfs）组成。</p><p>Linux刚启动时会加载bootfs文件系统，之后bootfs会被卸载掉。</p><p>用户空间的文件系统是rootfs，包含我们熟悉的/dev、/proc、/bin等目录。对于base镜像来说，底层直接用Host的kernel，自己只需要提供rootfs就行了。<strong>而对于一个精简的OS, rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了。</strong></p><p>因此，base镜像只是在用户空间与发行版一致，kernel版本与发行版是不同的。镜像的Kernel版本取决于Docker Host（Docker装在哪台机器上，这台机器就是Docker Host）。所以容器只能使用Host的kernel，并且不能修改</p><p>base镜像提供的是最小安装的Linux发行版。</p></blockquote><h2 id="镜像分层"><a href="#镜像分层" class="headerlink" title="镜像分层"></a>镜像分层</h2><p>我们拿一个Dockerfile来举例：</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> debian</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install emacs</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install apach2</span></span><br></pre></td></tr></table></figure><p>上述构建过程如图所示：</p><p><img src="image-20220428234124163.png" alt="构建"></p><p>可以看到，新镜像是从base镜像一层一层叠加生成的。每安装一个软件，就在现有镜像的基础上增加一层。</p><blockquote><p>为什么Docker镜像要采用这种分层结构呢？</p><ul><li>最大的一个好处就是：共享资源。比如：有多个镜像都从相同的base镜像构建而来，那么Docker Host只需在磁盘上保存一份base镜像；同时内存中也只需加载一份base镜像，就可以为所有容器服务了，而且镜像的每一层都可以被共享，我们将在后面更深入地讨论这个特性。</li></ul><p>如果多个容器共享一份基础镜像，当某个容器修改了基础镜像的内容，比如/etc下的文件，这时其他容器的 /etc是否也会被修改？</p><ul><li>答案是不会！修改会被限制在单个容器内。这就是我们接下来要学习的容器Copy-on-Write特性。</li></ul></blockquote><h2 id="Copy-on-Write特性"><a href="#Copy-on-Write特性" class="headerlink" title="Copy-on-Write特性"></a>Copy-on-Write特性</h2><p>对于Dockerfile的每一行构建语句都会增加一层镜像，而当容器启动时，一个新的<strong>可写层</strong>被加载到镜像的顶部。这是特殊的一层，这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。所有对容器的改动，无论添加、删除，还是修改文件都只会发生在容器层中。<strong>只有容器层是可写的，容器层下面的所有镜像层都是只读的。</strong></p><ol><li>添加文件。在容器中创建文件时，新文件被添加到容器层中。</li><li>读取文件。在容器中读取某个文件时，Docker会从上往下依次在各镜像层中查找此文件。一旦找到，打开并读入内存。</li><li>修改文件。在容器中修改已存在的文件时，Docker会从上往下依次在各镜像层中查找此文件。一旦找到，<strong>立即将其复制到容器层</strong>，然后修改之。</li><li>删除文件。在容器中删除文件时，Docker也是从上往下依次在镜像层中查找此文件。找到后，会在容器层中记录下此删除操作。</li></ol><p>只有当需要修改时才复制一份数据，这种特性被称作Copy-on-Write。可见，容器层保存的是镜像变化的部分，不会对镜像本身进行任何修改。</p><p>这样就解释了我们前面提出的问题：容器层记录对镜像的修改，所有镜像层都是只读的，不会被容器修改，所以镜像可以被多个容器共享。</p><h2 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h2><p>Docker提供了两种构建镜像的方法： <code>docker commit</code>命令与Dockerfile构建文件。</p><h3 id="docker-commit（不推荐）"><a href="#docker-commit（不推荐）" class="headerlink" title="docker commit（不推荐）"></a>docker commit（不推荐）</h3><p>docker commit命令是创建新镜像最直观的方法，其过程包含三个步骤：运行容器。修改容器。将容器保存为新的镜像。</p><p>下面的例子将在CentOS base镜像中安装vim并保存为新镜像：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it ubuntu # 启动Container并进入容器</span><br><span class="line">vim # command not found</span><br><span class="line">apt-get install -y vim # 安装vim</span><br><span class="line">vim # 发现命令可以执行成功了</span><br></pre></td></tr></table></figure><p>在新窗口使用命令查看容器：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop01 ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE             COMMAND       CREATED          STATUS          PORTS     NAMES</span><br><span class="line">013be1649d31   centos:7.2.1511   &quot;/bin/bash&quot;   54 seconds ago   Up 53 seconds             frosty_kowalevski</span><br></pre></td></tr></table></figure><p>frosty_kowalevski是Docker为我们的容器随机分配的名字。</p><p>执行docker commit命令将容器保存为镜像，然后查看镜像</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop01 ~]# docker commit frosty_kowalevski centos_test</span><br><span class="line">sha256:5889b0d6ca05e96a7d1ba31dcc732d36b0651ebf7725bf0fb91def9aa2211420</span><br><span class="line">[root@hadoop01 ~]# docker images</span><br><span class="line">REPOSITORY    TAG        IMAGE ID       CREATED         SIZE</span><br><span class="line">centos_test   latest     5889b0d6ca05   6 seconds ago   409MB</span><br><span class="line">httpd         latest     c30a46771695   10 days ago     144MB</span><br><span class="line">hello-world   latest     feb5d9fea6a5   7 months ago    13.3kB</span><br><span class="line">centos        7.2.1511   9aec5c5fe4ba   3 years ago     195MB</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上演示了如何用docker commit创建新镜像。然而，Docker并不建议用户通过这种方式构建镜像。原因如下：</p><ol><li>这是一种手工创建镜像的方式，容易出错，效率低且可重复性弱。比如要在debian base镜像中也加入vi，还得重复前面的所有步骤。</li><li>更重要的：使用者并不知道镜像是如何创建出来的，里面是否有恶意程序。也就是说无法对镜像进行审计，存在安全隐患。</li></ol><p>既然docker commit不是推荐的方法，我们为什么还要花时间学习呢？原因是：即便是用Dockerfile（推荐方法）构建镜像，底层也是docker commit一层一层构建新镜像的。学习docker commit能够帮助我们更加深入地理解构建过程和镜像的分层结构。</p><h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><p>使用Dockerfile创建上一节的centos_test镜像</p><h4 id="编辑Dockerfile文件"><a href="#编辑Dockerfile文件" class="headerlink" title="编辑Dockerfile文件"></a>编辑Dockerfile文件</h4><p>创建一个Dockerfile，内容为</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos:<span class="number">7.2</span>.<span class="number">1511</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum -y install vim</span></span><br></pre></td></tr></table></figure><blockquote><p>注意这里<code>-y</code>必须加，否则在执行yum install时，很可能因为需要用户输入<code>yes</code>而失败</p></blockquote><p>执行build命令，并进行分析：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop01 docker]# pwd</span><br><span class="line">/root/docker</span><br><span class="line">[root@hadoop01 docker]# ls</span><br><span class="line">Dockerfile</span><br><span class="line">[root@hadoop01 docker]# docker build -t centos-vim-dockerfile-image .</span><br><span class="line">Sending build context to Docker daemon  2.048kB</span><br><span class="line">Step 1/2 : FROM centos:7.2.1511</span><br><span class="line"><span class="meta prompt_"> ---&gt; </span><span class="language-bash">9aec5c5fe4ba</span></span><br><span class="line">Step 2/2 : RUN yum install vim</span><br><span class="line"><span class="meta prompt_"> ---&gt; </span><span class="language-bash">Running <span class="keyword">in</span> 1caec46cd6a4</span></span><br><span class="line">Loaded plugins: fastestmirror</span><br><span class="line">……</span><br><span class="line">Successfully built b93576fddd48</span><br><span class="line">Successfully tagged centos-vim-dockerfile-image:latest</span><br></pre></td></tr></table></figure><ol><li>第三行显示文件夹下的所有文件，这里只有我们编写好的Dockerfile，值得注意的是，文件名必须叫“Dockerfile”否则执行docker build时会显示文件不存在。</li><li>第五行执行docker build命令，-t参数指定了镜像的名字，最后的点表示指定docker context为当前目录。</li><li>关于docker context：Docker默认会从build context中查找Dockerfile文件；Docker将build context中的所有文件发送给Docker daemon；Dockerfile中的ADD、COPY等命令可以将build context中的文件添加到镜像。因此不要在docker context加入不需要的文件。</li><li>第7到14行显示了执行docker build的具体过程。</li></ol><p>构建好的镜像可以通过docker history命令查看构建过程：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop01 docker]# docker history centos-vim-dockerfile-image:latest </span><br><span class="line">IMAGE          CREATED         CREATED BY                                      SIZE      COMMENT</span><br><span class="line">b93576fddd48   6 minutes ago   /bin/sh -c yum -y install vim                   214MB     </span><br><span class="line">9aec5c5fe4ba   3 years ago     /bin/sh -c #(nop)  CMD [&quot;/bin/bash&quot;]            0B        </span><br><span class="line">&lt;missing&gt;      3 years ago     /bin/sh -c #(nop)  LABEL license=GPLv2          0B        </span><br><span class="line">&lt;missing&gt;      3 years ago     /bin/sh -c #(nop)  LABEL vendor=CentOS          0B        </span><br><span class="line">&lt;missing&gt;      3 years ago     /bin/sh -c #(nop)  LABEL name=CentOS Base Im…   0B        </span><br><span class="line">&lt;missing&gt;      3 years ago     /bin/sh -c #(nop) ADD file:e76000d9816e4e380…   195MB     </span><br><span class="line">&lt;missing&gt;      3 years ago     /bin/sh -c #(nop)  MAINTAINER The CentOS Pro…   0B        </span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="镜像的缓存特性"><a href="#镜像的缓存特性" class="headerlink" title="镜像的缓存特性"></a>镜像的缓存特性</h4><p>Docker会缓存已有镜像的镜像层，构建新镜像时，如果某镜像层已经存在，就直接使用，无须重新创建。</p><p>例如在之前的Dockerfile中加入一行：</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos:<span class="number">7.2</span>.<span class="number">1511</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum -y install vim</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> <span class="built_in">test</span>/</span></span><br></pre></td></tr></table></figure><p>则在执行的过程中，之前已经运行过相同的RUN指令，这次直接使用缓存中的镜像层</p><h4 id="Dockerfile构建过程"><a href="#Dockerfile构建过程" class="headerlink" title="Dockerfile构建过程"></a>Dockerfile构建过程</h4><p>总结一下通过Dockerfile构建镜像的过程：</p><ol><li>从base镜像运行一个容器。</li><li>执行一条指令，对容器做修改。</li><li>执行类似docker commit的操作，生成一个新的镜像层。</li><li>Docker再基于刚刚提交的镜像运行一个新容器。</li><li>重复2～4步，直到Dockerfile中的所有指令执行完毕。</li></ol><p>从这个过程可以看出，如果Dockerfile由于某种原因执行到某个指令失败了，我们也将能够得到前一个指令成功执行构建出的镜像，这对调试Dockerfile非常有帮助。</p><h4 id="调试Dockerfile"><a href="#调试Dockerfile" class="headerlink" title="调试Dockerfile"></a>调试Dockerfile</h4><p>一句话概括就是：启动失败的前一层构建成功镜像的容器，进入容器，执行失败的语句，从而查看问题所在。</p><h2 id="分发镜像"><a href="#分发镜像" class="headerlink" title="分发镜像"></a>分发镜像</h2><h3 id="docker-tag"><a href="#docker-tag" class="headerlink" title="docker tag"></a>docker tag</h3><p>这里注意tag为lastest，注意docker tag的合并方式。</p><h3 id="使用公共的Registry"><a href="#使用公共的Registry" class="headerlink" title="使用公共的Registry"></a>使用公共的Registry</h3><p>看官方文档去。</p><h1 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h1><h2 id="运行容器的三种方法"><a href="#运行容器的三种方法" class="headerlink" title="运行容器的三种方法"></a>运行容器的三种方法</h2><ul><li>CMD指令</li><li>ENTRYPOINT指令</li><li>在docker run命令行中指定，例如，<code>docker run ubuntu pwd</code></li></ul><h2 id="长期运行容器"><a href="#长期运行容器" class="headerlink" title="长期运行容器"></a>长期运行容器</h2><p>容器在执行完启动时的指令后就会退出。想要让容器保持运行状态，那运行的命令不退出就好了。。</p><h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><p>在容器running时，我们可以进入容器work，有两种方法，</p><ul><li>docker attach</li><li>docker exec</li></ul><p>详细见常用命令总结章节</p><p>docker attach和docker exec区别：</p><ol><li>attach直接进入容器启动命令的终端，不会启动新的进程。</li><li>exec则是在容器中打开新的终端，并且可以启动新的进程。</li><li>如果想直接在终端中查看启动命令的输出，用attach；其他情况使用exec。</li></ol><h2 id="docker-start-stop-restart"><a href="#docker-start-stop-restart" class="headerlink" title="docker start/stop/restart"></a>docker start/stop/restart</h2><p>容器在docker host中实际上是一个进程，通过<code>docker start/stop/restart &lt;container id&gt;</code>命令启动，停止和重启容器。</p><h2 id="docker-pause-unpause"><a href="#docker-pause-unpause" class="headerlink" title="docker pause/unpause"></a>docker pause/unpause</h2><p>通过<code>docker pause/unpause &lt;container id&gt;</code>命令暂停和恢复容器。</p><h2 id="docker-rm"><a href="#docker-rm" class="headerlink" title="docker rm"></a>docker rm</h2><p>通过<code>docker rm &lt;container id&gt;</code>命令删除容器。</p><h2 id="docker生命周期"><a href="#docker生命周期" class="headerlink" title="docker生命周期"></a>docker生命周期</h2><p><img src="image-20220502225040947.png" alt="docker生命周期"></p><h2 id="资源限制"><a href="#资源限制" class="headerlink" title="资源限制"></a>资源限制</h2><p>一个docker host 会运行若干容器，对于容器，Docker也提供了类似的机制避免某个容器因占用太多资源而影响其他容器乃至整个host的性能。</p><p>docker 提供命令以限制容器的内存，CPU，BlockIO（磁盘读写）等。</p><p>具体请查阅相关资料。</p><h2 id="实现容器的底层技术"><a href="#实现容器的底层技术" class="headerlink" title="实现容器的底层技术"></a>实现容器的底层技术</h2><p>cgroup和namespace是最重要的两种技术。cgroup实现资源限额，namespace实现资源隔离。</p><p>Linux使用了6种namespace，分别对应6种资源：Mount、UTS、IPC、PID、Network和User。</p><p>具体用到再说。</p><h1 id="Docker-网络"><a href="#Docker-网络" class="headerlink" title="Docker 网络"></a>Docker 网络</h1><p>4种网络：</p><ul><li>none：封闭网络，对安全性要求高并且不需要联网的应用可以使用none网络。</li><li>host： 连接到host网络的容器共享Docker host的网络栈，容器的网络配置与host完全一样。可以通过 —network=host指定使用host网络。</li><li>bridge：Docker安装时会创建一个命名为docker0的Linuxbridge。如果不指定—network，创建的容器默认都会挂到docker0上。</li><li>user-defined：除了none、host、bridge这三个自动创建的网络，用户也可以根据业务需要创建user-defined网络。</li></ul><h2 id="容器间通信"><a href="#容器间通信" class="headerlink" title="容器间通信"></a>容器间通信</h2><p>待补充</p><h2 id="将容器与外部世界连接"><a href="#将容器与外部世界连接" class="headerlink" title="将容器与外部世界连接"></a>将容器与外部世界连接</h2><p>待补充</p><h1 id="Docker-存储"><a href="#Docker-存储" class="headerlink" title="Docker 存储"></a>Docker 存储</h1><p>待补充</p><h1 id="常用命令总结"><a href="#常用命令总结" class="headerlink" title="常用命令总结"></a>常用命令总结</h1><h2 id="Docker镜像-1"><a href="#Docker镜像-1" class="headerlink" title="Docker镜像"></a>Docker镜像</h2><h3 id="docker-images"><a href="#docker-images" class="headerlink" title="docker  images"></a>docker  images</h3><p>列出镜像</p><p><code>docker images [OPTIONS] [REPOSITORY[:TAG]]</code></p><p>OPTIONS说明：</p><ul><li><strong>-a :</strong>列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）；</li></ul><h3 id="docker-rmi"><a href="#docker-rmi" class="headerlink" title="docker rmi"></a>docker rmi</h3><p><code>docker rmi [OPTIONS] IMAGE [IMAGE...]</code></p><p>删除本地镜像</p><h3 id="docker-build"><a href="#docker-build" class="headerlink" title="docker build"></a>docker build</h3><p>使用 Dockerfile 创建镜像。</p><p><code>docker build [OPTIONS] PATH | URL | -</code></p><p>OPTIONS说明：</p><ul><li><strong>—build-arg=[] :</strong>设置镜像创建时的变量；</li><li><strong>—cpu-shares :</strong>设置 cpu 使用权重；</li><li><strong>-f :</strong>指定要使用的Dockerfile路径；</li><li><strong>—force-rm :</strong>设置镜像过程中删除中间容器；</li><li><strong>—isolation :</strong>使用容器隔离技术；</li><li><strong>-m :</strong>设置内存最大值；</li><li><strong>—memory-swap :</strong>设置Swap的最大值为内存+swap，”-1”表示不限swap；</li><li><strong>—no-cache :</strong>创建镜像的过程不使用缓存；</li><li><strong>—pull :</strong>尝试去更新镜像的新版本；</li><li><strong>—quiet, -q :</strong>安静模式，成功后只输出镜像 ID；</li><li><strong>—rm :</strong>设置镜像成功后删除中间容器；</li><li><strong>—tag, -t:</strong> 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。</li><li><strong>—network:</strong> 默认 default。在构建期间设置RUN指令的网络模式</li></ul><h3 id="docker-history"><a href="#docker-history" class="headerlink" title="docker history"></a>docker history</h3><p>查看指定镜像的创建历史。</p><p><code>docker history [OPTIONS] IMAGE</code></p><hr><h3 id="docker-login"><a href="#docker-login" class="headerlink" title="docker login"></a>docker login</h3><p> 登陆到一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub</p><h3 id="docker-pull"><a href="#docker-pull" class="headerlink" title="docker pull"></a>docker pull</h3><p>拉取镜像</p><h3 id="docker-push"><a href="#docker-push" class="headerlink" title="docker push"></a>docker push</h3><p>推送镜像</p><h3 id="docker-search"><a href="#docker-search" class="headerlink" title="docker search"></a>docker search</h3><p>查找镜像</p><h2 id="Docker-容器-1"><a href="#Docker-容器-1" class="headerlink" title="Docker 容器"></a>Docker 容器</h2><h3 id="docker-run"><a href="#docker-run" class="headerlink" title="docker run"></a>docker run</h3><p><strong>docker run ：</strong>创建一个新的容器并运行一个命令</p><p><code>docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</code></p><p>OPTIONS说明：</p><ul><li><strong>-d:</strong> 后台运行容器，并返回容器ID；</li><li><strong>-i:</strong> 以交互模式运行容器，通常与 -t 同时使用；</li><li><strong>-p:</strong> 指定端口映射，格式为：<strong>主机(宿主)端口:容器端口</strong></li><li><strong>-t:</strong> 为容器重新分配一个伪输入终端，通常与 -i 同时使用；</li><li><strong>—name=”nginx-lb”:</strong> 为容器指定一个名称；</li><li><strong>—dns 8.8.8.8:</strong> 指定容器使用的DNS服务器，默认和宿主一致；</li><li><strong>—dns-search example.com:</strong> 指定容器DNS搜索域名，默认和宿主一致；</li><li><strong>-h “mars”:</strong> 指定容器的hostname；</li><li><strong>-e username=”ritchie”:</strong> 设置环境变量；</li><li><strong>-m :</strong>设置容器使用内存最大值；</li><li><strong>—net=”bridge”:</strong> 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型；</li><li><strong>—expose=[]:</strong> 开放一个端口或一组端口；</li></ul><h3 id="docker-start-stop-restart-1"><a href="#docker-start-stop-restart-1" class="headerlink" title="docker start/stop/restart"></a>docker start/stop/restart</h3><p><strong>docker start</strong> :启动一个或多个已经被停止的容器</p><p><strong>docker stop</strong> :停止一个运行中的容器</p><p><strong>docker restart</strong> :重启容器</p><h3 id="docker-rm-1"><a href="#docker-rm-1" class="headerlink" title="docker rm"></a>docker rm</h3><p><strong>docker rm ：</strong>删除一个或多个容器。</p><h3 id="docker-pause-unpause-1"><a href="#docker-pause-unpause-1" class="headerlink" title="docker pause/unpause"></a>docker pause/unpause</h3><p><strong>docker pause</strong> :暂停容器中所有的进程。</p><p><strong>docker unpause</strong> :恢复容器中所有的进程。</p><h3 id="docker-create"><a href="#docker-create" class="headerlink" title="docker create"></a>docker create</h3><p><strong>docker create ：</strong>创建一个新的容器但不启动它；用法同docker run</p><h3 id="docker-attach"><a href="#docker-attach" class="headerlink" title="docker attach"></a>docker attach</h3><p><strong>docker attach :</strong>连接到正在运行中的容器。</p><p>要attach上去的容器必须正在运行，可以同时连接上同一个container来共享屏幕（与screen命令的attach类似）。</p><h3 id="docker-exec"><a href="#docker-exec" class="headerlink" title="docker exec"></a>docker exec</h3><p><strong>docker exec ：</strong>在运行的容器中执行命令</p><p><code>docker exec [OPTIONS] CONTAINER COMMAND [ARG...]</code></p><p>OPTIONS说明：</p><ul><li><strong>-d :</strong>分离模式: 在后台运行</li><li><strong>-t :</strong>分配一个伪终端</li></ul><h3 id="docker-ps"><a href="#docker-ps" class="headerlink" title="docker ps"></a>docker ps</h3><p>列出容器</p><p><code>docker ps [OPTIONS]</code></p><p>OPTIONS说明：</p><ul><li><strong>-a :</strong>显示所有的容器，包括未运行的。</li><li><strong>-n :</strong>列出最近创建的n个容器。</li><li><strong>-q :</strong>静默模式，只显示容器编号。</li></ul><h3 id="docker-inspect"><a href="#docker-inspect" class="headerlink" title="docker inspect"></a>docker inspect</h3><p><strong>docker inspect :</strong> 获取容器/镜像的元数据。</p><h3 id="docker-top"><a href="#docker-top" class="headerlink" title="docker top"></a>docker top</h3><p>查看容器中运行的进程信息，支持 ps 命令参数。</p><p>容器运行时不一定有/bin/bash终端来交互执行top命令，而且容器还不一定有top命令，可以使用docker top来实现查看container中正在运行的进程。</p><h3 id="docker-logs"><a href="#docker-logs" class="headerlink" title="docker logs"></a>docker logs</h3><p>获取容器的日志</p><h3 id="docker-commit"><a href="#docker-commit" class="headerlink" title="docker commit"></a>docker commit</h3><p>从容器创建一个新的镜像。</p><p><code>docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</code></p><p>OPTIONS说明：</p><ul><li><strong>-a :</strong>提交的镜像作者；</li><li><strong>-c :</strong>使用Dockerfile指令来创建镜像；</li><li><strong>-m :</strong>提交时的说明文字；</li><li><strong>-p :</strong>在commit时，将容器暂停。</li></ul><h3 id="docker-cp"><a href="#docker-cp" class="headerlink" title="docker cp"></a>docker cp</h3><p>用于容器与主机之间的数据拷贝。</p><p>例如：将主机/www/runoob目录拷贝到容器96f7f14e99ab的/www目录下。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker cp /www/runoob 96f7f14e99ab:/www/</span><br></pre></td></tr></table></figure><h2 id="Dockerfile-1"><a href="#Dockerfile-1" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><ul><li>FROM指定base镜像。</li><li>MAINTAINER设置镜像的作者，可以是任意字符串。</li><li>COPY将文件从build context复制到镜像。COPY支持两种形式： COPY src dest与COPY [“src”, “dest”]。注意：src只能指定build context中的文件或目录。</li><li>ADD与COPY类似，从build context复制文件到镜像。不同的是，如果src是归档文件（tar、zip、tgz、xz等），文件会被自动解压到dest。</li><li>ENV设置环境变量，环境变量可被后面的指令使用。</li><li>EXPOSE指定容器中的进程会监听某个端口，Docker可以将该端口暴露出来。我们会在容器网络部分详细讨论。</li><li>VOLUME将文件或目录声明为volume。我们会在容器存储部分详细讨论。</li><li>WORKDIR为后面的RUN、CMD、ENTRYPOINT、ADD或COPY指令设置镜像中的当前工作目录。</li><li>RUN在容器中运行指定的命令。</li><li>CMD容器启动时运行指定的命令。Dockerfile中可以有多个CMD指令，但只有最后一个生效。CMD可以被dockerrun之后的参数替换。</li><li>ENTRYPOINT设置容器启动时运行的命令。Dockerfile中可以有多个ENTRYPOINT指令，但只有最后一个生效。CMD或docker run之后的参数会被当作参数传递给ENTRYPOINT。</li></ul><h3 id="RUN-vs-CMD-vs-ENTRYPOINT"><a href="#RUN-vs-CMD-vs-ENTRYPOINT" class="headerlink" title="RUN vs CMD vs ENTRYPOINT"></a>RUN vs CMD vs ENTRYPOINT</h3><p>略</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>《每天五分钟玩转Docker容器技术》</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Docker-能做什么&quot;&gt;&lt;a href=&quot;#Docker-能做什么&quot; class=&quot;headerlink&quot; title=&quot;Docker 能做什么&quot;&gt;&lt;/a&gt;Docker 能做什么&lt;/h1&gt;&lt;p&gt;以前学习的时候，想要搭建一个Hadoop集群，那就要安装一个VMWa</summary>
      
    
    
    
    <category term="Docker" scheme="https://gmet233.gitee.io/categories/Docker/"/>
    
    
    <category term="Docker" scheme="https://gmet233.gitee.io/tags/Docker/"/>
    
    <category term="容器" scheme="https://gmet233.gitee.io/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>HashMap知识整理</title>
    <link href="https://gmet233.gitee.io/2022/04/21/HashMap%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"/>
    <id>https://gmet233.gitee.io/2022/04/21/HashMap%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/</id>
    <published>2022-04-21T15:28:41.000Z</published>
    <updated>2022-05-18T14:33:56.256Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Java为数据结构中的映射定义了一个接口java.util.Map，此接口主要有四个常用的实现类，分别是HashMap、Hashtable、LinkedHashMap和TreeMap，类继承关系如下图所示：</p><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/f7fe16a2.png" alt="Map类图"></p><ol><li><strong>HashMap</strong>：它根据键的hashCode值存储数据，<strong>遍历顺序不确定</strong>。 HashMap<strong>最多只允许一条记录的key为null</strong>，允许多条记录的value为null。HashMap<strong>非线程安全</strong>，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。</li><li><strong>Hashtable</strong>：Hashtable是遗留类，不再推荐使用。</li><li><strong>LinkedHashMap</strong>：LinkedHashMap是HashMap的一个子类，<strong>保存了记录的插入顺序</strong>，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。</li><li><strong>TreeMap</strong>：TreeMap实现SortedMap接口，能够<strong>把它保存的记录根据键排序</strong>，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator**，否则会在运行时抛出java.lang.ClassCastException类型的异常。</li></ol><p>对于上述四种Map类型的类，要求映射中的key是<strong>不可变对象</strong>。不可变对象是该对象在创建后它的哈希值不会被改变。如果对象的哈希值发生变化，Map对象很可能就定位不到映射的位置了。</p><h1 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h1><p>从结构实现来讲，HashMap是数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下如所示。</p><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/e4a19398.png" alt="HashMap存储结构"></p><h2 id="什么是Node"><a href="#什么是Node" class="headerlink" title="什么是Node"></a>什么是Node</h2><p>源码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> hash;    <span class="comment">//用来定位数组索引位置</span></span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;   <span class="comment">//链表的下一个node</span></span><br><span class="line"></span><br><span class="line">        Node(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123; ... &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> K <span class="title function_">getKey</span><span class="params">()</span>&#123; ... &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">getValue</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">setValue</span><span class="params">(V newValue)</span> &#123; ... &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)。上图中的每个黑色圆点就是一个Node对象。</p><blockquote><p>Map.Entry是Map声明的一个内部接口，此接口为泛型，定义为Entry<K,V>。它表示Map中的一个实体（一个key-value对）。接口中有getKey(), getValue方法。</p></blockquote><h2 id="HashMap存储"><a href="#HashMap存储" class="headerlink" title="HashMap存储"></a>HashMap存储</h2><p>HashMap就是使用哈希表来存储的。哈希表为解决冲突，可以采用开放地址法和链地址法等来解决问题，Java中HashMap采用了<strong>链地址法</strong>。链地址法，简单来说，就是数组加链表的结合。在每个数组元素上都一个链表结构，当数据被Hash后，得到数组下标，把数据放在对应下标元素的链表上。</p><p>对于HashMap来说，调用<code>map.put(key, value)</code>方法时，先通过<code>key.hashCode()</code>得到hashCode值（该方法适用于每个Java对象），在对hashCode值进行Hash运算来确定该键值对在哈希桶数组中的存储位置。如果两个key会定位到相同的位置，表示发生了Hash冲突。</p><p>HashMap的存储效率取决于Hash算法和哈希桶数组的大小。如果哈希桶数组很大，即使较差的Hash算法也会比较分散，如果哈希桶数组数组很小，即使好的Hash算法也会出现较多碰撞，所以就需要在空间成本和时间成本之间权衡，其实就是在根据实际情况确定哈希桶数组的大小，并在此基础上设计好的hash算法减少Hash碰撞。那么通过什么方式来控制map使得Hash碰撞的概率又小，哈希桶数组（Node[] table）占用空间又少呢？答案就是好的<strong>Hash算法</strong>和<strong>扩容机制</strong>。</p><h2 id="HashMap关键变量"><a href="#HashMap关键变量" class="headerlink" title="HashMap关键变量"></a>HashMap关键变量</h2><p>在理解Hash和扩容流程之前，我们得先了解下HashMap的几个字段。从HashMap的默认构造函数源码可知，构造函数就是对下面几个字段进行初始化，源码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="type">int</span> threshold;             <span class="comment">// 所能容纳的key-value对极限 </span></span><br><span class="line"><span class="keyword">final</span> <span class="type">float</span> loadFactor;    <span class="comment">// 负载因子</span></span><br><span class="line"><span class="type">int</span> modCount;  </span><br><span class="line"><span class="type">int</span> size;</span><br></pre></td></tr></table></figure><ul><li>table是哈希桶数组，它默认初始化长度length为16</li><li>loadFactor为负载因子(默认值是0.75)</li><li>threshold是HashMap所能容纳的最大数据量的Node(键值对)个数</li><li>threshold = length * Load factor，也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。</li><li>负载因子的定义公式可知，threshold就是在此Load factor和length(数组长度)对应下允许的<strong>最大元素数目</strong>，超过这个数目就重新resize(扩容)，<strong>扩容后的HashMap容量是之前容量的两倍</strong>。默认的负载因子0.75是对空间和时间效率的一个平衡选择，建议大家不要修改，除非在时间和空间比较特殊的情况下，如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值；相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。</li><li>size就是HashMap中<strong>实际存在的键值对数量</strong>。</li><li>modCount字段主要用来记录HashMap内部结构发生变化的次数（比如扩容， 或者链表变为红黑树），主要用于迭代的快速失败。强调一点，内部结构发生变化指的是结构发生变化，例如put新键值对，但是某个key对应的value值被覆盖不属于结构变化。</li></ul><h2 id="哈希桶数组的设计"><a href="#哈希桶数组的设计" class="headerlink" title="哈希桶数组的设计"></a>哈希桶数组的设计</h2><p>在HashMap中，哈希桶数组table的长度length大小必须为2的n次方(一定是合数)，这是一种<strong>非常规</strong>的设计，常规的设计是把桶的大小设计为素数。相对来说素数导致冲突的概率要小于合数，具体证明可以参考<a href="http://blog.csdn.net/liuqiyao_01/article/details/14475159">这篇文章</a>，Hashtable初始化桶大小为11，就是桶大小设计为素数的应用（Hashtable扩容后不能保证还是素数）。HashMap采用这种非常规设计，主要是<strong>为了在取模和扩容时做优化</strong>。同时为了减少冲突，HashMap定位哈希桶索引位置时，也加入了高位参与运算的过程。</p><p>这里存在一个问题，即使负载因子和Hash算法设计的再合理，也免不了会出现拉链过长的情况（即链表很长），一旦出现拉链过长，则会严重影响HashMap的性能。于是，在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树。而当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入、删除、查找等算法。本文不再对红黑树展开讨论，想了解更多红黑树数据结构的工作原理可以参考<a href="http://blog.csdn.net/v_july_v/article/details/6105630">这篇文章</a>。</p><h1 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h1><h2 id="hash算法"><a href="#hash算法" class="headerlink" title="hash算法"></a>hash算法</h2><p>源码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法一：</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;   <span class="comment">//jdk1.8 &amp; jdk1.7</span></span><br><span class="line">     <span class="type">int</span> h;</span><br><span class="line">     <span class="comment">// h = key.hashCode() 为第一步 取hashCode值</span></span><br><span class="line">     <span class="comment">// h ^ (h &gt;&gt;&gt; 16)  为第二步 高位参与运算</span></span><br><span class="line">     <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line">方法二：</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">indexFor</span><span class="params">(<span class="type">int</span> h, <span class="type">int</span> length)</span> &#123;  <span class="comment">//jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的</span></span><br><span class="line">     <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);  <span class="comment">//第三步 取模运算</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的Hash算法本质上就是三步：<strong>取key的hashCode值、高位运算、取模运算</strong>。</p><p>对于任意给定的对象，只要它的hashCode()返回值相同，那么程序调用方法一所计算得到的Hash码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，<strong>模运算的消耗还是比较大</strong>的，在HashMap中是这样做的：调用方法二来计算该对象应该保存在table数组的哪个索引处。</p><p>这个方法（方法二）非常巧妙，它通过h &amp; (table.length -1)来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n次方时，<strong>h&amp; (length-1)运算等价于对length取模</strong>，也就是h%length，但是&amp;比%具有更高的效率。</p><p>在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。</p><p>下面举例说明下，n为table的长度</p><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/45205ec2.png" alt="hash算法"></p><h2 id="HashMap的put方法"><a href="#HashMap的put方法" class="headerlink" title="HashMap的put方法"></a>HashMap的put方法</h2><p>HashMap的put方法执行过程可以通过下图来理解</p><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/d669d29c.png" alt="HashMap的put方法（1.7，1.8有变化）"></p><ol><li>判断键值对数组table是否为空或长度为0，否则执行resize()进行扩容；（这里可以看出，<code>new HashMap()</code>的时候并不会初始化哈希桶数组，而是当第一次执行put操作的时候才会初始化。）</li><li>根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向6，如果table[i]不为空，转向3</li><li>判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向4，这里的相同指的是hashCode以及equals；</li><li>判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向5；</li><li>遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可； </li><li>插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。</li></ol><p>put方法源码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="comment">// 对key的hashCode()做hash</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">               <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">// 步骤①：tab为空则创建</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 步骤②：计算index，并对null做处理 </span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>) </span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 步骤③：节点key存在，直接覆盖value</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 步骤④：判断该链为红黑树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 步骤⑤：该链为链表</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key,value,<span class="literal">null</span>);</span><br><span class="line">                     <span class="comment">//链表长度大于8转换为红黑树进行处理</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st  </span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                 <span class="comment">// key已经存在直接覆盖value</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) </span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 步骤⑥：超过最大容量 就扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><p>扩容(resize)就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。当然Java里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组，就像我们用一个小桶装水，如果想装更多的水，就得换大水桶。</p><blockquote><p>这里有一个不大不小的质疑，如果所有的size到达了threshold，但是所有的键值对都装在了一个哈希桶中，那么其实其他桶是空的，也是可以继续放更多的键值对，那么此时不能说<HashMap对象内部的数组无法装载更多的元素>，但依然会扩容</p></blockquote><p>我们分析下resize的源码，鉴于JDK1.8融入了红黑树，较复杂，为了便于理解我们仍然使用JDK1.7的代码，好理解一些，本质上区别不大，具体区别后文再说。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(<span class="type">int</span> newCapacity)</span> &#123;   <span class="comment">//传入新的容量</span></span><br><span class="line">    Entry[] oldTable = table;    <span class="comment">//引用扩容前的Entry数组</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> oldTable.length;         </span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;  <span class="comment">//扩容前的数组大小如果已经达到最大(2^30)了</span></span><br><span class="line">        threshold = Integer.MAX_VALUE; <span class="comment">//修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> <span class="title class_">Entry</span>[newCapacity];  <span class="comment">//初始化一个新的Entry数组</span></span><br><span class="line">    transfer(newTable);                         <span class="comment">//！！将数据转移到新的Entry数组里</span></span><br><span class="line">    table = newTable;                           <span class="comment">//HashMap的table属性引用新的Entry数组</span></span><br><span class="line">    threshold = (<span class="type">int</span>)(newCapacity * loadFactor);<span class="comment">//修改阈值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Entry[] newTable)</span> &#123;</span><br><span class="line">    Entry[] src = table;                   <span class="comment">//src引用了旧的Entry数组</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; src.length; j++) &#123; <span class="comment">//遍历旧的Entry数组</span></span><br><span class="line">        Entry&lt;K,V&gt; e = src[j];             <span class="comment">//取得旧Entry数组的每个元素</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            src[j] = <span class="literal">null</span>;<span class="comment">//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash, newCapacity); <span class="comment">//！！重新计算每个元素在数组中的位置</span></span><br><span class="line">                e.next = newTable[i]; <span class="comment">//标记[1]，这句不太理解</span></span><br><span class="line">                newTable[i] = e;      <span class="comment">//将元素放在数组上</span></span><br><span class="line">                e = next;             <span class="comment">//访问下一个Entry链上的元素</span></span><br><span class="line">            &#125; <span class="keyword">while</span> (e != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>newTable[i]的引用赋给了e.next，也就是使用了单链表的<strong>头插</strong>入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素终会被放到Entry链的尾部(如果发生了hash冲突的话），这一点和Jdk1.8有区别，下文详解。在旧数组中同一条Entry链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。</p><p>下面举个例子说明下扩容过程。假设了我们的hash算法就是简单的用key mod 一下表的大小（也就是数组的长度）。其中的哈希桶数组table的size=2， 所以key = 3、7、5，put顺序依次为 5、7、3。在mod 2以后都冲突在table[1]这里了。这里假设负载因子 loadFactor=1，即当键值对的实际大小size 大于 table的实际大小时进行扩容。接下来的三个步骤是哈希桶数组 resize成4，然后所有的Node重新rehash的过程。</p><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/b2330062.png" alt="JDK7 HashMap扩容"></p><p>下面我们讲解下JDK1.8做了哪些优化。经过观测可以发现，我们使用的是<strong>2次幂</strong>的扩展(指长度扩为原来2倍)，所以，<strong>元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置</strong>。看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。</p><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/4d8022db.png" alt="img"></p><p>元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：</p><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/d773f86e.png" alt="img"></p><p>因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，<strong>只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”</strong>，可以看看下图为16扩充为32的resize示意图：</p><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/3cc9813a.png" alt="img"></p><p>这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。有一点注意区别，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，<strong>JDK1.8不会倒置</strong>。有兴趣的同学可以研究下JDK1.8的resize源码，写的很赞，如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没超过最大值，就扩充为原来的2倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算新的resize上限</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;，&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 把每个bucket都移动到新的buckets中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// 链表优化重hash的代码块</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 原索引</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 原索引+oldCap</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 原索引放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 原索引+oldCap放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><h2 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h2><p>在多线程使用场景中，应该尽量避免使用线程不安全的HashMap，而使用线程安全的ConcurrentHashMap。那么为什么说HashMap是线程不安全的，下面举例子说明在并发的多线程使用场景中使用HashMap可能造成死循环。代码例子如下(便于理解，仍然使用JDK1.7的环境)：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapInfiniteLoop</span> &#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;Integer,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer,String&gt;(<span class="number">2</span>，<span class="number">0.75f</span>);  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        map.put(<span class="number">5</span>， <span class="string">&quot;C&quot;</span>);  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;Thread1&quot;</span>) &#123;  </span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;  </span><br><span class="line">                map.put(<span class="number">7</span>, <span class="string">&quot;B&quot;</span>);  </span><br><span class="line">                System.out.println(map);  </span><br><span class="line">            &#125;;  </span><br><span class="line">        &#125;.start();  </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;Thread2&quot;</span>) &#123;  </span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;  </span><br><span class="line">                map.put(<span class="number">3</span>, <span class="string">&quot;A);  </span></span><br><span class="line"><span class="string">                System.out.println(map);  </span></span><br><span class="line"><span class="string">            &#125;;  </span></span><br><span class="line"><span class="string">        &#125;.start();        </span></span><br><span class="line"><span class="string">    &#125;  </span></span><br><span class="line"><span class="string">&#125; </span></span><br></pre></td></tr></table></figure><p>其中，map初始化为一个长度为2的数组，loadFactor=0.75，threshold=2*0.75=1，也就是说当put第二个key的时候，map就需要进行resize。</p><p>通过设置断点让线程1和线程2同时debug到transfer方法(3.3小节代码块)的首行。注意此时两个线程已经成功添加数据。放开thread1的断点至transfer方法的“Entry next = e.next;” 这一行；然后放开线程2的的断点，让线程2进行resize。结果如下图。</p><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/7df99266.png" alt="img"></p><p>注意，Thread1的 e 指向了key(3)，而next指向了key(7)，其在线程二rehash后，指向了线程二重组后的链表。</p><p>线程一被调度回来执行，先是执行 newTalbe[i] = e， 然后是e = next，导致了e指向了key(7)，而下一次循环的next = e.next导致了next指向了key(3)。</p><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/4c3c28fb.png" alt="img"></p><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/6c8d086a.png" alt="img"></p><p>e.next = newTable[i] 导致 key(3).next 指向了 key(7)。注意：此时的key(7).next 已经指向了key(3)， 环形链表就这样出现了。</p><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/6eed9aaf.png" alt="img"></p><p>于是，当我们用线程一调用map.get(11)时，悲剧就出现了——Infinite Loop。</p><h1 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h1><p>JDK1.8做了多方面的优化，总体性能优于JDK1.7。具体详见参考资料1</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://tech.meituan.com/2016/06/24/java-hashmap.html">Java 8系列之重新认识HashMap</a></li><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;Java为数据结构中的映射定义了一个接口java.util.Map，此接口主要有四个常用的实现类，分别是HashMap、Hashtable、</summary>
      
    
    
    
    <category term="Java" scheme="https://gmet233.gitee.io/categories/Java/"/>
    
    <category term="集合" scheme="https://gmet233.gitee.io/categories/Java/%E9%9B%86%E5%90%88/"/>
    
    
    <category term="Java" scheme="https://gmet233.gitee.io/tags/Java/"/>
    
    <category term="HashMap" scheme="https://gmet233.gitee.io/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>完美解决ChromeDriver与Chrome版本匹配问题</title>
    <link href="https://gmet233.gitee.io/2022/04/11/%E5%AE%8C%E7%BE%8E%E8%A7%A3%E5%86%B3ChromeDriver%E4%B8%8EChrome%E7%89%88%E6%9C%AC%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98/"/>
    <id>https://gmet233.gitee.io/2022/04/11/%E5%AE%8C%E7%BE%8E%E8%A7%A3%E5%86%B3ChromeDriver%E4%B8%8EChrome%E7%89%88%E6%9C%AC%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98/</id>
    <published>2022-04-11T14:47:58.000Z</published>
    <updated>2022-04-11T14:53:41.897Z</updated>
    
    <content type="html"><![CDATA[<p>在使用Selenium调用Chrome浏览器爬取互联网数据时，会遇到Chrome和ChromeDriver版本不兼容的问题，导致爬取失败。</p><p>一种解决方案是，进行版本匹配。但是随着本机Chrome的更新，每次都需要随之更新ChromeDriver版本。</p><p>更好的方案是，通过使用<code>webdriver-manager</code>来自动匹配ChromeDriver，安装：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install webdriver-manager</span><br></pre></td></tr></table></figure><p>Usage：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> webdriver_manager.chrome <span class="keyword">import</span> ChromeDriverManager</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome(ChromeDriverManager().install())</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://stackoverflow.com/questions/60296873/sessionnotcreatedexception-message-session-not-created-this-version-of-chrome">SessionNotCreatedException: Message: session not created: This version of ChromeDriver only supports Chrome version 81</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在使用Selenium调用Chrome浏览器爬取互联网数据时，会遇到Chrome和ChromeDriver版本不兼容的问题，导致爬取失败。&lt;/p&gt;
&lt;p&gt;一种解决方案是，进行版本匹配。但是随着本机Chrome的更新，每次都需要随之更新ChromeDriver版本。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="网络爬虫" scheme="https://gmet233.gitee.io/categories/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"/>
    
    
    <category term="网络爬虫" scheme="https://gmet233.gitee.io/tags/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"/>
    
    <category term="Selenium" scheme="https://gmet233.gitee.io/tags/Selenium/"/>
    
  </entry>
  
  <entry>
    <title>基于ResNet的树叶分类任务</title>
    <link href="https://gmet233.gitee.io/2022/04/04/%E5%9F%BA%E4%BA%8EResNet%E7%9A%84%E6%A0%91%E5%8F%B6%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/"/>
    <id>https://gmet233.gitee.io/2022/04/04/%E5%9F%BA%E4%BA%8EResNet%E7%9A%84%E6%A0%91%E5%8F%B6%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/</id>
    <published>2022-04-04T03:16:17.000Z</published>
    <updated>2022-04-04T09:17:56.792Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本文任务、数据集来源于《动手学深度学习》课程中的树叶分类竞赛。详见参考资料1</p><p>本文代码主要参考kaggle用户nekokiku给出的resnet baseline。详见参考资料2</p><p>通过本次竞赛和代码可以学习到：</p><ul><li>简单的PyTorch深度学习项目代码、结构是怎样的</li><li>如何继承PyTorch中的Dataset, DataLoader实现自己的Dataset, DataLoader类</li><li>如何使用PyTorch快速实现ResNet模型。</li></ul></blockquote><h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><p>分析baseline code，总结一下深度学习的代码流程。</p><ol><li>处理数据：包括元数据和图像数据。比如看看数据的样子，标签的分布，unique 标签的数量等。</li><li>实现自己的Dataset、DataLoader类</li><li>CPU OR GPU</li><li>定义模型</li><li>定义超参数：学习率等</li><li>train&amp;valid</li><li>使用训练好的模型进行预测。</li></ol><h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p>针对本次任务项目结构如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">leaves_classification_competition/</span><br><span class="line">└─data/</span><br><span class="line">    └─classify-leaves/</span><br><span class="line">        └─images/</span><br><span class="line">└─train.csv</span><br><span class="line">└─test.csv</span><br><span class="line">└─script.ipynb</span><br></pre></td></tr></table></figure><p><code>data/</code>目录下是本次任务用到的数据。将从kaggle上下载的数据压缩包解压到本文件夹。</p><p><code>script.ipynb</code>是代码脚本。</p><p>在更大的训练中，代码应该拆分为各种<code>.py</code>文件。</p><h1 id="baseline"><a href="#baseline" class="headerlink" title="baseline"></a>baseline</h1><h2 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 首先导入包</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset, DataLoader</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> torchvision.models <span class="keyword">as</span> models</span><br><span class="line"><span class="comment"># This is for the progress bar.</span></span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br></pre></td></tr></table></figure><h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><p>看一看train.csv长什么样</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DATA_BASE_PATH = <span class="string">&#x27;./data/classify-leaves/&#x27;</span></span><br><span class="line"><span class="comment"># label文件</span></span><br><span class="line">labels_df = pd.read_csv(os.path.join(DATA_BASE_PATH, <span class="string">&#x27;train.csv&#x27;</span>))</span><br><span class="line">labels_df.head()</span><br><span class="line"><span class="comment"># len(labels_df)</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">labels_df.describe()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 把树叶的标签去重映射为数值</span></span><br><span class="line">leaves_labels = <span class="built_in">sorted</span>(<span class="built_in">list</span>(<span class="built_in">set</span>(labels_df[<span class="string">&#x27;label&#x27;</span>])))</span><br><span class="line">n_classes = <span class="built_in">len</span>(leaves_labels)</span><br><span class="line">class2num = <span class="built_in">dict</span>(<span class="built_in">zip</span>(leaves_labels, <span class="built_in">range</span>(n_classes)))</span><br><span class="line">class2num</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#x27;abies_concolor&#x27;: 0,</span><br><span class="line"> &#x27;abies_nordmanniana&#x27;: 1,</span><br><span class="line"> &#x27;acer_campestre&#x27;: 2,</span><br><span class="line">……</span><br><span class="line"> &#x27;zelkova_serrata&#x27;: 175&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 转换成key为数字，val为树叶类型，方便预测。</span></span><br><span class="line">num2class = &#123;v:k <span class="keyword">for</span> k, v <span class="keyword">in</span> class2num.items()&#125;</span><br><span class="line">num2class</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;0: &#x27;abies_concolor&#x27;,</span><br><span class="line"> 1: &#x27;abies_nordmanniana&#x27;,</span><br><span class="line"> 2: &#x27;acer_campestre&#x27;,</span><br><span class="line"> 3: &#x27;acer_ginnala&#x27;,</span><br><span class="line"> 4: &#x27;acer_griseum&#x27;,</span><br><span class="line">……</span><br><span class="line"> 175: &#x27;zelkova_serrata&#x27;&#125;</span><br></pre></td></tr></table></figure><h2 id="实现Dataset"><a href="#实现Dataset" class="headerlink" title="实现Dataset"></a>实现Dataset</h2><p>继承Dataset类，实现自己的Dataset。继承之后，需要实现三个函数</p><ul><li><code>__init__</code>：传入必要的参数，初始化；</li><li><code>__getitem__</code>：返回item，如果是train或者valid则返回img和label，如果是test则返回img</li><li><code>__len__</code>：数据集长度</li><li>更多参见参考资料3</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 继承Dataset类。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LeaveDataSet</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, csv_path, img_path, mode=<span class="string">&#x27;train&#x27;</span>, valid_ratio = <span class="number">0.2</span>, resize_height = <span class="number">256</span>, resize_width = <span class="number">256</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">          csv_path: label文件路径</span></span><br><span class="line"><span class="string">          img_path: 图片存放路径</span></span><br><span class="line"><span class="string">          mode: 训练模式还是测试模式</span></span><br><span class="line"><span class="string">          valid_ratio: 验证集比例</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.img_path = img_path</span><br><span class="line">        self.mode = mode</span><br><span class="line">        self.data_info = pd.read_csv(csv_path)</span><br><span class="line">        self.data_len = <span class="built_in">len</span>(self.data_info)</span><br><span class="line">        self.train_len = <span class="built_in">int</span>(self.data_len * (<span class="number">1</span> - valid_ratio))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> mode == <span class="string">&#x27;train&#x27;</span>:</span><br><span class="line">            <span class="comment"># 为啥要转成nparray</span></span><br><span class="line">            self.train_image = np.asarray(self.data_info.iloc[:self.train_len, <span class="number">0</span>])</span><br><span class="line">            self.train_label = np.asarray(self.data_info.iloc[:self.train_len, <span class="number">1</span>])</span><br><span class="line">            <span class="comment"># 为了在不同模式下统一变量</span></span><br><span class="line">            self.image_arr = self.train_image</span><br><span class="line">            self.label_arr = self.train_label</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> mode == <span class="string">&#x27;valid&#x27;</span>:</span><br><span class="line">            self.valid_image = np.asarray(self.data_info.iloc[self.train_len:,<span class="number">0</span>])</span><br><span class="line">            self.valid_label = np.asarray(self.data_info.iloc[self.train_len:,<span class="number">1</span>])</span><br><span class="line">            self.image_arr = self.valid_image</span><br><span class="line">            self.label_arr = self.valid_label</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.test_image = np.asarray(self.data_info.iloc[:,<span class="number">0</span>])</span><br><span class="line">            self.image_arr = self.test_image</span><br><span class="line">            <span class="comment">#test 没有label</span></span><br><span class="line">        self.real_len = <span class="built_in">len</span>(self.image_arr)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Finished reading the &#123;&#125; set of Leaves Dataset. (&#123;&#125; samples found)&quot;</span>.<span class="built_in">format</span>(mode, self.real_len))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, index</span>):</span><br><span class="line"></span><br><span class="line">        single_image_name = self.image_arr[index]</span><br><span class="line">        img_as_img = Image.<span class="built_in">open</span>(os.path.join(self.img_path, single_image_name))</span><br><span class="line">        <span class="keyword">if</span> self.mode == <span class="string">&#x27;train&#x27;</span>:</span><br><span class="line">            transform = transforms.Compose([</span><br><span class="line">                transforms.Resize((<span class="number">224</span>, <span class="number">224</span>)),</span><br><span class="line">                transforms.RandomHorizontalFlip(p=<span class="number">0.5</span>),   <span class="comment">#随机水平翻转 选择一个概率</span></span><br><span class="line">                transforms.ToTensor()</span><br><span class="line">            ])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># valid和test不做数据增强</span></span><br><span class="line">            transform = transforms.Compose([</span><br><span class="line">                transforms.Resize((<span class="number">224</span>, <span class="number">224</span>)),</span><br><span class="line">                transforms.ToTensor()</span><br><span class="line">            ])</span><br><span class="line">        img_as_img = transform(img_as_img)</span><br><span class="line">        <span class="comment"># 先不做图像裁剪，增强和灰度处理</span></span><br><span class="line">        <span class="keyword">if</span> self.mode == <span class="string">&#x27;test&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> img_as_img</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            label = self.label_arr[index]</span><br><span class="line">            <span class="comment"># label转数字</span></span><br><span class="line">            number_label = class2num[label]</span><br><span class="line">            <span class="keyword">return</span> img_as_img, number_label</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.real_len</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">生成dataset对象</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">train_csv_path = <span class="string">&#x27;./data/classify-leaves/train.csv&#x27;</span></span><br><span class="line">test_csv_path = <span class="string">&#x27;./data/classify-leaves/test.csv&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># csv文件中已经images的路径了，因此这里只到上一级目录</span></span><br><span class="line"></span><br><span class="line">img_path = <span class="string">&#x27;./data/classify-leaves/&#x27;</span></span><br><span class="line"></span><br><span class="line">train_dataset = LeaveDataSet(train_csv_path, img_path, mode=<span class="string">&#x27;train&#x27;</span>)</span><br><span class="line">test_dataset = LeaveDataSet(train_csv_path, img_path, mode=<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line">valid_dataset = LeaveDataSet(train_csv_path, img_path, mode=<span class="string">&#x27;valid&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Finished reading the train set of Leaves Dataset (14681 samples found)</span><br><span class="line">Finished reading the test set of Leaves Dataset (18353 samples found)</span><br><span class="line">Finished reading the valid set of Leaves Dataset (3672 samples found)</span><br></pre></td></tr></table></figure><h2 id="实现Dataloader"><a href="#实现Dataloader" class="headerlink" title="实现Dataloader"></a>实现Dataloader</h2><p>定义train，valid，test的dataloader，参数详见参考资料4</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义 data loader</span></span><br><span class="line"><span class="comment"># dataloader 参数详解：https://blog.csdn.net/qq_36653505/article/details/84728855</span></span><br><span class="line"></span><br><span class="line">train_loader = DataLoader(</span><br><span class="line">    dataset=train_dataset,</span><br><span class="line">    batch_size=<span class="number">8</span>,</span><br><span class="line">    shuffle=<span class="literal">False</span>,</span><br><span class="line">    num_workers=<span class="number">5</span> <span class="comment"># 使用nums_workers个线程读数据</span></span><br><span class="line">)</span><br><span class="line">valid_loader = DataLoader(</span><br><span class="line">    dataset=valid_dataset,</span><br><span class="line">    batch_size=<span class="number">8</span>,</span><br><span class="line">    shuffle=<span class="literal">False</span>,</span><br><span class="line">    num_workers=<span class="number">5</span></span><br><span class="line">)</span><br><span class="line">test_loader = DataLoader(</span><br><span class="line">    dataset=test_dataset,</span><br><span class="line">    batch_size=<span class="number">8</span>,</span><br><span class="line">    shuffle=<span class="literal">False</span>,</span><br><span class="line">    num_workers=<span class="number">5</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="获取GPU"><a href="#获取GPU" class="headerlink" title="获取GPU"></a>获取GPU</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># CPU OR GPU</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_device</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;cuda&#x27;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&#x27;cpu&#x27;</span></span><br><span class="line"></span><br><span class="line">device = get_device()</span><br><span class="line"><span class="built_in">print</span>(device)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cuda</span><br></pre></td></tr></table></figure><h2 id="定义模型"><a href="#定义模型" class="headerlink" title="定义模型"></a>定义模型</h2><p>这里模型使用resnet34</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义resnet34</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">num_classes: 传入分类任务的类别数，由上面的数据可知，一共有176种树叶，所以一会调用该函数返回模型时，传入的num_classes参数为176</span></span><br><span class="line"><span class="string">use_pretrained: 是否使用预训练模型。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">res_model</span>(<span class="params">num_classes, feature_extract = <span class="literal">False</span>, use_pretrained = <span class="literal">False</span></span>):</span><br><span class="line">    model_ft = models.resnet34(pretrained=use_pretrained)</span><br><span class="line">    <span class="comment"># set_parameter_requires_grad(model_ft, feature_extract)</span></span><br><span class="line">    <span class="comment"># 这里是想要把原始模型的最后一层全连接层替换掉，替换成输出类别为num_classes的全连接层。</span></span><br><span class="line">    <span class="comment"># 为了做到这一点我们需要先知道原始模型的全连接层的输入feature维度。</span></span><br><span class="line">    num_ftrs = model_ft.fc.in_features</span><br><span class="line">    model_ft.fc = nn.Sequential(nn.Linear(num_ftrs, num_classes))</span><br><span class="line">    <span class="keyword">return</span> model_ft</span><br></pre></td></tr></table></figure><h2 id="定义超参数"><a href="#定义超参数" class="headerlink" title="定义超参数"></a>定义超参数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 超参数</span></span><br><span class="line">lr = <span class="number">3e-4</span> <span class="comment">#学习率</span></span><br><span class="line">weight_decay = <span class="number">1e-3</span></span><br><span class="line">num_epoch = <span class="number">50</span> <span class="comment">#迭代轮数</span></span><br><span class="line">model_path = <span class="string">&#x27;./pre_res_model.ckpt&#x27;</span> <span class="comment"># 模型保存位置</span></span><br></pre></td></tr></table></figure><h2 id="train-amp-valid"><a href="#train-amp-valid" class="headerlink" title="train&amp;valid"></a>train&amp;valid</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 模型初始化，并放到具体的设备中</span></span><br><span class="line">model = res_model(<span class="number">176</span>)</span><br><span class="line"><span class="comment"># 将模型放到device上。</span></span><br><span class="line">model = model.to(device)</span><br><span class="line">model.device = device <span class="comment"># 这行代码貌似没什么用</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分类任务使用交叉熵损失作为评估标准</span></span><br><span class="line">criterion = nn.CrossEntropyLoss()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Adam优化器</span></span><br><span class="line">optimizer = torch.optim.Adam(model.parameters(), lr = lr, weight_decay= weight_decay)</span><br><span class="line"></span><br><span class="line">n_epochs = num_epoch</span><br><span class="line"></span><br><span class="line">best_acc = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(n_epochs):</span><br><span class="line">    <span class="comment"># ------- train --------</span></span><br><span class="line">    <span class="comment"># 训练的时候，要调用该函数，使模型处于训练模式</span></span><br><span class="line">    model.train()</span><br><span class="line">    <span class="comment"># 记录每次使用一个batch训练后，模型的损失和精确率。</span></span><br><span class="line">    train_loss = []</span><br><span class="line">    train_accs = []</span><br><span class="line">    <span class="comment"># tqdm是一个显示进度条的工具包，不用管。</span></span><br><span class="line">    <span class="keyword">for</span> batch <span class="keyword">in</span> tqdm(train_loader):</span><br><span class="line">        <span class="comment"># A batch consists of image data and corresponding labels.</span></span><br><span class="line">        imgs, labels = batch</span><br><span class="line">        <span class="comment"># 把数据都放到同一个device上</span></span><br><span class="line">        imgs = imgs.to(device)</span><br><span class="line">        labels = labels.to(device)</span><br><span class="line"></span><br><span class="line">        logits = model(imgs)</span><br><span class="line">        <span class="comment"># 计算模型输出和真实label之间的损失，反向传播。。</span></span><br><span class="line">        loss = criterion(logits, labels)</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">        <span class="comment">#这行code不是很懂，大概就是统计预测正确标签的占比</span></span><br><span class="line">        <span class="comment"># 弄明白：https://csbwang.github.io/dl_ch2#2161</span></span><br><span class="line">        acc = (logits.argmax(dim = -<span class="number">1</span>) == labels).<span class="built_in">float</span>().mean()</span><br><span class="line">        </span><br><span class="line">        train_loss.append(loss.item())</span><br><span class="line">        train_accs.append(acc)</span><br><span class="line">    <span class="comment"># 计算本次epoch后的loss和acc</span></span><br><span class="line">    train_loss = <span class="built_in">sum</span>(train_loss) / <span class="built_in">len</span>(train_loss)</span><br><span class="line">    train_acc = <span class="built_in">sum</span>(train_accs) / <span class="built_in">len</span>(train_accs)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;[ Train | <span class="subst">&#123;epoch + <span class="number">1</span>:03d&#125;</span>/<span class="subst">&#123;n_epochs:03d&#125;</span> ] loss = <span class="subst">&#123;train_loss:<span class="number">.5</span>f&#125;</span>, acc = <span class="subst">&#123;train_acc:<span class="number">.5</span>f&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="comment"># ------- valid --------</span></span><br><span class="line">    <span class="comment"># 验证时，把模型调成评估模式</span></span><br><span class="line">    model.<span class="built_in">eval</span>()  <span class="comment"># eval具体是做什么?</span></span><br><span class="line"></span><br><span class="line">    valid_loss = []</span><br><span class="line">    valid_accs = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> batch <span class="keyword">in</span> tqdm(valid_loader):</span><br><span class="line">        imgs, labels = batch</span><br><span class="line">        <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">            logits = model(imgs.to(device))</span><br><span class="line">        loss = criterion(logits, labels.to(device))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># acc = (logits.argmax(dim = -1) == labels).float().mean()</span></span><br><span class="line">        acc = (logits.argmax(dim = -<span class="number">1</span>) == labels.to(device)).<span class="built_in">float</span>().mean()</span><br><span class="line"></span><br><span class="line">        valid_loss.append(loss.item())</span><br><span class="line">        valid_accs.append(acc)</span><br><span class="line">    </span><br><span class="line">    valid_loss = <span class="built_in">sum</span>(valid_loss) / <span class="built_in">len</span>(valid_loss)</span><br><span class="line">    valid_acc = <span class="built_in">sum</span>(valid_accs) / <span class="built_in">len</span>(valid_accs)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;[ Valid | <span class="subst">&#123;epoch + <span class="number">1</span>:03d&#125;</span>/<span class="subst">&#123;n_epochs:03d&#125;</span> ] loss = <span class="subst">&#123;valid_loss:<span class="number">.5</span>f&#125;</span>, acc = <span class="subst">&#123;valid_acc:<span class="number">.5</span>f&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果在验证集得到的acc大于已知最好的acc，则保存模型。</span></span><br><span class="line">    <span class="keyword">if</span> valid_acc &gt; best_acc:</span><br><span class="line">        best_acc = valid_acc</span><br><span class="line">        torch.save(model.state_dict(), model_path)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;saving model with acc &#123;:.3f&#125;&#x27;</span>.<span class="built_in">format</span>(best_acc))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>//控制台输出</p><h2 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h2><p>上面就是训练过程，下面用训练好的模型进行预测</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">################ </span></span><br><span class="line">saveFileName = <span class="string">&#x27;./data/classify-leaves/submission.csv&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## predict</span></span><br><span class="line">model = res_model(<span class="number">176</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># create model and load weights from checkpoint</span></span><br><span class="line">model = model.to(device)</span><br><span class="line">model.load_state_dict(torch.load(model_path))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Make sure the model is in eval mode.</span></span><br><span class="line"><span class="comment"># Some modules like Dropout or BatchNorm affect if the model is in training mode.</span></span><br><span class="line">model.<span class="built_in">eval</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Initialize a list to store the predictions.</span></span><br><span class="line">predictions = []</span><br><span class="line"><span class="comment"># Iterate the testing set by batches.</span></span><br><span class="line"><span class="keyword">for</span> batch <span class="keyword">in</span> tqdm(test_loader):</span><br><span class="line">    </span><br><span class="line">    imgs = batch</span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        logits = model(imgs.to(device))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Take the class with greatest logit as prediction and record it.</span></span><br><span class="line">    predictions.extend(logits.argmax(dim=-<span class="number">1</span>).cpu().numpy().tolist())</span><br><span class="line"></span><br><span class="line">preds = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> predictions:</span><br><span class="line">    preds.append(num2class[i])</span><br><span class="line"></span><br><span class="line">test_data = pd.read_csv(test_path)</span><br><span class="line">test_data[<span class="string">&#x27;label&#x27;</span>] = pd.Series(preds)</span><br><span class="line">submission = pd.concat([test_data[<span class="string">&#x27;image&#x27;</span>], test_data[<span class="string">&#x27;label&#x27;</span>]], axis=<span class="number">1</span>)</span><br><span class="line">submission.to_csv(saveFileName, index=<span class="literal">False</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Done!!!!!!!!!!!!!!!!!!!!!!!!!!!&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="改进模型"><a href="#改进模型" class="headerlink" title="改进模型"></a>改进模型</h1><p>//TODO</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>初学深度学习，代码上犯了很多细节上的错误。其次，很多细节问题不明白，例如，优化器？各种计算公式等。以后要弄懂。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://www.bilibili.com/video/BV1z64y1o7iz">第二部分完结竞赛：图片分类【动手学深度学习v2】</a></li><li><a href="https://www.kaggle.com/code/nekokiku/simple-resnet-baseline">nekokiku/simple-resnet-baseline</a></li><li><a href="https://blog.csdn.net/leviopku/article/details/99958182">Pytorch中的dataset类——创建适应任意模型的数据集接口</a></li><li><a href="https://blog.csdn.net/qq_36653505/article/details/84728855">Pytorch 中的数据类型 torch.utils.data.DataLoader 参数详解</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本文任务、数据集来源于《动手学深度学习》课程中的树叶分类竞赛。详见参考资料1&lt;/p&gt;
&lt;p&gt;本文代码主要参考kag</summary>
      
    
    
    
    <category term="深度学习" scheme="https://gmet233.gitee.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="动手学深度学习" scheme="https://gmet233.gitee.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="深度学习" scheme="https://gmet233.gitee.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>复现ResNet50（PyTorch）</title>
    <link href="https://gmet233.gitee.io/2022/03/29/%E5%A4%8D%E7%8E%B0ResNet50%EF%BC%88PyTorch%EF%BC%89/"/>
    <id>https://gmet233.gitee.io/2022/03/29/%E5%A4%8D%E7%8E%B0ResNet50%EF%BC%88PyTorch%EF%BC%89/</id>
    <published>2022-03-29T13:45:17.000Z</published>
    <updated>2022-03-30T13:47:01.221Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本篇博客介绍了 ResNet50 网络 PyTorch 复现（复现代码为 PyTorch 源码）</p></blockquote><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>Residual Net：残差网络。</p><p>将靠前若干层的某一层数据输出直接跳过多层引入到后面数据层的输入部分。意味着后面的特征层的内容会有一部分由其前面的某一层线性贡献。</p><p><img src="image-20220329215711900.png" alt="残差块"></p><p>深度残差网络的设计是为了克服由于网络深度加深而产生的学习效率变低与准确率无法有效提升的问题。</p><p>下面这张图来自参考文献[1]，给出了ResNet18、ResNet34、ResNet50、ResNet101、ResNet152的块结构。</p><p><img src="image-20220329220108463.png" alt="ResNet-XX 网络结构"></p><p>根据该图，我们可以画出ResNet50的网络结构，</p><p><img src="image-20220329220245960.png" alt="ResNet-50 网络结构"></p><p>由上述网络结构可以看到，ResNet包含两种Block：分别为<strong>Conv Block</strong>和<strong>Identity Block</strong>。</p><ul><li><strong>Conv Block</strong>输入和输出的维度（通道数和size）是不一样的，所以相同的Conv Block不能连续串联，它的作用是改变网络的维度；</li><li><strong>Identity Block</strong>输入维度和输出维度（通道数和size）相同，可以串联，用于加深网络的。</li></ul><p>下面是两种块的结构：</p><p><img src="image-20220329221454060.png" alt="Conv Block"></p><p><img src="image-20220329221531582.png" alt="Identity Block"></p><p>这两种块的区别在于残差边是否卷积。如果经过$1*1$卷积。经过卷积的是Conv Block，直连的是Identity Block。</p><p>稍后用一个类<code>Bottleneck</code>实现这两种块。</p><p>下面参考PyTorch框架源码，对 ResNet50  一步步复现。</p><h1 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h1><h2 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br></pre></td></tr></table></figure><h2 id="ResNet50-生成函数"><a href="#ResNet50-生成函数" class="headerlink" title="ResNet50 生成函数"></a>ResNet50 生成函数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">resnet50</span>(<span class="params">pretrained = <span class="literal">False</span>, **kwargs</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    Constructs a ResNet-50 model.</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        pretrained:(bool): If True, return a model pretrained on ImageNet</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    model = ResNet(Bottleneck, [<span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>], **kwargs)</span><br><span class="line">    <span class="keyword">if</span> pretrained:</span><br><span class="line">        <span class="comment"># model.load_state_dict(model_zoo.load_url(model_urls[&#x27;resnet50&#x27;]))</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">return</span> model</span><br><span class="line"></span><br><span class="line">net = resnet50()</span><br></pre></td></tr></table></figure><p>通过 <code>model = ResNet(Bottleneck, [3, 4, 6, 3], **kwargs)</code> 构造网络结构，主要分成两个部分即 <code>Bottleneck</code>和 <code>[3,4,6,3]</code> 由这两个参数共同决定了ResNet50的网络结构 ，当<code>pretrained</code>为<code>True</code>时，model加载ImageNet中预训练的参数。（这块本篇文章先不考虑）</p><p><code>[3,4,6,3]</code>对应于上图中ResNet50中 conv2_x中有三个（$1<em>1, 64$，$3</em>3, 64$，$1<em>1, 256$）卷积层的堆叠 ，同理conv3_x中有4个（$1</em>1, 128$，$3<em>3, 128$，$1</em>1, 512$）卷积层的堆叠，ResNet50将卷积层分为4个大层，<code>[3,4,6,3]</code>代表每一个大层中$1<em>1$，$3</em>3$，$1<em>1$卷积层组合的重复次数总共1（第一个卷积层）+1（第一个池化层）+（3+4+6+3）</em>3 = 50层。</p><p>这里<code>Bottleneck</code>类，就是一个基础块。对应上图（$1<em>1$，$3</em>3$，$1*1$）的三个卷积层组合。</p><h2 id="ResNet类"><a href="#ResNet类" class="headerlink" title="ResNet类"></a>ResNet类</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ResNet</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_make_layer</span>(<span class="params">self, block, planes, blocks, stride=<span class="number">1</span></span>):</span><br><span class="line">        downsample = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> stride != <span class="number">1</span> <span class="keyword">or</span> self.inplanes != planes * block.expansion:</span><br><span class="line">            downsample = nn.Sequential(</span><br><span class="line">                nn.Conv2d(self.inplanes, planes * block.expansion,</span><br><span class="line">                kernel_size=<span class="number">1</span>, stride=stride, bias=<span class="literal">False</span>),</span><br><span class="line">                nn.BatchNorm2d(planes * block.expansion)</span><br><span class="line">            )</span><br><span class="line">        layers = []</span><br><span class="line">        layers.append(block(self.inplanes, planes, stride, downsample))</span><br><span class="line">        self.inplanes = planes * block.expansion</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, blocks): <span class="comment"># for (blocks - 1)</span></span><br><span class="line">            layers.append(block(self.inplanes, planes))</span><br><span class="line">        <span class="keyword">return</span> nn.Sequential(*layers)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, block, layers, num_classes = <span class="number">1000</span></span>):</span><br><span class="line">        self.inplanes = <span class="number">64</span></span><br><span class="line">        <span class="built_in">super</span>(ResNet, self).__init__() <span class="comment"># ?</span></span><br><span class="line">        self.conv1 = nn.Conv2d(<span class="number">3</span>, <span class="number">64</span>, kernel_size=<span class="number">7</span>, stride=<span class="number">2</span>, padding=<span class="number">3</span>, bias=<span class="literal">False</span>)</span><br><span class="line">        self.bn1 = nn.BatchNorm2d(<span class="number">64</span>)</span><br><span class="line">        self.relu = nn.ReLU(inplace=<span class="literal">True</span>)</span><br><span class="line">        self.maxpool = nn.MaxPool2d(kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>, padding=<span class="number">1</span>)</span><br><span class="line">        self.layer1 = self._make_layer(block, <span class="number">64</span>, layers[<span class="number">0</span>])</span><br><span class="line">        self.layer2 = self._make_layer(block, <span class="number">128</span>, layers[<span class="number">1</span>], stride=<span class="number">2</span>)</span><br><span class="line">        self.layer3 = self._make_layer(block, <span class="number">256</span>, layers[<span class="number">2</span>], stride=<span class="number">2</span>)</span><br><span class="line">        self.layer4 = self._make_layer(block, <span class="number">512</span>, layers[<span class="number">3</span>], stride=<span class="number">2</span>)</span><br><span class="line">        self.avgpool = nn.AvgPool2d(<span class="number">7</span>, stride=<span class="number">1</span>)</span><br><span class="line">        <span class="comment">#因为最后feature map在输入为224时，经过layer4之后大小为7*7，此时经过nn.AvgPool2d(7, stride=1)大小变为1*1，再经过全连接层时，self.fc = nn.Linear(512 * block.expansion, num_classes) 前者是输出的所有channel数目，实际应该为channel*1*1，后者为分类数</span></span><br><span class="line">        self.fc = nn.Linear(<span class="number">512</span> * block.expansion, num_classes)</span><br><span class="line"><span class="comment"># ?</span></span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> self.modules():</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(m, nn.Conv2d):</span><br><span class="line">                nn.init.kaiming_normal_(m.weight, mode=<span class="string">&#x27;fan_out&#x27;</span>, nonlinearity=<span class="string">&#x27;relu&#x27;</span>)</span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">isinstance</span>(m, nn.BatchNorm2d):</span><br><span class="line">                nn.init.constant_(m.weight, <span class="number">1</span>)</span><br><span class="line">                nn.init.constant_(m.bias, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">       self.avgpool = nn.AvgPool2d(<span class="number">7</span>, stride=<span class="number">1</span>)</span><br><span class="line">  x = self.avgpool(x)  </span><br><span class="line"></span><br><span class="line">  x = x.view(x.size(<span class="number">0</span>), -<span class="number">1</span>)     </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="comment"># 首先对输入进行7*7的卷积</span></span><br><span class="line">        x = self.conv1(x)</span><br><span class="line">        x = self.bn1(x)</span><br><span class="line">        x = self.relu(x)</span><br><span class="line">        <span class="comment"># 然后对x进行3*3的最大池化</span></span><br><span class="line">        x = self.maxpool(x)</span><br><span class="line"><span class="comment"># 接着进入四个layer/stage</span></span><br><span class="line">        x = self.layer1(x)</span><br><span class="line">        x = self.layer2(x)</span><br><span class="line">        x = self.layer3(x)</span><br><span class="line">        x = self.layer4(x)</span><br><span class="line"><span class="comment">#最后平均池化</span></span><br><span class="line"></span><br><span class="line">        x = self.avgpool(x)</span><br><span class="line">        <span class="comment"># 将数据拉伸成batchsize * channel * 1 * 1 ?</span></span><br><span class="line">        x = x.view(x.size(<span class="number">0</span>), -<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 如果输入大小不为224  那么相应的可以修改AvgPool2d 或者在全连接层第一个参数中乘上最终的width 和height</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><p>ResNet 是由<code>__init__</code>和<code>forward</code>构成，为了方便分析这里首先分析<code>__init__</code>函数。</p><h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><p>在<code>__init__</code>中，最重要的是<code>_make_layer</code>函数，以<code>layer1</code>为例，block为Bottleneck，planes=64（即channel数目）blocks=3 （<code>[3,4,6,3]</code>分别代表每一层的blocks数目）这里要注意<code>layer1</code>的stride为1，其他layer的stride为2。</p><p>对于<code>layer1</code>而言，<code>inplanes=64</code>， <code>planes=64</code>， <code>block.expansion=4</code>，因此需要经过downsample才能够使得残差和经过该层的feature map能够相加，downsample即为右路部分。（可以看<code>Bottleneck</code>的实现）</p><h3 id="forward"><a href="#forward" class="headerlink" title="forward"></a>forward</h3><p>见上面的代码注释。</p><h2 id="Bottleneck"><a href="#Bottleneck" class="headerlink" title="Bottleneck"></a>Bottleneck</h2><p>接着我们看一下Bottleneck的实现。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    Block的各个plane值：</span></span><br><span class="line"><span class="string">        inplanes：输出block的之前的通道数</span></span><br><span class="line"><span class="string">        planes：在block中间处理的时候的通道数（这个值是输出维度的1/4）</span></span><br><span class="line"><span class="string">        midplane*self.expansion：输出的维度</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bottleneck</span>(nn.Module):</span><br><span class="line">    <span class="comment">#每个stage中维度拓展的倍数</span></span><br><span class="line">    expansion = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1 * 1卷积核不改变feature map的大小，3 * 3卷积核padding=1&amp;&amp;stride=1也不改变输入feature map的大小，因此经过一个Bottleneck组成的卷积层组操作后feature map大小不会改变</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, inplanes, planes, stride = <span class="number">1</span>, downsample=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(Bottleneck, self).__init__()</span><br><span class="line">        self.conv1 = nn.Conv2d(inplanes, planes, kernel_size=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">        self.bn1 = nn.BatchNorm2d(planes)</span><br><span class="line">        self.conv2 = nn.Conv2d(planes, planes, kernel_size=<span class="number">3</span>, stride=stride, padding=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">        self.bn2 = nn.BatchNorm2d(planes)</span><br><span class="line">        self.conv3 = nn.Conv2d(planes, planes * self.expansion, kernel_size=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">        self.bn3 = nn.BatchNorm2d(planes * self.expansion)</span><br><span class="line">        self.relu = nn.ReLU(inplace= <span class="literal">True</span>)</span><br><span class="line">        self.downsample = downsample</span><br><span class="line">        self.stride = stride</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        residual = x</span><br><span class="line">        out = self.conv1(x)</span><br><span class="line">        out = self.bn1(out)</span><br><span class="line">        out = self.conv2(out)</span><br><span class="line">        out = self.bn2(out)</span><br><span class="line">        out = self.conv3(out)</span><br><span class="line">        out = self.bn3(out)</span><br><span class="line">        <span class="keyword">if</span> self.downsample <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            residual = self.downsample(x)</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        out += residual</span><br><span class="line">        out = self.relu(out)</span><br><span class="line">        <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure><p>其中当<code>downsample</code>为None时，残差边直连，此时为Identify Block，当<code>downsample</code>不为None时，残差边进行卷积再相加，此时为Conv Block。</p><blockquote><p>为什么要先卷积再相加呢？</p><p>因为feature map的大小不变 但是在经过Bottleneck 之后channel变成了原来的四倍，因此想要和原始的feature map相加需要将原始的feature map也变为原来的四倍 ，downsample作用是residual+当前feature map时将维度统一。</p></blockquote><h1 id="从输入到layers"><a href="#从输入到layers" class="headerlink" title="从输入到layers"></a>从输入到layers</h1><p>首先输入(3, 224, 224)，即三个通道，224<em>224像素的输入，经过一个输出通道数为64的7\</em>7卷积层，一个3*3池化，得到(64, 56, 56)。然后将其输入到layer1、2、3、4。</p><blockquote><p>解释一下为什么是(64, 56, 56)</p><p>因为ResNet接受的图像大小为224 * 224 经过第一层卷积层<code>self.conv1 = nn.Conv2d(3, 64, kernel_size=7, stride=2, padding=3, bias=False)</code></p><script type="math/tex; mode=display">floor((224-7+3*2)/2)+1=112</script><p>经过第一层池化之后，<code>self.maxpool = nn.MaxPool2d(kernel_size=3, stride=2, padding=1)</code></p><script type="math/tex; mode=display">floor((112+2*1-3)/2)+1=56</script><p>因此在输入到Bottleneck之前得到一个64(channel), 56(height)，56(weight)大小的feature map。</p></blockquote><h2 id="layer1-Bottleneck1"><a href="#layer1-Bottleneck1" class="headerlink" title="layer1/Bottleneck1"></a>layer1/Bottleneck1</h2><p>输入 ：[batch_size,64,56,56]</p><p>调用<code>_make_layer(block, 64, layers[0])</code>构造了layer1，此时<code>self.inplanes</code>为64，<code>planes * block.expansion</code>=64 <em> 4，不相等（之所以要二者相等，是因为在<code>Bottleneck</code>主体分支最后一个卷积层会将<code>channel</code>变为`planes</em>block.expansion<code>，如果</code>inplanes<code>（实际就是输入的channel）与之不相等则不可相加因此构造右路</code>downsample` （1*1卷积核的卷积层扩展channel+BN层）</p><p><img src="20181108104951863.png" alt="主体分支"></p><p><img src="20181108105037539.png" alt="downsample分支"></p><p>更新 inplanes=64*4=256</p><h2 id="layer1-Bottleneck2"><a href="#layer1-Bottleneck2" class="headerlink" title="layer1/Bottleneck2"></a>layer1/Bottleneck2</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">self.conv1 = nn.Conv2d(<span class="number">256</span>, <span class="number">64</span>, kernel_size=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">self.bn1 = nn.BatchNorm2d(<span class="number">64</span>)</span><br><span class="line">self.conv2 = nn.Conv2d(<span class="number">64</span>, <span class="number">64</span>, kernel_size=<span class="number">3</span>, stride=stride, padding=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">self.bn2 = nn.BatchNorm2d(<span class="number">64</span>)</span><br><span class="line">self.conv3 = nn.Conv2d(<span class="number">64</span>,<span class="number">256</span>, kernel_size=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">self.bn3 = nn.BatchNorm2d(planes * self.expansion)</span><br><span class="line">self.relu = nn.ReLU(inplace=<span class="literal">True</span>)</span><br><span class="line">self.downsample = <span class="literal">None</span></span><br><span class="line">self.stride = <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="layer1-Bottleneck3"><a href="#layer1-Bottleneck3" class="headerlink" title="layer1/Bottleneck3"></a>layer1/Bottleneck3</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">self.conv1 = nn.Conv2d(<span class="number">256</span>, <span class="number">64</span>, kernel_size=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">self.bn1 = nn.BatchNorm2d(<span class="number">64</span>)</span><br><span class="line">self.conv2 = nn.Conv2d(<span class="number">64</span>, <span class="number">64</span>, kernel_size=<span class="number">3</span>, stride=stride,padding=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">self.bn2 = nn.BatchNorm2d(<span class="number">64</span>)</span><br><span class="line">self.conv3 = nn.Conv2d(<span class="number">64</span>,<span class="number">256</span>, kernel_size=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">self.bn3 = nn.BatchNorm2d(planes * self.expansion)</span><br><span class="line">self.relu = nn.ReLU(inplace=<span class="literal">True</span>)</span><br><span class="line">self.downsample = <span class="literal">None</span></span><br><span class="line">self.stride = <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="layer2-Bottleneck1"><a href="#layer2-Bottleneck1" class="headerlink" title="layer2/Bottleneck1"></a>layer2/Bottleneck1</h2><p>此时<code>stride</code>=2，<code>self.inplanes</code>=256， <code>planes * block.expansion</code>=128*4，需要生成downsample层</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">downsample = nn.Sequential(</span><br><span class="line">nn.Conv2d(<span class="number">256</span>, <span class="number">512</span>,kernel_size=<span class="number">1</span>, stride=<span class="number">2</span>, bias=<span class="literal">False</span>),</span><br><span class="line">nn.BatchNorm2d(<span class="number">512</span>),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>生成第一个Bottleneck的主干</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">self.conv1 = nn.Conv2d(<span class="number">256</span>, <span class="number">128</span>, kernel_size=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">self.bn1 = nn.BatchNorm2d(planes)</span><br><span class="line"><span class="comment"># 此时feature map 大小由56变成28</span></span><br><span class="line">self.conv2 = nn.Conv2d(<span class="number">128</span>, <span class="number">128</span>, kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>, padding=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">self.bn2 = nn.BatchNorm2d(planes)</span><br><span class="line">self.conv3 = nn.Conv2d(<span class="number">128</span>, <span class="number">512</span>, kernel_size=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">self.bn3 = nn.BatchNorm2d(planes * self.expansion)</span><br><span class="line">self.relu = nn.ReLU(inplace=<span class="literal">True</span>)</span><br><span class="line">self.downsample = downsample</span><br><span class="line">self.stride = stride</span><br></pre></td></tr></table></figure><p>更新inplanes=512</p><h2 id="layer2-Bottleneck234"><a href="#layer2-Bottleneck234" class="headerlink" title="layer2/Bottleneck234"></a>layer2/Bottleneck234</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">self.conv1 = nn.Conv2d(<span class="number">512</span>, <span class="number">128</span>, kernel_size=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">self.bn1 = nn.BatchNorm2d(<span class="number">64</span>)</span><br><span class="line">self.conv2 = nn.Conv2d(<span class="number">128</span>, <span class="number">128</span>, kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>,padding=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">self.bn2 = nn.BatchNorm2d(<span class="number">64</span>)</span><br><span class="line">self.conv3 = nn.Conv2d(<span class="number">128</span>,<span class="number">256</span>, kernel_size=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">self.bn3 = nn.BatchNorm2d(planes * self.expansion)</span><br><span class="line">self.relu = nn.ReLU(inplace=<span class="literal">True</span>)</span><br><span class="line">self.downsample = <span class="literal">None</span></span><br><span class="line">self.stride = <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="layer3-4"><a href="#layer3-4" class="headerlink" title="layer3/4"></a>layer3/4</h2><p>对于layer3和layer4同理。</p><h2 id="打印完整的网络结构"><a href="#打印完整的网络结构" class="headerlink" title="打印完整的网络结构"></a>打印完整的网络结构</h2><p>最后，我们打印完整的网络结构：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">net</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ResNet(</span><br><span class="line">  (conv1): Conv2d(3, 64, kernel_size=(7, 7), stride=(2, 2), padding=(3, 3), bias=False)</span><br><span class="line">  (bn1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">  (relu): ReLU(inplace=True)</span><br><span class="line">  (maxpool): MaxPool2d(kernel_size=3, stride=2, padding=1, dilation=1, ceil_mode=False)</span><br><span class="line">  (layer1): Sequential(</span><br><span class="line">    (0): Bottleneck(</span><br><span class="line">      (conv1): Conv2d(64, 64, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)</span><br><span class="line">      (bn2): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv3): Conv2d(64, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn3): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (relu): ReLU(inplace=True)</span><br><span class="line">      (downsample): Sequential(</span><br><span class="line">        (0): Conv2d(64, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">        (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">    (1): Bottleneck(</span><br><span class="line">      (conv1): Conv2d(256, 64, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)</span><br><span class="line">      (bn2): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv3): Conv2d(64, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn3): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (relu): ReLU(inplace=True)</span><br><span class="line">    )</span><br><span class="line">    (2): Bottleneck(</span><br><span class="line">      (conv1): Conv2d(256, 64, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)</span><br><span class="line">      (bn2): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv3): Conv2d(64, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn3): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (relu): ReLU(inplace=True)</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">  (layer2): Sequential(</span><br><span class="line">    (0): Bottleneck(</span><br><span class="line">      (conv1): Conv2d(256, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv2): Conv2d(128, 128, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False)</span><br><span class="line">      (bn2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv3): Conv2d(128, 512, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn3): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (relu): ReLU(inplace=True)</span><br><span class="line">      (downsample): Sequential(</span><br><span class="line">        (0): Conv2d(256, 512, kernel_size=(1, 1), stride=(2, 2), bias=False)</span><br><span class="line">        (1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">    (1): Bottleneck(</span><br><span class="line">      (conv1): Conv2d(512, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv2): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)</span><br><span class="line">      (bn2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv3): Conv2d(128, 512, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn3): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (relu): ReLU(inplace=True)</span><br><span class="line">    )</span><br><span class="line">    (2): Bottleneck(</span><br><span class="line">      (conv1): Conv2d(512, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv2): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)</span><br><span class="line">      (bn2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv3): Conv2d(128, 512, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn3): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (relu): ReLU(inplace=True)</span><br><span class="line">    )</span><br><span class="line">    (3): Bottleneck(</span><br><span class="line">      (conv1): Conv2d(512, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv2): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)</span><br><span class="line">      (bn2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv3): Conv2d(128, 512, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn3): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (relu): ReLU(inplace=True)</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">  (layer3): Sequential(</span><br><span class="line">    (0): Bottleneck(</span><br><span class="line">      (conv1): Conv2d(512, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False)</span><br><span class="line">      (bn2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv3): Conv2d(256, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn3): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (relu): ReLU(inplace=True)</span><br><span class="line">      (downsample): Sequential(</span><br><span class="line">        (0): Conv2d(512, 1024, kernel_size=(1, 1), stride=(2, 2), bias=False)</span><br><span class="line">        (1): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">    (1): Bottleneck(</span><br><span class="line">      (conv1): Conv2d(1024, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)</span><br><span class="line">      (bn2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv3): Conv2d(256, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn3): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (relu): ReLU(inplace=True)</span><br><span class="line">    )</span><br><span class="line">    (2): Bottleneck(</span><br><span class="line">      (conv1): Conv2d(1024, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)</span><br><span class="line">      (bn2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv3): Conv2d(256, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn3): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (relu): ReLU(inplace=True)</span><br><span class="line">    )</span><br><span class="line">    (3): Bottleneck(</span><br><span class="line">      (conv1): Conv2d(1024, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)</span><br><span class="line">      (bn2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv3): Conv2d(256, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn3): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (relu): ReLU(inplace=True)</span><br><span class="line">    )</span><br><span class="line">    (4): Bottleneck(</span><br><span class="line">      (conv1): Conv2d(1024, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)</span><br><span class="line">      (bn2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv3): Conv2d(256, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn3): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (relu): ReLU(inplace=True)</span><br><span class="line">    )</span><br><span class="line">    (5): Bottleneck(</span><br><span class="line">      (conv1): Conv2d(1024, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)</span><br><span class="line">      (bn2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv3): Conv2d(256, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn3): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (relu): ReLU(inplace=True)</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">  (layer4): Sequential(</span><br><span class="line">    (0): Bottleneck(</span><br><span class="line">      (conv1): Conv2d(1024, 512, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv2): Conv2d(512, 512, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False)</span><br><span class="line">      (bn2): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv3): Conv2d(512, 2048, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn3): BatchNorm2d(2048, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (relu): ReLU(inplace=True)</span><br><span class="line">      (downsample): Sequential(</span><br><span class="line">        (0): Conv2d(1024, 2048, kernel_size=(1, 1), stride=(2, 2), bias=False)</span><br><span class="line">        (1): BatchNorm2d(2048, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">    (1): Bottleneck(</span><br><span class="line">      (conv1): Conv2d(2048, 512, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv2): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)</span><br><span class="line">      (bn2): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv3): Conv2d(512, 2048, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn3): BatchNorm2d(2048, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (relu): ReLU(inplace=True)</span><br><span class="line">    )</span><br><span class="line">    (2): Bottleneck(</span><br><span class="line">      (conv1): Conv2d(2048, 512, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv2): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)</span><br><span class="line">      (bn2): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (conv3): Conv2d(512, 2048, kernel_size=(1, 1), stride=(1, 1), bias=False)</span><br><span class="line">      (bn3): BatchNorm2d(2048, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span><br><span class="line">      (relu): ReLU(inplace=True)</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">  (avgpool): AvgPool2d(kernel_size=7, stride=1, padding=0)</span><br><span class="line">  (fc): Linear(in_features=2048, out_features=1000, bias=True)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>He K, Zhang X, Ren S, et al. Deep residual learning for image recognition[C]//Proceedings of the IEEE conference on computer vision and pattern recognition. 2016: 770-778.</li><li><a href="https://blog.csdn.net/a940902940902/article/details/83858694">ResNet结构分析</a></li><li><a href="https://www.bilibili.com/video/BV1154y1S7WC">史上最详细ResNet50复现解析（面向小白）</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本篇博客介绍了 ResNet50 网络 PyTorch 复现（复现代码为 PyTorch 源码）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="深度学习" scheme="https://gmet233.gitee.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="ResNet" scheme="https://gmet233.gitee.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/ResNet/"/>
    
    
    <category term="深度学习" scheme="https://gmet233.gitee.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="ResNet" scheme="https://gmet233.gitee.io/tags/ResNet/"/>
    
  </entry>
  
  <entry>
    <title>经典内排序算法汇总</title>
    <link href="https://gmet233.gitee.io/2022/03/26/%E7%BB%8F%E5%85%B8%E5%86%85%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/"/>
    <id>https://gmet233.gitee.io/2022/03/26/%E7%BB%8F%E5%85%B8%E5%86%85%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/</id>
    <published>2022-03-26T06:30:35.548Z</published>
    <updated>2022-04-12T14:57:08.874Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文介绍几种经典、常考的内排序算法。</p><p>本文试图建立一个比较标准的快速排序、归并排序、堆排序算法代码。</p><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>了解。</p><h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>每一轮选取未排定的部分中<strong>最小</strong>的部分交换到未排定部分的最开头，经过若干个步骤，就能排定整个数组。即：先选出最小的，再选出第 2 小的，以此类推。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>略</p><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>了解</p><h2 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h2><p>每次将一个数字插入一个有序的数组里，成为一个长度更长的有序数组，有限次操作以后，数组整体有序。</p><p><img src="插入排序.gif" alt="插入排序排序"></p><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><p>略</p><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>了解</p><h2 id="算法思想-2"><a href="#算法思想-2" class="headerlink" title="算法思想"></a>算法思想</h2><p>外层循环每一次经过两两比较，把每一轮未排定部分最大的元素放到了数组的末尾；<br>「冒泡排序」有个特点：在遍历的过程中，提前检测到数组是有序的，从而结束排序，而不像「选择排序」那样，即使输入数据是有序的，「选择排序」依然需要「傻乎乎」地走完所有的流程。</p><h2 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h2><p>略</p><h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p>了解</p><h2 id="算法思想-3"><a href="#算法思想-3" class="headerlink" title="算法思想"></a>算法思想</h2><p>插入排序的优化。在插入排序里，如果靠后的数字较小，它来到前面就得交换多次。「希尔排序」改进了这种做法。带间隔地使用插入排序，直到最后「间隔」为 11 的时候，就是标准的「插入排序」，此时数组里的元素已经「几乎有序」了。</p><h2 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h2><p>略</p><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>重要</p><h2 id="算法思想-4"><a href="#算法思想-4" class="headerlink" title="算法思想"></a>算法思想</h2><p>快速排序每一次都排定一个元素（这个元素呆在了它最终应该呆的位置），然后递归地去排它左边的部分和右边的部分，依次进行下去，直到数组有序。</p><h2 id="实现（递归）"><a href="#实现（递归）" class="headerlink" title="实现（递归）"></a>实现（递归）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//https://mp.weixin.qq.com/s/8ZTMhvHJK_He48PpSt_AmQ</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Quick</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 为了避免出现耗时的极端情况，先随机打乱</span></span><br><span class="line">        shuffle(nums);</span><br><span class="line">        <span class="comment">// 排序整个数组（原地修改）</span></span><br><span class="line">        sort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lo &gt;= hi) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对 nums[lo..hi] 进行切分</span></span><br><span class="line">        <span class="comment">// 使得 nums[lo..p-1] &lt;= nums[p] &lt; nums[p+1..hi]</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> partition(nums, lo, hi);</span><br><span class="line"></span><br><span class="line">        sort(nums, lo, p - <span class="number">1</span>);</span><br><span class="line">        sort(nums, p + <span class="number">1</span>, hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对 nums[lo..hi] 进行切分</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> nums[lo];</span><br><span class="line">        <span class="comment">// 关于区间的边界控制需格外小心，稍有不慎就会出错</span></span><br><span class="line">        <span class="comment">// 我这里把 i, j 定义为开区间，同时定义：</span></span><br><span class="line">        <span class="comment">// [lo, i) &lt;= pivot；(j, hi] &gt; pivot</span></span><br><span class="line">        <span class="comment">// 之后都要正确维护这个边界区间的定义</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo + <span class="number">1</span>, j = hi;</span><br><span class="line">        <span class="comment">// 当 i &gt; j 时结束循环，以保证区间 [lo, hi] 都被覆盖</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; hi &amp;&amp; nums[i] &lt;= pivot) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="comment">// 此 while 结束时恰好 nums[i] &gt; pivot</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; lo &amp;&amp; nums[j] &gt; pivot) &#123;</span><br><span class="line">                j--;</span><br><span class="line">                <span class="comment">// 此 while 结束时恰好 nums[j] &lt;= pivot</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 此时 [lo, i) &lt;= pivot &amp;&amp; (j, hi] &gt; pivot</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= j) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将 pivot 放到合适的位置，即 pivot 左边元素较小，右边元素较大</span></span><br><span class="line">        swap(nums, lo, j);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 洗牌算法，将输入的数组随机打乱</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shuffle</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 生成 [i, n - 1] 的随机数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> i + rand.nextInt(n - i);</span><br><span class="line">            swap(nums, i, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原地交换数组中的两个元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现（非递归）"><a href="#实现（非递归）" class="headerlink" title="实现（非递归）"></a>实现（非递归）</h2><p>暂略</p><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>重要</p><h2 id="算法思想-5"><a href="#算法思想-5" class="headerlink" title="算法思想"></a>算法思想</h2><p>借助额外空间，合并两个有序数组，得到更长的有序数组。</p><h2 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Merge</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于辅助合并有序数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] temp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 先给辅助数组开辟内存空间</span></span><br><span class="line">        temp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="comment">// 排序整个数组（原地修改）</span></span><br><span class="line">        sort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义：将子数组 nums[lo..hi] 进行排序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lo == hi) &#123;</span><br><span class="line">            <span class="comment">// 单个元素不用排序</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这样写是为了防止溢出，效果等同于 (hi + lo) / 2</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 先对左半部分数组 nums[lo..mid] 排序</span></span><br><span class="line">        sort(nums, lo, mid);</span><br><span class="line">        <span class="comment">// 再对右半部分数组 nums[mid+1..hi] 排序</span></span><br><span class="line">        sort(nums, mid + <span class="number">1</span>, hi);</span><br><span class="line">        <span class="comment">// 将两部分有序数组合并成一个有序数组</span></span><br><span class="line">        merge(nums, lo, mid, hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 nums[lo..mid] 和 nums[mid+1..hi] 这两个有序数组合并成一个有序数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> mid, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="comment">// 先把 nums[lo..hi] 复制到辅助数组中</span></span><br><span class="line">        <span class="comment">// 以便合并后的结果能够直接存入 nums</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo; i &lt;= hi; i++) &#123;</span><br><span class="line">            temp[i] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数组双指针技巧，合并两个有序数组</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo, j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> lo; p &lt;= hi; p++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == mid + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 左半边数组已全部被合并</span></span><br><span class="line">                nums[p] = temp[j++];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == hi + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 右半边数组已全部被合并</span></span><br><span class="line">                nums[p] = temp[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp[i] &gt; temp[j]) &#123;</span><br><span class="line">                nums[p] = temp[j++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[p] = temp[i++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>重要</p><h2 id="算法思想-6"><a href="#算法思想-6" class="headerlink" title="算法思想"></a>算法思想</h2><p>将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列。</p><h2 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">// 将数组整理成堆</span></span><br><span class="line">        heapify(nums);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环不变量：区间 [0, i] 堆有序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len - <span class="number">1</span>; i &gt;= <span class="number">1</span>; ) &#123;</span><br><span class="line">            <span class="comment">// 把堆顶元素（当前最大）交换到数组末尾</span></span><br><span class="line">            swap(nums, <span class="number">0</span>, i);</span><br><span class="line">            <span class="comment">// 逐步减少堆有序的部分</span></span><br><span class="line">            i--;</span><br><span class="line">            <span class="comment">// 下标 0 位置下沉操作，使得区间 [0, i] 堆有序</span></span><br><span class="line">            siftDown(nums, <span class="number">0</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将数组整理成堆（堆有序）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">// 只需要从 i = (len - 1) / 2 这个位置开始逐层下移</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (len - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            siftDown(nums, i, len - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k    当前下沉元素的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end  [0, end] 是 nums 的有效部分</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftDown</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span> * k + <span class="number">1</span> &lt;= end) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span> * k + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> &lt;= end &amp;&amp; nums[j + <span class="number">1</span>] &gt; nums[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; nums[k]) &#123;</span><br><span class="line">                swap(nums, j, k);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> index1, <span class="type">int</span> index2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[index1];</span><br><span class="line">        nums[index1] = nums[index2];</span><br><span class="line">        nums[index2] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="排序复杂度比较"><a href="#排序复杂度比较" class="headerlink" title="排序复杂度比较"></a>排序复杂度比较</h1><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/sort.png" alt="图片来源：菜鸟教程/十大经典排序"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://leetcode-cn.com/problems/sort-an-array/solution/fu-xi-ji-chu-pai-xu-suan-fa-java-by-liweiwei1419/">复习基础排序算法</a></li><li><a href="https://www.runoob.com/w3cnote/ten-sorting-algorithm.html">菜鸟教程：十大排序算法</a></li><li>《算法 第四版》</li><li><a href="https://mp.weixin.qq.com/s/8ZTMhvHJK_He48PpSt_AmQ">快速排序的正确理解方式及运用</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&amp;mid=2247495989&amp;idx=1&amp;sn=30e34ac75dd1c724205e9c8b0f488e35&amp;scene=21#wechat_redirect">归并排序的正确理解方式及运用</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文介绍几种经典、常考的内排序算法。&lt;/p&gt;
&lt;p&gt;本文试图建立一个比较标准的快速排序、归并排序、堆排序算法代码。&lt;/p&gt;
&lt;h1 id=&quot;</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://gmet233.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="排序" scheme="https://gmet233.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
    <category term="排序" scheme="https://gmet233.gitee.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>【笔记】BFS 算法解题套路框架</title>
    <link href="https://gmet233.gitee.io/2022/03/09/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91BFS-%E7%AE%97%E6%B3%95%E8%A7%A3%E9%A2%98%E5%A5%97%E8%B7%AF%E6%A1%86%E6%9E%B6/"/>
    <id>https://gmet233.gitee.io/2022/03/09/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91BFS-%E7%AE%97%E6%B3%95%E8%A7%A3%E9%A2%98%E5%A5%97%E8%B7%AF%E6%A1%86%E6%9E%B6/</id>
    <published>2022-03-09T14:08:06.000Z</published>
    <updated>2022-03-09T14:09:12.964Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文FROM《labuladong 算法秘籍》</p></blockquote><h1 id="什么是-BFS"><a href="#什么是-BFS" class="headerlink" title="什么是 BFS"></a>什么是 BFS</h1><p>BFS(Breadth First Search)，广度优先搜索，起源于<strong>树的层次遍历</strong>。其核心是利用<strong>队列</strong>这种数据结构。</p><p>BFS 的核心思想应该不难理解的，就是把⼀些问题抽象成图，从⼀个点开始，向四周开始扩散。 </p><h1 id="BFS-的应用场景"><a href="#BFS-的应用场景" class="headerlink" title="BFS 的应用场景"></a>BFS 的应用场景</h1><p>BFS 算法常见于求最值的场景，因为 BFS 的算法逻辑保证了算法第⼀次到达目标时的代价是最小的（？）。</p><p>举例⼀下 BFS 出现的常见场景好吧，问题的本质就是让你在⼀幅「图」中找到从起点 start 到终点 target 的最近距离。</p><p>这个广义的描述可以有各种变体，比如走迷宫，有的格子是围墙不能走，从起点到终点的最短距离是多少？如果这个迷宫带「传送门」可以瞬间传送呢？再比如说两个单词，要求你通过某些替换，把其中一个变成另一个，每次只能替换一个字符，最少要替换几次？再比如说连连看游戏，两个方块消除的条件不仅仅是图案相同，还得保证两个方块之间的最短连线不能多于两个拐点。你玩连连看，点击两个坐标，游戏是如何判断它俩的最短连线有几个拐点的？</p><h1 id="BFS-框架代码"><a href="#BFS-框架代码" class="headerlink" title="BFS 框架代码"></a>BFS 框架代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算从起点 start 到终点 target 的最近距离</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">BFS</span><span class="params">(Node start, Node target)</span> &#123;</span><br><span class="line">    Queue&lt;Node&gt; q; <span class="comment">// 核心数据结构</span></span><br><span class="line">    Set&lt;Node&gt; visited; <span class="comment">// 避免走回头路</span></span><br><span class="line">    </span><br><span class="line">    q.offer(start); <span class="comment">// 将起点加入队列</span></span><br><span class="line">    visited.add(start);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 记录扩散的步数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (q not empty) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> q.size();</span><br><span class="line">        <span class="comment">/* 将当前队列中的所有节点向四周扩散 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> q.poll();</span><br><span class="line">            <span class="comment">/* 划重点：这里判断是否到达终点 */</span></span><br><span class="line">            <span class="keyword">if</span> (cur is target)</span><br><span class="line">                <span class="keyword">return</span> step;</span><br><span class="line">            <span class="comment">/* 将 cur 的相邻节点加入队列 */</span></span><br><span class="line">            <span class="keyword">for</span> (Node x : cur.adj()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x not in visited) &#123;</span><br><span class="line">                    q.offer(x);</span><br><span class="line">                    visited.add(x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 划重点：更新步数在这里 */</span></span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>队列 <code>q</code> 就不说了，BFS 的核心数据结构；<code>cur.adj()</code> 泛指 <code>cur</code> 相邻的节点，比如说二维数组中，<code>cur</code> 上下左右四面的位置就是相邻节点；<code>visited</code> 的主要作用是防止走回头路，大部分时候都是必须的，但是像一般的二叉树结构，没有子节点到父节点的指针，不会走回头路就不需要 <code>visited</code>。</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p>LeetCode 111、752</p><h1 id="双向BFS（了解）"><a href="#双向BFS（了解）" class="headerlink" title="双向BFS（了解）"></a>双向BFS（了解）</h1><p>传统的 BFS 框架就是从起点开始向四周扩散，遇到终点时停止；而双向 BFS 则是从起点和终点同时开始扩散，当两边有交集的时候停止。</p><h1 id="BFS-与-DFS"><a href="#BFS-与-DFS" class="headerlink" title="BFS 与 DFS"></a>BFS 与 DFS</h1><blockquote><p>这部分不是很懂，后面再看</p></blockquote><p>BFS 相对 DFS 的最主要的区别是：BFS 找到的路径⼀定是最短的，但代价就是空间复杂度可能比 DFS 大很多。</p><p><strong>1、为什么 BFS 可以找到最短距离，DFS 不行吗</strong>？</p><p>首先，你看 BFS 的逻辑，<code>depth</code> 每增加一次，队列中的所有节点都向前迈一步，这保证了第一次到达终点的时候，走的步数是最少的。</p><p>DFS 不能找最短路径吗？其实也是可以的，但是时间复杂度相对高很多。你想啊，DFS 实际上是靠递归的堆栈记录走过的路径，你要找到最短路径，肯定得把二叉树中所有树杈都探索完才能对比出最短的路径有多长对不对？而 BFS 借助队列做到一次一步「齐头并进」，是可以在不遍历完整棵树的条件下找到最短距离的。</p><p>形象点说，DFS 是线，BFS 是面；DFS 是单打独斗，BFS 是集体行动。这个应该比较容易理解吧。</p><p><strong>2、既然 BFS 那么好，为啥 DFS 还要存在</strong>？</p><p>BFS 可以找到最短距离，但是空间复杂度高，而 DFS 的空间复杂度较低。</p><p>还是拿刚才我们处理二叉树问题的例子，假设给你的这个二叉树是满二叉树，节点数为 <code>N</code>，对于 DFS 算法来说，空间复杂度无非就是递归堆栈，最坏情况下顶多就是树的高度，也就是 <code>O(logN)</code>。</p><p>但是你想想 BFS 算法，队列中每次都会储存着二叉树一层的节点，这样的话最坏情况下空间复杂度应该是树的最底层节点的数量，也就是 <code>N/2</code>，用 Big O 表示的话也就是 <code>O(N)</code>。</p><p>由此观之，BFS 还是有代价的，一般来说在找最短路径的时候使用 BFS，其他时候还是 DFS 使用得多一些（主要是递归代码好写）。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://labuladong.gitee.io/algo/4/30/113/">BFS 算法解题套路框架</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文FROM《labuladong 算法秘籍》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;什么是-BFS&quot;&gt;&lt;a href=&quot;#什么是-BFS&quot; class=&quot;headerlink&quot; title=&quot;什么是 BFS&quot;&gt;&lt;/a&gt;什么是 BFS</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://gmet233.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="BFS" scheme="https://gmet233.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/BFS/"/>
    
    
    <category term="算法" scheme="https://gmet233.gitee.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="BFS" scheme="https://gmet233.gitee.io/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>什么是端到端（end-to-end）的学习模型</title>
    <link href="https://gmet233.gitee.io/2022/03/07/%E4%BB%80%E4%B9%88%E6%98%AF%E7%AB%AF%E5%88%B0%E7%AB%AF%EF%BC%88end-to-end%EF%BC%89%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B/"/>
    <id>https://gmet233.gitee.io/2022/03/07/%E4%BB%80%E4%B9%88%E6%98%AF%E7%AB%AF%E5%88%B0%E7%AB%AF%EF%BC%88end-to-end%EF%BC%89%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B/</id>
    <published>2022-03-07T12:25:03.000Z</published>
    <updated>2022-03-07T12:25:29.762Z</updated>
    
    <content type="html"><![CDATA[<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p><strong>端到端的学习模型</strong>是指将原始数据不做任何的预处理直接将原始数据输入到模型当中，最后得到的输出结果与期望结果有误差，这误差在反向传播模型的各层中，将参数进行优化，一直到期望结果结束。<strong>非端到端</strong>是将原始数据进行标注，得到具有特征的处理后的数据，然后在作为输入，这样的弊端是如果提取数据特征时出现错误，将无法调整。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://www.its203.com/article/qq_42514225/108835224?2022-03-07">什么是端到端的学习模型</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;&gt;&lt;/a&gt;正文&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;端到端的学习模型&lt;/strong&gt;是指将原始数据不做任何的预处理直接将原始数据输入到模型当中，最后得到的输出结果与期望结果有</summary>
      
    
    
    
    <category term="机器学习" scheme="https://gmet233.gitee.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="机器学习" scheme="https://gmet233.gitee.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>最大M对齐子集</title>
    <link href="https://gmet233.gitee.io/2022/03/01/%E6%9C%80%E5%A4%A7M%E5%AF%B9%E9%BD%90%E5%AD%90%E9%9B%86/"/>
    <id>https://gmet233.gitee.io/2022/03/01/%E6%9C%80%E5%A4%A7M%E5%AF%B9%E9%BD%90%E5%AD%90%E9%9B%86/</id>
    <published>2022-03-01T13:52:37.000Z</published>
    <updated>2022-03-01T13:53:34.808Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>有 N 个点位于一条线上，编号从 0 到 N-1 ，其坐标在数组 A 中给出。对于每个I (0 ≤ l &lt;N)，直线上点数 I 的坐标为 A[l] 。点的坐标可能相同。</p><p>对于给定的整数 M ，如果子集内任意两个点之间的距离可被M整除，则称这些点的子集为M<strong>对齐</strong>。您的任务是查找给定 N 个点集的最大 M 对齐子集的大小。</p><p>例如，考虑整数 M=3 和数组 A，如下所示：</p><blockquote><p>A[0] = -3  A[1] = -2  A[2] = 1  A[3] = 0  A[4] = 8  A[5] = 7  A[6] = 1</p></blockquote><p>包含编号为1、2、5和6的点的子集，坐标分别为-2、1、7和1，是3对齐子集的示例，因为：</p><ul><li>编号为1和2的点之间的距离为abs(A[1] - A[2]) = 3，</li><li>从5号点到编号1和2的点的距离分别为9和6，</li><li>从6号点到编号为1、2和5的点的距离分别为3、0和6，</li></ul><p>这些距离都可以被 M=3 整除。此子集的大小为4，并且没有更大的3对齐子集。</p><p>编写一个函数:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">solution</span><span class="params">(<span class="type">int</span>[] A, <span class="type">int</span> M)</span>;</span><br></pre></td></tr></table></figure><p>给定一个由 N 个整数和一个整数 M 组成的数组 A，返回最大 M 对齐子集的大小。</p><p>例如，给定 M=3 且 A=[-3，-2，1，0，8，7，1]，函数应返回4，如上所述；</p><p>给定 M=8 且 A=[7，1，11，8,4，10]，函数应返回1。</p><h1 id="解"><a href="#解" class="headerlink" title="解"></a>解</h1><p>把所有按 M 的余数存成一组就可以，<strong>同组的刚好把余数消掉就是距离整除</strong>。返回最大即为所求。</p><p><strong>注意</strong>：余数为负的，需要转为最小正余数（+M）</p><h2 id="Java实现"><a href="#Java实现" class="headerlink" title="Java实现"></a>Java实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">solution</span><span class="params">(<span class="type">int</span>[] A, <span class="type">int</span> M)</span>&#123;</span><br><span class="line">    <span class="comment">//remainders[i] = j, 表示余数为i的频次是j</span></span><br><span class="line">    <span class="type">int</span>[] remainders = <span class="keyword">new</span> <span class="title class_">int</span>[M];</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 记录最大的频次</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> A.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">remainder</span> <span class="operator">=</span> A[i] % M;</span><br><span class="line">        <span class="keyword">if</span>(remainder &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            remainder += M;</span><br><span class="line">        &#125;</span><br><span class="line">        remainders[remainder] ++;</span><br><span class="line">        ans = Math.max(ans, remainders[remainder]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;有 N 个点位于一条线上，编号从 0 到 N-1 ，其坐标在数组 A 中给出。对于每个I (0 ≤ l &amp;lt;N)，直线上点数 I 的坐标</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://gmet233.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="数论" scheme="https://gmet233.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E8%AE%BA/"/>
    
    
    <category term="算法" scheme="https://gmet233.gitee.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数论" scheme="https://gmet233.gitee.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>求数字1在所有不超过N的十进制正整数中出现的次数</title>
    <link href="https://gmet233.gitee.io/2022/03/01/%E6%B1%82%E6%95%B0%E5%AD%971%E5%9C%A8%E6%89%80%E6%9C%89%E4%B8%8D%E8%B6%85%E8%BF%87N%E7%9A%84%E5%8D%81%E8%BF%9B%E5%88%B6%E6%AD%A3%E6%95%B4%E6%95%B0%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/"/>
    <id>https://gmet233.gitee.io/2022/03/01/%E6%B1%82%E6%95%B0%E5%AD%971%E5%9C%A8%E6%89%80%E6%9C%89%E4%B8%8D%E8%B6%85%E8%BF%87N%E7%9A%84%E5%8D%81%E8%BF%9B%E5%88%B6%E6%AD%A3%E6%95%B4%E6%95%B0%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</id>
    <published>2022-03-01T13:51:19.000Z</published>
    <updated>2022-03-01T13:52:07.445Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>写一个函数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">solution</span><span class="params">(<span class="type">int</span> N)</span>;</span><br></pre></td></tr></table></figure><p>即给定一个整数N，返回数字1在所有不超过 N 的正整数的十进制表示中出现的次数。</p><p>例如，给定N = 13，该函数应返回6，因为：</p><ul><li>所有不超过13的正整数是1、2、3、4、5、6、7、8、9、10、11、12 和13；</li><li>数字1共出现六次：一次在数字1中，一次在数字10中，两次在数字11中，一次在数字12中，一次在数字13中。</li></ul><p>N 是[0.. 100,000,000]范围内的整数。</p><h1 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h1><p>暴力求解：遍历每一个数，对每一个数求1的个数，然后加起来得和。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">solution</span><span class="params">(<span class="type">int</span> N)</span><span class="comment">//统计1-n中1的个数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=i; j&gt;<span class="number">0</span>; j/=<span class="number">10</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(j%<span class="number">10</span>==<span class="number">1</span>)</span><br><span class="line">ans ++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法时间复杂度：$O(nlgn)$</p><h1 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h1><p>考虑两位数。将一个正整数中1的个数分成两部分，一部分是个位上出现1的数目f1(n)，一部分是十位上出现1的数目f2(n) 。</p><p>n=10， f1(10)=1（1-10个位出现的1的个数为1），f2(10)=1（1-10个位出现的1的十数为1）。</p><p>举一些代表性的数：</p><div class="table-container"><table><thead><tr><th>n</th><th>f1(n)</th><th>f2(n)</th><th>f(n)</th></tr></thead><tbody><tr><td>10</td><td>1</td><td>1</td><td>2</td></tr><tr><td>11</td><td>2</td><td>2</td><td>4</td></tr><tr><td>12</td><td>2</td><td>3</td><td>5</td></tr><tr><td>13</td><td>2</td><td>4</td><td>6</td></tr><tr><td>20</td><td>2</td><td>10</td><td>12</td></tr><tr><td>21</td><td>3</td><td>10</td><td>13</td></tr><tr><td>22</td><td>3</td><td>10</td><td>13</td></tr><tr><td>23</td><td>3</td><td>10</td><td>13</td></tr><tr><td>30</td><td>3</td><td>10</td><td>13</td></tr><tr><td>31</td><td>4</td><td>10</td><td>14</td></tr><tr><td>32</td><td>4</td><td>10</td><td>14</td></tr><tr><td>33</td><td>4</td><td>10</td><td>14</td></tr></tbody></table></div><p>先来看十位，当十位上的数为1时，</p><div class="table-container"><table><thead><tr><th>n</th><th>f2(n)</th></tr></thead><tbody><tr><td>10</td><td>1</td></tr><tr><td>11</td><td>2</td></tr><tr><td>12</td><td>3</td></tr><tr><td>13</td><td>4</td></tr></tbody></table></div><p>f2(n)=当前数个位数字+1；</p><p>当十位上的数大于1时，</p><div class="table-container"><table><thead><tr><th>n</th><th>f2(n)</th></tr></thead><tbody><tr><td>20</td><td>10</td></tr><tr><td>21</td><td>10</td></tr><tr><td>22</td><td>10</td></tr><tr><td>23</td><td>10</td></tr><tr><td>30</td><td>10</td></tr><tr><td>31</td><td>10</td></tr><tr><td>32</td><td>10</td></tr><tr><td>33</td><td>10</td></tr></tbody></table></div><p>f2(n) = 10，也就是说此时十位上1的数目仅仅和十位有关系，也就是<strong>十位的位因子</strong>10。</p><p>再来看个位，当个位上的数为1的时候</p><div class="table-container"><table><thead><tr><th>n</th><th>f1(n)</th></tr></thead><tbody><tr><td>11</td><td>2</td></tr><tr><td>21</td><td>3</td></tr><tr><td>31</td><td>4</td></tr></tbody></table></div><p>f1(n) = 当前数十位数字+1；</p><p>当个位上的数大于1时，</p><div class="table-container"><table><thead><tr><th>n</th><th>f1(n)</th></tr></thead><tbody><tr><td>22</td><td>3</td></tr><tr><td>23</td><td>3</td></tr><tr><td>32</td><td>4</td></tr><tr><td>33</td><td>4</td></tr></tbody></table></div><p>f1(n) = 当前数十位数字+1；</p><p>还有当个位上的数等于0时，</p><div class="table-container"><table><thead><tr><th>n</th><th>f1(n)</th></tr></thead><tbody><tr><td>10</td><td>1</td></tr><tr><td>20</td><td>2</td></tr><tr><td>30</td><td>3</td></tr></tbody></table></div><p>f1(n) = 当前数十位数字。</p><p>这还不够，我们还没有分析两位数以上的数字，根据上面的分析，我们将当前位分为三种情况：=0，=1，&gt;1。</p><p>当百位上的数字是0的时候，假设n=12013。此时1-12013的所有整数中，百位上出现1的数是100~199，1100~1199，2100~2199……11100~11199。也就是12个100，1200个。也就是说此时百位上1的数目是由高位（12）决定的，而且等于高位（12）* 当前位因子（100）。</p><p>当百位上的数字是1的时候，假设n=12113。此时1-12113的所有整数中，百位上出现1的数是100~199，1100~1199，2100~2199……11100~11199，12100~12113。也就是13个100，1300个。也就是说此时百位上1的数目是由高位（12）决定的，而且等于（高位（12）+1）* 当前位因子（100）。</p><p>还有一个小问题就是如何求一个数的高位和低位，还有当前位。这和当前位的位因子有关系。</p><p>对于12345，假设当前位是百位（100），则</p><ul><li>低位数字：12345 - (12345 / 100) *100 = 45</li><li>高位数字：12345 / (100 * 10) = 12</li><li>当前位数字：12345 / 100 = 123，123 % 10 = 3。</li></ul><p>以上分析可以写出完整代码。</p><h2 id="Java实现"><a href="#Java实现" class="headerlink" title="Java实现"></a>Java实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">solution</span><span class="params">(<span class="type">int</span> N)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">lowNum</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 当前位的低位的数字</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">currNum</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 当前位数字</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">highNum</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 当前位的高位的数字</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">factor</span> <span class="operator">=</span> <span class="number">1</span>; factor &lt;= N; factor *= <span class="number">10</span>) &#123; <span class="comment">// 位因子</span></span><br><span class="line">        lowNum = N - (N / factor) * factor;</span><br><span class="line">        currNum = (N / factor) % <span class="number">10</span>;</span><br><span class="line">        highNum = N / (factor * <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span>(currNum == <span class="number">0</span>) &#123;</span><br><span class="line">            ans += highNum * factor;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(currNum == <span class="number">1</span>) &#123;</span><br><span class="line">            ans += highNum * factor + lowNum +<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans += (highNum + <span class="number">1</span>) * factor;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度只与N的位数有关，为$O(lgn)$。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://blog.csdn.net/liangbopirates/article/details/9323727">求1-N中十进制正整数1的个数</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;写一个函数&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://gmet233.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://gmet233.gitee.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【不会做】矩阵路径形成的最大整数</title>
    <link href="https://gmet233.gitee.io/2022/03/01/%E3%80%90%E4%B8%8D%E4%BC%9A%E5%81%9A%E3%80%91%E7%9F%A9%E9%98%B5%E8%B7%AF%E5%BE%84%E5%BD%A2%E6%88%90%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B4%E6%95%B0/"/>
    <id>https://gmet233.gitee.io/2022/03/01/%E3%80%90%E4%B8%8D%E4%BC%9A%E5%81%9A%E3%80%91%E7%9F%A9%E9%98%B5%E8%B7%AF%E5%BE%84%E5%BD%A2%E6%88%90%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B4%E6%95%B0/</id>
    <published>2022-03-01T13:47:55.000Z</published>
    <updated>2022-03-01T13:50:26.391Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>您将获得一个由 N 行和 M 列组成的板。电路板的每个字段（其实就是数组中的一个坐标点，作者注）都包含一个数字 (0-9)。</p><p>您希望查找由四个相邻字段组成的路径。如果两个字段共享一个共同点，则它们是相邻的。此外，路径中的字段应该是不同的（不能两次访问同一字段）。</p><p>路径的四位数字（按您访问它们的顺序）创建一个 整数。通过这种方式可以实现的最大整数是多少?</p><p>编写函数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">solution</span> <span class="params">(<span class="type">int</span>[][] board)</span> ;</span><br></pre></td></tr></table></figure><p>给定表示为由 N 行和 M 列组成的整数矩阵的板，则返回在长度为 4 的路径中连接值时可以实现的最大整数。<br>例子：给定以下板（N=3, M=5） :</p><p><img src="image-20220228105252210.png" alt="图1"></p><p>该函数应返回9121。您可以选择以下路径（第一 个字段用红色表示)：</p><p><img src="image-20220228105416502.png" alt="图2"></p><h1 id="解"><a href="#解" class="headerlink" title="解"></a>解</h1><p>知道用回溯或者BFS，但是代码写不出来。😓</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;您将获得一个由 N 行和 M 列组成的板。电路板的每个字段（其实就是数组中的一个坐标点，作者注）都包含一个数字 (0-9)。&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://gmet233.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="回溯" scheme="https://gmet233.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF/"/>
    
    
    <category term="算法" scheme="https://gmet233.gitee.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="回溯" scheme="https://gmet233.gitee.io/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>个人比较喜欢的健身动作</title>
    <link href="https://gmet233.gitee.io/2022/02/28/%E4%B8%AA%E4%BA%BA%E6%AF%94%E8%BE%83%E5%96%9C%E6%AC%A2%E7%9A%84%E5%81%A5%E8%BA%AB%E5%8A%A8%E4%BD%9C/"/>
    <id>https://gmet233.gitee.io/2022/02/28/%E4%B8%AA%E4%BA%BA%E6%AF%94%E8%BE%83%E5%96%9C%E6%AC%A2%E7%9A%84%E5%81%A5%E8%BA%AB%E5%8A%A8%E4%BD%9C/</id>
    <published>2022-02-28T15:31:17.000Z</published>
    <updated>2022-03-03T12:52:44.478Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文整理一下个人比较喜欢健身动作。并备注动作要点</p></blockquote><h1 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h1><h2 id="平板支撑"><a href="#平板支撑" class="headerlink" title="平板支撑"></a>平板支撑</h2><p>改善的平板支撑：</p><ol><li>身体后移</li><li>骨盆后倾：收紧臀部，感觉上向后顶</li><li>纠正身体位置。肩膀用力向前推，上肢离地更远。</li></ol><p>新手先做到第二点延长到60秒，再两点一起做。</p><p>禁忌：</p><ol><li>手臂后缩</li><li>提臀或者臀太低。相反要用力收紧骨盆</li></ol><h1 id="臀腿"><a href="#臀腿" class="headerlink" title="臀腿"></a>臀腿</h1><h2 id="深蹲"><a href="#深蹲" class="headerlink" title="深蹲"></a>深蹲</h2><p>使用弹力带加大深蹲的阻力。</p><h2 id="单腿罗马尼亚硬拉"><a href="#单腿罗马尼亚硬拉" class="headerlink" title="单腿罗马尼亚硬拉"></a>单腿罗马尼亚硬拉</h2><p>锻炼臀肌、腘绳肌，锻炼单腿站立的稳定性，膝关节得稳定性。</p><p>视频：<a href="https://www.bilibili.com/video/BV1Ci4y1R72o?spm_id_from=333.999.0.0">https://www.bilibili.com/video/BV1Ci4y1R72o?spm_id_from=333.999.0.0</a></p><h1 id="背部"><a href="#背部" class="headerlink" title="背部"></a>背部</h1><h2 id="引体向上"><a href="#引体向上" class="headerlink" title="引体向上"></a>引体向上</h2><p>如果做不来可以使用弹力绳辅助。</p><h1 id="前锯肌"><a href="#前锯肌" class="headerlink" title="前锯肌"></a>前锯肌</h1><p>待整理：<a href="https://www.bilibili.com/video/BV1qq4y1k7oP?spm_id_from=333.999.0.0">https://www.bilibili.com/video/BV1qq4y1k7oP?spm_id_from=333.999.0.0</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://www.bilibili.com/video/BV1SP4y1j71R?spm_id_from=333.999.0.0">核心太弱，肚子肯定大（3个技巧快速改善）</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文整理一下个人比较喜欢健身动作。并备注动作要点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;核心&quot;&gt;&lt;a href=&quot;#核心&quot; class=&quot;headerlink&quot; title=&quot;核心&quot;&gt;&lt;/a&gt;核心&lt;/h1&gt;&lt;h2 id=&quot;平板支撑&quot;&gt;</summary>
      
    
    
    
    <category term="方法论" scheme="https://gmet233.gitee.io/categories/%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
    <category term="健身" scheme="https://gmet233.gitee.io/categories/%E6%96%B9%E6%B3%95%E8%AE%BA/%E5%81%A5%E8%BA%AB/"/>
    
    
    <category term="健身" scheme="https://gmet233.gitee.io/tags/%E5%81%A5%E8%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>Keep上不错的课程合集</title>
    <link href="https://gmet233.gitee.io/2022/02/28/Keep%E4%B8%8A%E4%B8%8D%E9%94%99%E7%9A%84%E8%AF%BE%E7%A8%8B%E5%90%88%E9%9B%86/"/>
    <id>https://gmet233.gitee.io/2022/02/28/Keep%E4%B8%8A%E4%B8%8D%E9%94%99%E7%9A%84%E8%AF%BE%E7%A8%8B%E5%90%88%E9%9B%86/</id>
    <published>2022-02-28T15:24:57.000Z</published>
    <updated>2022-03-27T06:16:18.005Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文整理了一些适合自己的Keep课程，这些课程都亲自做过一遍。</p><p>本文会不断更新。</p></blockquote><div class="table-container"><table><thead><tr><th>课程名称</th><th>课程链接</th><th>难度</th><th>部位</th><th>器械</th><th>感受</th></tr></thead><tbody><tr><td>HIIT - 腹肌塑造</td><td><a href="https://show.gotokeep.com/course/607fefaa1310a35004149bc4">https://show.gotokeep.com/course/607fefaa1310a35004149bc4</a></td><td>3</td><td>腹部</td><td>不需要</td><td>挺累的，但是不难。做完腹部有明显酸痛</td></tr><tr><td>哑铃全方位胸部刺激-罗洪Ric</td><td><a href="https://show.gotokeep.com/course/6051a1b41310a33405483f53">https://show.gotokeep.com/course/6051a1b41310a33405483f53</a></td><td>4</td><td>胸部</td><td>哑铃</td><td>很有感觉。</td></tr><tr><td>哑铃手臂轰炸</td><td><a href="https://show.gotokeep.com/course/59ddde95a29e342161e42290">https://show.gotokeep.com/course/59ddde95a29e342161e42290</a></td><td>3</td><td>手臂</td><td>哑铃</td><td>练了好几次，快没感觉了，可能需要加大重量</td></tr><tr><td>跃动燃脂强化</td><td><a href="https://show.gotokeep.com/course/5b1e349aa29e343df182c7c0">https://show.gotokeep.com/course/5b1e349aa29e343df182c7c0</a></td><td>4</td><td>全身</td><td>不需要</td><td>挺累的。。</td></tr><tr><td>家庭哑铃增肌特训 · 强力臀腿</td><td><a href="https://show.gotokeep.com/course/601696ae627efb1bdd12ae13">https://show.gotokeep.com/course/601696ae627efb1bdd12ae13</a></td><td>3</td><td>臀腿</td><td>哑铃</td><td>忘记了。</td></tr><tr><td>核心功能强化</td><td><a href="https://show.gotokeep.com/course/5b90af2da29e342ee240c94f">https://show.gotokeep.com/course/5b90af2da29e342ee240c94f</a></td><td>4</td><td>腰腹</td><td>不需要</td><td>和“HIIT - 腹肌塑造”有点重复</td></tr></tbody></table></div>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文整理了一些适合自己的Keep课程，这些课程都亲自做过一遍。&lt;/p&gt;
&lt;p&gt;本文会不断更新。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;课程名</summary>
      
    
    
    
    <category term="方法论" scheme="https://gmet233.gitee.io/categories/%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
    <category term="健身" scheme="https://gmet233.gitee.io/categories/%E6%96%B9%E6%B3%95%E8%AE%BA/%E5%81%A5%E8%BA%AB/"/>
    
    
    <category term="健身" scheme="https://gmet233.gitee.io/tags/%E5%81%A5%E8%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>银行转账</title>
    <link href="https://gmet233.gitee.io/2022/02/27/%E9%93%B6%E8%A1%8C%E8%BD%AC%E8%B4%A6/"/>
    <id>https://gmet233.gitee.io/2022/02/27/%E9%93%B6%E8%A1%8C%E8%BD%AC%E8%B4%A6/</id>
    <published>2022-02-27T02:06:55.000Z</published>
    <updated>2022-02-28T15:10:27.229Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文FROM 微软 软开 笔试题</p></blockquote><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>您将获得两个银行之间的N次转账列表（编号0到N-1）：银行A和银行B，第K次传输由两个值描述：</p><ul><li>R[K]（A或B）代表收款人（转账发送到的银行）；</li><li>V[K]表示通过传输发送的值。</li></ul><p>所有转移均按他们在列表中出现的顺序完成。银行不想负债（即他们的账户余额可能不会低于0）。每家银行的初始账户余额最低是多少才能完成转账？</p><p>编写一个函数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] solution(String R, <span class="type">int</span>[] V);</span><br></pre></td></tr></table></figure><p>给定一个字符串R和一个长度均为N的整数数组V，返回一个由两个整数组成的数组。证书应按以下顺序表示银行A和B的最小初始账户余额：[银行A, 银行B]。</p><p>结果数组应作为整数向量返回。</p><p>例子：</p><ol><li>给定R = “BAABA”且V=[2,4,1,1,2]，函数应该返回[2, 4]。每次转账后的银行账户余额如下表所示：</li></ol><div class="table-container"><table><thead><tr><th></th><th>A</th><th>B</th></tr></thead><tbody><tr><td>初始余额</td><td>2</td><td>4</td></tr><tr><td>A -&gt; B：转移 2</td><td>0</td><td>6</td></tr><tr><td>B -&gt; A：转移 4</td><td>4</td><td>2</td></tr><tr><td>B -&gt; A：转移 1</td><td>5</td><td>1</td></tr><tr><td>A -&gt; B：转移 1</td><td>4</td><td>2</td></tr><tr><td>B -&gt; A：转移 2</td><td>6</td><td>0</td></tr></tbody></table></div><ol><li>给定R = “ABAB”且V=[10,5,10,15]，函数应返回[0, 15]。</li><li>给定R = “B”且V=[100]，函数应返回[100, 0]。</li></ol><p>为以下假设编写有效算法。</p><h1 id="解"><a href="#解" class="headerlink" title="解"></a>解</h1><p>以例1为例，设计银行A的初始余额为X，银行B的初始余额为Y。则每一次转账后A的余额分别为：</p><p>X-2, X+2, X+3, X+2, X+4；B的余额分别为：</p><p>Y+2, Y-2, Y-3, Y-2, Y-4；</p><p>根据题目要求得any(X, X-2, X+2, X+3, X+2, X+4) &gt;=0 &amp;&amp; any(Y, Y+2, Y-2, Y-3, Y-2, Y-4)&gt;=0</p><p>即要求X-2&gt;=0; Y-4&gt;=0;</p><p>题目求最小初始余额，可得，X=2； Y=4</p><p>下面是代码实现。</p><h2 id="Java实现"><a href="#Java实现" class="headerlink" title="Java实现"></a>Java实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] solution(String R, <span class="type">int</span>[] V) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> V.length;</span><br><span class="line">    <span class="type">int</span>[] A = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="type">int</span>[] B = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span>(R.charAt(<span class="number">0</span>) == <span class="string">&#x27;B&#x27;</span>) &#123;</span><br><span class="line">        B[<span class="number">0</span>] = V[<span class="number">0</span>];</span><br><span class="line">        A[<span class="number">0</span>] = -V[<span class="number">0</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        B[<span class="number">0</span>] = -V[<span class="number">0</span>];</span><br><span class="line">        A[<span class="number">0</span>] = V[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">min_A</span> <span class="operator">=</span> A[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">min_B</span> <span class="operator">=</span> B[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(R.charAt(i) == <span class="string">&#x27;B&#x27;</span>) &#123;</span><br><span class="line">            A[i] = A[i-<span class="number">1</span>] - V[i];</span><br><span class="line">            B[i] = B[i-<span class="number">1</span>] + V[i];</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            A[i] = A[i-<span class="number">1</span>] + V[i];</span><br><span class="line">            B[i] = B[i-<span class="number">1</span>] - V[i];</span><br><span class="line">        &#125;</span><br><span class="line">        min_A = Math.min(min_A, A[i]);</span><br><span class="line">        min_B = Math.min(min_B, B[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//min_A和min_B不能是负数</span></span><br><span class="line">    min_A = Math.max(<span class="number">0</span>, -min_A);</span><br><span class="line">    min_B = Math.max(<span class="number">0</span>, -min_B);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;min_A, min_B&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文FROM 微软 软开 笔试题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;您将获得两个银行之间的N次转账列表（编</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://gmet233.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="数组" scheme="https://gmet233.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/"/>
    
    
    <category term="算法" scheme="https://gmet233.gitee.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数组" scheme="https://gmet233.gitee.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>找到数组中比左边元素都大同时比右边元素都小的元素</title>
    <link href="https://gmet233.gitee.io/2022/02/23/%E6%89%BE%E5%88%B0%E6%95%B0%E7%BB%84%E4%B8%AD%E6%AF%94%E5%B7%A6%E8%BE%B9%E5%85%83%E7%B4%A0%E9%83%BD%E5%A4%A7%E5%90%8C%E6%97%B6%E6%AF%94%E5%8F%B3%E8%BE%B9%E5%85%83%E7%B4%A0%E9%83%BD%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/"/>
    <id>https://gmet233.gitee.io/2022/02/23/%E6%89%BE%E5%88%B0%E6%95%B0%E7%BB%84%E4%B8%AD%E6%AF%94%E5%B7%A6%E8%BE%B9%E5%85%83%E7%B4%A0%E9%83%BD%E5%A4%A7%E5%90%8C%E6%97%B6%E6%AF%94%E5%8F%B3%E8%BE%B9%E5%85%83%E7%B4%A0%E9%83%BD%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/</id>
    <published>2022-02-23T12:33:29.000Z</published>
    <updated>2022-02-23T12:34:38.886Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>求数组中比左边元素都大同时比右边元素都小的元素，返回这些元素的索引。要求时间复杂度$O(N)$</p><blockquote><p>输入：[2, 3, 1, 8, 9, 20, 12]<br>输出：3, 4<br>解释：数组中 8, 9 满足题目要求，他们的索引分别是 3、4</p></blockquote><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>最简单最暴力的就是没从头到尾遍历元素，对于每个元素分别往前、往后遍历一下，看看是否它是否满足条件。</p><p>这种解法的时间复杂度为$O(N^2)$，不符合题目要求。</p><p>通过分析可以得到，对于每个元素，如果它比<strong>左侧最大的值</strong>要大，同时比<strong>右侧最小的值</strong>要小，就满足条件。</p><p>那如果有这样两个数组，</p><p><code>left_max[i]</code> 表示原数组 [0, i) 的最大值</p><p><code>right_min[i]</code> 表示原数组 (i, n) 的最小值</p><p>内循环就可以通过 <code>left_max[i] &lt; nums[i] &amp;&amp; nums[i] &lt; right_min[i]</code> 来判断了。</p><p>对于 left_max 和 right_min 这两数组，提前先算好，每个数组都能$O(N)$得到。</p><p>left_max 和 right_min 递推式如下：</p><blockquote><p>left_max[i] = max(left_max[i-1], nums[i])</p><p>right_min[i] = min(right_min[i-1], nums[i])</p></blockquote><p>总时间复杂度为 $O(N)$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">find</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] left_max = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span>[] right_min = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(left_max, Integer.MIN_VALUE);</span><br><span class="line">        Arrays.fill(right_min, Integer.MAX_VALUE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            left_max[i] = Math.max(left_max[i-<span class="number">1</span>], nums[i-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n-<span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            right_min[i] = Math.min(right_min[i+<span class="number">1</span>], nums[i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; left_max[i] &amp;&amp; nums[i] &lt; right_min[i]) &#123;</span><br><span class="line">                res.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://mp.weixin.qq.com/s/ilOdw4qdu_EJZNXvybqdag">一道热乎的字节三面原创题</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;求数组中比左边元素都大同时比右边元素都小的元素，返回这些元素的索引。要求时间复杂度$O(N)$&lt;/p&gt;
&lt;blockquot</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://gmet233.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="数组/链表" scheme="https://gmet233.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84-%E9%93%BE%E8%A1%A8/"/>
    
    
    <category term="算法" scheme="https://gmet233.gitee.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数组" scheme="https://gmet233.gitee.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>如何读论文</title>
    <link href="https://gmet233.gitee.io/2022/02/22/%E5%A6%82%E4%BD%95%E8%AF%BB%E8%AE%BA%E6%96%87/"/>
    <id>https://gmet233.gitee.io/2022/02/22/%E5%A6%82%E4%BD%95%E8%AF%BB%E8%AE%BA%E6%96%87/</id>
    <published>2022-02-22T13:37:55.000Z</published>
    <updated>2022-02-22T14:51:44.730Z</updated>
    
    <content type="html"><![CDATA[<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>一篇论文往往分为<strong>标题，摘要，导言，算法，实验，结论</strong>。</p><p><strong>算法</strong>就是论文作者提出的新的方法；<strong>实验</strong>是为了证明提出的算法。</p><h2 id="读第一遍"><a href="#读第一遍" class="headerlink" title="读第一遍"></a>读第一遍</h2><p>关注<strong>标题</strong>，<strong>摘要</strong>和<strong>结论</strong>；结论和摘要往往是一个东西，但是结论会把摘要的问题给证明一下；顺便看一下算法和实验部分的图标。</p><p><strong>目的</strong>：</p><ul><li>这篇论文介绍了什么</li><li>是否与自己相关</li><li>质量怎么样</li><li>是否继续读下去</li></ul><h2 id="读第二遍"><a href="#读第二遍" class="headerlink" title="读第二遍"></a>读第二遍</h2><p>如果第一遍认为该论文需要读下去，则进行第二遍通读，可以忽略很细节的部分，例如公式证明。</p><p>圈出引用的重要的相关的文献，例如，作者解决的问题是哪篇论文提出的，作者的方法是哪篇论文改进来的。</p><p><strong>目的：</strong></p><ul><li>掌握论文中的每一个图、表是什么意思；</li><li>作者的方法和别人的方法是怎么对比的，差距有多大</li></ul><h2 id="读第三遍"><a href="#读第三遍" class="headerlink" title="读第三遍"></a>读第三遍</h2><p>详细阅读第三遍，读懂每一句话，每一个细节。感同身受的去读。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://www.bilibili.com/video/BV1H44y1t75x">如何读论文 - 李沐</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;&gt;&lt;/a&gt;正文&lt;/h1&gt;&lt;p&gt;一篇论文往往分为&lt;strong&gt;标题，摘要，导言，算法，实验，结论&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;算法&lt;/strong&gt;</summary>
      
    
    
    
    <category term="方法论" scheme="https://gmet233.gitee.io/categories/%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
    <category term="阅读AI论文" scheme="https://gmet233.gitee.io/categories/%E6%96%B9%E6%B3%95%E8%AE%BA/%E9%98%85%E8%AF%BBAI%E8%AE%BA%E6%96%87/"/>
    
    
    <category term="方法论" scheme="https://gmet233.gitee.io/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>_Python 抛出异常后程序继续执行</title>
    <link href="https://gmet233.gitee.io/2022/02/22/Python-%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E5%90%8E%E7%A8%8B%E5%BA%8F%E7%BB%A7%E7%BB%AD%E6%89%A7%E8%A1%8C/"/>
    <id>https://gmet233.gitee.io/2022/02/22/Python-%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E5%90%8E%E7%A8%8B%E5%BA%8F%E7%BB%A7%E7%BB%AD%E6%89%A7%E8%A1%8C/</id>
    <published>2022-02-22T13:09:15.000Z</published>
    <updated>2022-02-22T13:16:04.092Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是一个知识碎片</p></blockquote><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>当遇到异常时，为了让程序继续执行而不中断，代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 可能抛出异常的代码块</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>注：<strong>这样做需要谨慎</strong>，原因如下：</p><ol><li>这样做抛出异常的类型不明确。可能抛出了你并不想忽略的异常；</li><li>这样做过于敷衍（除非你是有目的的这么做）</li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://blog.csdn.net/weixin_43307577/article/details/87710251">Python异常处理 -跳过异常继续执行</a></li><li><a href="https://developer.aliyun.com/article/803360">问题：为什么“except:pass”是一个不好的编程习惯？</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文是一个知识碎片&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;&gt;&lt;/a&gt;正文&lt;/h1&gt;&lt;p&gt;当遇到异常时，为了让程序继续执行而不中断，代码如下：</summary>
      
    
    
    
    <category term="Python" scheme="https://gmet233.gitee.io/categories/Python/"/>
    
    <category term="异常" scheme="https://gmet233.gitee.io/categories/Python/%E5%BC%82%E5%B8%B8/"/>
    
    
    <category term="Python" scheme="https://gmet233.gitee.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>《动手学深度学习》读书笔记（三）CNN的填充、步幅、通道、池化</title>
    <link href="https://gmet233.gitee.io/2022/02/15/%E3%80%8A%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89CNN%E7%9A%84%E5%A1%AB%E5%85%85%E3%80%81%E6%AD%A5%E5%B9%85%E3%80%81%E9%80%9A%E9%81%93%E3%80%81%E6%B1%A0%E5%8C%96/"/>
    <id>https://gmet233.gitee.io/2022/02/15/%E3%80%8A%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89CNN%E7%9A%84%E5%A1%AB%E5%85%85%E3%80%81%E6%AD%A5%E5%B9%85%E3%80%81%E9%80%9A%E9%81%93%E3%80%81%E6%B1%A0%E5%8C%96/</id>
    <published>2022-02-15T14:51:25.000Z</published>
    <updated>2022-02-15T15:20:18.519Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文FROM《动手学深度学习》第六章 卷积神经网络 6.3、6.4和6.5小节</p><p>虽然标题中，填充、步幅、通道、池化放在一起，但是实际这四者并非并列关系。</p></blockquote><h1 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h1><p>在卷积神经网络中，卷积的输出形状取决于输入形状和卷积核的形状。</p><p>例如，一个 240×240 像素的图像，经过 10 层 5×5 的卷积后，将减少到 200×200 像素。如此一来，原始图像的边界丢失了许多有用信息。而<strong>填充</strong>是解决此问题最有效的方法。</p><p>下面的图展示了带填充的二维互相关。</p><p><img src="conv-pad.svg" alt="带填充的二维互相关"></p><p>设网络输入宽高分别为 $n_w$ 和 $n_h$，卷积核宽高分别为 $k_w$ 和 $k_h$，如果我们添加 $p_h$ 行填充（大约一半在顶部，一半在底部）和 $p_w$ 列填充（左侧大约一半，右侧一半），则输出形状将为</p><script type="math/tex; mode=display">(n_h-k_h+p_h+1)\times(n_w-k_w+p_w+1)。</script><p>这意味着输出的高度和宽度将分别增加 $p_h$ 和 $p_w$。</p><p>在许多情况下，我们需要设置 $p_h=k_h-1$ 和 $p_w=k_w-1$，使输入和输出具有相同的高度和宽度。这样可以在构建网络时更容易地预测每个图层的输出形状。假设 $k_h$ 是奇数，我们将在高度的两侧填充 $p_h/2$ 行。<br>如果 $k_h$ 是偶数，则一种可能性是在输入顶部填充 $\lceil p_h/2\rceil$ 行，在底部填充 $\lfloor p_h/2\rfloor$ 行。填充宽度的两侧同理。</p><p>卷积神经网络中卷积核的高度和宽度通常为奇数，例如 1、3、5 或 7。选择奇数的好处是，保持空间维度的同时，我们可以在顶部和底部填充相同数量的行，在左侧和右侧填充相同数量的列。</p><p>此外，使用奇数核和填充也提供了书写上的便利。对于任何二维张量 $X$，当满足：</p><ol><li>内核的大小是奇数；</li><li>所有边的填充行数和列数相同；</li><li>输出与输入具有相同高度和宽度</li></ol><p>则可以得出：输出 $Y[i, j]$ 是通过以输入 $X[i, j]$ 为中心，与卷积核进行互相关计算得到的。比如，在下面的例子中，我们创建一个高度和宽度为3的二维卷积层，并<strong>在所有侧边填充1个像素</strong>。给定高度和宽度为8的输入，则输出的高度和宽度也是8。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 为了方便起见，我们定义了一个计算卷积层的函数。</span></span><br><span class="line"><span class="comment"># 此函数初始化卷积层权重，并对输入和输出提高和缩减相应的维数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">comp_conv2d</span>(<span class="params">conv2d, X</span>):</span><br><span class="line">    <span class="comment"># 这里的（1，1）表示批量大小和通道数都是1</span></span><br><span class="line">    X = X.reshape((<span class="number">1</span>, <span class="number">1</span>) + X.shape)</span><br><span class="line">    Y = conv2d(X)  <span class="comment"># 将X输入到卷积层中，输出Y</span></span><br><span class="line">    <span class="comment"># 省略前两个维度：批量大小和通道</span></span><br><span class="line">    <span class="keyword">return</span> Y.reshape(Y.shape[<span class="number">2</span>:])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 请注意，这里每边都填充了1行或1列，因此总共添加了2行或2列</span></span><br><span class="line">conv2d = nn.Conv2d(<span class="number">1</span>, <span class="number">1</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>)  <span class="comment"># 这里定义了一个卷积层</span></span><br><span class="line">X = torch.rand(size=(<span class="number">8</span>, <span class="number">8</span>))</span><br><span class="line">comp_conv2d(conv2d, X).shape</span><br></pre></td></tr></table></figure><pre><code>torch.Size([8, 8])</code></pre><p>当卷积核的高度和宽度不同时，我们可以填充不同的高度和宽度，使输出和输入具有相同的高度和宽度。在如下示例中，我们使用高度为5，宽度为3的卷积核，高度和宽度两边的填充分别为2和1。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">conv2d = nn.Conv2d(<span class="number">1</span>, <span class="number">1</span>, kernel_size=(<span class="number">5</span>, <span class="number">3</span>), padding=(<span class="number">2</span>, <span class="number">1</span>))</span><br><span class="line">comp_conv2d(conv2d, X).shape</span><br></pre></td></tr></table></figure><pre><code>torch.Size([8, 8])</code></pre><h1 id="步幅"><a href="#步幅" class="headerlink" title="步幅"></a>步幅</h1><p>在计算互相关时，卷积窗口从输入张量的左上角开始，向下、向右滑动。 在前面的例子中，我们默认每次滑动一个元素。 但是，有时候为了高效计算或是缩减采样次数，卷积窗口可以跳过中间位置，每次滑动多个元素。</p><p>我们将每次滑动元素的数量称为步幅（stride）。下图展示了垂直步幅为 3 ，水平步幅为 2 的二维互相关运算。</p><p><img src="conv-stride.svg" alt="垂直步幅为 $3$，水平步幅为 $2$ 的二维互相关运算"></p><p>可以看到，为了计算输出中第一列的第二个元素和第一行的第二个元素，卷积窗口分别向下滑动三行和向右滑动两列。但是，当卷积窗口继续向右滑动两列时，没有输出，因为输入元素无法填充窗口（除非我们添加另一列填充）。</p><p>通常，当垂直步幅为 $s_h$ 、水平步幅为 $s_w$ 时，输出形状为</p><script type="math/tex; mode=display">\lfloor(n_h-k_h+p_h+s_h)/s_h\rfloor \times \lfloor(n_w-k_w+p_w+s_w)/s_w\rfloor.</script><p>如果我们设置了 $p_h=k_h-1$ 和 $p_w=k_w-1$，则输出形状将简化为 $\lfloor(n_h+s_h-1)/s_h\rfloor \times \lfloor(n_w+s_w-1)/s_w\rfloor$。<br>更进一步，如果输入的高度和宽度可以被垂直和水平步幅整除，则输出形状将为 $(n_h/s_h) \times (n_w/s_w)$。</p><p>下面，我们<strong>将高度和宽度的步幅设置为2</strong>，从而将输入的高度和宽度减半。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">conv2d = nn.Conv2d(<span class="number">1</span>, <span class="number">1</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>, stride=<span class="number">2</span>)</span><br><span class="line">comp_conv2d(conv2d, X).shape</span><br></pre></td></tr></table></figure><pre><code>torch.Size([4, 4])</code></pre><p>为了简洁起见，当输入高度和宽度两侧的填充数量分别为 $p_h$ 和 $p_w$ 时，我们称之为填充 $(p_h, p_w)$。当 $p_h = p_w = p$ 时，填充是 $p$。同理，当高度和宽度上的步幅分别为 $s_h$ 和 $s_w$ 时，我们称之为步幅 $(s_h, s_w)$。当时的步幅为 $s_h = s_w = s$ 时，步幅为 $s$。默认情况下，填充为 0，步幅为 1。<strong>在实践中，我们很少使用不一致的步幅或填充，也就是说，我们通常有 $p_h = p_w$ 和 $s_h = s_w$。</strong></p><h1 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h1><p>当我们添加通道时，我们的输入和隐藏的表示从二维张量变成了三维张量。例如，每个RGB输入图像具有 3×h×w 的形状。我们将这个大小为 3 的轴称为通道（channel）维度。</p><p>通道分为输入通道和输出通道。灰度图的输入通道为1，RGB图的输入通道为3。而输出通道是自定义的。灰度图的输出通道也可以大于1，RGB图的输出通道也可以为1，这取决于如何定义卷积核和输出。</p><h2 id="多输入通道"><a href="#多输入通道" class="headerlink" title="多输入通道"></a>多输入通道</h2><p>当输入包含多个通道时，需要构造一个与输入数据具有相同输入通道数目的卷积核，以便与输入数据进行互相关运算。假设输入的通道数为 $c_i$，那么卷积核的输入通道数也需要为 $c_i$ 。如果卷积核的窗口形状是 $k_h\times k_w$，那么当 $c_i=1$ 时，我们可以把卷积核看作形状为 $k_h\times k_w$ 的二维张量。</p><p>然而，当 $c_i&gt;1$ 时，我们卷积核的每个输入通道将包含形状为 $k_h\times k_w$ 的张量。将这些张量 $c_i$ 连结在一起可以得到形状为 $c_i\times k_h\times k_w$ 的卷积核。由于输入和卷积核都有 $c_i$ 个通道，我们可以对每个通道输入的二维张量和卷积核的二维张量进行互相关运算，再对通道求和（将 $c_i$ 的结果相加）得到二维张量。这是多通道输入和多输入通道卷积核之间进行二维互相关运算的结果。</p><p>下图我们演示了一个具有两个输入通道的二维互相关运算的示例。</p><p><img src="conv-multi-in.svg" alt="两个输入通道的互相关计算。"></p><p>多输入通道互相关运算的实现如下。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">corr2d_multi_in</span>(<span class="params">X, K</span>):</span><br><span class="line">    <span class="comment"># 先遍历“X”和“K”的第0个维度（通道维度），再把它们加在一起</span></span><br><span class="line">    <span class="comment"># for x, k in zip(X, K) 拿出X, K对应维度里的矩阵</span></span><br><span class="line">    <span class="comment"># d2l.corr2d()函数：完成互相关运算</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(d2l.corr2d(x, k) <span class="keyword">for</span> x, k <span class="keyword">in</span> <span class="built_in">zip</span>(X, K))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = torch.tensor([[[<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>], [<span class="number">3.0</span>, <span class="number">4.0</span>, <span class="number">5.0</span>], [<span class="number">6.0</span>, <span class="number">7.0</span>, <span class="number">8.0</span>]],</span><br><span class="line">               [[<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>], [<span class="number">4.0</span>, <span class="number">5.0</span>, <span class="number">6.0</span>], [<span class="number">7.0</span>, <span class="number">8.0</span>, <span class="number">9.0</span>]]])</span><br><span class="line">K = torch.tensor([[[<span class="number">0.0</span>, <span class="number">1.0</span>], [<span class="number">2.0</span>, <span class="number">3.0</span>]], [[<span class="number">1.0</span>, <span class="number">2.0</span>], [<span class="number">3.0</span>, <span class="number">4.0</span>]]])</span><br><span class="line"></span><br><span class="line">corr2d_multi_in(X, K)</span><br></pre></td></tr></table></figure><pre><code>tensor([[ 56.,  72.],        [104., 120.]])</code></pre><h2 id="多输出通道"><a href="#多输出通道" class="headerlink" title="多输出通道"></a>多输出通道</h2><p>到目前为止，不论有多少输入通道，我们还只有一个输出通道。然而，这是不够的。在最流行的神经网络架构中，随着神经网络层数的加深，我们常会<strong>增加输出通道的维数，通过减少空间分辨率以获得更大的通道深度</strong>。直观地说，我们可以将每个通道看作是对不同特征的响应。而现实可能更为复杂一些，因为每个通道不是独立学习的，而是为了共同使用而优化的。因此，多输出通道并不仅是学习多个单通道的检测器。</p><p>用 $c_i$ 和 $c_o$ 分别表示输入和输出通道的数目，并让 $k_h$ 和 $k_w$ 为卷积核的高度和宽度。为了获得多个通道的输出，我们可以为每个输出通道创建一个形状为 $c_i\times k_h\times k_w$ 的卷积核张量，这样卷积核的形状是 $c_o\times c_i\times k_h\times k_w$。在互相关运算中，每个输出通道先获取所有输入通道，再以对应该输出通道的卷积核计算出结果。</p><p>如下所示，我们实现一个<strong>计算多个通道的输出的互相关函数</strong>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">corr2d_multi_in_out</span>(<span class="params">X, K</span>):</span><br><span class="line">    <span class="comment"># 迭代“K”的第0个维度，每次都对输入“X”执行互相关运算。</span></span><br><span class="line">    <span class="comment"># 最后将所有结果都叠加在一起</span></span><br><span class="line">    <span class="comment"># `corr2d_multi_in(X, k) for k in K`意思是在拿出每一个二维卷积核k，都对完整的输入X做互相关运算</span></span><br><span class="line">    <span class="comment"># torch.stack(…, 0)意思是将结果在0的维度上“堆”起来</span></span><br><span class="line">    <span class="keyword">return</span> torch.stack([corr2d_multi_in(X, k) <span class="keyword">for</span> k <span class="keyword">in</span> K], <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>上面代码中，<code>torch.stack(…, 0)</code>是将结果在0的维度上“堆”起来。下面通过将核张量K与K+1（K中每个元素加 1 ）和K+2连接起来，构造了一个具有 3 个输出通道的卷积核。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">K = torch.stack((K, K + <span class="number">1</span>, K + <span class="number">2</span>), <span class="number">0</span>)</span><br><span class="line">K.shape  <span class="comment"># 原始K的维度是(2,2,2)</span></span><br></pre></td></tr></table></figure><pre><code>torch.Size([3, 2, 2, 2])</code></pre><p>下面，我们对输入张量X与卷积核张量K执行互相关运算。现在的输出包含 3 个通道，</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">corr2d_multi_in_out(X, K)</span><br></pre></td></tr></table></figure><pre><code>tensor([[[ 56.,  72.],         [104., 120.]],        [[ 76., 100.],         [148., 172.]],        [[ 96., 128.],         [192., 224.]]])</code></pre><h2 id="1-times-1-卷积层"><a href="#1-times-1-卷积层" class="headerlink" title="$1\times 1$ 卷积层"></a>$1\times 1$ 卷积层</h2><p>$1\times 1$ 卷积，即 $k_h = k_w = 1$，看起来似乎没有多大意义。<br>毕竟，卷积的本质是有效提取相邻像素间的相关特征，而 $1 \times 1$ 卷积显然没有此作用。<br>尽管如此，$1 \times 1$ 仍然十分流行，时常包含在复杂深层网络的设计中。下面，让我们详细地解读一下它的实际作用。</p><p>因为使用了最小窗口，$1\times 1$ 卷积失去了卷积层的特有能力——在高度和宽度维度上，识别相邻元素间相互作用的能力。<br>其实 $1\times 1$ 卷积的唯一计算发生在通道上。</p><p>下图展示了使用 $1\times 1$ 卷积核与 $3$ 个输入通道和 $2$ 个输出通道的互相关计算。这里输入和输出具有相同的高度和宽度，输出中的每个元素都是从输入图像中同一位置的元素的线性组合。我们可以将 $1\times 1$ 卷积层看作是在每个像素位置应用的全连接层，以 $c_i$ 个输入值转换为 $c_o$ 个输出值。因为这仍然是一个卷积层，所以跨像素的权重是一致的。同时，$1\times 1$ 卷积层需要的权重维度为 $c_o\times c_i$ ，再额外加上一个偏置。</p><p><img src="conv-1x1.svg" alt="互相关计算使用了具有3个输入通道和2个输出通道的 $1\times 1$ 卷积核。其中，输入和输出具有相同的高度和宽度。"></p><p>下面，我们使用全连接层实现 $1 \times 1$ 卷积。请注意，我们需要对输入和输出的数据形状进行微调。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">corr2d_multi_in_out_1x1</span>(<span class="params">X, K</span>):</span><br><span class="line">    c_i, h, w = X.shape</span><br><span class="line">    c_o = K.shape[<span class="number">0</span>]</span><br><span class="line">    X = X.reshape((c_i, h * w))</span><br><span class="line">    K = K.reshape((c_o, c_i))</span><br><span class="line">    <span class="comment"># 全连接层中的矩阵乘法</span></span><br><span class="line">    Y = torch.matmul(K, X)</span><br><span class="line">    <span class="keyword">return</span> Y.reshape((c_o, h, w))</span><br></pre></td></tr></table></figure><p>当执行 $1\times 1$ 卷积运算时，上述函数相当于先前实现的互相关函数<code>corr2d_multi_in_out</code>。让我们用一些样本数据来验证这一点。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = torch.normal(<span class="number">0</span>, <span class="number">1</span>, (<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line">K = torch.normal(<span class="number">0</span>, <span class="number">1</span>, (<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Y1 = corr2d_multi_in_out_1x1(X, K)</span><br><span class="line">Y2 = corr2d_multi_in_out(X, K)</span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">float</span>(torch.<span class="built_in">abs</span>(Y1 - Y2).<span class="built_in">sum</span>()) &lt; <span class="number">1e-6</span></span><br></pre></td></tr></table></figure><h1 id="pooling"><a href="#pooling" class="headerlink" title="pooling"></a>pooling</h1><p>通常当我们处理图像时，我们希望逐渐降低隐藏表示的空间分辨率，聚集信息，这样随着我们在神经网络中层叠的上升，每个神经元对其敏感的感受野（输入）就越大。</p><p>而我们的机器学习任务通常会跟全局图像的问题有关（例如，“图像是否包含一只猫呢？”）， 所以我们最后一层的神经元应该对整个输入的全局敏感。通过逐渐聚合信息，生成越来越粗糙的映射，最终实现学习全局表示的目标，同时将卷积图层的所有优势保留在中间层。</p><p>此外，当检测较底层的特征时，我们通常希望这些特征保持某种程度上的平移不变性。例如，如果我们拍摄黑白之间轮廓清晰的图像 $X$，并将整个图像向右移动一个像素，即 $Z[i, j] = X[i, j + 1]$，则新图像 $Z$ 的输出可能大不相同。而在现实中，随着拍摄角度的移动，任何物体几乎不可能发生在同一像素上。即使用三脚架拍摄一个静止的物体，由于快门的移动而引起的相机振动，可能会使所有物体左右移动一个像素。</p><p>本节将介绍 <em>池化</em>（pooling）层，它具有双重目的：降低卷积层对位置的敏感性，同时降低对空间降采样表示的敏感性。</p><h2 id="最大汇聚层和平均汇聚层"><a href="#最大汇聚层和平均汇聚层" class="headerlink" title="最大汇聚层和平均汇聚层"></a>最大汇聚层和平均汇聚层</h2><p>与卷积层类似，汇聚层运算符由一个固定形状的窗口组成，该窗口根据其步幅大小在输入的所有区域上滑动，为固定形状窗口（有时称为 <em>池化窗口</em>）遍历的每个位置计算一个输出。</p><p>然而，不同于卷积层中的输入与卷积核之间的互相关计算，汇聚层不包含参数。<br>相反，池运算符是确定性的，我们通常计算池化窗口中所有元素的最大值或平均值。这些操作分别称为 <em>最大汇聚层</em> （maximum pooling）和 <em>平均汇聚层</em> （average pooling）。</p><p>在这两种情况下，与互相关运算符一样，池化窗口从输入张量的左上角开始，从左到右、从上到下的在输入张量内滑动。在池化窗口到达的每个位置，它计算该窗口中输入子张量的最大值或平均值，具体取决于是使用了最大汇聚层还是平均汇聚层。</p><p><img src="pooling.svg" alt="池化窗口形状为 $2\times 2$ 的最大汇聚层。着色部分是第一个输出元素，以及用于计算这个输出的输入元素: $\max(../img/pooling.svg)=4$."></p><p>上图中输出张量的高度为 $2$，宽度为 $2$。这四个元素为每个池化窗口中的最大值：</p><script type="math/tex; mode=display">\max(0, 1, 3, 4)=4,\\\max(1, 2, 4, 5)=5,\\\max(3, 4, 6, 7)=7,\\\max(4, 5, 7, 8)=8.\\</script><p>池化窗口形状为 $p \times q$ 的汇聚层称为 $p \times q$ 汇聚层，池化操作称为 $p \times q$ 池化。</p><p>回到本节开头提到的对象边缘检测示例，现在我们将使用卷积层的输出作为 $2\times 2$ 最大池化的输入。设置卷积层输入为 $X$，汇聚层输出为 $Y$。无论 $X[i, j]$ 和 $X[i, j + 1]$ 的值是否不同，或 $X[i, j + 1]$ 和 $X[i, j + 2]$ 的值是否不同，汇聚层始终输出 $Y[i, j] = 1$。也就是说，使用 $2\times 2$ 最大汇聚层，即使在高度或宽度上移动一个元素，卷积层仍然可以识别到模式。</p><p>在下面的代码中的 <code>pool2d</code> 函数，我们<strong>实现汇聚层的正向传播</strong>。然而，这里我们没有卷积核，输出为输入中每个区域的最大值或平均值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">pool2d</span>(<span class="params">X, pool_size, mode=<span class="string">&#x27;max&#x27;</span></span>):</span><br><span class="line">    p_h, p_w = pool_size</span><br><span class="line">    Y = torch.zeros((X.shape[<span class="number">0</span>] - p_h + <span class="number">1</span>, X.shape[<span class="number">1</span>] - p_w + <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(Y.shape[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(Y.shape[<span class="number">1</span>]):</span><br><span class="line">            <span class="keyword">if</span> mode == <span class="string">&#x27;max&#x27;</span>:</span><br><span class="line">                Y[i, j] = X[i: i + p_h, j: j + p_w].<span class="built_in">max</span>()</span><br><span class="line">            <span class="keyword">elif</span> mode == <span class="string">&#x27;avg&#x27;</span>:</span><br><span class="line">                Y[i, j] = X[i: i + p_h, j: j + p_w].mean()</span><br><span class="line">    <span class="keyword">return</span> Y</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 构建输入X，验证最大池化的输出</span></span><br><span class="line">X = torch.tensor([[<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>], [<span class="number">3.0</span>, <span class="number">4.0</span>, <span class="number">5.0</span>], [<span class="number">6.0</span>, <span class="number">7.0</span>, <span class="number">8.0</span>]])</span><br><span class="line">pool2d(X, (<span class="number">2</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure><pre><code>tensor([[4., 5.],        [7., 8.]])</code></pre><h2 id="填充与步幅"><a href="#填充与步幅" class="headerlink" title="填充与步幅"></a>填充与步幅</h2><p>与卷积层一样，汇聚层也可以改变输出形状。和以前一样，我们可以通过填充和步幅以获得所需的输出形状。 下面，我们用深度学习框架中内置的二维最大汇聚层，来演示汇聚层中填充和步幅的使用。 我们首先构造了一个输入张量X，它有四个维度，其中样本数和通道数都是1。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = torch.arange(<span class="number">16</span>, dtype=torch.float32).reshape((<span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">4</span>))</span><br><span class="line">X</span><br></pre></td></tr></table></figure><pre><code>tensor([[[[ 0.,  1.,  2.,  3.],          [ 4.,  5.,  6.,  7.],          [ 8.,  9., 10., 11.],          [12., 13., 14., 15.]]]])</code></pre><p>默认情况下，深度学习框架中的步幅与汇聚窗口的大小相同。 因此，如果我们使用形状为(3, 3)的汇聚窗口，那么默认情况下，我们得到的步幅形状为(3, 3)</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pool2d = nn.MaxPool2d(<span class="number">3</span>)</span><br><span class="line">pool2d(X)</span><br></pre></td></tr></table></figure><pre><code>tensor([[[[10.]]]])</code></pre><p>填充和步幅可以手动设定：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pool2d = nn.MaxPool2d(<span class="number">3</span>, padding=<span class="number">1</span>, stride=<span class="number">2</span>)</span><br><span class="line">pool2d(X)</span><br></pre></td></tr></table></figure><p>当然，我们可以设定一个任意大小的矩形汇聚窗口，并分别设定填充和步幅的高度和宽度。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pool2d = nn.MaxPool2d((<span class="number">2</span>, <span class="number">3</span>), stride=(<span class="number">2</span>, <span class="number">3</span>), padding=(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">pool2d(X)</span><br></pre></td></tr></table></figure><pre><code>tensor([[[[ 5.,  7.],          [13., 15.]]]])</code></pre><h2 id="多个通道"><a href="#多个通道" class="headerlink" title="多个通道"></a>多个通道</h2><p>在处理多通道输入数据时，汇聚层在每个输入通道上单独运算，而不是像卷积层一样在通道上对输入进行汇总。 这意味着汇聚层的输出通道数与输入通道数相同。 下面，我们将在通道维度上连结张量X和X + 1，以构建具有2个通道的输入。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = torch.cat((X, X + <span class="number">1</span>), <span class="number">1</span>)</span><br><span class="line">X</span><br></pre></td></tr></table></figure><pre><code>tensor([[[[ 0.,  1.,  2.,  3.],          [ 4.,  5.,  6.,  7.],          [ 8.,  9., 10., 11.],          [12., 13., 14., 15.]],         [[ 1.,  2.,  3.,  4.],          [ 5.,  6.,  7.,  8.],          [ 9., 10., 11., 12.],          [13., 14., 15., 16.]]]])</code></pre><p>pooling后输出通道的数量仍然是2。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pool2d = nn.MaxPool2d(<span class="number">3</span>, padding=<span class="number">1</span>, stride=<span class="number">2</span>)</span><br><span class="line">pool2d(X)</span><br></pre></td></tr></table></figure><pre><code>tensor([[[[ 5.,  7.],          [13., 15.]],         [[ 6.,  8.],          [14., 16.]]]])</code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>《动手学深度学习》6.3、6.4、6.5节</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文FROM《动手学深度学习》第六章 卷积神经网络 6.3、6.4和6.5小节&lt;/p&gt;
&lt;p&gt;虽然标题中，填充、步幅、通道、池化放在一起，但是实际这四者并非并列关系。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;填充&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="深度学习" scheme="https://gmet233.gitee.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="动手学深度学习" scheme="https://gmet233.gitee.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="深度学习" scheme="https://gmet233.gitee.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="动手学深度学习" scheme="https://gmet233.gitee.io/tags/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Java 多线程基础</title>
    <link href="https://gmet233.gitee.io/2022/01/24/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <id>https://gmet233.gitee.io/2022/01/24/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</id>
    <published>2022-01-24T13:38:18.000Z</published>
    <updated>2022-01-24T13:57:11.310Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇博客叙述Java多线程的基本知识和基本操作。</p><blockquote><p>待补充的部分：</p><ul><li>[ ] 线程调度</li><li>[ ] AtomicInteger</li><li>[ ] Semaphore</li><li>[ ] 阻塞队列的实现类详解</li><li>[ ] 多线程共享数据的方法</li><li>[ ] ConcurrentHashMap</li><li>[ ] Java并发关键字</li><li>[ ] 进程调度算法</li><li>[ ] CAS/ABA/AQS</li></ul></blockquote><h1 id="线程概述"><a href="#线程概述" class="headerlink" title="线程概述"></a>线程概述</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>当一个程序进入内存运行时，即变成一个进程。进程是处于运行过程中的程序，并且具有一定独立的功能，进程是系统进行资源分配和调度的一个独立单位。</p><p>一般而言，进程包含三个特征：独立性；动态性；并发性。、</p><p>并发和并行是两个概念，并行是指同一时刻，有多条指令在多个处理器上同时执行；并发指在同一时刻只能有一条指令执行，但多个进程指令被快速轮换执行，使得宏观上具有多个进程同时执行的效果。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>多线程扩展了多进程的概念，使得同一个进程可以同时并发处理多个任务。</p><p>线程是进程的执行单元，是进程的组成部分，一个进程可以拥有多个线程，一个线程必须有一个父进程。线程可以拥有自己的堆栈、自己的程序计数器和自己的局部变量。</p><p>多个线程共享父进程里的全部资源，可以与其他线程共享父进程中的共享变量和部分环境。</p><p>线程是独立于运行的，他并不知道进程中是否还有其他线程存在。现成的执行是抢占式的，也就是说，当前运行的线程在任何时候都可能被挂起，以便另一个线程可以运行。</p><p>一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行。</p><p>从逻辑的角度，多线程存在于一个应用程序中，让一个应用程序中可以有多个执行部分同时执行，但操作系统无须将多个线程看作多个独立的应用，对多线程实现调度和管理以及资源分配。线程的调度和管理由进程本身负责完成。</p><h2 id="线程优势"><a href="#线程优势" class="headerlink" title="线程优势"></a>线程优势</h2><p>进程中线程的之间的隔离程度更小。</p><p>多个线程共享同一个进程虚拟空间。线程共享的环境包括：进程代码段、进程的共有数据等。<br>总结起来，使用多线程编程具有如下优点：</p><ul><li>进程之间不能共享内存，但线程之间共享内存很容易</li><li>系统创建进程时，需要位该进程重新分配系统资源，但创建线程则代价小很多，因此使用多线程实现多任务并发比多进程的效率高。</li><li>Java语言内置了多线程功能支持，而不是单纯的作为底层操作系统的调度方式，从而简化了Java的多线程编程。</li></ul><h1 id="线程创建和启动"><a href="#线程创建和启动" class="headerlink" title="线程创建和启动"></a>线程创建和启动</h1><p>有三种方式创建线程类</p><h2 id="继承Thread类创建线程类"><a href="#继承Thread类创建线程类" class="headerlink" title="继承Thread类创建线程类"></a>继承Thread类创建线程类</h2><ol><li>定义Thread的子类，并重写run方法，该run方法的方法题就代表了线程需要完成的任务。（线程执行体）</li><li>创建Thread子类的实例，即创建了线程对象。</li><li>调用线程对象的start方法来启动该线程。</li></ol><h2 id="实现Runnable接口创建线程类"><a href="#实现Runnable接口创建线程类" class="headerlink" title="实现Runnable接口创建线程类"></a>实现Runnable接口创建线程类</h2><ol><li>定义Runnable接口的实现类，并重写该接口的run方法。该run方法的方法体同样是该线程的线程执行体。</li><li>创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。</li></ol><blockquote><p>代码</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTester</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">firstThread</span>().start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">firstThread</span>().start();</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">tt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">secondThread</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(tt, <span class="string">&quot;新线程1&quot;</span>).start(); <span class="comment">//可以给线程命名</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(tt, <span class="string">&quot;新线程2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">firstThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(getName() + <span class="string">&quot;：&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">secondThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：&quot;</span> + i); <span class="comment">//只能使用Thread.currentThread().getName()来获得线程名</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注</p><ul><li>使用继承Thread类的方法来创建线程类时，多个线程之间无法共享线程类的实例变量。</li><li>Runnable对象仅作为Thread对象的target，Runnable实现类里包含的run方法仅作为线程执行体。而实际的线程对象依然是Thread实例，只是该Thread线程负责执行其target的run方法。</li><li>通过实现Runnable接口来获得当前线程对象，则必须使用Thread.currentThread()方法。</li><li>从Java8开始，Runnable接口使用了@FunctionalInterface，也就是说，可以使用Lambda表达式创建Runnable对象。下面介绍的Callable接口也是函数式接口。</li></ul><h2 id="使用Callable和Future创建线程"><a href="#使用Callable和Future创建线程" class="headerlink" title="使用Callable和Future创建线程"></a>使用Callable和Future创建线程</h2><p>Callable接口提供了一个call方法可以作为线程执行体，但call方法比run方法功能更强大。</p><ul><li>call方法有返回值。</li><li>call可以声明抛出异常。</li></ul><p>完全可以提供一个Callable对象作为Thread的target，而该线程的线程执行体就是该Callable对象的call方法。但Callable接口不是Runnable接口的子接口，所以Callable对象不能直接作为Thread的target。</p><p>Java5提供了Future接口来代表Callable接口里call方法的返回值，并为Future接口提供了一个FutureTask实现类，该实现类实现了Future接口并实现了Runnable接口，可以作为Thread类的target。</p><p><img src="20160713174739239.png" alt="FutureTask"></p><p>Future接口中定义了如下公共方法来控制它关联的Callable任务。</p><ul><li><code>boolean cancel(boolean mayInterroutIfRunning)</code>：试图取消该Future里关联的Callable任务。</li><li><code>V get()</code>：返回Callable任务里的call方法的返回值。调用该方法将导致程序阻塞，必须等待子线程接口后才会得到返回值。</li><li><code>V get(long timeout, TimeUnit unit)</code>：返回Callable任务里的call方法的返回值。该方法让程序最多阻塞timeout和unit指定的时间，如果经过指定时间后Callable任务依然没有返回值，将会抛出TimeoutException异常。</li><li><code>boolean isCancelled()</code>如果Callable任务正常完成前被取消，则返回true。</li><li><code>boolean isDone()</code>如果Callable任务已完成，则返回true。</li></ul><p>创建并启动有返回值的线程步骤如下：</p><ol><li>创建Callable接口的实现类，并实现call方法（注意泛型），该call方法将作为线程执行体，且该call方法有返回值，再创建Callable实现类的实例。</li><li>使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call方法的返回值。</li><li>使用FutureTask对象作为Thread对象的target创建并启动新线程。</li><li>调用FutureTask对象的get方法来获得子线程执行结束后的返回值。</li></ol><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableTester</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">thirdThread</span>()); <span class="comment">//也可以使用lambda表达式生成Callable对象</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(task, <span class="string">&quot;有返回值的线程1&quot;</span>).start();</span><br><span class="line"><span class="comment">//        new Thread(task, &quot;有返回值的线程2&quot;).start(); // 不生效，task对象只能用一次？</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程返回值：&quot;</span>+task.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">thirdThread</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span>(; i &lt; <span class="number">10</span> ; i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：Callable接口有泛型限制，Callable接口里的泛型形参类型与call方法返回值类型相同。</p><h2 id="三种创建线程的方式对比"><a href="#三种创建线程的方式对比" class="headerlink" title="三种创建线程的方式对比"></a>三种创建线程的方式对比</h2><ul><li>实现Runnable接口和实现Callable接口的方式基本相同，只是Callable接口里定义的方法有返回值，可以声明抛出异常而已。</li><li>采用实现Runnable、Callable接口的方式的优点是<ul><li>线程类还可以继承其他类</li><li>多个线程可以共享一个target对象，非常适合多个相同线程来处理同一份资源的情况。</li></ul></li><li>采用继承Thread类方式创建多线程的优点是：<ul><li>编写简单</li></ul></li></ul><h1 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h1><p>一个线程要经过新建（New）、就绪（Ready）、运行（Running）、阻塞（Blocked）、死亡（Dead）5种状态。</p><p>线程状态以及转换图如下：</p><p><img src="image-20210709151939392.png" alt="线程生命周期"></p><h2 id="新建和就绪状态"><a href="#新建和就绪状态" class="headerlink" title="新建和就绪状态"></a>新建和就绪状态</h2><p>当程序使用了new关键字创建了一个线程之后，该线程就处于新建状态。</p><p>当线程调用了start方法后，该线程就处于就绪状态。处于就绪状态的线程并没有开始运行，只是表示该线程可以运行了。</p><h2 id="运行和阻塞状态"><a href="#运行和阻塞状态" class="headerlink" title="运行和阻塞状态"></a>运行和阻塞状态</h2><p>如果处于就绪状态的线程获得了CPU，开始执行run方法的线程执行体，则该线程就处于运行状态。</p><p>线程在运行过程种需要被中断，目的是使其他线程获得执行的机会。当前执行的线程被阻塞后，其他线程就可以获得执行的机会。被阻塞的线程会在合适的时候将重新进入<strong>就绪状态</strong>。</p><p>比较特殊的情况，调用yield方法可以让运行状态的线程转入就绪状态。、</p><h2 id="线程死亡"><a href="#线程死亡" class="headerlink" title="线程死亡"></a>线程死亡</h2><p>线程可以以如上图三种方式死亡。</p><p>为了测试某个线程是否死亡，可以调用线程对象的isAlive方法，当线程处于就绪、运行、阻塞三种状态时，该方法将返回true；当线程处于新建、死亡两种状态时，该方法将返回false。</p><p>注意：</p><ul><li>当主线程结束时，其他线程不受影响，并不会随之结束。一旦子线程启动起来后，他就拥有和主线程相同的地位，他不会受主线程的影响。</li><li>不要试图对一个已经死亡的线程调用start方法使他重新启动。</li><li>对于新建状态的线程两次调用start方法也是错误的。</li></ul><h1 id="控制线程"><a href="#控制线程" class="headerlink" title="控制线程"></a>控制线程</h1><h2 id="join线程"><a href="#join线程" class="headerlink" title="join线程"></a>join线程</h2><p>Thread提供了一个让线程等待另一个线程完成的方法——join方法。当在某个车光绪执行流中调用其他线程的join方法时，调用线程将被阻塞，直到被join方法加入的join线程执行完为止。</p><p>join方法通常由使用线程的程序调用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JoinTester</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">jt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">joinThread</span>();</span><br><span class="line">        jt.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">20</span>) &#123;</span><br><span class="line">                jt.join();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">joinThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="image-20210709163027111.png" alt="join 运行结果"></p><p>由于在主线程调用了子线程的join方法，则主线程必须等到子线程（被Join的线程）执行完毕才能继续执行。</p><h2 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h2><p>有一种线程，他是在后台运行的，他的任务是为其他线程提供服务，这种线程被称为“后台线程（Daemon Thread）”，又称为守护线程或精灵线程。</p><p>后台线程有个特征：<strong>如果前台线程都死亡，后台线程会自动死亡。</strong></p><p>调用Thread的setDaemon(true)方法可将指定线程设置为后台线程。</p><p>Thread类还提供一个isDaemon方法，用于判断指定线程是否为后台线程。</p><p>前台线程创建的子线程默认就是前台线程，后台线程创建的子程序默认是后台线程。</p><p>注意：要将某个线程设置为后台线程，必须在该线程启动之前设置，也就是说setDaemon(true)比如在start方法之前调用。否则会引发异常。</p><h2 id="线程睡眠sleep"><a href="#线程睡眠sleep" class="headerlink" title="线程睡眠sleep"></a>线程睡眠sleep</h2><p><code>Thread.sleep(long milis)</code></p><p>Thread提供了一个与sleep方法有点相似的yield方法，后者也可以让当前正在执行的线程暂停，但他不会阻塞该线程，他只是将该线程转入就绪状态。yield只是让当前线程暂停一下。让系统的线程调度器重新调度一次。</p><p>关于sleep方法和yield方法的区别如下：</p><ul><li>sleep方法暂停当前线程后，会给其他线程执行机会，不会理会其他线程的优先级；但yield方法只会给同优先级相同，或优先级更高的线程执行机会。</li><li>sleep方法会将线程转入阻塞状态，直到经过阻塞时间才会转入就绪状态；而yield不会讲线程转入阻塞状态，他只是强制当前线程进入就绪状态。因此完全有可能某个线程被yield方法暂停之后，立即再次获得处理器资源被执行。</li><li>sleep方法声明抛出了异常，所以调用sleep方法必须捕捉或者显式声明抛出该异常；而yield没有声明抛出任何异常。</li><li>sleep方法比yield方法具有更好的移植性，更推荐用于控制并发线程的执行。</li></ul><h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><p>每个线程执行都具有一定的优先级，优先级高的线程获得较多的执行机会，而优先级低的线程则获得较少的执行机会。</p><p>每个线程默认的优先级都与创建它的父线程的优先级相同，在默认情况下，main线程具有普通优先级，由main线程创建的子线程也具有普通优先级。</p><p>Thread类提供了setPriority(int newPriority)、getPriority方法来指定或返回指定线程的优先级。其中setPriority的参数可以是一个整数，范围是1~10之间，也可以使用Thread类的如下三个静态常量。</p><ul><li>MAX_PRIORITY：其值为10</li><li>MIN_PRIORITY：其值为1</li><li>NORM_PRIORITY：其值为5</li></ul><p>这些优先级需要操作系统的支持，因此应该尽量避免直接为线程指定优先级，而应该使用上述三个静态常量。</p><h1 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h1><h2 id="抢占式调度"><a href="#抢占式调度" class="headerlink" title="抢占式调度"></a>抢占式调度</h2><h2 id="协同式调度"><a href="#协同式调度" class="headerlink" title="协同式调度"></a>协同式调度</h2><h2 id="Java的线程调度方式：抢占式"><a href="#Java的线程调度方式：抢占式" class="headerlink" title="Java的线程调度方式：抢占式"></a>Java的线程调度方式：抢占式</h2><h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><p>线程安全的经典问题：银行取钱问题。下面使用两个线程模拟两个人从一个银行账户中取钱。接下来定义一个账户类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String accountNo;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> balance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Account</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(String accountNo, <span class="type">double</span> balance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.accountNo = accountNo;</span><br><span class="line">        <span class="built_in">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略getter、setter</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBalance</span><span class="params">(<span class="type">double</span> balance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> (Account) o;</span><br><span class="line">        <span class="keyword">return</span> account.accountNo.equals(accountNo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> accountNo.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后是取钱线程类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DrawThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="comment">//账户</span></span><br><span class="line">    <span class="keyword">private</span> Account account;</span><br><span class="line">    <span class="comment">//取得钱数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> drawAmount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DrawThread</span><span class="params">(String name, Account account, <span class="type">double</span> drawAmount)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.account = account;</span><br><span class="line">        <span class="built_in">this</span>.drawAmount = drawAmount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(account.getBalance() &gt;= drawAmount) &#123;</span><br><span class="line">            System.out.println(getName() + <span class="string">&quot;取钱成功，吐出钞票：&quot;</span> + drawAmount);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            account.setBalance(account.getBalance() - drawAmount);</span><br><span class="line">            System.out.println(<span class="string">&quot;余额为：&quot;</span>+ account.getBalance());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(getName() + <span class="string">&quot;取钱失败，余额不足&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是主程序</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DrawTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个账户</span></span><br><span class="line">        <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>(<span class="string">&quot;0001&quot;</span>, <span class="number">1000</span>);</span><br><span class="line">        <span class="comment">//模拟两个线程取钱</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DrawThread</span>(<span class="string">&quot;甲&quot;</span>, account, <span class="number">800</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DrawThread</span>(<span class="string">&quot;乙&quot;</span>, account, <span class="number">800</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果<strong>可能</strong>为如下：</p><p><img src="image-20210710000053047.png" alt="线程同步 运行结果"></p><p>这就涉及了线程同步问题。</p><h2 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h2><p>之所以出现上述结果，是因为run方法的方法体不具有线程安全性，程序有两个并发线程在修改Account对象。</p><p>为了解决这样的问题，Java的多线程支持引入了同步监视器来解决这个问题，使用让同步监视器的通用方法就是同步代码块，语法格式如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(obj) &#123;</span><br><span class="line">    <span class="comment">//此处的代码就是同步代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：</p><ol><li>上述obj就是同步监视器，上面代码的含义是线程开始执行同步代码块之前必须先获得对同步监视器的锁定。</li><li>任何时刻只能有一个线程可以获得对同步监视器的锁定，当同步代码块执行完成后，该线程会释放对同步监视器的锁定。</li><li>通常推荐使用可能被并发访问的共享资源充当同步监视器。</li></ol><blockquote><p>synchronized属于独占式的悲观锁，同时属于可重入锁。</p><p>Synchronized的实现原理：详见《Offer来了 原理篇》P87</p></blockquote><p>根据上述修改代码考虑使用Account作为同步监视器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DrawThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="comment">//账户</span></span><br><span class="line">    <span class="keyword">private</span> Account account;</span><br><span class="line">    <span class="comment">//取得钱数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> drawAmount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DrawThread</span><span class="params">(String name, Account account, <span class="type">double</span> drawAmount)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.account = account;</span><br><span class="line">        <span class="built_in">this</span>.drawAmount = drawAmount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//同步代码块：使用account作为同步监视器，任何线程进入下面同步代码块之前，必须先获得对account账户的锁定，其他线程无法获得锁也就无法修改它，这种做法符合“加锁，修改，释放锁”的逻辑</span></span><br><span class="line">        <span class="keyword">synchronized</span> (account) &#123;</span><br><span class="line">            <span class="keyword">if</span>(account.getBalance() &gt;= drawAmount) &#123;</span><br><span class="line">                System.out.println(getName() + <span class="string">&quot;取钱成功，吐出钞票：&quot;</span> + drawAmount);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                account.setBalance(account.getBalance() - drawAmount);</span><br><span class="line">                System.out.println(<span class="string">&quot;余额为：&quot;</span>+ account.getBalance());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(getName() + <span class="string">&quot;取钱失败，余额不足&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这种方式就可以保证并发线程在任一时刻只有一个线程可以进入修改共享资源的代码区（也被称为临界区），所以同一时刻只有一个线程处于临界区内，从而保证了线程安全性。</p><h2 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h2><p>同步方法就是使用synchronized关键字来修饰某个方法，则该方法称为同步方法，对于synchronized修饰的实例方法（而非静态方法），无需显式指定同步监视器，同步方法的同步监视器是this，也就是调用该方法的对象。</p><p>下面将Account的balance的访问设置成线程安全的，那么只要把修改balance的方法编程同步方法即可。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String accountNo;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> balance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Account</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(String accountNo, <span class="type">double</span> balance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.accountNo = accountNo;</span><br><span class="line">        <span class="built_in">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//getter、setter</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAccountNo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> accountNo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    public void setBalance(double balance) &#123;</span></span><br><span class="line"><span class="comment">//        this.balance = balance;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//账户余额不允许修改，所以只为balance提供getter方法，</span></span><br><span class="line">    <span class="comment">//提供一线程安全的draw方法来完成取钱操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(<span class="type">double</span> drawAmount)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(balance &gt;= drawAmount) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;取钱成功！吐出钞票：&quot;</span>+drawAmount);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            balance -= drawAmount;</span><br><span class="line">            System.out.println(<span class="string">&quot;余额为：&quot;</span>+ balance);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;取钱失败，余额不足&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略equals和hashCode方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>因为Account提供了draw方法，而且取消了setBalance方法，DrawThread的run方法需要改写。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    account.draw(drawAmount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：</p><ol><li>synchronized关键字可以修饰方法，代码块但是布恩那个修饰构造器、成员变量等。</li><li>经过上述修改，DrawThread类无需自己实现取钱操作，而是直接调用account的draw方法。由于draw方法使用了synchronized修饰，同步方法的监视器是this。在上面的示例种，this是account，因此多个线程并发访问同一份account之前必须先对account加锁。这就保证了线程安全。</li><li>在Account里定义draw方法，而不是直接在run方法种实现取钱逻辑，这种做法更符合面向对象的规则。在面向对象里有一种流行的设计：Domain Driven Design（<strong>领域驱动设计</strong>，DDD），这种方式认为每个类都应该是完备的领域对象，例如账户类应该提供账户的相关方法。</li><li>为了减少线程安全带来的降低程序运行效率的影响应该：不要对线程安全类的所有方法进行同步，只对那些改变京城资源的方法进行同；如果可变类有两种运行环境：单线程运行环境和多线程运行环境，则应该为可变类提供两种版本。</li></ol><h2 id="释放同步监视器的锁定"><a href="#释放同步监视器的锁定" class="headerlink" title="释放同步监视器的锁定"></a>释放同步监视器的锁定</h2><p>程序无法显式释放对同步监视器的锁定，线程会在如下几种情况下释放对同步监视器的锁定。</p><ul><li>当前线程的同步方法、同步代码块执行结束。</li><li>当前线程在同步代码块，同步方法中遇到了break、return终止了该代码块、该方法的继续执行。</li><li>当前线程在同步代码块，同步方法中遇到了未处理的Error或Exception</li><li>程序执行了同步监视器对象的wait方法，则当前线程暂停，并释放同步监视器。</li></ul><p>在如下情况下，线程不会释放同步监视器。</p><ul><li>程序调用了Thread.sleep、Thread.yield方法来暂停当前线程的执行，</li><li>其他线程调用了该线程的suspend方法将线程挂起。</li></ul><h2 id="同步锁"><a href="#同步锁" class="headerlink" title="同步锁"></a>同步锁</h2><p>Lock提供了比synchronized方法和synchronized代码块更广泛更灵活的操作。</p><p>Lock是控制多个线程对共享资源进行访问的工具，通常，锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。</p><p>Lock接口的主要方法：</p><ul><li><code>void lock();</code> 加锁</li><li><code>void lockInterruptibly()</code> 当前线程未被中断则获取该锁。</li><li><code>boolean tryLock();</code>试图加锁，但不会阻塞</li><li><code>boolean tryLock(long time, TimeUnit unit)</code> 创建定时锁</li><li><code>void unlock();</code> 释放锁</li><li><code>Condition newCondition();</code> 创建条件对象，获取等待通知组件。</li></ul><p>Lock、ReadWriteLock是J5提供的两个根接口，并为Lock提供了ReentrantLock（可重入锁）【常用】实现类，为ReadWriteLock提供了ReentrantReadWriteLock实现类。</p><p>J8新增了StampedLock类，在大多数场景下可以替代传统的ReentrantReadWriteLock。ReentrantReadWriteLock为读写操作提供了三种锁模式：Writing、ReadingOptimistic、Reading</p><p>通常使用ReentrantLock的代码格式如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="comment">//定义需要保证线程安全的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//需要保证线程安全的代码</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ReentrantLock是一个可重入的独占锁。通过AQS来实现锁的获取和释放。</p><p>ReentrantLock不但提供了Synchronized对锁的操作功能。还提供了诸如可响应中断锁、可轮询锁请求，定时锁等避免多线程死锁的方法。</p></blockquote><p>根据Lock的使用修改Account的代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String accountNo;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> balance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Account</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(String accountNo, <span class="type">double</span> balance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.accountNo = accountNo;</span><br><span class="line">        <span class="built_in">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//getter、setter</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAccountNo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> accountNo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    public void setBalance(double balance) &#123;</span></span><br><span class="line"><span class="comment">//        this.balance = balance;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//账户余额不允许修改，所以只为balance提供getter方法，</span></span><br><span class="line">    <span class="comment">//提供一线程安全的draw方法来完成取钱操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(<span class="type">double</span> drawAmount)</span>&#123;</span><br><span class="line">        lock.lock(); <span class="comment">//加锁</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(balance &gt;= drawAmount) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;取钱成功！吐出钞票：&quot;</span>+drawAmount);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                balance -= drawAmount;</span><br><span class="line">                System.out.println(<span class="string">&quot;余额为：&quot;</span>+ balance);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;取钱失败，余额不足&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">//释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//省略hashCode、equals</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用Lock与使用同步方法有点相似，只是使用Lock时显式使用Lock对象作为同步锁，而使用同步方法时系统隐式使用当前对象作为同步监视器。</p><p>同步方法或同步代码块使用竞争资源相关的、隐式的同步监视器，并且强制要求加锁和释放锁要出现在一个块结构中。并且获取了多个锁时，他们必须以相反的顺序释放。所以同步方法或同步代码块的范围机制使得多线程安全编程非常方便，可以避免很多锁的常见编程错误。</p><p>Lock提供了同步方法或同步代码块所没有的其他功能，包括tryLock方法，以及试图获取可中断锁的lockInterruptibly方法，还可以获取超时失效锁的tryLock(long, TimeUnit)方法</p><p>ReentrantLock锁具有可重入性，也就是说，一个线程可以对已加锁的ReentrantLock锁再次加锁，ReentrantLock对象会维持一个计数器来追踪lock方法的嵌套调用，线程在每次调用lock加锁后，必须显式调用unlock来释放锁，所以一段被所保护的代码可以调用另一个被相同锁保护的方法。</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>编写程序时应尽量避免死锁。</p><ul><li>避免多次锁定：尽量避免同一个线程对多个同步监视器进行锁定</li><li>具有相同的加锁顺序：如果多个线程需要对多个同步监视器进行锁定，则应该保证他们以相同的顺序请求加锁。</li><li>使用定时锁：设置锁的超时时间。</li><li>依靠算法进行死锁检测。</li></ul><h1 id="Java锁详解"><a href="#Java锁详解" class="headerlink" title="Java锁详解"></a>Java锁详解</h1><p>Java中的锁主要保障多并发线程情况下的数据一致性。</p><p>锁从乐观和悲观的角度可分为乐观锁和悲观锁，从获取资源的公平性角度可分为公平锁和非公平锁，从是否共享资源的角度可分为共享锁和独占锁，从锁的状态可分为偏向锁，轻量级锁和重量级锁。此外JVM还设计了自旋锁来更快的使用CPU。</p><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>乐观锁，在每次读取数据时都认为别人不会修改数据，所以不会上锁，但在更新时会判断在此期间别人有没有更新该数据，通常在写时先读出当前版本号然后加锁的方法。具体过程是，比较当前版本号和上一版本号，如果版本号一致，则更新，否则重复进行读、比较、写操作。</p><p>Java中的乐观锁大部分是通过CAS算法实现的。</p><h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p>悲观锁，在每次读取数据时都认为别人会修改数据，所以每次在读写数据都会上锁，这样别人像读写这个数据就会阻塞、等待直到拿到锁。</p><p>Java中的悲观锁大部分是通过AQS架构实现的。许多同步类的实现都依赖于它，例如Synchronized、ReentrantLock、Semaphore、CountDownLatch。该框架下的锁先尝试以乐观锁去获取锁，如果获取不到，则会转为悲观锁。</p><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>自旋锁认为，如果持有锁的线程能够在很短时间内释放锁，那么等待竞争的锁线程不需要阻塞、挂起状态切换，只需要等一等（内旋），在持有锁的线程释放锁之后即可立即获得锁，这样减少了时间损耗。</p><p>线程自选时会占用CPU，所以需要设置一个自选等待的最大时间。</p><p>自旋锁的优缺点：</p><ul><li>优点：减少了CPU上下文的切换，对于占用锁的时间非常短或锁竞争不激烈的代码块来说，性能大幅提升。</li><li>缺点：线程如果在自旋过程中长时间获取不到锁资源，将会引起CPU的浪费。</li></ul><h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><p>可重入锁是指该锁支持一个线程对同一个资源多次加锁。Synchronized、ReentrantLock都是可重入锁。</p><h2 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h2><p>允许多个线程同时获取该锁，并发访问共享资源。ReentrantReadWriteLock中的读锁为共享锁的实现。</p><p>共享锁采用了乐观的加锁策略，允许多个执行读操作的线程同时访问共享资源。</p><h2 id="独占锁"><a href="#独占锁" class="headerlink" title="独占锁"></a>独占锁</h2><p>也叫互斥锁。每次只允许一个线程持有该锁。ReentrantLock为独占锁的实现。</p><p>独占锁是一种悲观的加锁策略。同一时刻只允许一个读线程读取锁资源，限制了读操作的并发性。</p><h2 id="重量级锁、轻量级锁和偏向锁"><a href="#重量级锁、轻量级锁和偏向锁" class="headerlink" title="重量级锁、轻量级锁和偏向锁"></a>重量级锁、轻量级锁和偏向锁</h2><p>以后再说。</p><h2 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h2><ul><li>公平锁指再分配锁之前检查是否有线程在排队等待获取锁，优先将锁分配给排队时间最长的线程。</li><li>非公平锁指在分配锁时不考虑线程排队的情况，直接尝试获取锁，在获取不到锁时在排到队尾等待。</li></ul><p>公平锁需要在多核的情况下维护一个锁线程等待队列，基于该队列进行锁的分配，因此效率比非公平锁低很多。</p><p>Java中的Synchronized、ReentrantLock默认lock方法都是非公平锁。</p><h2 id="读写锁：ReadWriteLock"><a href="#读写锁：ReadWriteLock" class="headerlink" title="读写锁：ReadWriteLock"></a>读写锁：ReadWriteLock</h2><p>Lock接口及对象加的锁是普通锁，这种锁不区分读写。为了提高性能，Java提供了读写锁。</p><p>读写锁分为读锁和写锁。多个读锁不互斥，读锁和写锁互斥。在没有写锁的情况下，读是无阻塞的。</p><p>一般做法是分别定义一个读锁和写锁。在Java中使用ReentrantReadWriteLock来完成对读写锁的定义和使用。</p><h2 id="分段锁"><a href="#分段锁" class="headerlink" title="分段锁"></a>分段锁</h2><p>分段锁是一种思想。用于将数据分段并在每个分段上都单独加锁，把锁进一步细粒度化，以提高并发效率。例如：ConcurrentHashMap</p><h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><ul><li>减少锁的持有时间</li><li>减少锁粒度</li><li>锁分离</li><li>锁粗化</li><li>锁消除</li></ul><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>不再赘述。</p><h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h2><p>不再赘述。</p><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>以后再说</p><h2 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h2><p>以后再说</p><h1 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h1><p>通过一个案例，来学习线程通信部分的知识。</p><p>假设系统有一个特殊的需求：系统要求存款者和取款者不断重复地存款取款，而且要求每当存款者将钱存入账户，取款者就立刻去除这笔钱，不允许连续两次存钱，也不允许连续两次取钱。</p><h2 id="传统的线程通信"><a href="#传统的线程通信" class="headerlink" title="传统的线程通信"></a>传统的线程通信</h2><p>为了实现上述功能，可以借助Object类提供的wait、notify、notifyAll方法。这三个方法不属于Thread，但是这三个方法必须由同步监视器对象来调用。</p><ul><li>对于synchronized修饰的同步方法，this就是同步监视器对象，所以可以直接在同步方法中直接调用这三个方法。</li><li>对于synchronized修饰的同步代码块，同步监视器是synchronized后括号里的对象，必须使用该对象调用这三个方法。</li></ul><p>下面介绍这三个方法：</p><ul><li>wait：导致当前线程等待，直到其他线程调用该同步监视器的notify或notifyAll来唤醒该线程。无参数的wait方法会一直等待，带时间参数的wait方法线程会在指定时间后自动苏醒。</li><li>notify：唤醒在此同步监视器上等待的单个线程。唤醒是任意的。只有当前线程放弃对该同步监视器的锁定后，才可以执行被唤醒的线程。</li><li>notifyAll：唤醒在此同步监视器上等待的所有线程。</li></ul><p>本程序为Account类提供了draw方法和deposit方法，分别对应账户的取钱和存钱操作。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String accountNo;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> balance; <span class="comment">//账户余额</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">//是否已有存款</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Account</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(String accountNo, <span class="type">double</span> balance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.accountNo = accountNo;</span><br><span class="line">        <span class="built_in">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//getter、setter</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAccountNo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> accountNo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    public void setBalance(double balance) &#123;</span></span><br><span class="line"><span class="comment">//        this.balance = balance;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//账户余额不允许修改，所以只为balance提供getter方法，</span></span><br><span class="line">    <span class="comment">//提供一线程安全的draw方法来完成取钱操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(<span class="type">double</span> drawAmount)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!flag) &#123; <span class="comment">//无存款，则取钱线程阻塞</span></span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;取钱：&quot;</span> + drawAmount);</span><br><span class="line">                balance -= drawAmount;</span><br><span class="line">                System.out.println(<span class="string">&quot;账户余额：&quot;</span>+ balance);</span><br><span class="line">                flag = <span class="literal">false</span>; <span class="comment">//存款标志设置为false</span></span><br><span class="line">                notifyAll(); <span class="comment">//唤醒其他线程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">deposit</span><span class="params">(<span class="type">double</span> depositAmount)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag) &#123; <span class="comment">//有存款，则存款线程阻塞</span></span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;存款：&quot;</span> + depositAmount);</span><br><span class="line">                balance += depositAmount;</span><br><span class="line">                System.out.println(<span class="string">&quot;账户余额：&quot;</span>+ balance);</span><br><span class="line">                flag = <span class="literal">true</span>; <span class="comment">//存款标志设置为false</span></span><br><span class="line">                notifyAll(); <span class="comment">//唤醒其他线程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略hashCode、equals</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来是取款者和存款者线程</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取款线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DrawThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="comment">//账户</span></span><br><span class="line">    <span class="keyword">private</span> Account account;</span><br><span class="line">    <span class="comment">//取得钱数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> drawAmount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DrawThread</span><span class="params">(String name, Account account, <span class="type">double</span> drawAmount)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.account = account;</span><br><span class="line">        <span class="built_in">this</span>.drawAmount = drawAmount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            account.draw(drawAmount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//存款线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DepositThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="comment">//账户</span></span><br><span class="line">    <span class="keyword">private</span> Account account;</span><br><span class="line">    <span class="comment">//取得钱数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> depositAmount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DepositThread</span><span class="params">(String name, Account account, <span class="type">double</span> depositAmount)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.account = account;</span><br><span class="line">        <span class="built_in">this</span>.depositAmount = depositAmount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            account.deposit(depositAmount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后是主程序：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//创建一个账户</span></span><br><span class="line">    <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>(<span class="string">&quot;0001&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//一个取款线程，两个存款线程</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">DrawThread</span>(<span class="string">&quot;取款者&quot;</span>, account, <span class="number">800</span>).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">DepositThread</span>(<span class="string">&quot;存款者1&quot;</span>, account, <span class="number">800</span>).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">DepositThread</span>(<span class="string">&quot;存款者2&quot;</span>, account, <span class="number">800</span>).start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主程序设置了一个取款者和两个存款者，最后线程会阻塞这是因为两个存款者会有200次存款操作，而一个取款者只有100次取款操作。运行程序可以发现，存取款线程交替执行。</p><h2 id="使用Condition控制线程通信"><a href="#使用Condition控制线程通信" class="headerlink" title="使用Condition控制线程通信"></a>使用Condition控制线程通信</h2><p>如果程序不使用synchronized关键字来保证同步，而是使用Lock对象来保证同步，则系统中不存在隐式的同步监视器，也就不能使用wait、notify、notifyAll方法进行通信了。</p><p>当使用Lock对象来保证同步时，Java提供了一个Condition类来保持协调，使用Condition可以让那些已经得到Lock对象却无法继续执行的线程释放Lock对象，Condition对象也可以唤醒其他处于等待的线程。</p><p>Condition实例被绑定在一个Lock对象上。要获得Lock实例的Condition实例，需要调用Lock都西昂的newCondition方法。Condition提供了如下三个方法</p><ul><li>await：类似于wait方法，导致线程等待，直到其他线程调用该Condition的signal、signalAll方法来唤醒该线程。</li><li>signal：唤醒此Lock对象上等待的单个线程。只有当前线程放弃对该Lock对象的锁定后，才可以执行被唤醒的进程。</li><li>signalAll：唤醒此Lock对象上等待的所有线程。</li></ul><p>根据上面改写Account类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(); <span class="comment">//定义Lock对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();<span class="comment">//获得指定的Condition</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String accountNo;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> balance; <span class="comment">//账户余额</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">//是否已有存款</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Account</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(String accountNo, <span class="type">double</span> balance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.accountNo = accountNo;</span><br><span class="line">        <span class="built_in">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//getter、setter</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAccountNo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> accountNo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    public void setBalance(double balance) &#123;</span></span><br><span class="line"><span class="comment">//        this.balance = balance;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//账户余额不允许修改，所以只为balance提供getter方法，</span></span><br><span class="line">    <span class="comment">//提供一线程安全的draw方法来完成取钱操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(<span class="type">double</span> drawAmount)</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!flag) &#123; <span class="comment">//无存款，则取钱线程阻塞</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;取钱：&quot;</span> + drawAmount);</span><br><span class="line">                balance -= drawAmount;</span><br><span class="line">                System.out.println(<span class="string">&quot;账户余额：&quot;</span>+ balance);</span><br><span class="line">                flag = <span class="literal">false</span>; <span class="comment">//存款标志设置为false</span></span><br><span class="line">                condition.signalAll(); <span class="comment">//唤醒其他线程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">deposit</span><span class="params">(<span class="type">double</span> depositAmount)</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag) &#123; <span class="comment">//有存款，则存款线程阻塞</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;存款：&quot;</span> + depositAmount);</span><br><span class="line">                balance += depositAmount;</span><br><span class="line">                System.out.println(<span class="string">&quot;账户余额：&quot;</span>+ balance);</span><br><span class="line">                flag = <span class="literal">true</span>; <span class="comment">//存款标志设置为false</span></span><br><span class="line">                condition.signalAll(); <span class="comment">//唤醒其他线程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//忽略hashCode、equals</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用阻塞队列控制线程通信"><a href="#使用阻塞队列控制线程通信" class="headerlink" title="使用阻塞队列控制线程通信"></a>使用阻塞队列控制线程通信</h2><p>Java5提供了一个BlockingQueue接口，它主要用作线程同步工具，而非容器。</p><p>BlockingQueue有一个特征：当生产者线程试图向BlockingQueue中放入元素时，如果该队列已满，则该线程被阻塞。当消费者线程试图从BlockingQueue取出元素时，如果该队列已空，则该线程被阻塞。</p><p>程序的两个线程通过交替向BlockingQueue放入取出元素，即可很好的控制线程的通信。</p><p>BlockingQueue包含的方法对应关系如图：</p><div class="table-container"><table><thead><tr><th></th><th>抛出异常</th><th>返回boolean</th><th>阻塞线程</th><th>指定超时市场</th></tr></thead><tbody><tr><td>队尾插入元素</td><td>add(e)</td><td>offer(e)</td><td>put(e)</td><td>offer(e, time, unit)</td></tr><tr><td>队头删除元素</td><td>remove()</td><td>poll()</td><td>take()</td><td>poll(time, unit)</td></tr><tr><td>获取、不删除元素</td><td>element()</td><td>peek()</td><td>无</td><td>无</td></tr></tbody></table></div><p>BlockingQueue与实现类之间类图如下：</p><p><img src="image-20210710181645057.png" alt="BlockingQueue 类图"></p><p>可以看到BlockingQueue的五个实现类</p><p>下面使用BlockingQueue来实现生产者消费者的线程通信。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockingQueueTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        BlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Producer</span>(<span class="string">&quot;产品A&quot;</span>, queue).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Producer</span>(<span class="string">&quot;产品B&quot;</span>, queue).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Consumer</span>(queue).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;String&gt; queue;</span><br><span class="line">    <span class="keyword">private</span> String productName ;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(String productName, BlockingQueue&lt;String&gt; queue)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.productName = productName;</span><br><span class="line">        <span class="built_in">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(productName + i); <span class="comment">//尝试放入元素，如果队列满，则阻塞</span></span><br><span class="line">                System.out.println(getName() + <span class="string">&quot;生产完成：&quot;</span> + queue);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;String&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(BlockingQueue&lt;String&gt; queue)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(getName() + <span class="string">&quot;消费元素：&quot;</span> + queue.take());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>该程序不符合预期，原因不明。</strong></p><p><img src="image-20210710190620858.png" alt="阻塞队列 运行结果"></p><h1 id="多线程共享数据"><a href="#多线程共享数据" class="headerlink" title="多线程共享数据"></a>多线程共享数据</h1><h2 id="将数据抽象成一个类，并将这个数据的操作封装到这个类中"><a href="#将数据抽象成一个类，并将这个数据的操作封装到这个类中" class="headerlink" title="将数据抽象成一个类，并将这个数据的操作封装到这个类中"></a>将数据抽象成一个类，并将这个数据的操作封装到这个类中</h2><h2 id="将Runnable对象作为一个类的内部类，将共享数据作为这个类的成员变量"><a href="#将Runnable对象作为一个类的内部类，将共享数据作为这个类的成员变量" class="headerlink" title="将Runnable对象作为一个类的内部类，将共享数据作为这个类的成员变量"></a>将Runnable对象作为一个类的内部类，将共享数据作为这个类的成员变量</h2><h1 id="线程组和未处理的异常"><a href="#线程组和未处理的异常" class="headerlink" title="线程组和未处理的异常"></a>线程组和未处理的异常</h1><h2 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h2><p>Java使用ThreadGroup来表示线程组，Java允许程序对线程组进行控制。用户创建的所有线程都属于指定线程组。如果程序没有显式指定线程属于哪个线程组，则该线程属于默认线程组。默认情况下， 子线程和创建它的父线程处于同一个线程组。</p><p>线程运行中途不能改变它所属的线程组。</p><p>下面是Thread类提供的构造器来设置线程属于哪个线程组：</p><ul><li>Thread(ThreadGroup group, Runnable target)：以target的run方法作为线程执行体创建新线程，属于group线程组。</li><li>Thread(ThreadGroup group, Runnable target, String name)</li><li>Thread(ThreadGroup group, String name)</li></ul><p>Thread提供了一个getThreadGroup方法来返回线程所属的线程组。</p><p>ThreadGroup提供了两个构造器来创建实例。</p><ul><li>ThreadGroup(String name)</li><li>ThreadGroup(ThreadGroup parent, String name)：以指定名字、指定父线程组创建一个新线程组。</li></ul><p>其中name参数是指定线程组的名字，线程组的名字可以通过getName方法得到，但是不能修改。</p><p>ThreadGroup的常用方法：</p><ul><li>int activeCount()</li><li>void isDaemon()</li><li>void interrupt()</li><li>void setDaemon(boolean daemon)</li><li>void setMaxPriority(int pri)</li></ul><p>ThreadGroup内定义了一个很有用的方法：<code>void uncaughtException(Thread t, Throwable e)</code>，该方法可以处理该线程组内的任意线程所抛出的未处理异常。</p><h2 id="线程异常"><a href="#线程异常" class="headerlink" title="线程异常"></a>线程异常</h2><p>Java5之后，如果线程执行过程中抛出了一个未处理的异常，JVM在结束之前会自动查找是否有对应的Thread.UncaughtExceptionHandler对象，如果有，则会调用该对象的<code>uncaughtException(Thread t, Throwable e)</code>来处理异常。</p><p>Thread类提供了两个方法来设置异常处理器：</p><ul><li>setUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh)：为指定线程实例设置默认的异常处理器</li><li>static setDefaultUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh)：为该线程类的所有实例设置默认的异常处理器。</li></ul><p>ThreadGroup类实现了Thread.UncaughtExceptionHandler接口。</p><p>所以线程处理异常的流程如下：</p><ol><li>如果线程设置了异常处理器，则调用该异常处理器处理异常</li><li>查找线程是否属于线程组：<ol><li>如果所属线程组有父线程组，则调用父线程组的uncaughtException方法</li><li>如果该线程组有异常处理器，则使用该异常处理器处理异常。</li></ol></li></ol><p>注意：当使用catch捕获异常时，异常不会向上传播给上一级调用者；但使用异常处理器对异常进行处理后，异常依然会传播给上一级调用者。</p><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>当程序需要创建大量生存期很短暂的线程时，更应该考虑使用线程池。</p><p>线程池在系统启动时即创建大量空闲线程，程序将一个Runnable/Callable对象传给线程池，线程池就会启动一个空闲线程来执行run/call方法，方法执行完毕后，线程不会死亡而是返回线程池成为空闲状态。</p><p>线程池的主要作用是线程复用，线程资源管理，控制操作系统的最大并发数，以保证系统高效（通过线程资源复用实现）且安全（通过控制最大线程并发数实现）的运行。</p><h2 id="线程池的核心组件和核心类"><a href="#线程池的核心组件和核心类" class="headerlink" title="线程池的核心组件和核心类"></a>线程池的核心组件和核心类</h2><p>Java线程池主要由4个核心组件组成。</p><ul><li>线程池管理器：用于创建并管理线程</li><li>工作线程：线程池中执行具体任务的线程。</li><li>任务接口：用于定义工作线程的调度和执行策略，只有线程实现了该接口，线程中的任务才能够被线程池调度。</li><li>任务队列：存放待处理的任务，新的任务将会不断被加入队列中，执行完成的任务将被从队列中移除。</li></ul><p>Java线程池用到了Executor、Executors、ExecutorService、ThreadPoolExecutor、Callable、Future、FutureTask这几个核心类，具体继承关系如下：</p><p><img src="image-20210803000256474.png" alt="线程池核心类 类图"></p><p>ThreadPoolExecutor是构建线程池的核心实现。</p><h2 id="使用Executors管理线程"><a href="#使用Executors管理线程" class="headerlink" title="使用Executors管理线程"></a>使用Executors管理线程</h2><p>Java5以前，开发者必须实现自己的线程池，从Java5开始，新增了一个Executors工厂类来产生线程池。它包含如下静态工厂方法：</p><ul><li>ExecutorService newCachedThreadPool()：创建一个具有缓存功能的线程池</li><li>ExecutorService newFixedThreadPool(int nThreads)：创建一个可重用的、具有固定线程数的线程池</li><li>ExecutorService newSingleThreadExecutor()：创建一个只有单线程的线程池，相当于newFixedThreadPool(1)</li><li>ScheduledExecutorService newScheduledThreadPool(int corePoolSize)：创建具有指定线程数的线程池。参数指出池中所保存的线程数。</li><li>ScheduledExecutorService newSingleThreadScheduledExecutor()：创建只有一个现成的线程池</li><li>ExecutorService newWorkStealingPool(int parallelism)：创建持有足够的线程的线程池来支持给定的并行级别</li><li>ExecutorService newWorkStealingPool()：相当于前一个方法的简化版本，假设当前机器有4个CPU，则相当于前一个方法传入4</li></ul><p>前面介绍的方法中返回值类型中ExecutorService代表线程池，它可以执行Runnable/Callable所代表的线程；ScheduledExecutorService 是ExecutorService的子类，它可以在指定延迟后执行线程任务。</p><p>最后两个方法是J8新增，他们成分利用了多CPU的并行能力，这两个方法创建的相当于后台线程池。</p><p>ExecutorService代表尽快执行线程的线程池：</p><ul><li><code>Future&lt;?&gt; submit(Runnable task)</code>：将一个Runnable对象提交给线程池，线程池将在有空闲线程时执行Runnable对象代表的任务。其中Future对象代表Runnable的返回值，但是run方法没有返回值，所以Future对象将在run方法执行结束后返回null</li><li><code>&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result)</code>：同上一个方法类似，但本方法将在run方法结束后返回result</li><li><code>&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)</code></li></ul><p>ScheduledExecutorService 代表在指定延迟后或周期性的执行线程任务，它提供了四个主要方法：</p><ul><li><code>&lt;V&gt; ScheduledFuture&lt;V&gt; schedule(Callable&lt;V&gt; callable, long delay, TimeUnit unit)</code>：</li><li><code>ScheduledFuture&lt;?&gt; schedule(Runnable command, long delay, TimeUnit unit)</code></li><li><code>ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)</code>：可设定频率重复执行线程任务</li><li><code>ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)</code>：每一次执行终止和下一次执行开始之间都存在一个给定的延迟。</li></ul><p>当用完一个线程池后，应该调用该线程池的shutdown方法，调用shutdown方法后，线程池不再接受新的任务，但会将以前所有已提交任务执行完成。</p><p>使用线程池执行线程任务的步骤如下：</p><ol><li>调用Executors类的静态工厂方法创建一个线程池</li><li>创建Runnable/Callable实例</li><li>调用submit方法提交Runnable/Callable实例</li><li>调用线程池的shutdown方法关闭线程池。</li></ol><p>举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个固定线程处的线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">6</span>);</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;的i值为：&quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//向线程池提交两个线程</span></span><br><span class="line">        pool.submit(target);</span><br><span class="line">        pool.submit(target);</span><br><span class="line"></span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用ForkJoinPool利用多CPU"><a href="#使用ForkJoinPool利用多CPU" class="headerlink" title="使用ForkJoinPool利用多CPU"></a>使用ForkJoinPool利用多CPU</h2><p>Java7提供了ForkJoinPool来支持多CPU计算。ForkJoinPool是ExecutorService的实现类，因此是一个特殊的线程池。</p><p>ForkJoinPool有两个构造器：</p><ul><li>ForkJoinPool(int parallelism)：创建一个包含parallelism个并行线程的ForkJoinPool</li><li>ForkJoinPool()：以Runtime.availableProcessors方法的返回值作为parallelism参数创建ForkJoinPool</li></ul><p>J8进一步扩展了ForkJoinPool的功能。J8通过提供如下两个静态方法为ForkJoinPool增加了通用池功能。</p><ul><li>ForkJoinPool commonPool()：该方法返回一个通用池，通用池不会受到shutdown或shutdownNow方法的影响。</li><li>int getCommonPoolParallelism：该方法返回通用池的并行级别。</li></ul><p>在创建ForkJoinPool实例之后就可以调用它的submit(ForkJoinTask<T> task)方法来执行指定任务。ForkJoinTask是一个抽象类，他代表一个可并行、合并的任务。他有两个抽象子类。RecursiveAction和RecursiveTask。RecursiveAction代表无返回值的任务，RecursiveTask代表有返回值的任务。</p><p>举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForkJoinPoolTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">ForkJoinPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100</span>];</span><br><span class="line">        <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> rand.nextInt(<span class="number">20</span>);</span><br><span class="line">            total += (arr[i] = tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;单线程累加的结果为：&quot;</span> + total);</span><br><span class="line"></span><br><span class="line">        Future&lt;Integer&gt; future = pool.submit(<span class="keyword">new</span> <span class="title class_">CalTask</span>(arr, <span class="number">0</span>, arr.length));</span><br><span class="line">        System.out.println(<span class="string">&quot;并行CPU累加的结果为：&quot;</span> + future.get());</span><br><span class="line"></span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CalTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THRESHOLD</span> <span class="operator">=</span> <span class="number">20</span>; <span class="comment">//每个小人物最多累加20个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CalTask</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.arr = arr;</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(end - start &lt; THRESHOLD) &#123; <span class="comment">//当数组数量小于THRESHOLD时开始累加</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; end; i++) &#123;</span><br><span class="line">                sum += arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (start + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//分解成子任务</span></span><br><span class="line">            <span class="type">CalTask</span> <span class="variable">left</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CalTask</span>(arr, start, mid);</span><br><span class="line">            <span class="type">CalTask</span> <span class="variable">right</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CalTask</span>(arr, mid, end);</span><br><span class="line">            left.fork();<span class="comment">//执行任务</span></span><br><span class="line">            right.fork();</span><br><span class="line">            <span class="keyword">return</span> left.join() + right.join(); <span class="comment">//返回结果</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="*ThreadPoolExecutor"></a>*ThreadPoolExecutor</h2><p>Java提供了Excutors工具类，适用于小项目，对于一些大型程序还是需要自己创建ThreadPoolExecutor类。这样做的好处有：</p><ul><li>使用ThreadPoolExecutor更加明确线程池的运行规则，规避资源耗尽的风险。</li><li>Excutors的newFixedThreadPool和newSingleThreadExecutor的主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至OOM；Excutors的newCachedThreadPool和newScheduledThreadPool主要问题是线程最大数为Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至OOM。</li></ul><p>ThreadPoolExecutor是构建线程池的核心实现，定义如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                              TimeUnit unit,</span></span><br><span class="line"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                              ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                              RejectedExecutionHandler handler)</span> &#123;</span><br><span class="line">    <span class="comment">//code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体参数如表格：</p><div class="table-container"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>corePoolSize</td><td>线程池中核心线程的数量</td></tr><tr><td>maximumPoolSize</td><td>线程池中最大线程数量</td></tr><tr><td>keepAliveTime</td><td>当前线程数量超过corePoolSize时，空闲线程的存活时间</td></tr><tr><td>unit</td><td>keepAliveTime的时间单位</td></tr><tr><td>workQueue</td><td>任务队列，被提交但尚未被执行的任务存放的地方</td></tr><tr><td>threadFactory</td><td>线程工厂，用于创建线程，可使用默认的线程工厂或自定义</td></tr><tr><td>handler</td><td>由于任务过多或其他原因导致线程池无法处理时的任务拒绝策略</td></tr></tbody></table></div><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>通过调用ThreadPoolExecutor的构造方法来创建一个线程池。线程池刚被创建时，只是向系统申请一个用于执行线程队列和管理线程池的线程资源。在添加一个任务时，当前现有线程数（设为n）：</p><ol><li>n&lt;corePoolSize，线程池就会立刻创建线程并执行该线程任务。</li><li>n&gt;=corePoolSize，该任务就会进入阻塞队列。</li><li>如果队列已满，且n&lt;maximumPoolSize时，线程池会创建非核心线程立刻执行该线程任务。</li><li>如果队列已满，且n&gt;=maximumPoolSize时，线程池将拒绝执行该线程任务并抛出RejectExecutionException异常。</li><li>线程任务执行完毕，该任务将从线程池队列中移除，线程池将从队列中取出下一个线程任务继续执行。</li><li>在线程处于空闲状态的实践超过keepAliveTime时，正在运行的线程数量超过corePoolSize，该线程将被认定为空闲线程并停止。因此，在线程池中所有线程任务都执行完毕，线程池会收缩到corePoolSize大小。</li></ol><h3 id="入队策略"><a href="#入队策略" class="headerlink" title="入队策略"></a>入队策略</h3><ol><li>直接传递：SynchronousQueue（待补充）</li><li>无界队列：使用无界队列（LinkedBlockingQueue）作为等待队列，当所有核心线程都在处理任务时，新提交的任务都会进入等待队列。此时maximumPoolSize将失去作用。</li><li>有界队列：有界队列（ArrayBlockingQueue）可以防止资源耗尽，但是难以调整和控制。队列大小和线程池大小可以相互作用，使用大队列和小线程数可以减少CPU使用率、系统资源和上下文切换的开销，但是会导致吞吐量变低，如果任务频繁阻塞，系统就能为更多的线程调度执行时间。使用小队列通常需要更多的线程数，这样可以最大化CPU使用率。但可能会需要更大的调度开销，从而降低吞吐量。</li></ol><h3 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h3><p>JDK内置的拒绝策略有AbortPolicy、CallerRunsPolicy、DiscardOldestPolicy、DiscardPolicy这四种。</p><ul><li>AbortPolicy：默认策略，抛出RejectExecutionException异常</li><li>CallerRunsPolicy：在execute方法的调用线程中运行被拒绝的任务，如果线程已关闭，任务将被丢弃。</li><li>DiscardOldestPolicy：丢弃队列中等待时间最长的任务并执行当前提交的任务。</li><li>DiscardPolicy：直接丢弃任务。</li><li>自定义拒绝策略需要实现RejectedExecutionHandler接口，实现<code>rejectedExecution(Runnable r, ThreadPoolExecutor executor)</code>方法。</li></ul><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">corePoolSize</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maximumPoolSize</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">keepAliveTime</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="type">TimeUnit</span> <span class="variable">unit</span> <span class="operator">=</span> TimeUnit.SECONDS;</span><br><span class="line">    BlockingQueue&lt;Runnable&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">    <span class="type">ThreadPoolExecutor</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    pool = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, queue);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> i+<span class="number">1</span>;</span><br><span class="line">        pool.submit(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我是线程&quot;</span> + index);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//每个任务提交后休眠500ms在执行下一个任务，用于保证提交顺序。</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pool.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是运行结果。</p><p><img src="image-20210730173914926.png" alt="拒绝策略 运行截图"></p><p>对该运行结果进行分析：</p><ol><li>由于corePoolSize设置的为3，所以任务1、2、3正常提交且开始执行。</li><li>提交任务4，5时，任务123还在运行，所以任务4，5进入到阻塞队列。</li><li>提交任务6，7，8时，正在运行的任务等于corePoolSize且小于maximumPoolSize，阻塞队列满，所以会立即创建非核心线程执行任务678</li><li>当任务1执行完毕后，取出队列中的任务4开始执行。</li><li>当任务2执行完毕后，取出队列中的任务5开始执行。</li></ol><p>为了演示默认的拒绝策略，将上述案例增加一个线程。结果如图</p><p><img src="image-20210730174640219.png" alt="拒绝策略 截图"></p><h1 id="线程相关类"><a href="#线程相关类" class="headerlink" title="线程相关类"></a>线程相关类</h1><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>ThreadLocal是Therad的局部变量的维护类，在Java中是作为一个特殊的变量存储在。当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。</p><p>因为每个Thread内有自己的实例副本，且该副本只能由当前Thread使用，也就不存在多线程间共享的问题。</p><p>总的来说，ThreadLocal适用于每个线程需要自己独立的实例且该实例需要在多个方法中被使用，也即变量在线程间隔离而在方法或类间共享的场景。</p><p>比如，有一个变量count，在多线程并发时操作count++会出现线程安全问题。但是通过ThreadLocal就可以为每个线程创建只属于当前线程的count副本，各自操作各自的副本，不会影响到其他线程。</p><p>使用示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; HOLDER = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ThreadLocalTest</span>().execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        HOLDER.set(<span class="string">&quot;main&quot;</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程ThreadLocal中的值：&quot;</span> + HOLDER.get());</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程ThreadLocal中的值：&quot;</span> + HOLDER.get());</span><br><span class="line">            HOLDER.set(<span class="string">&quot;thread&quot;</span>); <span class="comment">//设置当前线程的值</span></span><br><span class="line">            System.out.println(<span class="string">&quot;重新设置后，&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;线程ThreadLocal中的值：&quot;</span> + HOLDER.get());</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程执行结束&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程ThreadLocal中的值：&quot;</span> + HOLDER.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行程序，打印结果如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main线程ThreadLocal中的值：程序新视界</span><br><span class="line">Thread-0线程ThreadLocal中的值：null</span><br><span class="line">重新设置之后，Thread-0线程ThreadLocal中的值：《程序新视界》</span><br><span class="line">Thread-0线程执行结束</span><br><span class="line">main线程ThreadLocal中的值：程序新视界</span><br></pre></td></tr></table></figure><p>对照程序和输出结果，你会发现，主线程和Thread-0各自独享自己的变量存储。主线程并没有因为Thread-0调用了HOLDER的set方法而被改变。</p><p>之所以能达到这个效果，正是因为在ThreadLocal中，每个线程Thread拥有一份自己的副本变量，多个线程互不干扰。</p><p>ThreadLocal和其他同步机制一样，都是为了解决多线程对同一变量的访问冲突。在普通的同步机制中，试图用过对对象枷锁来实现多个线程对同一变量的安全访问的。ThreadLocal从另一个角度来解决多线程并发访问，ThreadLocal将需要并发访问的资源复制多分，每个线程拥有一份资源，从而就没有必要再对该变量进行同步了。在编写多线程代码时，可以把不安全的整个变量封装进ThreadLocal，或者把该对象与线程相关的状态使用ThreadLocal保存。</p><p>ThreadLocal不能代替同步机制，两者面向的领域不同。同步机制是为了同步多个线程对相同资源的并发访问，是多个线程之间通信的有效方式；而ThreadLocal是为了隔离多个线程的数据共享，从根本上避免了多个线程对共享资源的竞争。</p><p><em>参考资料：<a href="https://zhuanlan.zhihu.com/p/368293603">https://zhuanlan.zhihu.com/p/368293603</a></em></p><h2 id="包装线程不安全集合"><a href="#包装线程不安全集合" class="headerlink" title="包装线程不安全集合"></a>包装线程不安全集合</h2><p>在Java集合中所讲的ArrayList、LinkedList、HashSet、TreeSet、HashMap、TreeMap都是线程不安全的。Collections提供的类方法可以把这些集合包装成线程安全的集合。</p><ul><li>static <T> Collection<T> synchronizedCollection(Collection<T> c)</li><li>static <T> List<T> synchronizedList(List<T> list)</li><li>static <K,V> Map<K,V> synchronizedMap(Map<K,V> m)</li><li>static <T> Set<T> synchronizedSet(Set<T> s)</li><li>static <K,V> SortedMap<K,V> synchronizedSortedMap(SortedMap<K,V> m)</li><li>static <T> SortedSet<T> synchronizedSortedSet(SortedSet<T> s)</li></ul><p>例如需要使用线程安全的HashMap对象，则采用下面的代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = Collections.synchronizedMap(<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;()); <span class="comment">//在创建后立即包装</span></span><br></pre></td></tr></table></figure><h2 id="线程安全集合类"><a href="#线程安全集合类" class="headerlink" title="线程安全集合类"></a>线程安全集合类</h2><p><img src="image-20210711190905713.png" alt="线程安全的集合类"></p><p>线程安全的集合类可以分为两种：</p><ul><li>以Concurrent开头的集合类：代表了支持并发访问的集合，对这种集合的写入操作都是线程安全的，但读取操作不必锁定。</li><li>以CopyOnWrite开头的集合类：采用了更复杂的算法（复制底层数组的方式实现写操作）来保证永远不会锁住集合，因此并发写入时有较好的性能。</li></ul><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><ul><li>默认支持16个线程并发写入，可以通过设置构造参数来支持更多的并发。</li><li>J8扩展了ConcurrentHashMap的功能，新增的方法分为如下三类<ul><li>forEach</li><li>search</li><li>reduce</li></ul></li></ul><h2 id="J9新增的发布-订阅框架"><a href="#J9新增的发布-订阅框架" class="headerlink" title="J9新增的发布-订阅框架"></a>J9新增的发布-订阅框架</h2><p>略</p><h1 id="Java并发关键字"><a href="#Java并发关键字" class="headerlink" title="Java并发关键字"></a>Java并发关键字</h1><h2 id="CountDownLacth"><a href="#CountDownLacth" class="headerlink" title="CountDownLacth"></a>CountDownLacth</h2><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><h2 id="Semaphore-1"><a href="#Semaphore-1" class="headerlink" title="Semaphore"></a>Semaphore</h2><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><h1 id="补充：进程调度算法"><a href="#补充：进程调度算法" class="headerlink" title="补充：进程调度算法"></a>补充：进程调度算法</h1><h2 id="优先调度算法"><a href="#优先调度算法" class="headerlink" title="优先调度算法"></a>优先调度算法</h2><h2 id="高优先权优先调度算法"><a href="#高优先权优先调度算法" class="headerlink" title="高优先权优先调度算法"></a>高优先权优先调度算法</h2><h2 id="时间片的轮转调度算法"><a href="#时间片的轮转调度算法" class="headerlink" title="时间片的轮转调度算法"></a>时间片的轮转调度算法</h2><h1 id="补充：CAS、ABA、AQS"><a href="#补充：CAS、ABA、AQS" class="headerlink" title="补充：CAS、ABA、AQS"></a>补充：CAS、ABA、AQS</h1><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>《疯狂Java讲义》 多线程篇</li><li><a href="https://mp.weixin.qq.com/s/F8PbZ5PnwGNI4jRiylCRpQ">为什么阿里不允许用Executors创建线程池，而是通过ThreadPoolExecutor的方式？</a></li><li>《Offer 来了 Java面试核心知识点讲解 原理篇》 多线程</li><li><a href="https://zhuanlan.zhihu.com/p/368293603">ThreadLocal全攻略：使用实战，源码分析，内存泄露分析</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本篇博客叙述Java多线程的基本知识和基本操作。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;待补充的部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[ ] </summary>
      
    
    
    
    <category term="Java" scheme="https://gmet233.gitee.io/categories/Java/"/>
    
    <category term="多线程" scheme="https://gmet233.gitee.io/categories/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="https://gmet233.gitee.io/tags/Java/"/>
    
    <category term="多线程" scheme="https://gmet233.gitee.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
</feed>
