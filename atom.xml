<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Gmet&#39;s Blog</title>
  
  <subtitle>Eureka!</subtitle>
  <link href="https://gmet233.gitee.io/atom.xml" rel="self"/>
  
  <link href="https://gmet233.gitee.io/"/>
  <updated>2022-01-10T11:20:24.973Z</updated>
  <id>https://gmet233.gitee.io/</id>
  
  <author>
    <name>Met Guo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《动手学深度学习》读书笔记（一） 前言</title>
    <link href="https://gmet233.gitee.io/2022/01/10/%E3%80%8A%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89-%E5%89%8D%E8%A8%80/"/>
    <id>https://gmet233.gitee.io/2022/01/10/%E3%80%8A%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89-%E5%89%8D%E8%A8%80/</id>
    <published>2022-01-10T10:00:11.000Z</published>
    <updated>2022-01-10T11:20:24.973Z</updated>
    
    <content type="html"><![CDATA[<p><em>本博客记录阅读《动手学深度学习》的读书笔记。</em></p><blockquote><p>原文地址：<a href="http://zh-v2.d2l.ai/chapter_introduction/index.html">http://zh-v2.d2l.ai/chapter_introduction/index.html</a></p></blockquote><h1 id="日常生活中的机器学习"><a href="#日常生活中的机器学习" class="headerlink" title="日常生活中的机器学习"></a>日常生活中的机器学习</h1><p>我们可以把<strong>参数</strong>看作旋钮，我们可以转动旋钮来调整程序的行为。</p><p>任一调整参数后的程序，我们称为<strong>模型</strong>（model）。</p><p>通过操作参数而生成的所有不同程序（输入-输出映射）的集合称为“<strong>模型族</strong>”。</p><p>使用数据集来选择参数的元程序被称为<strong>学习算法</strong>（learning algorithm）。</p><p>在我们开始用机器学习算法解决问题之前，我们必须精确地定义问题，确定<strong>输入（input）和输出（output）</strong>的性质，并选择合适的模型族。</p><p>在机器学习中，<strong>学习</strong>（learning）是一个训练模型的过程。 通过这个过程，我们可以发现正确的参数集，从而使模型强制执行所需的行为。 换句话说，我们用数据<strong>训练</strong>（train）我们的模型。 </p><p>训练过程通常包含如下步骤：</p><ol><li>从一个随机初始化参数的模型开始，这个模型基本毫不“智能”。</li><li>获取一些数据样本（例如，音频片段以及对应的{是,否}标签）。</li><li>调整参数，使模型在这些样本中表现得更好。</li><li>重复第2步和第3步，直到模型在任务中的表现令你满意。</li></ol><p><img src="ml-loop.png" alt="典型的训练过程"></p><h1 id="关键组件"><a href="#关键组件" class="headerlink" title="关键组件"></a>关键组件</h1><p>无论我们遇到什么类型的机器学习问题，这些组件都将伴随我们左右：</p><ol><li>我们可以学习的<strong>数据</strong>（data）。</li><li>如何转换数据的<strong>模型</strong>（model）。</li><li>一个<strong>目标函数</strong>（objective function），用来量化模型的有效性。</li><li>调整模型参数以优化目标函数的<strong>算法</strong>（algorithm）。</li></ol><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p>每个数据集由一个个<strong>样本</strong>（example, sample）组成，大多时候，它们遵循独立同分布(independently and identically distributed, i.i.d.)。 样本有时也叫做<strong>数据点</strong>（data point）或者<strong>数据实例</strong>（data instance），通常每个样本由一组称为<strong>特征</strong>（features，或<strong>协变量</strong>（covariates））的属性组成。 机器学习模型会根据这些属性进行预测。 </p><p><strong>标签</strong>：预测的一个特殊属性，例如是/否，猫/狗等。</p><p>当每个样本的特征类别数量都是相同的时候，其特征向量是固定长度的，这个长度被称为数据的维数（dimensionality）。 固定长度的特征向量是一个方便的属性，它有助于我们量化学习大量样本。</p><p>然而，并不是所有的数据都可以用“固定长度”的向量表示。例如不同的图片大小，文本长度。与传统机器学习方法相比，深度学习的一个主要优势是可以处理不同长度的数据。</p><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><h2 id="目标函数"><a href="#目标函数" class="headerlink" title="目标函数"></a>目标函数</h2><p>在机器学习中，我们需要定义模型的优劣程度的度量，这个度量在大多数情况是“可优化”的，我们称之为<strong>目标函数</strong>（objective function）。 我们通常定义一个目标函数，并希望优化它到最低点。 因为越低越好，所以这些函数有时被称为<strong>损失函数</strong>（loss function，或cost function）。</p><p>当任务在试图预测数值时，最常见的损失函数是<strong>平方误差</strong>（squared error），即预测值与实际值之差的平方。 当试图解决分类问题时，最常见的目标函数是最小化错误率，即预测与实际情况不符的样本比例。 有些目标函数（如平方误差）很容易被优化，有些目标（如错误率）由于不可微性或其他复杂性难以直接优化。 在这些情况下，通常会优化替代目标。</p><p> 在一个数据集上，我们通过最小化总损失来学习模型参数的最佳值。 该数据集由一些为训练而收集的样本组成，称为<strong>训练数据集</strong>（training dataset，或称为训练集（training set））。 然而，在训练数据上表现良好的模型，并不一定在“新数据集”上有同样的效能，这里的“新数据集”通常称为测试数据集（test dataset，或称为<strong>测试集</strong>（test set））。</p><p>综上所述，我们通常将可用数据集分成两部分：<strong>训练数据集用于拟合模型参数，测试数据集用于评估拟合的模型。</strong> 然后我们观察模型在这两部分数据集的效能。 你可以把“一个模型在训练数据集上的效能”想象成“一个学生在模拟考试中的分数”。 这个分数用来为一些真正的期末考试做参考，即使成绩令人鼓舞，也不能保证期末考试成功。 换言之，测试性能可能会显著偏离训练性能。 当一个模型在训练集上表现良好，但不能推广到测试集时，我们说这个模型是“<strong>过拟合</strong>”（overfitting）的。</p><h2 id="优化算法"><a href="#优化算法" class="headerlink" title="优化算法"></a>优化算法</h2><p>一旦我们获得了一些数据源及其表示、一个模型和一个合适的损失函数，我们接下来就需要一种算法，它能够搜索出最佳参数，以最小化损失函数。 深度学习中，大多流行的优化算法通常基于一种基本方法–<strong>梯度下降</strong>（gradient descent）。 简而言之，在每个步骤中，梯度下降法都会检查每个参数，看看如果你仅对该参数进行少量变动，训练集损失会朝哪个方向移动。 然后，它在可以减少损失的方向上优化参数。</p><h1 id="各种机器学习问题"><a href="#各种机器学习问题" class="headerlink" title="各种机器学习问题"></a>各种机器学习问题</h1><h2 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h2><p>监督学习（supervised learning）擅长在“<strong>给定输入特征</strong>”的情况下预测标签。</p><p>监督学习举例：根据计算机断层扫描（CT）肿瘤图像，预测是否为癌症；根据本月的财务报告数据，预测下个月股票的价格。</p><p>在工业中，大部分机器学习的成功应用都是监督学习。 这是因为在一定程度上，许多重要的任务可以清晰地描述为：在给定一组特定的可用数据的情况下，估计未知事物的概率。</p><p><img src="supervised-learning.png" alt="监督学习"></p><h3 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h3><p>回归（regression）是最简单的监督学习任务之一。</p><p>当标签取任意数值时，我们称之为回归问题。 我们的目标是生成一个模型，它的预测非常接近实际标签值。</p><p>回归问题举例：预测房价；预测用户对一部电影的评分。</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>二分类，多分类。</p><p>分类可能变得比二元分类、多元分类复杂得多。 例如，有一些分类任务的变体可以用于寻找层次结构，层次结构假定在许多类之间存在某种关系。因此，并不是所有的错误都是均等的。 我们宁愿错误地分入一个相关的类别，也不愿错误地分入一个遥远的类别，这通常被称为<strong>层次分类</strong>(hierarchical classification)。</p><h3 id="标记问题"><a href="#标记问题" class="headerlink" title="标记问题"></a>标记问题</h3><p>学习预测不相互排斥的类别的问题称为<strong>多标签分类</strong>（multi-label classification）。</p><p> 举个例子，人们在技术博客上贴的标签，比如“机器学习”、“技术”、“小工具”、“编程语言”、“Linux”、“云计算”。 一篇典型的文章可能会用5-10个标签，因为这些概念是相互关联的。</p><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>在信息检索领域，我们希望对一组项目进行排序。 以网络搜索为例，我们的目标不是简单的“查询（query）-网页（page）”分类，而是在海量搜索结果中找到用户最需要的那部分。</p><h3 id="推荐系统"><a href="#推荐系统" class="headerlink" title="推荐系统"></a>推荐系统</h3><h3 id="序列学习"><a href="#序列学习" class="headerlink" title="序列学习"></a>序列学习</h3><p>有些时候，输入是连续的。我们的模型可能就需要拥有“记忆”功能。</p><p>比如文字序列，图像序列（视频）</p><p>以下是序列学习的特殊情况：</p><ul><li><strong>标记和解析</strong></li><li><strong>语音识别</strong></li><li><strong>文本到语音</strong></li><li><strong>机器翻译</strong></li></ul><h2 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h2><p> 比如，你的老板可能会给你一大堆数据，然后让你用它做一些数据科学研究，却没有对结果有要求。 我们称这类数据中不含有“目标”的机器学习问题为<strong>无监督学习</strong>（unsupervised learning）</p><p>以下列举了集中无监督学习：</p><ul><li><strong>聚类</strong>（clustering）问题：没有标签的情况下，我们是否能给数据分类</li><li><strong>主成分分析</strong>（principal component analysis）问题：我们能否找到少量的参数来准确地捕捉数据的线性相关属性？比如，一个球的运动轨迹可以用球的速度、直径和质量来描述。</li><li><strong>因果关系</strong>（causality）和概率图模型（probabilistic graphical models）问题：我们能否描述观察到的许多数据的根本原因？</li><li><strong>生成对抗性网络</strong>（generative adversarial networks）：为我们提供一种合成数据的方法，甚至像图像和音频这样复杂的结构化数据。</li></ul><h3 id="与环境互动"><a href="#与环境互动" class="headerlink" title="与环境互动"></a>与环境互动</h3><p>到目前为止，不管是监督学习还是无监督学习，我们都会预先获取大量数据，然后启动模型，不再与环境交互。 这里所有学习都是在算法与环境断开后进行的，被称为<strong>离线学习</strong>（offline learning）。</p><p>这种简单的离线学习有它的魅力。 好的一面是，我们可以孤立地进行模式识别，而不必分心于其他问题。 但缺点是，解决的问题相当有限。 与预测不同，“与真实环境互动”实际上会影响环境。 这里的人工智能是“智能代理”，而不仅是“预测模型”。 因此，我们必须考虑到它的行为可能会影响未来的观察结果。</p><p>考虑“与真实环境互动”将打开一整套新的建模问题。以下只是几个例子：</p><ul><li>环境还记得我们以前做过什么吗？</li><li>环境是否有助于我们建模？例如，用户将文本读入语音识别器。</li><li>环境是否想要打败模型？例如，一个对抗性的设置，如垃圾邮件过滤或玩游戏？</li><li>环境是否重要？</li><li>环境是否变化？例如，未来的数据是否总是与过去相似，还是随着时间的推移会发生变化？是自然变化还是响应我们的自动化工具而发生变化？</li></ul><p>当训练和测试数据不同时，最后一个问题提出了<strong>分布偏移</strong>（distribution shift）的问题。 接下来，我们将简要描述强化学习问题，这是一类明确考虑与环境交互的问题。</p><h3 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h3><p><em>不是太懂</em></p><p>在强化学习问题中，agent在一系列的时间步骤上与环境交互。 在每个特定时间点，agent从环境接收一些观察（observation），并且必须选择一个动作（action），然后通过某种机制（有时称为执行器）将其传输回环境，最后agent从环境中获得奖励（reward）。 此后新一轮循环开始，agent接收后续观察，并选择后续操作，依此类推。</p><p><img src="rl-environment.png" alt="强化学习"></p><p>强化学习框架的通用性十分强大。 例如，我们可以将任何监督学习问题转化为强化学习问题。</p><p>当然，强化学习还可以解决许多监督学习无法解决的问题。 例如，在监督学习中，我们总是希望<strong>输入与正确的标签相关联</strong>。 但在强化学习中，我们<strong>并不假设环境告诉agent每个观测的最优动作</strong>。 一般来说，agent只是得到一些奖励。 此外，环境甚至可能不会告诉我们是哪些行为导致了奖励。</p><p>强化学习可能还必须处理部分可观测性问题。 也就是说，当前的观察结果可能无法阐述有关当前状态的所有信息。 比方说，一个清洁机器人发现自己被困在一个许多相同的壁橱的房子里。 推断机器人的精确位置（从而推断其状态），需要在进入壁橱之前考虑它之前的观察结果。</p><p>最后，在任何时间点上，强化学习agent可能知道一个好的策略，但可能有许多更好的策略从未尝试过的。 强化学习agent必须不断地做出选择：是应该利用当前最好的策略，还是探索新的策略空间（放弃一些短期回报来换取知识）。</p><p>一般的强化学习问题是一个非常普遍的问题。 agent的动作会影响后续的观察，而奖励只与所选的动作相对应。 环境可以是完整观察到的，也可以是部分观察到的，解释所有这些复杂性可能会对研究人员要求太高。 此外，并不是每个实际问题都表现出所有这些复杂性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;em&gt;本博客记录阅读《动手学深度学习》的读书笔记。&lt;/em&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;http://zh-v2.d2l.ai/chapter_introduction/index.html&quot;&gt;http://zh-v2.d2l.a</summary>
      
    
    
    
    <category term="深度学习" scheme="https://gmet233.gitee.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="深度学习" scheme="https://gmet233.gitee.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>基于Scrapy的网络爬虫案例</title>
    <link href="https://gmet233.gitee.io/2022/01/09/%E5%9F%BA%E4%BA%8EScrapy%E7%9A%84%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E6%A1%88%E4%BE%8B/"/>
    <id>https://gmet233.gitee.io/2022/01/09/%E5%9F%BA%E4%BA%8EScrapy%E7%9A%84%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E6%A1%88%E4%BE%8B/</id>
    <published>2022-01-09T03:14:08.000Z</published>
    <updated>2022-01-09T05:29:09.015Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这是在公司实习时，领导给出的一个数据爬取需求。（所以涉及法律问题请找公司的麻烦，不要联系我😂）</p><p>虽然我之前也干过网络爬虫，但都是在比较完整的框架下进行实现：以前只需要实现URL解析和网页源码抽取接口，其他像网络爬虫配置，数据存储，数据抽取，数据导出，任务启动和停止等模块只需要鼠标click一下或者根本就是“黑盒”的，不需要我操心。。</p><p>这一次，我基本是从“0”开始。所以在完成任务的过程中学到了很多。（当然也还不够多）</p><p>由于爬取的网站是一个经典的“列表-详情”结构，且爬取难度不难（网站没有设置反爬），作为爬虫初学者很合适，所以我把该任务的实现过程记录下来，方便自己学习。</p><p>本篇博客将记录我在实现该任务时，学到的知识、遇到的困难、对应的解决方案。</p><p>通过阅读本篇博客你将获得</p><ul><li>使用Scrapy进行简单的网页数据爬取</li><li>使用BeautifulSoup解析HTML</li><li>使用Pandas做简单的数据读取、去重、分析操作</li></ul><p>不能获得：</p><ul><li>Scrapy高级使用、框架结构、底层原理</li><li>破解数据采集时遇到的反爬</li></ul><p>废话比较多。先来看一下阅读本文需要的前置知识。</p><h1 id="阅读本文需要的前置知识"><a href="#阅读本文需要的前置知识" class="headerlink" title="阅读本文需要的前置知识"></a>阅读本文需要的前置知识</h1><p>阅读本篇博客需要一定的前置知识。我将列举一些，可能不全。</p><ul><li>网络爬虫：什么是网络爬虫</li><li>//Conda：什么是Conda，Conda安装、环境创建等</li><li>Python 基础：基础数据结构及操作、文件I/O操作</li><li>PyCharm使用：如何配置开发环境，连接远程环境进行开发等</li><li>//Linux 服务器基本命令</li><li>HTML基础、CSS选择器等前端基础知识。</li><li>XPath数据定位、正则表达式匹配等知识。</li></ul><p>如果你有以上基础，那么阅读本篇博客基本没有障碍。</p><p>下面介绍我的工作环境。</p><h1 id="工作环境"><a href="#工作环境" class="headerlink" title="工作环境"></a>工作环境</h1><table><thead><tr><th>软件名称</th><th>备注</th><th>版本</th></tr></thead><tbody><tr><td>Windows</td><td>操作系统</td><td>10</td></tr><tr><td>PyCharm</td><td>开发IDE</td><td>2019.3.5</td></tr><tr><td>Ananconda</td><td>Python环境管理和包管理工具</td><td>懒得写了</td></tr><tr><td>Scrapy</td><td>Python开源模块，爬虫框架</td><td>懒得写了</td></tr><tr><td>BeautifulSoup</td><td>Python开源模块，解析HTML</td><td>懒得写了</td></tr><tr><td>Pandas</td><td>Python开源模块，这里用它做简单的数据提取</td><td>懒得写了</td></tr></tbody></table><p>下面介绍具体需求。</p><h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>爬取网站 <a href="https://www.yunyubaike.com/">孕育百科</a> 各分类下的孕育问答。结果以CSV格式给出。</p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>打开 <a href="https://www.yunyubaike.com/">孕育百科</a> 可以看到有很多孕育百科的分类，选择一个分类，比如，这里我们选择【准备怀孕】。</p><p><img src="image-20220107161453957.png" alt="分类"></p><p>新打开的网页为<a href="https://www.yunyubaike.com/beiyun/">https://www.yunyubaike.com/beiyun/</a></p><p>可以看到这里有一些子分类：</p><p><img src="image-20220107162138428.png" alt="分类和子分类"></p><p>这些分类和子分类下有很多孕育百科问答，我们点击一个问题的超链接，在弹出的详情页中给出问题的答案，如图：</p><p><img src="image-20220107162808046.png" alt="孕育百科-详情页"></p><p>把这些问题和答案“抽取”到到CSV文件中，作为最终结果。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先我们需要分析该网站，例如网站数据量大小，网站网页结构，网站跳转方式，数据传输方式，数据是否加密，网站反爬严不严重等等。</p><p>可以抓包、写网页下载代码测试一下。</p><p>据此指定网站采集策略，是使用本地IP就可以采集还是需要设置一批代理IP，数据文件是存放到本地还是需要存放到Hadoop，是否需要可视化（Selenium）采集等等。</p><h2 id="采集策略"><a href="#采集策略" class="headerlink" title="采集策略"></a>采集策略</h2><ol><li>先采集分类（首页）URL；</li><li>根据分类（首页）URL不断循环生成分页（列表页）；</li><li>爬取每个列表页中的详情URL；</li><li>下载详情URL的HTML文件，保存到本地；</li><li>解析本地HTML，生成CSV文件。</li></ol><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="采集分类"><a href="#采集分类" class="headerlink" title="采集分类"></a>采集分类</h2><p>仔细分析网站可以发现，在采集分类存在两个坑。</p><ul><li>不是所有分类都是孕育百科：对于不是分类的URL可以直接丢弃。</li><li>子分类下和分类存在重复：去重。</li></ul><p>由于子分类和分类不是很多，这里使用的手工采集。</p><p>虽说手工采集，但还是需要一点小小的技巧。这里不是挨个复制网页源码中的分类连接，而是通过Chrome的一个插件<a href="https://chrome.google.com/webstore/detail/xpath-helper/hgimnogjllphhhkhlmebbmlgjoejdpjl?utm_source=chrome-ntp-icon">XPath Helper</a>。</p><p>该插件支持通过写XPath的方式批量获得信息。</p><p>例如我们要获取上图【分类和子分类】中的子分类。先查看这部分的网页源码</p><p><img src="image-20220107165203546.png" alt="子分类网页源码"></p><p>打开XPath Helper，写入XPath获得结果。</p><p><img src="image-20220107165324295.png" alt="XPath Helper截图"></p><p>最终获得大小分类共72个。</p><h2 id="列表页翻页采集详情页URL"><a href="#列表页翻页采集详情页URL" class="headerlink" title="列表页翻页采集详情页URL"></a>列表页翻页采集详情页URL</h2><p>每个分类下有很多翻页，通过不断的翻页采集所有的详情URL。</p><p><img src="image-20220107165646544.png" alt="翻页"></p><p>这里我一开始偷懒，用的“八爪鱼采集器”。后来发现这软件虽然不需要写代码，但是对于大于1W的数据需要收费，就放弃了。</p><p>后续我基于Scrapy爬虫框架完成采集。</p><h3 id="新建Scrapy项目"><a href="#新建Scrapy项目" class="headerlink" title="新建Scrapy项目"></a>新建Scrapy项目</h3><p>首先我们需要新建一个Scrapy项目（前提是已经安装了Scrapy）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scrapy startproject yybkSpider</span><br></pre></td></tr></table></figure><p>其中， yybkSpider为项目名称，可以看到将会创建一个yybkSpider文件夹，目录结构大致如下：</p><p>下面来简单介绍一下各个主要文件的作用：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yybkSpider/</span><br><span class="line">    scrapy.cfg</span><br><span class="line">    yybkSpider/</span><br><span class="line">        __init__.py</span><br><span class="line">        items.py</span><br><span class="line">        pipelines.py</span><br><span class="line">        settings.py</span><br><span class="line">        spiders/</span><br><span class="line">            __init__.py</span><br></pre></td></tr></table></figure><p>这里介绍我认为比较重要的文件：</p><ul><li>settings.py: 项目的配置文件，默认下载的网页是Unicode，需要在这里配置为UTF-8编码。</li><li>yybkSpider/: 项目的Python模块，将会从这里引用代码。</li><li>yybkSpider/items.py: 保存数据的实体，有点像Java Bean。</li><li>yybkSpider/yybkSpider/: 存储爬虫代码目录。</li></ul><h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><p>这里默认下载的网页为UTF-8，所以需要在<code>settings.py</code>中增加配置<code>FEED_EXPORT_ENCODING = &#39;utf-8&#39;</code></p><p>还可以修改下载的线程数。但是我查阅了网上的相关资料，好像作用并不大。由于对Python和Scrapy不是很了解，这里直接给出连接：</p><ul><li><a href="https://www.zhihu.com/question/23474039">为什么有人说 Python 的多线程是鸡肋呢？</a></li><li><a href="https://www.zhihu.com/question/26062225">scrapy在爬网页的时候是自动采用多线程的吗？</a></li></ul><h3 id="制作爬虫"><a href="#制作爬虫" class="headerlink" title="制作爬虫"></a>制作爬虫</h3><p>紧接着，制作一个爬虫：</p><ul><li>Input：所有分类首页</li><li>Output：<ul><li>所有列表页</li><li>每个列表页的详情URL和其他信息。</li></ul></li></ul><p>进入<code>yybkSpider/</code>目录下，输入命令创建爬虫：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scrapy genspider yybk_list &quot;yunyubaike.com&quot;</span><br></pre></td></tr></table></figure><ul><li><code>yybk_list</code>是爬虫的名称</li><li><code>&quot;yunyubaike.com&quot;</code>指出该爬虫爬取的域名，超出域名的不会爬取。</li></ul><p>之后可以看到在<code>yybkSpider/yybkSpider/</code>生成了一个文件<code>yybk_list.py</code>，它默认增加了下列代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YybkListSpider</span>(<span class="params">scrapy.Spider</span>):</span></span><br><span class="line">    name = <span class="string">&#x27;yybk_list&#x27;</span></span><br><span class="line">    allowed_domains = [<span class="string">&#x27;yunyubaike.com&#x27;</span>]</span><br><span class="line">    start_urls = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span>(<span class="params">self, response</span>):</span></span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>name = “” ：这个爬虫的识别名称，必须是唯一的，在不同的爬虫必须定义不同的名字。</p><p>allow_domains = [] 是搜索的域名范围，也就是爬虫的约束区域，规定爬虫只爬取这个域名下的网页，不存在的URL会被忽略。</p><p>start_urls = [] ：爬取的URL列表。爬虫从这里开始抓取数据，所以，第一次下载的数据将会从这些urls开始。其他子URL将会从这些起始URL中继承性生成。</p><p>parse(self, response) ：解析的方法，每个初始URL完成下载后将被调用，调用的时候传入从每一个URL传回的Response对象来作为唯一参数，主要作用如下：</p><ul><li>负责解析返回的网页数据(response.body)，提取结构化数据(生成item)</li><li>生成需要下一页的URL请求。</li></ul><p>接下来我们完成该爬虫。首先start_urls不是一个而是72个分类首页URL。再者我们要在parse方法中完成两件事：</p><ol><li>不断生成下一页</li><li>对于每个列表页解析其中的数据。</li></ol><p>下面是完整代码，这部分参考了官方文档：<a href="https://docs.scrapy.org/en/latest/intro/overview.html%E3%80%82">https://docs.scrapy.org/en/latest/intro/overview.html。</a></p><p>这里有几个地方值得注意：</p><ol><li>通过<code>response.url</code>获得当前采集的URL</li><li><code>response.xpath(&#39;&#39;)</code>返回的是一组元素</li><li>我把<code>response.xpath(&#39;&#39;)[0].get()</code>都改写了，原因是如果<code>response.xpath(&#39;&#39;)</code>为空在执行<code>[0]</code>操作就会报错，导致爬取失败</li><li>使用<code>get()</code>而不是<code>exract()</code>。原因如下： </li></ol><blockquote><p>get() 、getall() 是新版本的方法，extract() 、extract_first()是旧版本的方法。</p><p>前者更好用，取不到就返回None，后者取不到就raise一个错误。</p></blockquote><ol start="5"><li>想要在当前元素下继续通过XPath选取元素，需要在XPath开头加一个<code>.</code></li><li>注意<code>yield</code>的使用</li><li>这里采集了很多“多余”的字段，例如页码，总数，当前url。这是为了后续验证采集的数据是否完整正确而增加的冗余字段。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YybkListSpider</span>(<span class="params">scrapy.Spider</span>):</span></span><br><span class="line">    name = <span class="string">&#x27;yybk_list&#x27;</span></span><br><span class="line">    allowed_domains = [<span class="string">&#x27;yunyubaike.com&#x27;</span>]</span><br><span class="line">    <span class="comment"># 一共是72个URL，这里没有列全</span></span><br><span class="line">    start_urls = [<span class="string">&#x27;https://www.yunyubaike.com/yunqi/&#x27;</span>,</span><br><span class="line">                  <span class="string">&#x27;https://www.yunyubaike.com/yichuanyousheng/&#x27;</span>,</span><br><span class="line">                  <span class="string">&#x27;https://www.yunyubaike.com/beiyun/&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span>(<span class="params">self, response</span>):</span></span><br><span class="line">        domain_url = <span class="string">&quot;https://www.yunyubaike.com&quot;</span></span><br><span class="line">        <span class="comment"># items = []</span></span><br><span class="line">        this_url = response.url</span><br><span class="line">        page_nums = response.xpath(<span class="string">&quot;//div[@class=&#x27;pagebar&#x27;]/b/text()&quot;</span>)</span><br><span class="line">        page_num = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> page_nums:</span><br><span class="line">            page_num = page_nums[<span class="number">0</span>].get()</span><br><span class="line">        <span class="comment"># page_num = response.xpath(&quot;//div[@class=&#x27;pagebar&#x27;]/b/text()&quot;)[0].get()</span></span><br><span class="line">        counts = response.xpath(<span class="string">&quot;//div[@class=&#x27;pagebar&#x27;]/a[@title]/b/text()&quot;</span>)</span><br><span class="line">        count=<span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> counts:</span><br><span class="line">            count = counts[<span class="number">0</span>].get()</span><br><span class="line">        <span class="comment"># count = response.xpath(&quot;//div[@class=&#x27;pagebar&#x27;]/a[@title]/b/text()&quot;)[0].get()</span></span><br><span class="line">        <span class="keyword">for</span> li <span class="keyword">in</span> response.xpath(<span class="string">&quot;//div[@class=&#x27;list&#x27;]/ul/li&quot;</span>):</span><br><span class="line">            titles = li.xpath(<span class="string">&#x27;.//h2/a/text()&#x27;</span>)</span><br><span class="line">            title = <span class="string">&#x27;&#x27;</span></span><br><span class="line">            <span class="keyword">if</span> titles:</span><br><span class="line">                title = titles[<span class="number">0</span>].get()</span><br><span class="line">            detail_urls = li.xpath(<span class="string">&#x27;.//h2/a/@href&#x27;</span>)</span><br><span class="line">            detail_url = <span class="string">&#x27;&#x27;</span></span><br><span class="line">            <span class="keyword">if</span> detail_urls:</span><br><span class="line">                detail_url = detail_urls[<span class="number">0</span>].get()</span><br><span class="line">            <span class="comment"># detail_url = li.xpath(&#x27;.//h2/a/@href&#x27;)[0].get()</span></span><br><span class="line">            <span class="keyword">yield</span> &#123;</span><br><span class="line">                <span class="string">&#x27;this_url&#x27;</span>: this_url,  <span class="comment"># 当前采集的URL</span></span><br><span class="line">                <span class="string">&#x27;page_num&#x27;</span>: page_num,  <span class="comment"># 第几页</span></span><br><span class="line">                <span class="string">&#x27;count&#x27;</span>: count,  <span class="comment"># 该分类下的问答总数</span></span><br><span class="line">                <span class="string">&#x27;title&#x27;</span>: title,  <span class="comment"># 问答标题</span></span><br><span class="line">                <span class="string">&#x27;detail_url&#x27;</span>: domain_url + detail_url  <span class="comment"># 详情URL</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment"># 生成下一页</span></span><br><span class="line">        next_pages = response.xpath(<span class="string">&quot;//a[text()=&#x27;下一页&#x27;]/@href&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> next_pages:</span><br><span class="line">            next_page = next_pages[<span class="number">0</span>].get()</span><br><span class="line">            <span class="comment"># next_page = response.xpath(&quot;//a[text()=&#x27;下一页&#x27;]/@href&quot;)[0].get()</span></span><br><span class="line">            <span class="keyword">if</span> next_page <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">yield</span> response.follow(domain_url + next_page, self.parse)  <span class="comment"># 将下一页的连接传递给爬虫继续解析。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h3 id="启动爬虫"><a href="#启动爬虫" class="headerlink" title="启动爬虫"></a>启动爬虫</h3><p>最后启动爬虫，保存数据。在项目根目录下运行</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scrapy crawl yybk_list -o urls.json</span><br></pre></td></tr></table></figure><p>可以发现，在项目根目录多出了urls.json文件，里面是我们保存的所有列表数据。</p><p>我们也可以保存为其他格式。这里不再赘述。</p><p>这样我们就得到了大约27W的详情连接。下面我们把这些连接对应的HTML保存到本地。</p><h2 id="下载详情网页源码"><a href="#下载详情网页源码" class="headerlink" title="下载详情网页源码"></a>下载详情网页源码</h2><h3 id="制作爬虫-1"><a href="#制作爬虫-1" class="headerlink" title="制作爬虫"></a>制作爬虫</h3><p>进入<code>yybkSpider/</code>目录下，输入命令创建爬虫：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scrapy genspider yybk_detail_down &quot;yunyubaike.com&quot;</span><br></pre></td></tr></table></figure><p>和上面类似，在<code>yybkSpider/yybkSpider/yybk_detail_down.py</code>写入代码：</p><p>这里需要注意：</p><ol><li>start_urls是需要从文件中读取的</li><li>为了读数据、取数据方便，我使用了pands</li><li>获得网页源码，使用<code>response.text</code></li><li>这里没有对网页源码直接解析，而是先保存，再在后续解析。提高容错。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YybkDetailDownSpider</span>(<span class="params">scrapy.Spider</span>):</span></span><br><span class="line">    name = <span class="string">&#x27;yybk_detail_down&#x27;</span></span><br><span class="line">    allowed_domains = [<span class="string">&#x27;yunyubaike.com&#x27;</span>]</span><br><span class="line">    df = pd.read_json(<span class="string">&quot;yybkSpider/urls.json&quot;</span>)</span><br><span class="line">    <span class="comment"># 273179条数据</span></span><br><span class="line">    <span class="comment"># 取detail_url列，去重，转换成list</span></span><br><span class="line">    start_urls = df[<span class="string">&#x27;detail_url&#x27;</span>].drop_duplicates().tolist()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span>(<span class="params">self, response</span>):</span></span><br><span class="line">        url = response.url</span><br><span class="line">        <span class="comment"># 获得网页源码</span></span><br><span class="line">        content = response.text</span><br><span class="line"></span><br><span class="line">        file_name = url.replace(<span class="string">&quot;https://www.yunyubaike.com/&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        file_name = <span class="string">&#x27;html/&#x27;</span> + file_name.replace(<span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;_&#x27;</span>)   <span class="comment"># html/huaiyun_wiki_270163.html</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;保存文件：&quot;</span> + file_name)</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(file_name, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(content)</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>此外，我担心detail_url格式是否一致，所以在Python Shell中执行了如下代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df = pd.read_json(<span class="string">&quot;yybkSpider/urls.json&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df[df[<span class="string">&#x27;detail_url&#x27;</span>].<span class="built_in">str</span>.match(<span class="string">r&#x27;https://www.yunyubaike.com/\w+/\d+\.html&#x27;</span>) == <span class="literal">False</span>]</span><br></pre></td></tr></table></figure><p>执行结果为空，这证明detail_url格式一致。</p><h3 id="启动爬虫-1"><a href="#启动爬虫-1" class="headerlink" title="启动爬虫"></a>启动爬虫</h3><p>紧接着启动爬虫，和上面类似：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scrapy crawl yybk_detail_down</span><br></pre></td></tr></table></figure><p>由于这里不需要生成文件，所以没有<code>-o</code></p><p>等待代码执行完毕后，可以发现在项目根目录产生了一个<code>html/</code>文件夹，下面保存了所有详情页的网页源码。</p><h2 id="解析详情页"><a href="#解析详情页" class="headerlink" title="解析详情页"></a>解析详情页</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>打开一个详情页：</p><p><img src="image-20220109124722467.png" alt="详情页"></p><p>可以定位到：在<code>&lt;div class=&#39;article_content&#39; /&gt;</code>标签下，所有的带文字的p标签是我们需要的。每个p标签是一个段落，在保存的时候，段落信息是不能丢失的。也就是说换行符是需要的。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>这一步是脱离于Scrapy框架的。</p><p>自定义一个Python脚本：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">input_dir = <span class="string">&#x27;html/&#x27;</span>  <span class="comment"># 上一步保存源码的文件夹路径</span></span><br><span class="line">output_file_base_name = <span class="string">&#x27;yybkSpider/output/yybk_&#123;&#125;.csv&#x27;</span>  <span class="comment"># 生成的CSV文件的保存路径</span></span><br><span class="line">MAX_ROWS = <span class="number">50000</span>    <span class="comment"># 单个csv文件写入的最大行数</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">解析方法，传入文件名</span></span><br><span class="line"><span class="string">返回需要的字段</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse</span>(<span class="params">file_name</span>):</span></span><br><span class="line">    soup = BeautifulSoup(<span class="built_in">open</span>(file_name, encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    <span class="comment"># title解析</span></span><br><span class="line">    title = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    h1 = soup.find_all(<span class="string">&quot;h1&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> h1:</span><br><span class="line">        title = h1[<span class="number">0</span>].get_text()</span><br><span class="line">    <span class="comment"># content解析</span></span><br><span class="line">    p_list = soup.select(<span class="string">&quot;div.article_content &gt; p&quot;</span>)</span><br><span class="line">    content = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> p_list:</span><br><span class="line">        p_text = p.get_text()</span><br><span class="line">        <span class="keyword">if</span> p_text != <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">            <span class="comment"># 为了避免csv解析失败</span></span><br><span class="line">            p_text = p_text.replace(<span class="string">&quot;,&quot;</span>, <span class="string">&quot;，&quot;</span>).replace(<span class="string">&#x27;&quot;&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            content += p_text + <span class="string">&quot;\n&quot;</span></span><br><span class="line">    content = content.rstrip().lstrip()</span><br><span class="line">    <span class="keyword">return</span> title, content</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    htmls = os.listdir(input_dir)</span><br><span class="line">    <span class="comment"># 计算最终生成的文件个数</span></span><br><span class="line">    file_num = (<span class="built_in">len</span>(htmls) + MAX_ROWS - <span class="number">1</span>) // MAX_ROWS</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(file_num):</span><br><span class="line">        <span class="comment"># i从0开始</span></span><br><span class="line">        <span class="comment"># 第i个文件保存 i*MAX_ROWS[下标] 到 (i+1)*MAX_ROWS - 1</span></span><br><span class="line">        start_index = i*MAX_ROWS</span><br><span class="line">        end_index = (i+<span class="number">1</span>)*MAX_ROWS - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> end_index &gt; <span class="built_in">len</span>(htmls):</span><br><span class="line">            end_index = <span class="built_in">len</span>(htmls)</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(output_file_base_name.<span class="built_in">format</span>(i), <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;parsing :start_index:&#123;&#125;, end_index:&#123;&#125;; saving as &#123;&#125;&quot;</span></span><br><span class="line">                  .<span class="built_in">format</span>(start_index, end_index, output_file_base_name.<span class="built_in">format</span>(i)))</span><br><span class="line">            f.write(<span class="string">&quot;article_id,content,title\n&quot;</span>)</span><br><span class="line">            <span class="keyword">for</span> html_name <span class="keyword">in</span> htmls[start_index: end_index]:</span><br><span class="line">                title, content = parse(os.path.join(input_dir, html_name))</span><br><span class="line">                f.write(html_name + <span class="string">&#x27;,&quot;&#x27;</span> + content + <span class="string">&#x27;&quot;,&#x27;</span> + title + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在<code>parse</code>方法中需要注意以下几点：</p><ol><li><code>soup.select(&quot;div.article_content &gt; p&quot;)</code>这里使用了CSS选择器，制定了div下的直接子标签；</li><li><code>p.get_text()</code>获得p标签下的所有文字；</li><li>为了避免CSV解析失败，这里把英文逗号换成中文逗号，把英文的引号全部去掉。（CSV文件用英文逗号做字段分割；当我们需要把多行数据保存在一个字段中时，需要把多行数据用英文引号包起来）；</li><li>使用BeautifulSoup解析HTML。</li></ol><p>在<code>main</code>方法中需要注意：</p><ol><li>27W行保存到一个CSV文件中，我担心不好把控，所以我将27W行数据每5W行保存为一个CSV</li><li>当需要对除法结果四舍五入时，这样做比较简单：<code>(被除数+除数-1)/除数</code></li></ol><h3 id="运行脚本"><a href="#运行脚本" class="headerlink" title="运行脚本"></a>运行脚本</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python xxx.py</span><br></pre></td></tr></table></figure><p>最终导出6个CSV文件。任务完成。</p><h1 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h1><p>//TODO: 稍后上传到git</p><h1 id="此外…"><a href="#此外…" class="headerlink" title="此外…"></a>此外…</h1><h2 id="Scrapy-Shell快速测试"><a href="#Scrapy-Shell快速测试" class="headerlink" title="Scrapy Shell快速测试"></a>Scrapy Shell快速测试</h2><p>在使用Scrapy的过程中，我想先传入一条URL测试返回的resonpse。经过查阅使用如下命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scrapy shell &lt;url&gt;</span><br></pre></td></tr></table></figure><p>执行后，进入Python Console，内置的response对象即是&lt;url&gt;的response</p><h2 id="在服务器运行"><a href="#在服务器运行" class="headerlink" title="在服务器运行"></a>在服务器运行</h2><p>如果在本机执行爬虫代码，会占用较多的资源，也不方便。此时可以把爬虫代码同步到服务器运行。我使用PyChram连接远程服务器，在本机编写爬虫代码，然后同步到服务器中执行。（具体请自行百度）</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://docs.scrapy.org/en/latest/intro/overview.html">Scrapy at a glance</a></li><li><a href="https://www.runoob.com/w3cnote/scrapy-detail.html">Scrapy 入门教程</a></li><li><a href="https://www.runoob.com/cssref/css-selectors.html">CSS选择器</a></li><li><a href="https://scrapy-chs.readthedocs.io/zh_CN/1.0/topics/shell.html">Scrapy shell</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这是在公司实习时，领导给出的一个数据爬取需求。（所以涉及法律问题请找公司的麻烦，不要联系我😂）&lt;/p&gt;
&lt;p&gt;虽然我之前也干过网络爬虫，但</summary>
      
    
    
    
    <category term="网络爬虫" scheme="https://gmet233.gitee.io/categories/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"/>
    
    
    <category term="网络爬虫" scheme="https://gmet233.gitee.io/tags/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"/>
    
    <category term="Scrapy" scheme="https://gmet233.gitee.io/tags/Scrapy/"/>
    
  </entry>
  
  <entry>
    <title>详解HTTP协议</title>
    <link href="https://gmet233.gitee.io/2022/01/05/%E8%AF%A6%E8%A7%A3HTTP%E5%8D%8F%E8%AE%AE/"/>
    <id>https://gmet233.gitee.io/2022/01/05/%E8%AF%A6%E8%A7%A3HTTP%E5%8D%8F%E8%AE%AE/</id>
    <published>2022-01-05T13:43:14.000Z</published>
    <updated>2022-01-05T13:49:02.193Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p><strong>超文本传输协议</strong>（HTTP，HyperText Transfer Protocol）是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。1960年美国人Ted Nelson构思了一种通过计算机处理文本信息的方法，并称之为超文本（hypertext）,这成为了HTTP超文本传输协议标准架构的发展根基。Ted Nelson组织协调万维网协会（World Wide Web Consortium）和互联网工程工作小组（Internet Engineering Task Force ）共同合作研究，最终发布了一系列的RFC，其中著名的RFC 2616定义了HTTP 1.1。</p><h1 id="HTTP协议的作用及特点"><a href="#HTTP协议的作用及特点" class="headerlink" title="HTTP协议的作用及特点"></a>HTTP协议的作用及特点</h1><p>HTTP是一个客户端和服务器端请求和应答的标准（TCP）。客户端是终端用户，服务器端是网站。</p><p>通过使用Web浏览器、网络爬虫或者其它的工具，客户端发起一个到服务器上指定端口（<strong>默认端口为80</strong>）的HTTP请求。（我们称这个客户端）叫<strong>用户代理（user agent）</strong>。应答的服务器上存储着（一些）资源，比如HTML文件和图像。（我们称）这个应答服务器为源服务器（origin server）。在用户代理和源服务器中间可能存在多个中间层，比如代理，网关，或者隧道（tunnels）。尽管TCP/IP协议是互联网上最流行的应用，HTTP协议并没有规定必须使用它和（基于）它支持的层。 事实上，HTTP可以在任何其他互联网协议上，或者在其他网络上实现。HTTP只假定（其下层协议提供）可靠的传输，任何能够提供这种保证的协议都可以被其使用。</p><p>通常，由HTTP客户端发起一个请求，建立一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端发送过来的请求。一旦收到请求，服务器（向客户端）发回一个状态行，比如”HTTP/1.1 200 OK”，和（响应的）消息，消息的消息体可能是请求的文件、错误消息、或者其它一些信息。<strong>HTTP使用TCP而不是UDP的原因在于（打开）一个网页必须传送很多数据，而TCP协议提供传输控制，按顺序组织数据，和错误纠正。</strong></p><p>通过HTTP或者HTTPS协议请求的资源由<strong>统一资源标示符</strong>（Uniform Resource Identifiers）（或者，更准确一些，URLs）来标识。</p><ol><li>基于请求/响应模型的协议。请求和响应必须成对，先有请求后有响应</li><li>HTTP协议默认端口:80</li><li>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST等。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</li><li>灵活：<strong>HTTP允许传输任意类型的数据对象。</strong>正在传输的类型由Content-Type加以标记。</li><li><strong>无连接</strong>：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li><li><strong>无状态</strong>：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</li></ol><h1 id="协议功能"><a href="#协议功能" class="headerlink" title="协议功能"></a>协议功能</h1><p>HTTP协议是用于从WWW服务器传输超文本到本地浏览器的传输协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。</p><p>HTTP是客户端浏览器或其他程序与Web服务器之间的<strong>应用层通信协议</strong>。在Internet上的Web服务器上存放的都是超文本信息，客户机需要通过HTTP协议传输所要访问的超文本信息。HTTP包含命令和传输信息，不仅可用于Web访问，也可以用于其他因特网/内联网应用系统之间的通信，从而实现各类应用资源超媒体访问的集成。</p><p>我们在浏览器的地址栏里输入的网站地址叫做URL (Uniform Resource Locator，统一资源定位符)。就像每家每户都有一个门牌地址一样，每个网页也都有一个Internet地址。当你在浏览器的地址框中输入一个URL或是单击一个超级链接时，URL就确定了要浏览的地址。浏览器通过超文本传输协议(HTTP)，将Web服务器上站点的网页代码提取出来，并翻译成漂亮的网页。</p><h1 id="HTTP协议的版本"><a href="#HTTP协议的版本" class="headerlink" title="HTTP协议的版本"></a>HTTP协议的版本</h1><p>HTTP/1.0，发送请求，创建一次连接，获得<strong>一个</strong>web资源，连接断开</p><p>HTTP/1.1，发送请求，创建一次连接，获得<strong>多个</strong>web资源，连接断开</p><p>HTTP/2.0</p><h1 id="HTTP协议的组成"><a href="#HTTP协议的组成" class="headerlink" title="HTTP协议的组成"></a>HTTP协议的组成</h1><p>HTTP协议由<strong>HTTP请求</strong>和<strong>HTTP响应</strong>组成，当在浏览器中输入网址访问某个网站时， 你的浏览器会将你的请求封装成一个HTTP请求发送给服务器站点，服务器接收到请  求后会组织响应数据封装成一个HTTP响应返回给浏览器。即没有请求就没有响应。</p><p><strong>HTTP请求包括：请求行、请求头、请求体</strong></p><p><strong>HTTP响应包括：响应行、响应头、响应体</strong></p><h1 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h1><p>HTTP请求报文由3部分组成（请求行+请求头+请求体）：</p><p><img src="HTTP%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87.png" alt="HTTP请求报文"></p><h2 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h2><p>例如：<code>POST /chapter17/user.html HTTP/1.1</code></p><p>格式：<code>请求方式 资源路径 协议/版本</code></p><p>请求行必须在HTTP请求格式的第一行。</p><blockquote><p>GET请求</p></blockquote><ul><li>将请求参数追加在URL后面，不安全</li><li>URL长度限制GET请求方式数据的大小</li><li>没有请求体</li><li>一般的HTTP请求大多都是GET。</li><li>常见GET请求：地址栏直接访问、&lt;a href=””&gt;、&lt;img src=””&gt;等</li></ul><blockquote><p>POST请求</p></blockquote><p>请求参数在请求体处，较安全。</p><p>请求数据大小没有限制</p><p>只有表单设置为method=“post”才是POST请求，其他都是GET请求</p><blockquote><p>HEAD请求</p></blockquote><p>HEAD跟GET相似，不过服务端接收到HEAD请求时<strong>只返回响应头</strong>，不发送响应内容。所以，如果只需要查看某个页面的状态时，用HEAD更高效，因为省去了传输页面内容的时间。</p><blockquote><p>DELETE请求</p></blockquote><p>删除某一个资源。</p><blockquote><p>OPTIONS请求</p></blockquote><p>用于获取当前URL所支持的方法。若请求成功，会在HTTP头中包含一个名为“Allow”的头，值是所支持的方法，如”GET, POST”。</p><blockquote><p>PUT请求</p></blockquote><p>把一个资源存放在指定的位置上。</p><p>本质上来讲， PUT和POST极为相似，都是向服务器发送数据，但它们之间有一个重要区别，PUT通常指定了资源的存放位置，而POST则没有，POST的数据存放位置由服务器自己决定。</p><blockquote><p>TRACE请求</p></blockquote><p>回显服务器收到的请求，主要用于测试或诊断。</p><blockquote><p>CONNECT请求</p></blockquote><p>CONNECT方法是HTTP/1.1协议预留的，能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接与非加密的HTTP代理服务器的通信。</p><p><strong>在 REST 架构风格中，有严格规定对于不同的请求类型要设置合适的请求方法。</strong></p><p>也是避免出现因为乱用导致混乱的问题。这里提到了REST架构，现在很多同学都在写REST，有没有人能够明白为什么要定义REST这个架构风格？（使用REST）</p><ol><li>随着服务化架构的普及，HTTP协议的使用频率越来越高</li><li>很多人在错误的使用HTTP协议定义接口，比如各种各样的命名，什么 getUserInfoById， deleteById 之类的、<strong>有状态和无状态请求混用。</strong></li><li>对于 http 协议本身提供的规则并没有很好的利用</li></ol><p>所以，为了更好的解决这些问题，干脆就定义一套规则，这套规则并没有引入新的东西，无非就是对 http 协议本身的使用做了一些约束，比如说</p><ol><li><strong>REST是面向资源</strong>，每一个 URI 代表一个资源</li><li>强调<strong>无状态化</strong>，服务器端不能存储来自某个客户的某个请求中的信息，并在该客户的其他 请求中使用</li><li>强调 URL 暴露资源时，<strong>不要在 URI 中出现动词</strong></li><li>合理的利用 http 状态码、请求方法。</li></ol><p>因此大家在参照这种标准去使用 REST 风格时，要明白你遵循的是什么以及要解决什么问题。</p><h2 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h2><p>例如：Host: 39.108.107.149:8080</p><p>请求头从第二行开始，到第一个空格结束。请求头和请求体之间存在一个空格(如下)</p><p>例如：Host: 39.108.107.149:8080</p><p>请求头从第二行开始，到第一个空格结束。请求头和请求体之间存在一个空格(如下)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST http://39.108.107.149:8080/vk/app/rest/ddp/iModelServiceImpl/findModelByType HTTP/1.1</span><br><span class="line">User-Agent: Fiddler</span><br><span class="line">Host: 39.108.107.149:8080</span><br><span class="line">Content-Length: 11</span><br><span class="line"> </span><br><span class="line">name=城市</span><br></pre></td></tr></table></figure><p>请求头通常以键值对{key:value}方式传递数据。</p><p>key为规范的固定值</p><p>value为key对应的取值，通常是一个值，可能是一组。</p><h3 id="常见的请求头属性"><a href="#常见的请求头属性" class="headerlink" title="常见的请求头属性"></a>常见的请求头属性</h3><p><strong>Referer:</strong> 表示这个请求是从哪个url跳过来的，通过百度来搜索淘宝网,那么在进入淘宝网的请求报文中，Referer的值就是:<a href="http://www.baidu.com./">www.baidu.com。</a> 如果是直接访问就不会有这个头。</p><p>常用于：防盗链。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Referer: no-referrer-when-downgrade</span><br></pre></td></tr></table></figure><p><strong>Accept:</strong> 告诉服务端，该请求所能支持的响应数据类型，专业术语称为MIME 类型(文件类型的一种描述方式)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8</span><br></pre></td></tr></table></figure><p>MIME格式：大类型/小类型[;参数]</p><p>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,<em>/</em>;q=0.8</p><p>例如:</p><p>text/html,html文件</p><p>text/css,css文件</p><p>text/javascript,js文件</p><p>image/*，所有图片文件</p><p><strong>Cookie:</strong> 客户端的Cookie就是通过这个报文头属性传给服务端的哦！</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cookie: JSESSIONID=15982C27F7507C7FDAF0F97161F634B5</span><br></pre></td></tr></table></figure><p>这里就出了一个问题,网站A怎么保证自己请求体中保存的cookie就是网站A的cookie而不是网站B的cookie呢,这就和cookie里面的jsessionid有关系了，关于cookie,session,sessionid,jsessionid的区别联系，可以参考这个博文:</p><p><a href="http://www.cnblogs.com/fnng/archive/2012/08/14/2637279.html">http://www.cnblogs.com/fnng/archive/2012/08/14/2637279.html</a></p><p><strong>User-Agent:</strong> 浏览器通知服务器，客户端浏览器与操作系统相关信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36</span><br></pre></td></tr></table></figure><p><strong>Connection:</strong> 表示客户端与服务连接类型；Keep-Alive表示持久连接，close已关闭</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure><p><strong>Host:</strong> 请求的服务器主机名</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host: sczpkj.f3322.net:3000</span><br></pre></td></tr></table></figure><p><strong>Content-Length:</strong> 请求体的长度</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST http://39.108.107.149:8080/vk/app/rest/ddp/iModelServiceImpl/findModelByType HTTP/1.1</span><br><span class="line">User-Agent: Fiddler</span><br><span class="line">Host: 39.108.107.149:8080</span><br><span class="line">Content-Length: 11</span><br><span class="line"> </span><br><span class="line">name=城市</span><br></pre></td></tr></table></figure><p><strong>Content-Type:</strong> 请求的与实体对应的MIME信息。如果是POST请求,会有这个头,默认值为application/x-www-form-urlencoded，表示请求体内容使用url编码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Content-Type: application/x-www-form-urlencoded</span><br></pre></td></tr></table></figure><blockquote><h4 id="Content-Type详解"><a href="#Content-Type详解" class="headerlink" title="Content-Type详解"></a>Content-Type详解</h4><p>常见的Content-Type：</p><table><thead><tr><th>Content-Type</th><th>解释</th></tr></thead><tbody><tr><td>text/html</td><td>html格式</td></tr><tr><td>text/plain</td><td>纯文本格式</td></tr><tr><td>text/css</td><td>CSS格式</td></tr><tr><td>text/javascript</td><td>js格式</td></tr><tr><td>image/gif</td><td>gif图片格式</td></tr><tr><td>image/jpeg</td><td>jpg图片格式</td></tr><tr><td>image/png</td><td>png图片格式</td></tr><tr><td>application/x-www-form-urlencoded</td><td>POST专用：普通的表单提交默认是通过这种方式。form表单数据被编码为key/value格式发送到服务器。</td></tr><tr><td>application/json</td><td>POST专用：用来告诉服务端消息主体是序列化后的 JSON 字符串</td></tr><tr><td>text/xml</td><td>POST专用：发送xml数据</td></tr><tr><td>multipart/form-data</td><td>POST专用：下面讲解</td></tr></tbody></table><p><strong>application/x-www-form-urlencoded</strong> </p><p>最常见的post提交数据的方式。浏览器原生的form表单，如果不设置<strong>enctype属性</strong>，那么最终就会以application/x-www-form-urlencoded 方式提交数据</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST http://39.108.107.149:8080/vk/app/rest/ddp/iModelServiceImpl/findModelByType HTTP/1.1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">cache-control: no-cache</span><br><span class="line">Postman-Token: 8e602802-b4f5-4d05-96d7-e1c7a1951719</span><br><span class="line">User-Agent: PostmanRuntime/7.1.1</span><br><span class="line">Accept: */*</span><br><span class="line">Host: 39.108.107.149:8080</span><br><span class="line">cookie: JSESSIONID=6CD80B7028062D9190717CEE001C3194</span><br><span class="line">accept-encoding: gzip, deflate</span><br><span class="line">content-length: 32</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line">name=%E5%9F%8E%E5%B8%82&amp;status=1</span><br></pre></td></tr></table></figure><p>首先，Content-Type 被指定为 application/x-www-form-urlencoded；其次，提交的数据按照 key1=val1&amp;key2=val2 的方式进行编码，key 和 val 都进行了 URL 转码。大部分服务端语言都对这种方式有很好的支持。</p><p>很多时候，我们用 Ajax 提交数据时，也是使用这种方式。例如 JQuery 和 QWrap 的 Ajax，Content-Type 默认「application/x-www-form-urlencoded;charset=utf-8」。 </p><p><strong>multipart/form-data</strong> </p><p>这又是一个常见的 POST 数据提交的方式。我们<strong>使用表单上传文件</strong>时，必须让 form 的 enctyped 等于这个值。</p><p>此时（当使用表单上传文件时），HTTP请求报文格式如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST http://39.108.107.149:8080/vk/app/rest/ddp/iDataSourcesBaseService/file HTTP/1.1</span><br><span class="line">Content-Type: multipart/form-data; boundary=--------------------------629236571647111133881449</span><br><span class="line">cache-control: no-cache</span><br><span class="line">Postman-Token: 2146b4b3-2d30-469c-bbcd-fbc4693934d9</span><br><span class="line">User-Agent: PostmanRuntime/7.1.1</span><br><span class="line">Accept: */*</span><br><span class="line">Host: 39.108.107.149:8080</span><br><span class="line">cookie: JSESSIONID=6CD80B7028062D9190717CEE001C3194</span><br><span class="line">accept-encoding: gzip, deflate</span><br><span class="line">content-length: 435</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line">----------------------------629236571647111133881449</span><br><span class="line">Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;test.txt&quot;</span><br><span class="line">Content-Type: text/plain</span><br><span class="line"></span><br><span class="line">test upload</span><br><span class="line">----------------------------629236571647111133881449</span><br><span class="line">Content-Disposition: form-data; name=&quot;extCode&quot;</span><br><span class="line"></span><br><span class="line">test</span><br><span class="line">----------------------------629236571647111133881449</span><br><span class="line">Content-Disposition: form-data; name=&quot;extId&quot;</span><br><span class="line"></span><br><span class="line">3306</span><br><span class="line">----------------------------629236571647111133881449--  //结束标识</span><br></pre></td></tr></table></figure><p>首先生成了一个 boundary 用于分割不同的字段，为了避免与正文内容重复，boundary 很长很复杂。然后 Content-Type 里指明了数据是以 mutipart/form-data 来编码，本次请求的 boundary 是什么内容。</p><p>消息主体里按照字段个数又分为多个结构类似的部分，每部分都是<strong>以–boundary开始</strong>，紧接着内容描述信息，然后是回车，最后是最后是字段具体内容（文本或二进制），如果传输的是文件，还要包含文件名和文件类型信息。消息主体最后<strong>以–boundary–标示结束</strong>。</p><p>上面提到的这两种 POST 数据的方式，都是浏览器原生支持的，而且现阶段原生 form 表单也只支持这两种方式。但是随着越来越多的 Web 站点，尤其是 WebApp，全部使用 Ajax 进行数据交互之后，我们完全可以定义新的数据提交方式，给开发带来更多便利。 </p><p><strong>application/json</strong></p><p>application/json 这个 Content-Type 作为响应头大家肯定不陌生。实际上，现在越来越多的人把它作为请求头，用来告诉服务端消息主体是序列化后的 JSON 字符串。由于 JSON 规范的流行，除了低版本 IE 之外的各大浏览器都原生支持 JSON.stringify，服务端语言也都有处理 JSON 的函数，使用 JSON 不会遇上什么麻烦。 <strong>JSON 格式支持比键值对复杂得多的结构化数据，这一点也很有用。</strong></p><p>当<code>Content-Type: application/json</code>时请求报文如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST http://39.108.107.149:8080/vk/app/rest/ddp/vkIndexsService/queryVkIndxs HTTP/1.1</span><br><span class="line">Content-Type: application/json</span><br><span class="line">cache-control: no-cache</span><br><span class="line">Postman-Token: 5014bc39-0777-49d5-bb8a-73db9a981e49</span><br><span class="line">User-Agent: PostmanRuntime/7.1.1</span><br><span class="line">Accept: */*</span><br><span class="line">Host: 39.108.107.149:8080</span><br><span class="line">cookie: JSESSIONID=6CD80B7028062D9190717CEE001C3194</span><br><span class="line">accept-encoding: gzip, deflate</span><br><span class="line">content-length: 132</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"> &quot;name&quot;:&quot;828验证继承&quot;,</span><br><span class="line"> &quot;getresultType&quot;:&quot;2&quot;,</span><br><span class="line"> &quot;createTime&quot;:&quot;Tue Sep 11 2018 00:00:00 GMT+0800 (中国标准时间)&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方案，可以方便的提交复杂的结构化数据，特别适合 RESTful 的接口。各大抓包工具如 Chrome 自带的开发者工具、Firebug、Fiddler，都会以树形结构展示 JSON 数据，非常友好。</p></blockquote><p><strong>Accept-Encoding:</strong> 浏览器通知服务器，浏览器支持的数据压缩格式。如GZIP压缩</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Accept-Encoding: gzip, deflate</span><br></pre></td></tr></table></figure><p><strong>Accept-Language:</strong> 浏览器通知服务器，浏览器支持的语言。各国语言(国际化i18n)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br></pre></td></tr></table></figure><p><strong>Cache-Control:</strong> 指定请求和响应遵循的缓存机制</p><p>对缓存进行控制，如一个请求希望响应返回的内容在客户端要被缓存一年，或不希望被缓存就可以通过这个报文头达到目的。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cache-Control: no-cache</span><br></pre></td></tr></table></figure><p>更多请求头属性可以参考这篇文章:<a href = "http://tools.jb51.net/table/http_header">HTTP响应头和请求头信息对照表</a></p><h2 id="请求体"><a href="#请求体" class="headerlink" title="请求体"></a>请求体</h2><p>当请求方式是post的时，请求体会有请求的参数，格式如下：</p><p>username=zhangsan&amp;password=123</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST http://39.108.107.149:8080/vk/app/rest/ddp/iModelServiceImpl/findModelByType HTTP/1.1</span><br><span class="line">User-Agent: Fiddler</span><br><span class="line">Host: 39.108.107.149:8080</span><br><span class="line">Content-Length: 20</span><br><span class="line"> </span><br><span class="line">name=城市&amp;status=1</span><br></pre></td></tr></table></figure><h1 id="HTTP响应报文"><a href="#HTTP响应报文" class="headerlink" title="HTTP响应报文"></a>HTTP响应报文</h1><p>HTTP的响应报文也由三部分组成（响应行+响应头+响应体）</p><p><img src="HTTP%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87.png" alt="HTTP响应报文"></p><h2 id="响应行"><a href="#响应行" class="headerlink" title="响应行"></a>响应行</h2><p>例如：<code>HTTP/1.1 200 OK</code></p><p>格式：<code>报文协议及版本 状态码及状态描述</code></p><h3 id="常见的状态码"><a href="#常见的状态码" class="headerlink" title="常见的状态码"></a>常见的状态码</h3><p>状态码：由3位数字组成，第一个数字定义了响应的类别</p><p>1xx：指示信息，表示请求已接收，继续处理</p><p>2xx：成功，表示请求已被成功接受，处理。</p><ul><li>200 OK：客户端请求成功</li><li>204 No Content：无内容。服务器成功处理，但未返回内容。一般用在只是客户端向服务器发送信息，而服务器不用向客户端返回什么信息的情况。不会刷新页面。</li><li>206 Partial Content：服务器已经完成了部分GET请求（客户端进行了范围请求）。响应报文中包含Content-Range指定范围的实体内容</li></ul><p>3xx：重定向</p><ul><li>301 Moved Permanently：永久重定向，表示请求的资源已经永久的搬到了其他位置。</li><li>302 Found：临时重定向，表示请求的资源临时搬到了其他位置</li><li>303 See Other：临时重定向，应使用GET定向获取请求资源。303功能与302一样，区别只是303明确客户端应该使用GET访问</li><li>307 Temporary Redirect：临时重定向，和302有着相同含义。POST不会变成GET</li><li>304 Not Modified：表示客户端发送附带条件的请求（GET方法请求报文中的IF…）时，条件不满足。返回304时，不包含任何响应主体。虽然304被划分在3XX，但和重定向一毛钱关系都没有</li></ul><p>4xx：客户端错误</p><ul><li>400 Bad Request：客户端请求有语法错误，服务器无法理解。</li><li>401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用。</li><li>403 Forbidden：服务器收到请求，但是拒绝提供服务</li><li>404 Not Found：请求资源不存在。比如，输入了错误的url</li><li>415 Unsupported media type：不支持的媒体类型</li></ul><p>5xx：服务器端错误，服务器未能实现合法的请求。</p><ul><li>500 Internal Server Error：服务器发生不可预期的错误。</li><li>503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常，</li></ul><h2 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h2><p>响应报文头，也是由多个属性组成；</p><p>响应头也是用键值对；</p><p>服务器通过响应头来控制浏览器的行为，不同的头浏览器操作不同</p><table><thead><tr><th>常见请求头</th><th>描述</th></tr></thead><tbody><tr><td>Location</td><td>指定响应的路径，需要与状态码302配合使用，完成跳转。</td></tr><tr><td>Content-Type</td><td>响应正文的类型（MIME类型）；取值：text/html;charset=UTF-8</td></tr><tr><td>Content-Disposition</td><td>通过浏览器以下载方式解析正文；  取值：attachment;filename=xx.zip</td></tr><tr><td>Set-Cookie</td><td>与会话相关技术。服务器向浏览器写入Cookie</td></tr><tr><td>Content-Encoding</td><td>服务器使用的压缩格式；取值：gzip</td></tr><tr><td>Content-length</td><td>响应正文的长度</td></tr><tr><td>Refresh</td><td>定时刷新，格式：秒数;url=路径。url可省略，默认值为当前页。取值：3;url=<a href="http://www.itcast.cn/">www.itcast.cn</a>    //三秒刷新页面到<a href="http://www.itcast.cn/">www.itcast.cn</a></td></tr><tr><td>Server</td><td>指的是服务器名称，默认值：Apache-Coyote/1.1。可以通过conf/server.xml配置进行修改。&lt;Connector port=”8080” … server=”itcast”/&gt;</td></tr><tr><td>Last-Modified</td><td>服务器通知浏览器，文件的最后修改时间。与If-Modified-Since一起使用。</td></tr><tr><td>Cache-Control</td><td>响应输出到客户端后，服务端通过该报文头属告诉客户端如何控制响应内容的缓存。常见的取值有常见的取值有private、public、no-cache、max-age，no-store，默认为private。缓存时间为31536000秒（365天）</td></tr></tbody></table><p>更多请求头属性可以参考这篇文章：<a href="http://tools.jb51.net/table/http_header">HTTP响应头和请求头信息对照表</a></p><h2 id="响应体"><a href="#响应体" class="headerlink" title="响应体"></a>响应体</h2><p>响应报文体，服务器发送给浏览器的正文，即我们真正要的“干货” ；</p><p>响应体，响应体是服务器回写给客户端的页面正文，浏览器将正文加载到内存，然后解析渲染，显示页面内容。</p><h1 id="HTTP协议扩展"><a href="#HTTP协议扩展" class="headerlink" title="HTTP协议扩展"></a>HTTP协议扩展</h1><blockquote><p><strong>如果传输的文件过大怎么办</strong></p></blockquote><p>服务器上返回的资源文件比较大，比如有些 js 文件大小可能就有几兆。文件过大就会影响传 输的效率，同时也会带来带宽的消耗。怎么办呢？</p><ol><li>常见的手段是，对文件进行<strong>压缩</strong>，减少文件大小。那压缩和解压缩的流程怎么实现呢？ 首先服务端需要能支持文件的压缩功能，其次浏览器能够针对被压缩的文件进行解压缩。浏览器可以指定 Accept-Encoding 来高速服务器我当前支持的编码类型 Accept-Encoding:gzip,deflate 那服务端会根据支持的编码类型，选择合适的类型进行压缩。常见的编码方式有：gzip/deflate</li><li><strong>分割</strong>传输 在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面。这种把实体主体分块的功能称为分块传输编码（Chunked Transfer Coding）。</li></ol><blockquote><p><strong>每次请求都要建立连接吗？</strong></p></blockquote><p>在最早的 HTTP 协议中，每进行一次 HTTP 通信，就需要做一次 TCP 的连接。而一次连接需要进行 3 次握手，这种通信方式会增加通信量的开销。</p><p><img src="HTTP%E4%B8%80%E6%AC%A1%E9%80%9A%E4%BF%A1.png" alt="HTTP一次通信"></p><p>所以在 <strong>HTTP/1.1 中改用了持久连接</strong>，就是在一次连接建立之后，只要客户端或者服务端没有 明确提出断开连接，那么这个 tcp 连接会一直保持连接状态 持久连接的一个最大的好处是：大大减少了连接的建立以及关闭时延。 HTTP1.1 中有一个 Transport 段。会携带一个 <strong>Connection:Keep-Alive</strong>，表示希望将此条连接 作为持久连接。</p><p>HTTP/1.1 持久连接在默认情况下是激活的，除非特别指明，否则 HTTP/1.1 假定所有的连接都 是持久的，要在事务处理结束之后将连接关闭，HTTP/1.1 应用程序必须向报文中显示地添加 一个 Connection：close 首部。</p><p>HTTP1.1 客户端加载在收到响应后，除非响应中包含了 Connection：close 首部，不然 HTTP/1.1 连接就仍然维持在打开状态。但是，客户端和服务器仍然可以随时关闭空闲的连接。不发送 Connection：close 并不意味这服务器承诺永远将连接保持在打开状态。</p><p><strong>管道化连接</strong>：http/1.1 允许在持久连接上使用请求管道。以前发送请求后需等待并收到响应， 才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。这样就 能够做到同时并行发送多个请求，而不需要一个接一个地等待响应了。</p><p><img src="%E7%AE%A1%E9%81%93%E5%8C%96%E8%BF%9E%E6%8E%A5.png" alt="管道化连接"></p><blockquote><p><strong>HTTP协议如何解决无状态问题</strong></p></blockquote><p>HTTP 协议是无状态的，什么是无状态呢？就是说 HTTP 协议本身不会对请求和响应之间的 通信状态做保存。 但是现在的应用都是有状态的，如果是无状态，那这些应用基本没人用，你想想，访问一个电商网站，先登录，然后去选购商品，当点击一个商品加入购物车以后又提示你登录。这种用户体验根本不会有人去使用。那我们是如何实现带状态的协议呢？</p><ol><li><strong>客户端支持的 cookie</strong></li></ol><p>HTTP 协议中引入了 Cookie 技术，用来解决HTTP协议无状态的问题。通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态；Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。</p><ol start="2"><li><strong>服务端支持的 session</strong></li></ol><p>服务端是通过什么方式来保存状态的呢？ 在基于 tomcat 这类的 jsp/servlet 容器中，会提供 session 这样的机制来保存服务端的对象状态，服务器使用一种类似于散列表的结构来保存信息，当程序需要为某个客户端的请求创建一个 session 的时候，服务器首先检查这个客户端 的请求是否包含了一个 session 标识- session id； 如果已包含一个 session id 则说明以前已经为客户端创建过 session，服务器就按照 session id 把这个 session 检索出来使用（如果检索不到，会新建一个）； 如果客户端请求不包含 sessionid，则为此客户端创建一个 session 并且生成一个与此 session 相关联的 session id， session id 的值是一个既不会重复，又不容易被找到规律的仿造字符 串，这个 session id 将会返回给客户端保存</p><p><img src="Session%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png" alt="Session实现原理"></p><h1 id="更多…"><a href="#更多…" class="headerlink" title="更多…"></a>更多…</h1><ul><li><input disabled="" type="checkbox"> HTTP1.0/HTTP1.1/HTTP2.0的异同</li><li><input disabled="" type="checkbox"> HTTP与HTTPS的不同；HTTPS的原理</li><li><input disabled="" type="checkbox"> HTTP长连接与短连接</li><li><input disabled="" type="checkbox"> GET/POST区别详解</li><li><input disabled="" type="checkbox"> Cookie、Session详解</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://blog.csdn.net/weixin_38087538/article/details/82838762">Http协议详解(深入理解)</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;引入&quot;&gt;&lt;a href=&quot;#引入&quot; class=&quot;headerlink&quot; title=&quot;引入&quot;&gt;&lt;/a&gt;引入&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;超文本传输协议&lt;/strong&gt;（HTTP，HyperText Transfer Protocol）是互联网上应用最为广泛的</summary>
      
    
    
    
    <category term="计算机网络" scheme="https://gmet233.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://gmet233.gitee.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="HTTP" scheme="https://gmet233.gitee.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>从堆排序到优先级队列</title>
    <link href="https://gmet233.gitee.io/2021/12/29/%E4%BB%8E%E5%A0%86%E6%8E%92%E5%BA%8F%E5%88%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/"/>
    <id>https://gmet233.gitee.io/2021/12/29/%E4%BB%8E%E5%A0%86%E6%8E%92%E5%BA%8F%E5%88%B0%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/</id>
    <published>2021-12-29T12:47:48.000Z</published>
    <updated>2021-12-29T14:41:29.954Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文包含以下几部分内容</p><ul><li><input checked="" disabled="" type="checkbox"> 二叉堆</li><li><input checked="" disabled="" type="checkbox"> 堆排序</li><li><input checked="" disabled="" type="checkbox"> 二叉堆应用：优先级队列</li><li><input checked="" disabled="" type="checkbox"> Java PriorityQueue</li></ul><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h2><p>二叉堆是堆排序实现的底层逻辑结构。二叉堆是一种特殊的二叉树（完全二叉树），一般存储在数组中。</p><p>对于链表二叉树，一般是操作节点指针，而对于二叉堆，我们使用数组索引作为指针。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父节点的索引</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">parent</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> root / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 左孩子的索引</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> root * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 右孩子的索引</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">right</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> root * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是二叉堆物理存储结构示意图，注意这里索引0空着不用。</p><p><img src="1.png" alt="二叉堆示意图"></p><p>二叉堆设计的巧妙之处就在于，对于一个节点，只需要通过简单的运算就可以得到其父、左右孩子节点。</p><p>二叉堆分为大顶堆和小顶堆。大顶堆的性质是<strong>每个节点都大于等于他的两个子节点</strong>，小顶堆的性质相反。</p><p>本文以大顶堆为例。此外，为了更加直观，下面会画的图都是二叉树结构。由于大顶堆的性质，堆顶元素arr[1]一定是所有元素中最大的元素。</p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆排序就是利用堆这种数据结构设计的一种排序算法。</p><blockquote><p><strong>堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了</strong></p></blockquote><p>堆排序是一种<strong>选择排序，</strong>它的最坏，最好，平均时间复杂度均为**O(nlogn)**，它是<a href="https://baike.baidu.com/item/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%A8%B3%E5%AE%9A%E6%80%A7/9763250"><strong>不稳定排序</strong></a>。</p><p>下面通过一个例子来了解堆排序的过程。</p><p>序列：4，6，8，5，9。</p><p><strong>步骤一</strong>： 构造初始堆。</p><p><img src="2.png" alt="初始堆"></p><p><strong>步骤二</strong>：由<strong>下向上，由右向左</strong>不断调整，使其满足大顶堆的要求。</p><p><img src="3.png" alt="构造大顶堆的过程示意"></p><ol><li>先看【6，5，9】，9为这棵树的最大值节点，因此将9和根节点6互换；</li><li>再看【4，9，8】，9为这棵树的最大值节点，因此将9和根节点4互换；</li><li>由于刚才的交换，【4，5，6】不再满足大顶堆的性质，6为这棵树的最大值节点，因此将4和根节点6互换。</li><li>此时整棵树都满足了大顶堆的性质。</li></ol><p><strong>步骤三</strong>：将堆顶元素与末尾元素进行交换，使末尾元素最大。弹出末尾最大元素。重复<strong>步骤二</strong>使其满足大顶堆。如此反复进行交换、重建、交换……直到堆空，元素弹出堆的顺序即为排序后的顺序。</p><p><img src="4.png" alt="步骤三示意"></p><p>总结堆排序算法步骤：</p><ol><li>将无需序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆；</li><li>由下向上，由右向左不断调整，使初始堆满足大顶堆的要求。</li><li>将堆顶元素与末尾元素进行交换，使末尾元素最大。弹出末尾最大元素。重复<strong>步骤二</strong>使其满足大顶堆。如此反复进行交换、重建、交换……直到堆空。元素弹出堆的顺序即为排序后的顺序。</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>//TODO</p><h2 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h2><p>优先级队列的性质是，出队元素总是优先级最高的元素。优先级队列的底层就是使用二叉堆和堆排序实现了这一性质。当元素插入/删除时，优先级队列的元素会自动排序。</p><h3 id="代码框架"><a href="#代码框架" class="headerlink" title="代码框架"></a>代码框架</h3><p>优先级队列有两个主要 API，分别是<code>insert</code>插入一个元素和<code>delMax</code>删除最大元素。</p><p>下面给出优先级队列的代码框架。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxPQ</span> &lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt;&gt; </span>&#123; <span class="comment">//Key是可比较大小的泛型</span></span><br><span class="line">    <span class="comment">//二叉堆，大顶堆</span></span><br><span class="line">    <span class="keyword">private</span> Key[] pq;</span><br><span class="line">    <span class="comment">//当前priority queue中元素个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MaxPQ</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//索引0不用，所以多一个分配空间</span></span><br><span class="line">        pq = (Key[]) <span class="keyword">new</span> Comparable[cap + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回当前队列中的最大元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">max</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pq[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//插入元素e</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span> <span class="params">(Key e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除并返回当前队列中的最大元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">delMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//上浮第k个元素，以维护最大堆的性质</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="comment">//TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//下沉第k个元素，以维护最大堆的性质</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="comment">//TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交换数组的两个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        Key tmp = pq[i];</span><br><span class="line">        pq[i] = pq[j];</span><br><span class="line">        pq[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//pq[i]是否比pq[j]小</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pq[i].compareTo(pq[j]) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现swim和sink"><a href="#实现swim和sink" class="headerlink" title="实现swim和sink"></a>实现swim和sink</h3><p>元素的swim（上浮）和sink（下沉）都是为了维护堆的性质。</p><p>我们要讲的是最大堆，每个节点都比它的两个子节点大，但是在插入元素和删除元素时，难免破坏堆的性质，这就需要通过这两个操作来恢复堆的性质了。</p><p>对于最大堆，会破坏堆性质的有有两种情况：</p><ol><li>如果某个节点 A 比它的子节点（中的一个）小，那么 A 就不配做父节点，应该下去，下面那个更大的节点上来做父节点，这就是对 A 进行<strong>下沉</strong>。</li><li>如果某个节点 A 比它的父节点大，那么 A 不应该做子节点，应该把父节点换下来，自己去做父节点，这就是对 A 的<strong>上浮</strong>。</li></ol><p>swim代码实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果浮到了堆顶，就不需要再上浮了</span></span><br><span class="line">    <span class="keyword">while</span>(k &gt; <span class="number">1</span> &amp;&amp; less(parent(k), k)) &#123;</span><br><span class="line">        <span class="comment">//如果第k个元素比上层大，就将k换上去</span></span><br><span class="line">        exch(parent(k), k);</span><br><span class="line">        k = parent(k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sink代码实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下沉第k个元素，以维护最大堆性质</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果沉到堆底，就沉不下去了</span></span><br><span class="line">    <span class="keyword">while</span>(left(k) &lt;= N) &#123;</span><br><span class="line">        <span class="comment">//假设左边节点比较大</span></span><br><span class="line">        <span class="keyword">int</span> older = left(k);</span><br><span class="line">        <span class="comment">//如果右边节点存在，则左右节点比一下大小</span></span><br><span class="line">        <span class="keyword">if</span>(right(k) &lt;= N &amp;&amp; less(older, right(k))) &#123;</span><br><span class="line">            older = right(k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//节点k比左右孩子都大，就不必下沉了</span></span><br><span class="line">        <span class="keyword">if</span>(less(older, k))  <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//否则，不符合大顶堆性质，下沉k节点</span></span><br><span class="line">        exch(k, older);</span><br><span class="line">        k = older;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现delMax和insert"><a href="#实现delMax和insert" class="headerlink" title="实现delMax和insert"></a>实现delMax和insert</h3><p>delMax和insert就是建立在swim和sink基础上。</p><p><code>insert</code>方法先把要插入的元素添加到堆底的最后，然后让其上浮到正确位置。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Key e)</span> </span>&#123;</span><br><span class="line">    N++;</span><br><span class="line">    <span class="comment">// 先把新元素加到最后</span></span><br><span class="line">    pq[N] = e;</span><br><span class="line">    <span class="comment">// 然后让它上浮到正确的位置</span></span><br><span class="line">    swim(N);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>delMax</code>方法先把堆顶元素 A 和堆底最后的元素 B 对调，然后删除 A，最后让 B 下沉到正确位置。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Key <span class="title">delMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 最大堆的堆顶就是最大元素</span></span><br><span class="line">    Key max = pq[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 把这个最大元素换到最后，删除之</span></span><br><span class="line">    exch(<span class="number">1</span>, N);</span><br><span class="line">    pq[N] = <span class="keyword">null</span>;</span><br><span class="line">    N--;</span><br><span class="line">    <span class="comment">// 让 pq[1] 下沉到正确位置</span></span><br><span class="line">    sink(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，一个优先级队列就实现了，插入和删除元素的时间复杂度为 *O(logK)*，K为当前二叉堆（优先级队列）中的元素总数。因为我们时间复杂度主要花费在<code>sink</code>或者<code>swim</code>上，而不管上浮还是下沉，最多也就树（堆）的高度，也就是 log 级别。</p><h2 id="Java-PriorityQueue"><a href="#Java-PriorityQueue" class="headerlink" title="Java PriorityQueue"></a>Java PriorityQueue</h2><p>Java PriorityQueue的介绍请看我的另一篇博客<a href="https://gmet233.gitee.io/2021/12/19/PriorityQueue-%E6%A6%82%E8%BF%B0/#%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8">PriorityQueue 概述</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://mp.weixin.qq.com/s/o7tdyLiYm668dpUWd-x7Lg">labuladong: 图文详解二叉堆，实现优先级队列</a></li><li>《算法（第4版）》</li><li><a href="https://www.cnblogs.com/chengxiao/p/6129630.html">图解排序算法(三)之堆排序</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文包含以下几部分内容&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input checked=&quot;&quot; disabled=&quot;&quot; type=&quot;checkbox&quot;</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://gmet233.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="排序" scheme="https://gmet233.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
    <category term="数据结构与算法" scheme="https://gmet233.gitee.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="排序" scheme="https://gmet233.gitee.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
    <category term="队列" scheme="https://gmet233.gitee.io/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>统计文件夹下各种后缀名的文件个数</title>
    <link href="https://gmet233.gitee.io/2021/12/29/%E7%BB%9F%E8%AE%A1%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E5%90%84%E7%A7%8D%E5%90%8E%E7%BC%80%E5%90%8D%E7%9A%84%E6%96%87%E4%BB%B6%E4%B8%AA%E6%95%B0/"/>
    <id>https://gmet233.gitee.io/2021/12/29/%E7%BB%9F%E8%AE%A1%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E5%90%84%E7%A7%8D%E5%90%8E%E7%BC%80%E5%90%8D%E7%9A%84%E6%96%87%E4%BB%B6%E4%B8%AA%E6%95%B0/</id>
    <published>2021-12-29T12:40:52.000Z</published>
    <updated>2021-12-29T12:42:55.243Z</updated>
    
    <content type="html"><![CDATA[<p>test文件夹组织结构如下：</p><blockquote><p>test/<br>   -1.jpg<br>   -dd/<br>       -2.jpg<br>       -e/<br>           -3.jpg<br>           -4.jpg<br>           -5.txt<br>   -ll.dir/<br>       -5.rar</p></blockquote><p>现在想统计test目录下不同<strong>文件</strong>后缀名的个数。</p><p>下面通过两种方案解决。</p><h1 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h1><p>shell一行命令搞定，<strong>但对于带点号的目录，这种方法会出Bug</strong>。应该可以对此改进，但后面找到了Python的方式。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find -type f -name &quot;*.*&quot; | cut -f3 -d&#x27;.&#x27; | sort | uniq -c -i  (递归查找当前文件夹下的所有子文件夹)</span><br></pre></td></tr></table></figure><p>下面对该命令进行分解解释。</p><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>find命令参数说明</p><blockquote><p>  -type c<br>        File is of type c:<br>            d      directory<br>            f      regular file<br>  -name pattern<br>        Base of file name (the path with the leading directories  removed)  matches  shell  pattern  pattern.  </p></blockquote><ul><li>只查找文件，而不需要关心文件夹，所以使用-type f参数(注意，在linux上会有链接文件、块文件等其它格式的文件类型，而且Window系统上的快捷方式其格式也是一般文件)</li><li>只过滤出有后缀名的文件，所以使用-name “<em>.</em>“参数(注意，使用-name “<em>.</em>“参数也会过滤出.name和name.这样的文件，因此要严格过滤出*.*且”.”前后都有字符的文件，可以使用-regex “./.+..+”参数，具体作用请百度“find正则表达式”)</li></ul><h2 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h2><p>cut命令参数说明</p><blockquote><p>   -f, –fields=LIST<br>          select  only  these fields;  also print any line that contains no delimiter character, unless the -s option is specified<br>   -d, –delimiter=DELIM<br>          use DELIM instead of TAB for field delimiter</p></blockquote><ul><li>-f3表示截取第三部分</li></ul><h2 id="sort和uniq"><a href="#sort和uniq" class="headerlink" title="sort和uniq"></a>sort和uniq</h2><p>sort命令很好理解，就是对前面的输出进行一下排序，以便与uniq命令操作。</p><p>uniq命令说明</p><blockquote><p>uniq - report or omit repeated lines</p><p>-c, –count<br>   prefix lines by the number of occurrences<br>-i, –ignore-case<br>   ignore differences in case when comparing</p></blockquote><ul><li>uniq的作用就是找到<strong>连续重复的行</strong></li><li>-c 统计次数</li><li>-i 忽略大小写</li></ul><h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">&quot;count suffix from dir&quot;</span>)</span><br><span class="line"><span class="comment"># 设置脚本传参，传入需要统计后缀名的文件夹</span></span><br><span class="line">parser.add_argument(<span class="string">&#x27;-d&#x27;</span>, <span class="string">&#x27;--directory&#x27;</span>, required=<span class="literal">True</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, <span class="built_in">help</span>=<span class="string">&#x27;need a full path&#x27;</span>)</span><br><span class="line">args = parser.parse_args()</span><br><span class="line">directory = args.directory</span><br><span class="line"><span class="comment"># 结果dict</span></span><br><span class="line">res = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;suffix : count&quot;</span>)</span><br><span class="line"><span class="comment"># print(directory)</span></span><br><span class="line"><span class="comment"># 如果目录不存在则退出</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(directory):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;dir does not exist&quot;</span>)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 如果传递的不是目录则退出</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.isdir(directory):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;need a dir not a file&quot;</span>)</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">os.walk得到的三元组列表：分别指出了目录，目录下目录列表，目录下的文件列表</span></span><br><span class="line"><span class="string">(&#x27;.&#x27;, [&#x27;dd&#x27;, &#x27;ll.dir&#x27;], [&#x27;1.jpg&#x27;])</span></span><br><span class="line"><span class="string">(&#x27;./dd&#x27;, [&#x27;e&#x27;], [&#x27;2.jpg&#x27;])</span></span><br><span class="line"><span class="string">(&#x27;./dd/e&#x27;, [], [&#x27;3.jpg&#x27;, &#x27;4.jpg&#x27;, &#x27;5.txt&#x27;])</span></span><br><span class="line"><span class="string">(&#x27;./ll.dir&#x27;, [], [&#x27;5.rar&#x27;])</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> path, dirs, files <span class="keyword">in</span> os.walk(directory):</span><br><span class="line">    <span class="comment"># print(str(files))</span></span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">        file = file.lower()  <span class="comment"># 都统一转换成小写</span></span><br><span class="line">        <span class="comment"># 如果没有后缀名则不纳入统计范围</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> re.match(<span class="string">r&#x27;[\s\S]*\.[\s\S]*&#x27;</span>, file):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="comment"># 得到后缀字符串</span></span><br><span class="line">        suffix = file.split(<span class="string">&quot;.&quot;</span>)[-<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># 从字典中取出后缀对应的count，如果没有则默认为0</span></span><br><span class="line">        count = res.setdefault(suffix, <span class="number">0</span>)</span><br><span class="line">        <span class="comment"># count ++</span></span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 将更新的count放回字典</span></span><br><span class="line">        res[suffix] = count</span><br><span class="line"></span><br><span class="line"><span class="comment"># print</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> res.keys():</span><br><span class="line">    <span class="built_in">print</span>(key + <span class="string">&quot; : &quot;</span> + <span class="built_in">str</span>(res[key]))</span><br></pre></td></tr></table></figure><p>将上述代码保存为<code>.py</code>文件，然后命令行执行<code>python xxx.py -d &lt;目录&gt;</code></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文涉及到的知识点：</p><ul><li>Shell<ul><li>find命令，查询目录/文件</li><li>cut命令，分割字符串</li><li>sort命令，排序</li><li>uniq命令，找到连续重复的行</li></ul></li><li>Python<ul><li>dict 基本操作</li><li>argparse库，脚本传参</li><li>os库，读目录/文件</li><li>re库，正则匹配</li></ul></li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://blog.csdn.net/nfer_zhuang/article/details/42582425">一句话脚本系列之统计文件夹下各种后缀名的文件个数</a></li><li><a href="https://www.runoob.com/python/os-walk.html">Python os.walk() 方法</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;test文件夹组织结构如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;test/&lt;br&gt;   -1.jpg&lt;br&gt;   -dd/&lt;br&gt;       -2.jpg&lt;br&gt;       -e/&lt;br&gt;           -3.jpg&lt;br&gt;           -4.jpg</summary>
      
    
    
    
    <category term="Linux" scheme="https://gmet233.gitee.io/categories/Linux/"/>
    
    <category term="Scripts" scheme="https://gmet233.gitee.io/categories/Linux/Scripts/"/>
    
    
    <category term="Linux" scheme="https://gmet233.gitee.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Python dict 笔记</title>
    <link href="https://gmet233.gitee.io/2021/12/28/Python-dict-%E7%AC%94%E8%AE%B0/"/>
    <id>https://gmet233.gitee.io/2021/12/28/Python-dict-%E7%AC%94%E8%AE%B0/</id>
    <published>2021-12-28T12:50:46.000Z</published>
    <updated>2021-12-28T12:52:17.784Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>字典（dict）是Python内置提供的一种常用数据结构，他用于存放具有映射（mapping）关系的数据。</p><p>可变对象。</p><h1 id="dict-常用操作"><a href="#dict-常用操作" class="headerlink" title="dict 常用操作"></a>dict 常用操作</h1><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>两种方式，使用dict()函数创建字典；使用花括号语法创建字典。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;&#125;</span><br><span class="line">dict2 = <span class="built_in">dict</span>()  <span class="comment"># 创建了一个空字典</span></span><br></pre></td></tr></table></figure><blockquote><p>dict的key必须为不可变类型，所以字符串、元组等类型可以作为dict的key，但像列表这种可变类型，不能作为dict的key</p></blockquote><p>在使用 dict() 函数创建字典时，可以传入多个列表或元组参数作为 key-value 对，每个列表或元组将被当成一个 key-value 对，因此这些列表或元组都只能包含两个元素。例如如下代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>person = [(<span class="string">&#x27;age&#x27;</span>, <span class="number">18</span>), (<span class="string">&#x27;sex&#x27;</span>, <span class="string">&#x27;male&#x27;</span>), (<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;gyj&#x27;</span>)]  <span class="comment"># 这里换成person = [[&#x27;age&#x27;, 18], [&#x27;sex&#x27;, &#x27;male&#x27;], [&#x27;name&#x27;, &#x27;gyj&#x27;]]也是可以的</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict3 = <span class="built_in">dict</span>(person)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict3</span><br><span class="line">&#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;male&#x27;</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;gyj&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="通过key访问value"><a href="#通过key访问value" class="headerlink" title="通过key访问value"></a>通过key访问value</h2><p>三种方式：</p><ul><li>通过方括号语法访问</li><li>使用get方法</li><li>使用setdefault()方法</li></ul><p>这三者不同的地方在于：</p><ul><li>使用方括号语法访问并不存在的key时，字典会引发KeyError错误</li><li>但如果使用get()方法访问不存在的key，该方法会简单地返回None，不会导致错误</li><li>使用setdefault()，当程序要获取的 key 在字典中不存在时，该方法会先为这个不存在的 key 设置一个默认的 value，然后再返回该 key 对应的 value。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">scores = &#123;<span class="string">&#x27;语文&#x27;</span>: <span class="number">89</span>&#125;</span><br><span class="line"><span class="comment"># 通过key访问value</span></span><br><span class="line">scores.get(<span class="string">&#x27;语文&#x27;</span>) <span class="comment"># 89</span></span><br><span class="line">scores.get(<span class="string">&#x27;数学&#x27;</span>) <span class="comment"># None</span></span><br><span class="line">scores[<span class="string">&#x27;数学&#x27;</span>] <span class="comment"># KeyError</span></span><br><span class="line">scores.setdefault(<span class="string">&#x27;数学&#x27;</span>, <span class="number">0</span>)  <span class="comment"># 0</span></span><br><span class="line">scores.setdefault(<span class="string">&#x27;语文&#x27;</span>, <span class="number">0</span>)  <span class="comment"># 89</span></span><br></pre></td></tr></table></figure><h2 id="通过key添加k-v对"><a href="#通过key添加k-v对" class="headerlink" title="通过key添加k-v对"></a>通过key添加k-v对</h2><p>例如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">scores[<span class="string">&#x27;数学&#x27;</span>] = <span class="number">93</span></span><br></pre></td></tr></table></figure><h2 id="通过key删除k-v对"><a href="#通过key删除k-v对" class="headerlink" title="通过key删除k-v对"></a>通过key删除k-v对</h2><p>使用del语句删除k-v对</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">del</span> scores[<span class="string">&#x27;语文&#x27;</span>]</span><br></pre></td></tr></table></figure><h2 id="通过key修改k-v对"><a href="#通过key修改k-v对" class="headerlink" title="通过key修改k-v对"></a>通过key修改k-v对</h2><p>两种方式：对存在的key-value对赋值，改变key-value对；使用update方法</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">scores[<span class="string">&#x27;数学&#x27;</span>] = <span class="number">95</span></span><br><span class="line">scores.update(&#123;<span class="string">&#x27;数学&#x27;</span>:<span class="number">100</span>&#125;)  <span class="comment"># 如果update的key不存在，那么会增加一个新的k-v对</span></span><br></pre></td></tr></table></figure><h2 id="判断指定key是否存在"><a href="#判断指定key是否存在" class="headerlink" title="判断指定key是否存在"></a>判断指定key是否存在</h2><p>使用in或not in 运算符判断key是否存在</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;数学&#x27;</span> <span class="keyword">in</span> scores  <span class="comment"># True</span></span><br><span class="line"><span class="string">&#x27;数学&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> scores    <span class="comment"># False</span></span><br></pre></td></tr></table></figure><h2 id="清空字典中所有的k-v对"><a href="#清空字典中所有的k-v对" class="headerlink" title="清空字典中所有的k-v对"></a>清空字典中所有的k-v对</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">scores.clear()</span><br></pre></td></tr></table></figure><h2 id="获取dict所有k-v对，所有key，所有value"><a href="#获取dict所有k-v对，所有key，所有value" class="headerlink" title="获取dict所有k-v对，所有key，所有value"></a>获取dict所有k-v对，所有key，所有value</h2><p>items()：获取字典中的所有 key-value 对</p><p>keys()：获取字典中的所有 key</p><p>values()：获取字典中的所有 value</p><p>这三个方法依次返回 dict_items、dict_keys 和 dict_values 对象，Python 不希望用户直接操作这几个方法，但可通过 list() 函数把它们转换成列表。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>scores = &#123;<span class="string">&#x27;数学&#x27;</span>: <span class="number">96</span>, <span class="string">&#x27;英语&#x27;</span>: <span class="number">88</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>scores.items()</span><br><span class="line">dict_items([(<span class="string">&#x27;数学&#x27;</span>, <span class="number">96</span>), (<span class="string">&#x27;英语&#x27;</span>, <span class="number">88</span>)])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(scores.items())</span><br><span class="line">[(<span class="string">&#x27;数学&#x27;</span>, <span class="number">96</span>), (<span class="string">&#x27;英语&#x27;</span>, <span class="number">88</span>)]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="弹出指定key的k-v对"><a href="#弹出指定key的k-v对" class="headerlink" title="弹出指定key的k-v对"></a>弹出指定key的k-v对</h2><p>pop() 方法用于获取指定 key 对应的 value，并删除这个 key-value 对。例如</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">math_score = scores.pop(<span class="string">&#x27;数学&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="随机弹出k-v对"><a href="#随机弹出k-v对" class="headerlink" title="随机弹出k-v对"></a>随机弹出k-v对</h2><p>popitem() 方法用于随机弹出字典中的一个 key-value 对。</p><blockquote><p>此处的随机其实是假的，正如列表的 pop() 方法总是弹出列表中最后一个元素，实际上字典的 popitem() 其实也是弹出字典中最后一个 key-value 对。由于字典存储 key-value 对的顺序是不可知的，因此开发者感觉字典的 popitem() 方法是“随机”弹出的，但实际上字典的 popitem() 方法总是弹出底层存储的最后一个 key-value 对。</p></blockquote><h2 id="根据给定的多个key创建字典"><a href="#根据给定的多个key创建字典" class="headerlink" title="根据给定的多个key创建字典"></a>根据给定的多个key创建字典</h2><p>fromkeys() 方法使用给定的多个 key 创建字典，参数可以是list也可以是tuple，这些 key 对应的 value 默认都是 None；也可以额外传入一个参数作为默认的 value。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用列表创建包含2个key的字典</span></span><br><span class="line">a_dict = <span class="built_in">dict</span>.fromkeys([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(a_dict) <span class="comment"># &#123;&#x27;a&#x27;: None, &#x27;b&#x27;: None&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用元组创建包含2个key的字典，指定默认的value</span></span><br><span class="line">c_dict = <span class="built_in">dict</span>.fromkeys((<span class="number">13</span>, <span class="number">17</span>), <span class="string">&#x27;good&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(c_dict) <span class="comment"># &#123;13: &#x27;good&#x27;, 17: &#x27;good&#x27;&#125;</span></span><br></pre></td></tr></table></figure><h2 id="使用字典格式化字符串"><a href="#使用字典格式化字符串" class="headerlink" title="使用字典格式化字符串"></a>使用字典格式化字符串</h2><p>举例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 字符串模板中使用key</span></span><br><span class="line">temp = <span class="string">&#x27;教程是:%(name)s, 价格是:%(price)010.2f, 出版社是:%(publish)s&#x27;</span></span><br><span class="line">book = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;Python基础教程&#x27;</span>, <span class="string">&#x27;price&#x27;</span>: <span class="number">99</span>, <span class="string">&#x27;publish&#x27;</span>: <span class="string">&#x27;C语言中文网&#x27;</span>&#125;</span><br><span class="line"><span class="comment"># 使用字典为字符串模板中的key传入值</span></span><br><span class="line"><span class="built_in">print</span>(temp % book)</span><br><span class="line">book = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;C语言小白变怪兽&#x27;</span>, <span class="string">&#x27;price&#x27;</span>:<span class="number">159</span>, <span class="string">&#x27;publish&#x27;</span>: <span class="string">&#x27;C语言中文网&#x27;</span>&#125;</span><br><span class="line"><span class="comment"># 使用字典为字符串模板中的key传入值</span></span><br><span class="line"><span class="built_in">print</span>(temp % book)</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="http://c.biancheng.net/view/2212.html">Python字典及基本操作（超级详细）</a></li><li>《Python 学习手册（第四版）》</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;字典（dict）是Python内置提供的一种常用数据结构，他用于存放具有映射（mapping）关系的数据。&lt;/p&gt;
&lt;p&gt;可变对象。&lt;/p&gt;</summary>
      
    
    
    
    <category term="Python" scheme="https://gmet233.gitee.io/categories/Python/"/>
    
    <category term="基础" scheme="https://gmet233.gitee.io/categories/Python/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Python" scheme="https://gmet233.gitee.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>LRU: 缓存淘汰算法</title>
    <link href="https://gmet233.gitee.io/2021/12/26/LRU-%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95/"/>
    <id>https://gmet233.gitee.io/2021/12/26/LRU-%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95/</id>
    <published>2021-12-26T11:54:01.000Z</published>
    <updated>2021-12-26T14:38:19.460Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在使用缓存时，由于缓存容量有限，当缓存容量到达上限，就需要删除部分数据挪出空间。但是缓存数据不能随机删除，一般情况下需要根据某种算法删除缓存数据。</p><p>常用的淘汰算法有LRU, LFU, FIFO，本篇介绍LRU算法并重点讲述LRU的实现。完整代码也是<a href="https://leetcode-cn.com/problems/lru-cache/">LeetCode 146. LRU缓存</a>的答案。</p><h1 id="LRU-简介"><a href="#LRU-简介" class="headerlink" title="LRU 简介"></a>LRU 简介</h1><p>LRU是Least recently used的缩写，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。当缓存容量满的时候，优先淘汰最近最少被使用的数据。</p><p>根据以上策略，给出使用LRU淘汰算法时的示例。</p><p><img src="LRU%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95%E7%A4%BA%E4%BE%8B.jpg" alt="LRU淘汰算法示例"></p><p>通过上图可以看到LRU算法的具体步骤是：</p><ol><li>新数据直接插入到列表头部</li><li>缓存数据被命中，将数据移动到链表头部</li><li>缓存已满，移除列表尾部数据。</li></ol><h1 id="LRU-算法实现"><a href="#LRU-算法实现" class="headerlink" title="LRU 算法实现"></a>LRU 算法实现</h1><p>上面看到LRU算法需要添加头节点，删除尾节点。而链表添加/删除节点的时间复杂度为O(1)，但这里不能使用普通的单向链表，原因在于：</p><ul><li>虽然单向链表添加/删除/移动元素比较方便，但是再查询元素时的时间复杂度为O(N)</li><li>移动中间节点到头节点需要知道前一个节点和后一个节点的信息，单向链表就不得不再次遍历获取信息。</li></ul><p>针对以上问题的解决方案是：</p><ul><li>使用散列表存储节点，获取节点的复杂度将为O(1)，</li><li>使用双向链表用来获得前驱节点的信息。</li></ul><p><img src="LRU%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="LRU数据结构"></p><p>在这里，增加了两个【哨兵】节点，不用来存储任何数据，目的是再增加、删除结点的时候不用考虑节点不存在的情况。简化编程难度。</p><p>在算法实现的过程中，我发现LeetCode 146是类似的题目，故把该题直接拿来使用。</p><p>该题的算法签名是</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(key);</span></span><br><span class="line"><span class="comment"> * obj.put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>通过调用put\get方法实现存取缓存的目的。下面是对代码的逐步分析。</p><h2 id="双向链表数据结构"><a href="#双向链表数据结构" class="headerlink" title="双向链表数据结构"></a>双向链表数据结构</h2><p>这里使用一个内部类作为双向链表的数据结构。比较简单，直接给出代码。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">//定义一个内部类，作为缓存列表</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span></span>&#123;</span><br><span class="line">       <span class="keyword">public</span> Entry pre; <span class="comment">//指向前驱的指针</span></span><br><span class="line">       <span class="keyword">public</span> Entry next; <span class="comment">//指向后继的指针</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">int</span> key; <span class="comment">//缓存的key</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">int</span> value; <span class="comment">//缓存的value</span></span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">Entry</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.key = key;</span><br><span class="line">           <span class="keyword">this</span>.value = value;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">Entry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="定义成员变量和构造函数"><a href="#定义成员变量和构造函数" class="headerlink" title="定义成员变量和构造函数"></a>定义成员变量和构造函数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Entry head, tail; <span class="comment">//头尾两个哨兵节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> capacity; <span class="comment">// 容量</span></span><br><span class="line"><span class="keyword">int</span> size; <span class="comment">//当前缓存大小</span></span><br><span class="line">Map&lt;Integer, Entry&gt; cache; <span class="comment">//缓存散列表</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    <span class="comment">//初始化操作</span></span><br><span class="line">    initLinkedList();</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    cache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化操作函数<code>initLinkedList()</code>的实现是将head和tail通过指针连接起来。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       head = <span class="keyword">new</span> Entry();</span><br><span class="line">       tail = <span class="keyword">new</span> Entry();</span><br><span class="line"></span><br><span class="line">       head.next = tail;</span><br><span class="line">       tail.pre = head;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="put操作"><a href="#put操作" class="headerlink" title="put操作"></a>put操作</h2><p>put操作可以分三种情况：</p><ol><li>如果key已经存在与缓存中，则将key对应的节点移动到链表头部，并重设value</li><li>如果key在缓存中不存在，那么检查缓存是否已满<ol><li>如果未满，就直接将新节点加入到链表头部</li><li>如果已满，就先删除尾节点，再将新节点加入到链表头部</li></ol></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    Entry node = cache.get(key);</span><br><span class="line">    <span class="comment">//如果key在缓存中已经存在，则移动到头部</span></span><br><span class="line">    <span class="keyword">if</span>(node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.value = value;</span><br><span class="line">        move2Head(node);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//容量已满先删除尾节点</span></span><br><span class="line">    <span class="keyword">if</span>(size == capacity) &#123;</span><br><span class="line">        Entry lastNode = tail.pre;</span><br><span class="line">        deleteNode(lastNode);</span><br><span class="line">        cache.remove(lastNode.key);</span><br><span class="line">        size --;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//add new Node</span></span><br><span class="line">    Entry newNode = <span class="keyword">new</span> Entry();</span><br><span class="line">    newNode.key = key;</span><br><span class="line">    newNode.value = value;</span><br><span class="line">    addNode(newNode);</span><br><span class="line">    cache.put(key, newNode);</span><br><span class="line">    size ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于<code>move2Head</code>操作，无非是先删除原来的节点关系<code>deleteNode</code>，再添加到队列头部<code>addNode</code></p><p>而<code>deleteNode</code>和<code>addNode</code>是比较基础的双向链表操作，这里就不再做过多解释。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addNode</span><span class="params">(Entry node)</span> </span>&#123;</span><br><span class="line">    head.next.pre = node;</span><br><span class="line">    node.next = head.next;</span><br><span class="line"></span><br><span class="line">    node.pre = head;</span><br><span class="line">    head.next = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(Entry node)</span> </span>&#123;</span><br><span class="line">    node.pre.next = node.next;</span><br><span class="line">    node.next.pre = node.pre;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">move2Head</span><span class="params">(Entry node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//删除原来的节点关系</span></span><br><span class="line">    deleteNode(node);</span><br><span class="line">    addNode(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="get-操作"><a href="#get-操作" class="headerlink" title="get 操作"></a>get 操作</h2><p>当key不在缓存中，返回-1，当key存在于缓存时，就将该元素移动到链表头部，并返回对应的value。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">       Entry node = cache.get(key);</span><br><span class="line">       <span class="keyword">if</span>(node == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       move2Head(node);</span><br><span class="line">       <span class="keyword">return</span> node.value;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Entry head, tail;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity; <span class="comment">// 容量</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    Map&lt;Integer, Entry&gt; cache;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        <span class="comment">//初始化操作</span></span><br><span class="line">        initLinkedList();</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        cache = <span class="keyword">new</span> HashMap&lt;&gt;(capacity + <span class="number">2</span>); <span class="comment">//这里为什么要+2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        head = <span class="keyword">new</span> Entry();</span><br><span class="line">        tail = <span class="keyword">new</span> Entry();</span><br><span class="line"></span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.pre = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        Entry node = cache.get(key);</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        move2Head(node);</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将节点插入到头节点，如果容量已满，则会删除尾节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        Entry node = cache.get(key);</span><br><span class="line">        <span class="comment">//如果key在缓存中已经存在，则移动到头部</span></span><br><span class="line">        <span class="keyword">if</span>(node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.value = value;</span><br><span class="line">            move2Head(node);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//容量已满先删除尾节点</span></span><br><span class="line">        <span class="keyword">if</span>(size == capacity) &#123;</span><br><span class="line">            Entry lastNode = tail.pre;</span><br><span class="line">            deleteNode(lastNode);</span><br><span class="line">            cache.remove(lastNode.key);</span><br><span class="line">            size --;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//add new Node</span></span><br><span class="line">        Entry newNode = <span class="keyword">new</span> Entry();</span><br><span class="line">        newNode.key = key;</span><br><span class="line">        newNode.value = value;</span><br><span class="line">        addNode(newNode);</span><br><span class="line">        cache.put(key, newNode);</span><br><span class="line">        size ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addNode</span><span class="params">(Entry node)</span> </span>&#123;</span><br><span class="line">        head.next.pre = node;</span><br><span class="line">        node.next = head.next;</span><br><span class="line"></span><br><span class="line">        node.pre = head;</span><br><span class="line">        head.next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(Entry node)</span> </span>&#123;</span><br><span class="line">        node.pre.next = node.next;</span><br><span class="line">        node.next.pre = node.pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">move2Head</span><span class="params">(Entry node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//删除原来的节点关系</span></span><br><span class="line">        deleteNode(node);</span><br><span class="line">        addNode(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个内部类，作为缓存链表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> Entry pre; <span class="comment">//指向前驱的指针</span></span><br><span class="line">        <span class="keyword">public</span> Entry next; <span class="comment">//指向后继的指针</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> key; <span class="comment">//缓存的key</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value; <span class="comment">//缓存的value</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Entry</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Entry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://www.bilibili.com/video/BV1Va411677h">手写LRU算法 - IT老哥</a></li><li><a href="https://zhuanlan.zhihu.com/p/34133067">LRU原理和Redis实现——一个今日头条的面试题</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在使用缓存时，由于缓存容量有限，当缓存容量到达上限，就需要删除部分数据挪出空间。但是缓存数据不能随机删除，一般情况下需要根据某种算法删除缓存</summary>
      
    
    
    
    <category term="操作系统" scheme="https://gmet233.gitee.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="数据结构与算法" scheme="https://gmet233.gitee.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="操作系统" scheme="https://gmet233.gitee.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Tmux 简介</title>
    <link href="https://gmet233.gitee.io/2021/12/26/Tmux-%E7%AE%80%E4%BB%8B/"/>
    <id>https://gmet233.gitee.io/2021/12/26/Tmux-%E7%AE%80%E4%BB%8B/</id>
    <published>2021-12-26T03:07:45.000Z</published>
    <updated>2022-01-06T14:17:39.257Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是Tmux"><a href="#什么是Tmux" class="headerlink" title="什么是Tmux"></a>什么是Tmux</h1><p>打开一个终端窗口（terminal window，以下简称”窗口”），在里面输入命令。</p><p>用户与计算机的这种临时的交互，称为一次”会话”（session） 。</p><p>会话的一个重要特点是，窗口与其中启动的进程是<a href="https://www.ruanyifeng.com/blog/2016/02/linux-daemon.html">连在一起</a>的。打开窗口，会话开始；关闭窗口，会话结束。</p><p>一个典型的例子，打开一个远程窗口执行命令，这时关闭窗口，那么会话也就终止，里面的进程也随之终止。</p><p>为了解决这个问题，会话与窗口可以”解绑”：窗口关闭时，会话并不终止，而是继续运行，等到以后需要的时候，再让会话”绑定”其他窗口。</p><p><strong>Tmux 就是会话与窗口的”解绑”工具</strong>。</p><h1 id="使用Tmux"><a href="#使用Tmux" class="headerlink" title="使用Tmux"></a>使用Tmux</h1><h2 id="安装Tmux"><a href="#安装Tmux" class="headerlink" title="安装Tmux"></a>安装Tmux</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Ubuntu 或 Debian</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install tmux</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> CentOS 或 Fedora</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo yum install tmux</span></span><br></pre></td></tr></table></figure><h2 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h2><p>直接给出最常用的操作流程如下：</p><ul><li>新建会话<code>tmux new -s &lt;session_name&gt;</code>。（第一个启动的 Tmux 窗口，编号是0，第二个窗口的编号是1，以此类推。）</li><li>在 Tmux 窗口运行所需的程序。</li><li>按下快捷键<code>Ctrl+b d</code>将会话分离。</li><li>下次使用时，重新连接到会话<code>tmux a -t &lt;session_name&gt;</code>。</li></ul><h2 id="其他Tricks"><a href="#其他Tricks" class="headerlink" title="其他Tricks"></a>其他Tricks</h2><ul><li><code>Ctrl+b s</code>：列出所有会话。</li><li><code>tmux rename-session -t 0 &lt;new-name&gt;</code>：重命名会话。</li><li><code>tmux kill-session -t &lt;session-name&gt;</code>：杀死会话。</li><li><code>Ctrl+b [</code>：进入会话后，使用该快捷命令查看控制台历史消息，可通过键盘上的上下左右键来滚动历史输出信息。如果要退出查看模式，按下q即可。</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://www.ruanyifeng.com/blog/2019/10/tmux.html">Tmux 使用教程</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是Tmux&quot;&gt;&lt;a href=&quot;#什么是Tmux&quot; class=&quot;headerlink&quot; title=&quot;什么是Tmux&quot;&gt;&lt;/a&gt;什么是Tmux&lt;/h1&gt;&lt;p&gt;打开一个终端窗口（terminal window，以下简称”窗口”），在里面输入命令。&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="Linux" scheme="https://gmet233.gitee.io/categories/Linux/"/>
    
    <category term="开发工具" scheme="https://gmet233.gitee.io/categories/Linux/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="Linux" scheme="https://gmet233.gitee.io/tags/Linux/"/>
    
    <category term="开发工具" scheme="https://gmet233.gitee.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>火车站台数量问题</title>
    <link href="https://gmet233.gitee.io/2021/12/25/%E7%81%AB%E8%BD%A6%E7%AB%99%E5%8F%B0%E6%95%B0%E9%87%8F%E9%97%AE%E9%A2%98/"/>
    <id>https://gmet233.gitee.io/2021/12/25/%E7%81%AB%E8%BD%A6%E7%AB%99%E5%8F%B0%E6%95%B0%E9%87%8F%E9%97%AE%E9%A2%98/</id>
    <published>2021-12-25T13:34:56.000Z</published>
    <updated>2021-12-25T13:39:27.993Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题干"><a href="#题干" class="headerlink" title="题干"></a>题干</h1><p>假设已知某个火车站的所有过往列车的到达arrival和离开departure时间（同一天），如果要求所有列车都不等待直接进站，问至少需要多少个站台。无需考虑晚点等特殊情况。</p><p>例如，<br> Input：<br> 到达时间：  arr[]  = {9:00,  9:40, 9:50,  11:00, 15:00, 18:00}<br> 离开时间：  dep[]  = {9:10, 12:00, 11:20, 11:30, 19:00, 20:00}</p><p><em>注：方便起见，输入为int，例如：9:00的输入是900</em></p><p>Output：<br> 3  （最多有3辆列车同时进站（在11:00到11:20之间））</p><h1 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h1><p>暴力解法。逐个检查每个车辆的<strong>停发时间段</strong>，然后看有多少个时间段区间与其有重合，记录最多的重合区间数目，即为待求解的答案。易知，此方法的时间复杂度为O(n^2)。</p><p>下面给出代码，<em>代码只经过简单测试，如有误请通过邮箱联系我</em></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"><span class="keyword">from</span> traitlets <span class="keyword">import</span> Int</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxPlatform</span>(<span class="params">self, arr: <span class="type">List</span>[Int], dep: <span class="type">List</span>[Int]</span>) -&gt; Int:</span></span><br><span class="line">        n = <span class="built_in">len</span>(arr)</span><br><span class="line">        max_platform = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            now_platform = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> dep[i] &gt; arr[j]:</span><br><span class="line">                    now_platform += <span class="number">1</span></span><br><span class="line">                max_platform = <span class="built_in">max</span>(max_platform, now_platform)</span><br><span class="line">        <span class="keyword">return</span> max_platform</span><br></pre></td></tr></table></figure><h1 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h1><p>将所有的<strong>事件</strong> (到达或离开)按时间顺序排序，然后只记录当前还在车站（未离开的）列车。所有时间点中最多数量列车即待求解的答案。该解法的时间复杂度为O(n·logn)</p><p>例如上述出发到达时间排序得到下表：</p><table><thead><tr><th>时间</th><th>事件</th><th>站台数</th></tr></thead><tbody><tr><td>9:00</td><td>Arrival</td><td>1</td></tr><tr><td>9:10</td><td>Departure</td><td>0</td></tr><tr><td>9:40</td><td>Arrival</td><td>1</td></tr><tr><td>9:50</td><td>Arrival</td><td>2</td></tr><tr><td>11:00</td><td>Arrival</td><td><strong>3</strong></td></tr><tr><td>11:20</td><td>Departure</td><td>2</td></tr><tr><td>11:30</td><td>Departure</td><td>1</td></tr><tr><td>12:00</td><td>Departure</td><td>0</td></tr><tr><td>15:00</td><td>Arrival</td><td>1</td></tr><tr><td>18:00</td><td>Arrival</td><td>2</td></tr><tr><td>19:00</td><td>Departure</td><td>1</td></tr><tr><td>20:00</td><td>Departure</td><td>0</td></tr></tbody></table><p>最多需要3站台。</p><p>在算法实现时，只需要对arr、dep数组单独排序，然后在进行有序数组的归并排序。下面给出代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPlatform</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span>[] dep)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        Arrays.sort(dep); <span class="comment">//分别对到达和离开排序</span></span><br><span class="line">        <span class="keyword">int</span> numPlatform = <span class="number">0</span>, maxPlatform = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; <span class="comment">//两个指针</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; n || j &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; n &amp;&amp; j &lt; n) &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i] &lt; dep[j]) &#123;</span><br><span class="line">                    numPlatform++;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(arr[i] &gt; dep[j])&#123;</span><br><span class="line">                    numPlatform--;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(j&gt;=n) &#123; <span class="comment">// 此时还将继续有火车进站</span></span><br><span class="line">                numPlatform++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 此时只有火车出站</span></span><br><span class="line">                numPlatform--;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            maxPlatform = Math.max(maxPlatform, numPlatform);</span><br><span class="line"><span class="comment">//            System.out.println(numPlatform);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxPlatform;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这是之前遇到的一道面试题，挺巧妙的。当时没做出来，故做一个小结。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://www.jianshu.com/p/3948fda91d3d">火车站台数量问题</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题干&quot;&gt;&lt;a href=&quot;#题干&quot; class=&quot;headerlink&quot; title=&quot;题干&quot;&gt;&lt;/a&gt;题干&lt;/h1&gt;&lt;p&gt;假设已知某个火车站的所有过往列车的到达arrival和离开departure时间（同一天），如果要求所有列车都不等待直接进站，问至少需要多少</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://gmet233.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://gmet233.gitee.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Java-初识注解</title>
    <link href="https://gmet233.gitee.io/2021/12/23/Java-%E5%88%9D%E8%AF%86%E6%B3%A8%E8%A7%A3/"/>
    <id>https://gmet233.gitee.io/2021/12/23/Java-%E5%88%9D%E8%AF%86%E6%B3%A8%E8%A7%A3/</id>
    <published>2021-12-23T12:45:17.000Z</published>
    <updated>2021-12-26T14:35:27.532Z</updated>
    
    <content type="html"><![CDATA[<h1 id="初识注解"><a href="#初识注解" class="headerlink" title="初识注解"></a>初识注解</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>Annotation提供了一种为恒旭元素设置元数据的方法。</li><li>类似于修饰符，可用于修饰包、类、构造器、方法、成员变量、参数、局部变量的声明。</li><li>Annotation是一个接口，程序可以通过反射来获取指定程序元素的Annotation对象。</li><li>Annotation不影响程序代码的运行。</li><li>如果希望Annotation在程序运行时起作用，只有通过某种配套工具对Annotation的信息进行访问和处理。访问和处理Annotation的工具统称为APT。</li></ul><h2 id="内置注解"><a href="#内置注解" class="headerlink" title="内置注解"></a>内置注解</h2><p>Java定义了一套注解如下。</p><ul><li>以下注解在java.lang中：<ul><li><strong>@Override</strong> - 检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。</li><li><strong>@Deprecated</strong> - 标记过时方法。如果使用该方法，会报编译警告。</li><li><strong>@SuppressWarnings</strong> - 指示编译器去忽略注解中声明的警告。</li><li>@SafeVarargs - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。</li><li><strong>@FunctionalInterface</strong> - Java 8 开始支持，标识一个匿名函数或函数式接口。</li></ul></li><li>以下注解在java.lang.annotation中，他们作用在其他注解中，也成为<strong>元注解</strong>：<ul><li><strong>@Retention</strong> - 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。</li><li>@Documented - 标记这些注解是否包含在用户文档中。</li><li><strong>@Target</strong> - 标记这个注解应该是哪种 Java 成员。</li><li><strong>@Inherited</strong> - 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类)<ul><li>详解：假设，我们定义了某个 Annotaion，它的名称是 MyAnnotation，并且 MyAnnotation 被标注为 @Inherited。现在，某个类 Base 使用了MyAnnotation，则 Base “具有了注解 MyAnnotation”；现在，Sub 继承了 Base，由于 MyAnnotation 是 @Inherited的(具有继承性)，所以，Sub 也 “具有了注解 MyAnnotation”。</li></ul></li><li>@Repeatable - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。</li></ul></li></ul><h2 id="Annotation架构"><a href="#Annotation架构" class="headerlink" title="Annotation架构"></a>Annotation架构</h2><p><img src="1.jpg" alt="Annotation架构"></p><p>从中可以看出：</p><ol><li>1个Annotation对象，都会有唯一的RetentionPolicy属性。</li><li>1 个 Annotation 对象，可以有若干个 ElementType 属性。</li><li>Annotation 有许多实现类，包括：Deprecated, Documented, Inherited, Override 等等。</li></ol><p>下面介绍，在java Annotation的组成中，有三个重要的主干类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Annotation.java</span></span><br><span class="line"><span class="keyword">package</span> java.lang.annotation;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Annotation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends Annotation&gt; annotationType();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ElementType.java</span></span><br><span class="line"><span class="keyword">package</span> java.lang.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">ElementType</span> </span>&#123;</span><br><span class="line">    TYPE,               <span class="comment">/* 类、接口（包括注释类型）或枚举声明  */</span></span><br><span class="line"></span><br><span class="line">    FIELD,              <span class="comment">/* 字段声明（包括枚举常量）  */</span></span><br><span class="line"></span><br><span class="line">    METHOD,             <span class="comment">/* 方法声明  */</span></span><br><span class="line"></span><br><span class="line">    PARAMETER,          <span class="comment">/* 参数声明  */</span></span><br><span class="line"></span><br><span class="line">    CONSTRUCTOR,        <span class="comment">/* 构造方法声明  */</span></span><br><span class="line"></span><br><span class="line">    LOCAL_VARIABLE,     <span class="comment">/* 局部变量声明  */</span></span><br><span class="line"></span><br><span class="line">    ANNOTATION_TYPE,    <span class="comment">/* 注释类型声明  */</span></span><br><span class="line"></span><br><span class="line">    PACKAGE             <span class="comment">/* 包声明  */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//RetentionPolicy.java</span></span><br><span class="line"><span class="keyword">package</span> java.lang.annotation;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">RetentionPolicy</span> </span>&#123;</span><br><span class="line">    SOURCE,            <span class="comment">/* Annotation信息仅存在于编译器处理期间，编译器处理完之后就没有该Annotation信息了  */</span></span><br><span class="line"></span><br><span class="line">    CLASS,             <span class="comment">/* 编译器将Annotation存储于类对应的.class文件中。默认行为  */</span></span><br><span class="line"></span><br><span class="line">    RUNTIME            <span class="comment">/* 编译器将Annotation存储于class文件中，并且可由JVM读入 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ol><li>Annotation是一个接口，继承这个接口的就是注解。</li><li><strong>ElementType 是 Enum 枚举类型，它用来指定 Annotation 的类型。</strong><ol><li>例如，若一个 Annotation 对象是 METHOD 类型，则该 Annotation 只能用来修饰方法。</li></ol></li><li><strong>RetentionPolicy 是 Enum 枚举类型，它用来指定 Annotation 的策略。通俗点说，就是不同 RetentionPolicy 类型的 Annotation 的作用域不同。</strong><ol><li>若 Annotation 的类型为 SOURCE，则意味着：Annotation 仅存在于编译器处理期间，编译器处理完之后，该 Annotation 就没用了。 例如，” @Override” 标志就是一个 Annotation。当它修饰一个方法的时候，就意味着该方法覆盖父类的方法；并且在编译期间会进行语法检查！编译器处理完后，”@Override” 就没有任何作用了。</li><li>若 Annotation 的类型为 CLASS，则意味着：编译器将 Annotation 存储于类对应的 .class 文件中，它是 Annotation 的默认行为。</li><li>若 Annotation 的类型为 RUNTIME，则意味着：编译器将 Annotation 存储于 class 文件中，并且可由JVM读入。</li></ol></li></ol><h2 id="注解通用定义"><a href="#注解通用定义" class="headerlink" title="注解通用定义"></a>注解通用定义</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation1 &#123;</span><br><span class="line">    <span class="comment">//属性列表</span></span><br><span class="line">    <span class="comment">//Annotation的成员变量在Annotation定义中以无形参方法形式来声明，其方法名和返回值定义了该成员变量的名字和类型。</span></span><br><span class="line">    <span class="comment">//注解元素的类型可以为：基本类型，String，Class，枚举类型，注解类型，以及前面所述类型组成的数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：上面的作用是定义了一个注解，名为MyAnnotation1。定义了MyAnnotation1之后，我们可以在代码中通过@MyAnnotation1使用它。其他的，@Documented, @Target, @Retention, @interface都是来修饰MyAnnotation1的。</p><ul><li><p><strong>@interface</strong>：使用 @interface <strong>关键字</strong>定义注解时，意味着它实现了java.lang.annotation.Annotation 接口，即该注解就是一个Annotation。</p></li><li><p><strong>@Documented</strong>：类和方法的 Annotation 在缺省情况下是不出现在 javadoc 中的。如果使用 @Documented 修饰该 Annotation，则表示它可以出现在 javadoc 中。定义 Annotation 时，@Documented 可有可无；若没有定义，则 Annotation 不会出现在 javadoc 中。</p></li><li><p>**@Target(ElementType.TYPE)**：ElementType 是 Annotation 的类型属性。而 @Target 的作用，就是来指定 Annotation 的类型属性。</p><p>@Target(ElementType.TYPE) 的意思就是指定该 Annotation 的类型是 ElementType.TYPE。这就意味着，MyAnnotation1 是来修饰”类、接口（包括注释类型）或枚举声明”的注解。</p><p>定义 Annotation 时，@Target 可有可无。若有 @Target，则该 Annotation 只能用于它所指定的地方；若没有 @Target，则该 Annotation 可以用于任何地方。</p></li><li><p>**@Retention(RetentionPolicy.RUNTIME)**：前面我们说过，RetentionPolicy 是 Annotation 的策略属性，而 @Retention 的作用，就是指定 Annotation 的策略属性。</p><p>@Retention(RetentionPolicy.RUNTIME) 的意思就是指定该 Annotation 的策略是 RetentionPolicy.RUNTIME。这就意味着，编译器会将该 Annotation 信息保留在 .class 文件中，并且能被虚拟机读取。</p><p>定义 Annotation 时，@Retention 可有可无。若没有 @Retention，则默认是 RetentionPolicy.CLASS。</p></li></ul><p>根据注解是否包含成员变量，可以把注解分为</p><ul><li>标记注解：没有成员变量的注解，这种注解仅利用自身是否存在来提供信息。</li><li>元数据注解：包含成员变量的注解，因为它可以接受更多的元数据，所以也被称为元数据注解。</li></ul><h2 id="Annotation作用"><a href="#Annotation作用" class="headerlink" title="Annotation作用"></a>Annotation作用</h2><h3 id="编译检查"><a href="#编译检查" class="headerlink" title="编译检查"></a>编译检查</h3><p>Annotation 具有”让编译器进行编译检查的作用”。@SuppressWarnings, @Deprecated 和 @Override 都具有编译检查作用。</p><h3 id="☆在反射中解析并使用-Annotation"><a href="#☆在反射中解析并使用-Annotation" class="headerlink" title="☆在反射中解析并使用 Annotation"></a>☆在反射中解析并使用 Annotation</h3><p>程序通过反射机制可以解析被修饰的方法中的注解数据，当程序获取特殊标记后，可以做出相应的处理。这在Spring等框架中经常使用。详见下面代码。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AnnotationTest.java</span></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Annotation;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Inherited;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Annotation在反射函数中的使用示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 说明：在这里，我们不能把value()看成一个方法，而是一个同名的变量</span></span><br><span class="line"><span class="comment">     * 在使用的时候可以通过@MyAnnotation(value=&#123;&quot;a&quot;,&quot;b&quot;&#125;来赋值</span></span><br><span class="line"><span class="comment">     * default 给value制定了默认值</span></span><br><span class="line"><span class="comment">     * 如果注解的属性只有一个，且叫value，那么使用该注解时，可以不用指定属性名，因为默认就是给value赋值：</span></span><br><span class="line"><span class="comment">     * @MyAnnotation(&#123;&quot;a&quot;,&quot;b&quot;&#125;) //这样也是可以的</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">    String[] value() default &quot;unknown&quot;;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Person类。它会使用MyAnnotation注解。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * empty()方法同时被 &quot;<span class="doctag">@Deprecated</span>&quot; 和 &quot;<span class="doctag">@MyAnnotation</span>(value=&#123;&quot;a&quot;,&quot;b&quot;&#125;)&quot;所标注</span></span><br><span class="line"><span class="comment">     * (01) <span class="doctag">@Deprecated</span>，意味着empty()方法，不再被建议使用</span></span><br><span class="line"><span class="comment">     * (02) <span class="doctag">@MyAnnotation</span>, 意味着empty() 方法对应的MyAnnotation的value值是默认值&quot;unknown&quot;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@MyAnnotation</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">empty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;\nempty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * sombody() 被 <span class="doctag">@MyAnnotation</span>(value=&#123;&quot;girl&quot;,&quot;boy&quot;&#125;) 所标注，</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@MyAnnotation</span>(value=&#123;&quot;girl&quot;,&quot;boy&quot;&#125;), 意味着MyAnnotation的value值是&#123;&quot;girl&quot;,&quot;boy&quot;&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@MyAnnotation(value=&#123;&quot;girl&quot;,&quot;boy&quot;&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">somebody</span><span class="params">(String name, <span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;\nsomebody: &quot;</span>+name+<span class="string">&quot;, &quot;</span>+age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 新建Person</span></span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        <span class="comment">// 获取Person的Class实例</span></span><br><span class="line">        Class&lt;Person&gt; c = Person.class;</span><br><span class="line">        <span class="comment">// 获取 somebody() 方法的Method实例</span></span><br><span class="line">        Method mSomebody = c.getMethod(<span class="string">&quot;somebody&quot;</span>, <span class="keyword">new</span> Class[]&#123;String.class, <span class="keyword">int</span>.class&#125;);</span><br><span class="line">        <span class="comment">// 执行该方法</span></span><br><span class="line">        mSomebody.invoke(person, <span class="keyword">new</span> Object[]&#123;<span class="string">&quot;lily&quot;</span>, <span class="number">18</span>&#125;);</span><br><span class="line">        iteratorAnnotations(mSomebody);</span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 somebody() 方法的Method实例</span></span><br><span class="line">        Method mEmpty = c.getMethod(<span class="string">&quot;empty&quot;</span>, <span class="keyword">new</span> Class[]&#123;&#125;);</span><br><span class="line">        <span class="comment">// 执行该方法</span></span><br><span class="line">        mEmpty.invoke(person, <span class="keyword">new</span> Object[]&#123;&#125;);        </span><br><span class="line">        iteratorAnnotations(mEmpty);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iteratorAnnotations</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断 somebody() 方法是否包含MyAnnotation注解</span></span><br><span class="line">        <span class="keyword">if</span>(method.isAnnotationPresent(MyAnnotation.class))&#123;</span><br><span class="line">            <span class="comment">// 获取该方法的MyAnnotation注解实例</span></span><br><span class="line">            MyAnnotation myAnnotation = method.getAnnotation(MyAnnotation.class);</span><br><span class="line">            <span class="comment">// 获取 myAnnotation的值，并打印出来</span></span><br><span class="line">            String[] values = myAnnotation.value();</span><br><span class="line">            <span class="keyword">for</span> (String str:values)</span><br><span class="line">                System.out.printf(str+<span class="string">&quot;, &quot;</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 获取方法上的所有注解，并打印出来</span></span><br><span class="line">        Annotation[] annotations = method.getAnnotations();</span><br><span class="line">        <span class="keyword">for</span>(Annotation annotation : annotations)&#123;</span><br><span class="line">            System.out.println(annotation);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">somebody: lily, 18</span><br><span class="line">girl, boy, </span><br><span class="line">@com.skywang.annotation.MyAnnotation(value=[girl, boy])</span><br><span class="line"></span><br><span class="line">empty</span><br><span class="line">unknown, </span><br><span class="line">@com.skywang.annotation.MyAnnotation(value=[unknown])</span><br><span class="line">@java.lang.Deprecated()</span><br></pre></td></tr></table></figure><h3 id="根据Annotation生成帮助文档"><a href="#根据Annotation生成帮助文档" class="headerlink" title="根据Annotation生成帮助文档"></a>根据Annotation生成帮助文档</h3><p>@Documented</p><h3 id="帮忙查看代码"><a href="#帮忙查看代码" class="headerlink" title="帮忙查看代码"></a>帮忙查看代码</h3><p>通过 @Override, @Deprecated 等，我们能很方便的了解程序的大致结构。</p><h3 id="附属文件的自动生成"><a href="#附属文件的自动生成" class="headerlink" title="附属文件的自动生成"></a>附属文件的自动生成</h3><p>例如部署描述符或者bean信息类。</p><h3 id="测试、日志等代码的自动生成"><a href="#测试、日志等代码的自动生成" class="headerlink" title="测试、日志等代码的自动生成"></a>测试、日志等代码的自动生成</h3><p>//TODO</p><h2 id="框架中常用的注解"><a href="#框架中常用的注解" class="headerlink" title="框架中常用的注解"></a>框架中常用的注解</h2><h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><p>//TODO</p><h3 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h3><p>//TODO</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li><p>注解就像标签，是程序判断执行的依据。比如，程序读到@Test就知道这个方法是待测试方法，而@Before的方法要在测试方法之前执行</p></li><li><p>注解需要三要素：定义、使用、<strong>读取并执行</strong></p></li><li><p>注解分为自定义注解、JDK内置注解和第三方注解（框架）。自定义注解一般要我们自己定义、使用、并写程序读取，而JDK内置注解和第三方注解我们只要使用，定义和读取都交给它们</p></li><li><p>大多数情况下，三角关系中我们只负责使用注解，无需定义和执行，框架会将注解类和读取注解的程序隐藏起来，除非阅读源码，否则根本看不到。平时见不到定义和读取的过程，光顾着使用注解，久而久之很多人就忘了注解如何起作用了！</p></li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://www.zhihu.com/question/47449512/answer/658228092">怎样理解 Java 注解和运用注解编程？</a></li><li><a href="https://www.runoob.com/w3cnote/java-annotation.html">菜鸟教程-Java 注解（Annotation）</a></li><li>《Java疯狂讲义 第十四章 注解》</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;初识注解&quot;&gt;&lt;a href=&quot;#初识注解&quot; class=&quot;headerlink&quot; title=&quot;初识注解&quot;&gt;&lt;/a&gt;初识注解&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h</summary>
      
    
    
    
    <category term="Java" scheme="https://gmet233.gitee.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://gmet233.gitee.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>编写脚本读取文件并执行命令</title>
    <link href="https://gmet233.gitee.io/2021/12/21/%E7%BC%96%E5%86%99%E8%84%9A%E6%9C%AC%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E5%B9%B6%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4/"/>
    <id>https://gmet233.gitee.io/2021/12/21/%E7%BC%96%E5%86%99%E8%84%9A%E6%9C%AC%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E5%B9%B6%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4/</id>
    <published>2021-12-21T13:38:58.000Z</published>
    <updated>2021-12-21T13:41:30.569Z</updated>
    
    <content type="html"><![CDATA[<p>最近遇到如下需求：</p><blockquote><p>有一个文件，文件格式大概是这样</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;filename1&gt;\t&lt;download_url1&gt;</span><br><span class="line"></span><br><span class="line">&lt;filename2&gt;\t&lt;download_url2&gt;</span><br></pre></td></tr></table></figure><p>编写一个脚本循环读取该文件的每一行，使用<code>axel</code>命令将<code>download_url</code>下载下来，保存为本地文件<code>filename</code></p></blockquote><h1 id="Bash"><a href="#Bash" class="headerlink" title="Bash"></a>Bash</h1><p>先给出Code：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ./download.sh &lt;filename&gt;</span></span><br><span class="line"></span><br><span class="line">cat <span class="variable">$1</span> | <span class="keyword">while</span> <span class="built_in">read</span> line</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="comment"># echo $&#123;line&#125;</span></span><br><span class="line">    array=(<span class="variable">$&#123;line// / &#125;</span>) <span class="comment"># array=($&#123;line//\t/ &#125;) 不生效</span></span><br><span class="line">    <span class="comment"># echo $&#123;array[0]&#125; + &quot;;&quot; + $&#123;array[1]&#125; </span></span><br><span class="line">    cmd=<span class="string">&#x27;axel -o &#x27;</span><span class="variable">$&#123;array[0]&#125;</span><span class="string">&#x27; &quot;&#x27;</span><span class="variable">$&#123;array[1]&#125;</span><span class="string">&#x27;&quot;&#x27;</span></span><br><span class="line">    <span class="built_in">eval</span> <span class="variable">$cmd</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>下面对code逐一解释</p><h2 id="bin-bash"><a href="#bin-bash" class="headerlink" title="#! /bin/bash"></a>#! /bin/bash</h2><p><strong>#!/bin/bash</strong>是指此脚本使用**/bin/bash**来解释执行，Bash脚本首行固定写法。</p><h2 id="Bash注释"><a href="#Bash注释" class="headerlink" title="Bash注释"></a>Bash注释</h2><p>Bash中使用<code>#</code>进行单行注释，见如上代码第三行</p><h2 id="Bash-接收外部参数"><a href="#Bash-接收外部参数" class="headerlink" title="Bash 接收外部参数"></a>Bash 接收外部参数</h2><p>我们可以在执行 Shell 脚本时，向脚本传递参数，脚本内获取参数的格式为：**$n<strong>。</strong>n** 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推……</p><p>特殊的 ，**$0** 表示脚本名称（含路径）。</p><p>另外，**$#** 表示传递参数的个数。</p><p>上面代码中<code>cat $1 |</code>就是将第一个参数作为文件名，读取文件中的内容，通过管道命令<code>|</code>将文件内容传给while循环</p><h2 id="Bash-循环读取每一行"><a href="#Bash-循环读取每一行" class="headerlink" title="Bash 循环读取每一行"></a>Bash 循环读取每一行</h2><p>最简单的</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> line</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$line</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>还可以使用for循环等，详细可参见参考资料1。</p><h2 id="Bash按指定字符分割字符串"><a href="#Bash按指定字符分割字符串" class="headerlink" title="Bash按指定字符分割字符串"></a>Bash按指定字符分割字符串</h2><p>接上文，line是待处理的字符串，则指定分隔符<code>\t</code>将line分割后的字符串数组存放到array，</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">array=(<span class="variable">$&#123;line// / &#125;</span>)</span><br></pre></td></tr></table></figure><p>注意这里<code>//</code>和<code>/</code>之间是一个制表符，而不是空格。</p><p>我也曾使用<code>array=($&#123;line//\t/ &#125;)</code>来进行分割，但是测试后发现它会按照字符<code>t</code>对字符串进行分割。</p><p><em>还没弄明白语法规则</em></p><h2 id="Bash字符串拼接"><a href="#Bash字符串拼接" class="headerlink" title="Bash字符串拼接"></a>Bash字符串拼接</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmd=<span class="string">&#x27;axel -o &#x27;</span><span class="variable">$&#123;array[0]&#125;</span><span class="string">&#x27; &quot;&#x27;</span><span class="variable">$&#123;array[1]&#125;</span><span class="string">&#x27;&quot;&#x27;</span></span><br></pre></td></tr></table></figure><p>这一行就是取array中的值进行字符串拼接，注意取值的语法<code>$&#123;&#125;</code></p><ul><li><p>Bash中对字符串拼接不需要使用<code>+</code>进行连接</p></li><li><p>这里使用单引号是为了避免对双引号转义</p></li></ul><h2 id="Bash执行cmd"><a href="#Bash执行cmd" class="headerlink" title="Bash执行cmd"></a>Bash执行cmd</h2><p><code>eval $cmd</code>是读取变量cmd的值当作一条Shell命令进行执行</p><h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><p>上面的代码先读取每一行，在对行按照制表符进行分割。其实可以更简洁：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> filenameurl</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="comment">#echo $filename</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>同样的需要注意<code>filename</code>，<code>url</code>之间是一个制表符而不是空格。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>当url过长时，该脚本并不能完整的读取url。例如，当文件如下时</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">covid19-image-dataset-collection-volumes-folder.ziphttps://storage.googleapis.com/kaggle-data-sets/862993/1470970/bundle/archive.zip?X-Goog-Algorithm=GOOG4-RSA-SHA256&amp;X-Goog-Credential=gcp-kaggle-com%40kaggle-161607.iam.gserviceaccount.com%2F20211221%2Fauto%2Fstorage%2Fgoog4_request&amp;X-Goog-Date=20211221T052609Z&amp;X-Goog-Expires=259199&amp;X-Goog-SignedHeaders=host&amp;X-Goog-Signature=6549111df89ca0440058e7061ba9a13d72ea22ed7bcfdbcfc56ddadaf7a54ec4d3285487b269808d60cf0568264db1803899989475d8ca0aeec0777891f54df612a6a8f7ba808c8df3899feda1a94ca0507a580e407c0e42371d97e3ce1c75d598bed1f693bf841f7d4660294488e99fc944d6e1498c5ec38b431b969e5f13eda5f2d8029e855ea368c57eab60897a32f7556df116a96bfd321dd4d214dfe847d4c8ca11fdb7c3472ebac9f7a9eb20b44a148df51ecb2f93acdc5459800a894cdc2d62a0cc2c2e42e6711e568827f44b82d6faaa02aa1357c8d93140eb2c72bde9b8c1716e565800ac3ff812df304ce7a54c2a83896696ac5fa935329afa66ef</span><br></pre></td></tr></table></figure><p>读取并拼接后的命令字符串如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">axel -o covid19-image-dataset-collection-volumes-folder.zip &quot;https://storage.googleapis.com/kaggle-data-sets/862993/1470970/bundle/archive.zip?X-Goog-Algorithm=GOOG4-RSA-SHA256&amp;X-Goog-Credential=gcp-kaggle-com%40kaggle-161607.iam.gserviceaccount.com%2F20211221%2Fauto%2Fstorage%2Fgoog4_request&amp;X-Goog-Date=20211221T052609Z&amp;X-Goog-Expires=259199&amp;X-Goog-SignedHeaders=host&amp;X-Goog-Signature=6549111df89ca0440058e7061ba9a13d72ea22ed7bcfdbcfc56ddadaf7a54ec4d3285487b269808d60cf0568264db1803899989475d8ca0aeec0777891f54df612a6a8f7ba808c8df3899feda1a94ca0507a580e407c0e42371d97e3ce1c75d598bed1f693bf841f7d4660294488e99fc944d6e1498c5ec38b431b969e5f13eda5f2d8029e855ea368c57eab60897a32f7556df116a96bfd321dd4d214dfe847d4c8ca11fdb7c3472ebac9f7a9eb20b44a148df51ecb2f93acdc5459800a894cdc2d62a0cc2c2e42e6711e568827f44b82d6faaa02aa1357c8d93140eb2c72bde9b8c1716e565800ac3ff812df304ce7a54c2a83896696ac5fa9353&quot;9afa66ef</span><br></pre></td></tr></table></figure><p>注意引号外面还有数据，这是不符合预期的。</p><p><em>目前还没有解决该问题</em></p><h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><p>由于本人对Bash不是很熟悉，所以改用Python来完成这一需求。</p><p>下面给出完整代码</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#python download.py -f list</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    parser = argparse.ArgumentParser(description=<span class="string">&quot;download kaggle dataset according to file&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;-f&#x27;</span>, <span class="string">&#x27;--filename&#x27;</span>, required=<span class="literal">True</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, <span class="built_in">help</span>=<span class="string">&#x27;filename&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">    filename = args.filename</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        lines = f.readlines()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        arr = line.split(<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">        save_name = arr[<span class="number">0</span>]</span><br><span class="line">        url = arr[<span class="number">1</span>].replace(<span class="string">&quot;\n&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        cmd = <span class="string">&#x27;axel -o &#x27;</span> + save_name + <span class="string">&#x27; &quot;&#x27;</span> + url + <span class="string">&#x27;&quot;&#x27;</span></span><br><span class="line">        <span class="comment"># print(cmd)</span></span><br><span class="line">        res_f = os.popen(cmd)  <span class="comment"># 返回的是一个文件对象</span></span><br><span class="line">        <span class="built_in">print</span>(res_f.read())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="Python-main函数"><a href="#Python-main函数" class="headerlink" title="Python main函数"></a>Python main函数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>这是Python的main函数，Python脚本总会从该“函数“进入。</p><h2 id="Python-接收外部参数"><a href="#Python-接收外部参数" class="headerlink" title="Python 接收外部参数"></a>Python 接收外部参数</h2><p>使用类库<code>argparse</code>来读取外部参数。上述代码给出了一个简单的示例</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">parser = argparse.ArgumentParser(description=<span class="string">&quot;download kaggle dataset according to file&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">第一、二个参数是指定参数名，第一个是简写形式</span></span><br><span class="line"><span class="string">在调用命令的时候，可以使用python script.py -f &lt;param&gt;或者python script.py --filename &lt;param&gt;</span></span><br><span class="line"><span class="string">required=True 表示该参数必填</span></span><br><span class="line"><span class="string">type=str 指定参数类型</span></span><br><span class="line"><span class="string">help=&#x27;filename&#x27; 指定提示语</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">parser.add_argument(<span class="string">&#x27;-f&#x27;</span>, <span class="string">&#x27;--filename&#x27;</span>, required=<span class="literal">True</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, <span class="built_in">help</span>=<span class="string">&#x27;filename&#x27;</span> 指定提示语)</span><br><span class="line"></span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">filename = args.filename  <span class="comment"># filename存放了外部参数的值</span></span><br></pre></td></tr></table></figure><p>详细请参见<code>参考资料2</code></p><h2 id="Python文件、字符串操作"><a href="#Python文件、字符串操作" class="headerlink" title="Python文件、字符串操作"></a>Python文件、字符串操作</h2><p>略</p><h2 id="在Python中执行Shell命令"><a href="#在Python中执行Shell命令" class="headerlink" title="在Python中执行Shell命令"></a>在Python中执行Shell命令</h2><p>有两种方式。使用<code>os.system(&quot;command&quot;)</code>执行无返回值的Shell命令；使用<code>f = os.popen(&quot;command&quot;)</code>执行有输出的Shell命令，其返回值<code>f</code>是一个文件对象，通过<code>f.read()</code>来读取命令输出内容。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="http://c.biancheng.net/shell/">Shell 脚本学习指南</a></li><li><a href="https://docs.python.org/zh-cn/3/howto/argparse.html">Python Argparse 教程</a></li><li><a href="https://blog.csdn.net/qq_27825451/article/details/102909772">python执行shell脚本的几种方法</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近遇到如下需求：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有一个文件，文件格式大概是这样&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;</summary>
      
    
    
    
    <category term="Linux" scheme="https://gmet233.gitee.io/categories/Linux/"/>
    
    <category term="Scripts" scheme="https://gmet233.gitee.io/categories/Linux/Scripts/"/>
    
    
    <category term="Linux Bash" scheme="https://gmet233.gitee.io/tags/Linux-Bash/"/>
    
    <category term="Python" scheme="https://gmet233.gitee.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>田忌赛马与贪心法则</title>
    <link href="https://gmet233.gitee.io/2021/12/20/%E7%94%B0%E5%BF%8C%E8%B5%9B%E9%A9%AC%E4%B8%8E%E8%B4%AA%E5%BF%83%E6%B3%95%E5%88%99/"/>
    <id>https://gmet233.gitee.io/2021/12/20/%E7%94%B0%E5%BF%8C%E8%B5%9B%E9%A9%AC%E4%B8%8E%E8%B4%AA%E5%BF%83%E6%B3%95%E5%88%99/</id>
    <published>2021-12-20T13:59:45.000Z</published>
    <updated>2021-12-20T14:01:55.082Z</updated>
    
    <content type="html"><![CDATA[<p>本文涉及*<a href="https://leetcode-cn.com/problems/advantage-shuffle/">LeetCode 870. 优势洗牌</a>*</p><blockquote><p>给定两个大小相等的数组 A 和 B，A 相对于 B 的优势可以用满足 A[i] &gt; B[i] 的索引 i 的数目来描述。返回 A 的任意排列，使其相对于 B 的优势最大化。</p><p>示例 1：</p><p>输入：A = [2,7,11,15], B = [1,10,4,11]<br>输出：[2,11,7,15]<br>示例 2：</p><p>输入：A = [12,24,8,32], B = [13,25,32,11]<br>输出：[24,32,8,12]</p></blockquote><p>这就像⽥忌赛⻢的情景，nums1 就是⽥忌的⻢，nums2 就是⻬王的⻢，数组中的元素就是⻢的战⽃⼒：</p><p>算法策略是：<strong>将⻬王和⽥忌的⻢按照战⽃⼒排序，然后按照排名⼀⼀对⽐。如果⽥忌的⻢能赢，那就⽐赛，如果赢不了，那就换个垫底的来送⼈头，保存实⼒。</strong></p><p>这里要注意一个问题：是否需要保存实力，即如果⽥忌的⼆号选⼿也能⼲得过⻬王的⼀号选⼿，此时让⼆号选⼿去对决⻬王的⼀号选⼿，不是更节约？</p><p>这种节约的策略是没问题的，但是<strong>没有必要</strong>。</p><p>我们暂且把⽥忌的⼀号选⼿称为 T1，⼆号选⼿称为 T2，⻬王的⼀号选⼿称为 Q1。如果 T2 能赢 Q1，你试图保存⼰⽅实⼒，让 T2 去战 Q1，把 T1 留着是为了对付谁？显然，你担⼼⻬王还有战⼒⼤于 T2 的⻢，可以让 T1 去对付。但是你仔细想想，现在 T2 已经是可以战胜 Q1 的，Q1 可是⻬王的最快的⻢，⻬王剩下的那些⻢⾥，怎么可能还有⽐ T2 更强的⻢？</p><p>所以没必要节约。</p><p>根据上述思路得到的代码逻辑如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对两个数组nums1和nums2排序</span><br><span class="line">对两个数组的元素挨个比较，如果nums1[i]&gt;nums2[i]那就比，否则就换上nums1最小的元素进行比较。</span><br></pre></td></tr></table></figure><p>由于需要对两个数组排序，但是返回结果依赖nums2的顺序，所以不能直接对nums2进行排序，而是利用优先级队列。（将(index, nums2[index]放入优先级队列，出队优先级按照nums2[index]大小，index记录索引值）</p><p>此外，解法还是用到双指针技巧。完整代码如下。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] advantageCount(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums1.length;</span><br><span class="line">    <span class="comment">// 给 nums2 降序排序</span></span><br><span class="line">    PriorityQueue&lt;<span class="keyword">int</span>[]&gt; maxpq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(</span><br><span class="line">        (<span class="keyword">int</span>[] pair1, <span class="keyword">int</span>[] pair2) -&gt; &#123; </span><br><span class="line">            <span class="keyword">return</span> pair2[<span class="number">1</span>] - pair1[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        maxpq.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, nums2[i]&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 给 nums1 升序排序</span></span><br><span class="line">    Arrays.sort(nums1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// nums1[left] 是最小值，nums1[right] 是最大值</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!maxpq.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] pair = maxpq.poll();</span><br><span class="line">        <span class="comment">// maxval 是 nums2 中的最大值，i 是对应索引</span></span><br><span class="line">        <span class="keyword">int</span> i = pair[<span class="number">0</span>], maxval = pair[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (maxval &lt; nums1[right]) &#123;</span><br><span class="line">            <span class="comment">// 如果 nums1[right] 能胜过 maxval，那就自己上</span></span><br><span class="line">            res[i] = nums1[right];</span><br><span class="line">            right--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则用最小值去换nums2的最大值</span></span><br><span class="line">            res[i] = nums1[left];</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247491139&idx=1&sn=10cb35e0056ac8f8c540fccd0156f333&scene=21&ascene=7&devicetype=iOS15.2&version=1800103a&nettype=WIFI&abtest_cookie=AAACAA==&lang=zh_CN&fontScale=100&exportkey=A2t5E2fVKmwEJxWEKsScbfU=&pass_ticket=n3zshxiiR8IMf1IfoZgzB+PSm6RatluaPa8vtuS3bDtR2ttHhdhxmZkQCXMUyC9L&wx_header=1">labuladong: 算法大师——孙膑</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文涉及*&lt;a href=&quot;https://leetcode-cn.com/problems/advantage-shuffle/&quot;&gt;LeetCode 870. 优势洗牌&lt;/a&gt;*&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定两个大小相等的数组 A 和 B，A 相对于 B </summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://gmet233.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="数组/链表" scheme="https://gmet233.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84-%E9%93%BE%E8%A1%A8/"/>
    
    
    <category term="数据结构与算法" scheme="https://gmet233.gitee.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="贪心" scheme="https://gmet233.gitee.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>PriorityQueue 概述</title>
    <link href="https://gmet233.gitee.io/2021/12/19/PriorityQueue-%E6%A6%82%E8%BF%B0/"/>
    <id>https://gmet233.gitee.io/2021/12/19/PriorityQueue-%E6%A6%82%E8%BF%B0/</id>
    <published>2021-12-19T08:58:37.000Z</published>
    <updated>2021-12-19T09:06:39.869Z</updated>
    
    <content type="html"><![CDATA[<h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><p><code>Queue</code>是一个严格的先进先出（FIFO）的队列。</p><p>但有时候这并不能满足我们的需求。当我们需要对队列中的元素重排，按照重排后的元素顺序出队时，这时候就需要<code>PriorityQueue</code>。</p><p><code>PriorityQueue</code>和<code>Queue</code>的区别在于，它的出队顺序与元素的优先级有关，对<code>PriorityQueue</code>调用<code>remove()</code>或<code>poll()</code>方法，返回的总是优先级最高的元素。</p><p>要使用<code>PriorityQueue</code>，我们就必须给每个元素定义“优先级”。请看下面的例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPriorityQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Queue&lt;User&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(</span><br><span class="line">                (User user1, User user2) -&gt; &#123;</span><br><span class="line">                    <span class="keyword">return</span> user2.getLevel() - user1.getLevel();</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">        queue.offer(<span class="keyword">new</span> User(<span class="string">&quot;sb_1&quot;</span>, <span class="number">1</span>)); <span class="comment">//优先级低</span></span><br><span class="line">        queue.offer(<span class="keyword">new</span> User(<span class="string">&quot;vip_1&quot;</span>, <span class="number">2</span>)); <span class="comment">//优先级高</span></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            User user = queue.poll();</span><br><span class="line">            System.out.println(user.getName());</span><br><span class="line">        &#125; <span class="comment">//出队的顺序是vip_1, sb_1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> level;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.level = level;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//getter、setter</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的例子使用lambda表达式实现了排序。你也可以自定义排序器（实现Comparable接口），然后将排序器对象传递给<code>PriorityQueue</code>构造器。构造函数签名如下：</p><p><code>public PriorityQueue(Comparator&lt;? super E&gt; comparator)</code></p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>通过堆实现，具体说是通过完全二叉树（<em>complete binary tree</em>）实现的<strong>小顶堆</strong>（任意一个非叶子节点的权值，都不大于其左右子节点的权值）。</p><p>具体请参考<strong>堆排序</strong>。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1265120632401152">https://www.liaoxuefeng.com/wiki/1252599548343744/1265120632401152</a></li><li><a href="https://www.cnblogs.com/CarpenterLee/p/5488070.html">https://www.cnblogs.com/CarpenterLee/p/5488070.html</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;快速入门&quot;&gt;&lt;a href=&quot;#快速入门&quot; class=&quot;headerlink&quot; title=&quot;快速入门&quot;&gt;&lt;/a&gt;快速入门&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Queue&lt;/code&gt;是一个严格的先进先出（FIFO）的队列。&lt;/p&gt;
&lt;p&gt;但有时候这并不能满足我们的需求。</summary>
      
    
    
    
    <category term="Java" scheme="https://gmet233.gitee.io/categories/Java/"/>
    
    <category term="集合" scheme="https://gmet233.gitee.io/categories/Java/%E9%9B%86%E5%90%88/"/>
    
    
    <category term="Java" scheme="https://gmet233.gitee.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>单例设计模式</title>
    <link href="https://gmet233.gitee.io/2021/12/16/%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://gmet233.gitee.io/2021/12/16/%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-12-16T13:19:39.000Z</published>
    <updated>2021-12-16T13:48:11.500Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>单例模式确保一个类只有一个实例，并提供了一个全局访问点。</p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>线程池，数据库连接对象。</p><h1 id="经典单例模式"><a href="#经典单例模式" class="headerlink" title="经典单例模式"></a>经典单例模式</h1><p>一个经典的单例模式实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> This is not thread safe!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> uniqueInstance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该实现是线程不安全的。可以想象有两个线程同时进入了getInstance()方法。</p><h1 id="解决经典单例模式线程安全问题"><a href="#解决经典单例模式线程安全问题" class="headerlink" title="解决经典单例模式线程安全问题"></a>解决经典单例模式线程安全问题</h1><p>解决方案，给getInstance方法加上synchronized关键字，迫使每个线程进入该方法前都需要等待别的线程离开该方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> uniqueInstance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该解决方案得缺点就是只有第一次执行该方法才真正需要线程同步。</p><h1 id="更进一步…"><a href="#更进一步…" class="headerlink" title="更进一步…"></a>更进一步…</h1><p>这里给出三种改善方案：</p><ol><li>如果getInstance得性能对于应用程序不是很关键，就什么也别做。</li><li>使用“急切”创建实例，而不用延迟实例化的做法。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>使用<strong>双重检查加锁</strong>，在getInstance中减少使用同步。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>备注：</p><ul><li>首先检查实例是否存在，如果不存在再进入同步代码块。</li><li>进入区块后在检查一次，如果仍然是null则创建实例。</li><li>volatile关键字确保：当instance变量初始化后，多个线程正确的处理instance变量。</li></ul><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><blockquote><p>两个类加载器可能有机会创建自己的单例实例？</p></blockquote><p>是的。所以如果你的程序有多个类加载器又同时使用了单例模式，请小心。解决方法是自行指定类加载器，并指定同一个类加载器。</p><blockquote><p>类如果能做两件事，就违反了OO设计。单例模式是否违反了这样的观念呢？</p></blockquote><p>单例类不止负责管理自己的实例，还在应用程序中担任角色，所以可以视为是两个责任。但是由类管理自己的实例的做法并不少见，也可以让设计更简单。</p><blockquote><p>我想把单例类当成超类，设计出子类。究竟可不可以继承单例类。</p></blockquote><p>不能。继承单例类遇到的一个问题就是构造器是私有的。你不能用私有构造器来扩展类。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《Head First设计模式》(中文版)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;单例模式确保一个类只有一个实例，并提供了一个全局访问点。&lt;/p&gt;
&lt;h1 id=&quot;应用&quot;&gt;&lt;a href=&quot;#应用&quot; class=&quot;head</summary>
      
    
    
    
    <category term="设计模式" scheme="https://gmet233.gitee.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="Java" scheme="https://gmet233.gitee.io/tags/Java/"/>
    
    <category term="设计模式" scheme="https://gmet233.gitee.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
