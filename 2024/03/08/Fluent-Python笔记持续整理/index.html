<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Fluent Python笔记持续整理"><meta name="keywords" content="Python"><meta name="author" content="Met Guo"><meta name="copyright" content="Met Guo"><title>Fluent Python笔记持续整理 | Gmet's Blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.8.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.8.2"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"LEZCUKXOU8","apiKey":"43c226e390cd280e256d1d7cc0e6cce4","indexName":"blogs","hits":{"per_page":10,"input_placeholder":"Search for Posts","hits_empty":"û���ҵ�����Ҫ�Ľ��: ${query}","hits_stats":"�ҵ�${hits}���������ʱ${time}���룩"},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.2'
} </script><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Gmet's Blog" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Met Guo</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">87</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">70</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">47</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://images7.alphacoders.com/550/thumb-1920-550739.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Gmet's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/slides">Slides</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">Fluent Python笔记持续整理</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2024-03-08</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Python/">Python</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Python/%E5%9F%BA%E7%A1%80/">基础</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">13k</span><span class="post-meta__separator">|</span><span>阅读时长: 45 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><blockquote>
<p>后面几节没整理；没有目录；一些重要章节不是很全，仅仅是介绍。</p>
<p>Ref：<a target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-1816710-1-1.html">https://www.52pojie.cn/thread-1816710-1-1.html</a></p>
</blockquote>
<p>在Python中，如果一个类定义了<code>__getitem__</code>方法，那么该类的对象可以像序列（如列表、字符串等）一样使用索引运算符[]来访问其元素。 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Seq</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.data = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, index</span>):</span><br><span class="line">        <span class="keyword">return</span> self.data[index]</span><br><span class="line">    </span><br><span class="line">seq = Seq()</span><br><span class="line">seq[<span class="number">0</span>:<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<p>这类方法称为魔术方法，类似的还有<code>__len__</code>, <code>__setitem__</code>, <code>__str__</code>, <code>__repr__</code>, <code>__add__</code>, <code>__eq__</code>等</p>
<p><code>__str__</code>和<code>__repr__</code>用于定义对象的字符串表示形式。<code>__str__</code>方法用于返回对象的人类可读的字符串表示形式，通常用于打印输出或显示给用户。 <code>__repr__</code>方法用于返回对象的官方字符串表示形式，通常用于调试和开发过程中。 下面是一个示例，展示了如何在自定义类中使用<code>__str__</code>和<code>__repr__</code>方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x, y</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;print..Point(<span class="subst">&#123;self.x&#125;</span>, <span class="subst">&#123;self.y&#125;</span>)&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;Point(<span class="subst">&#123;self.x&#125;</span>, <span class="subst">&#123;self.y&#125;</span>)&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">p = Point(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(p)</span><br><span class="line"><span class="built_in">repr</span>(p)</span><br></pre></td></tr></table></figure>
<p>总结魔术方法 TODO</p>
<hr>
<p>列表推导式： [expression for item in iterable if condition]<br>在处理大型数据集时，列表推导式可能会影响性能，这时应考虑使用生成器表达式或其他更适合的方法。</p>
<p>在Python中，map()和filter()是两个内置函数，用于对可迭代对象进行映射和过滤操作。 1. map()函数：   map()函数接受一个函数和一个或多个可迭代对象作为参数，将函数应用于每个可迭代对象中的元素，并返回一个新的迭代器（在Python 3中返回迭代器，在Python 2中返回列表）。    map()函数的语法如下：<br>map(function, iterable, …)  </p>
<p>filter()函数：   filter()函数接受一个函数和一个可迭代对象作为参数，根据函数的返回值（True或False）来过滤可迭代对象中的元素，并返回一个新的迭代器（在Python 3中返回迭代器，在Python 2中返回列表）。    filter()函数的语法如下：   </p>
<p>filter(function, iterable)</p>
<p>使用map()和filter()函数可以简化对列表的处理，使代码更简洁、可读性更高。然而，请注意在处理大型数据集时，这些函数可能会影响性能，这时应考虑使用列表推导式或其他更适合的方法。</p>
<p>生成器表达式与列表推导式的语法非常相似，只是将[]替换为()，从而创建一个生成器对象而不是列表对象。以下是生成器表达式的一般语法格式</p>
<p>(expression for item in iterable if condition)</p>
<p>与列表推导式不同，生成器表达式生成的是一个迭代器，而不是立即生成一个完整的列表。这种延迟计算的特性使得生成器表达式非常适合处理大数据集或无限序列。</p>
<p>拆包：拆包（Unpacking）是一种将序列（如元组或列表）中的元素分配给变量的操作。它可以方便地将序列中的元素解包并赋值给多个变量。 拆包可以应用于任何可迭代对象，例如元组、列表、集合等。要进行拆包，只需将可迭代对象放在赋值语句的左侧，并使用与元素数量相同的变量进行赋值。</p>
<p>使用拆包可以简化代码，并使其更易读。它允许一次性访问和操作序列中的多个元素，而不需要使用索引来逐个访问。 需要注意的是，如果拆包的变量数量与序列中的元素数量不匹配，将会引发ValueError异常。如果只想拆包序列中的一部分元素，可以使用占位符（如_）来表示不需要的元素。</p>
<p>在Python中，* 可以用于拆包操作，它可以将可迭代对象中的剩余元素打包成一个列表。这种用法通常称为“可变长参数”或“可变长参数列表”。 使用号拆包可以处理可变长度的参数列表，无需事先知道可迭代对象中的元素个数。 </p>
<p>Python支持嵌套拆包</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">a, *rest, b = lst</span><br><span class="line">rest</span><br></pre></td></tr></table></figure>
<p>序列模式匹配</p>
<p>从 Python 3.10 版本开始，引入了 match 表达式，以提供更强大的模式匹配功能。match 表达式可以用于匹配和解构各种数据类型，包括序列类型。 以下是一个示例，展示了如何在 Python 3.10 中使用 match 表达式进行模式匹配：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">process_data</span>(<span class="params">data</span>):</span><br><span class="line">    match data:</span><br><span class="line">        case [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;匹配到 [1, 2, 3]&quot;</span>)</span><br><span class="line">        case [<span class="number">4</span>, x, y]:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;匹配到 [4, <span class="subst">&#123;x&#125;</span>, <span class="subst">&#123;y&#125;</span>]&quot;</span>)</span><br><span class="line">        case [a, b, c]:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;匹配到 [<span class="subst">&#123;a&#125;</span>, <span class="subst">&#123;b&#125;</span>, <span class="subst">&#123;c&#125;</span>]&quot;</span>)</span><br><span class="line">        case _:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;未匹配到任何模式&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试示例</span></span><br><span class="line">process_data([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])  <span class="comment"># 输出: 匹配到 [1, 2, 3]</span></span><br><span class="line">process_data([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])  <span class="comment"># 输出: 匹配到 [4, 5, 6]</span></span><br><span class="line">process_data([<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])  <span class="comment"># 输出: 匹配到 [7, 8, 9]</span></span><br><span class="line">process_data([<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>])  <span class="comment"># 输出: 未匹配到任何模式</span></span><br></pre></td></tr></table></figure>
<p>字典推导式：它类似于列表推导式，但是生成的结果是字典而不是列表。</p>
<p>{key_expression: value_expression for item in iterable}</p>
<p>在Python中，defaultdict 是 collections 模块中的一个类，它是 dict 类的一个子类，用于创建具有默认值的字典。 与普通的字典不同，defaultdict 在创建时需要指定一个默认值的类型，当访问一个不存在的键时，它会自动返回默认值，而不会抛出 KeyError 异常。 以下是一个示例，展示了如何使用 defaultdict 创建具有默认值的字典：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line">d = defaultdict(<span class="built_in">int</span>)</span><br><span class="line"></span><br><span class="line">d[<span class="string">&#x27;a&#x27;</span>] = <span class="number">1</span></span><br><span class="line">d[<span class="string">&#x27;b&#x27;</span>]  <span class="comment"># 0 </span></span><br></pre></td></tr></table></figure>
<p>当我们使用一个字典访问一个不存在的键时，如果字典类中定义了 <code>__missing__</code> 方法，那么在访问不存在的键时，Python 会自动调用该方法，并将所访问的键作为参数传递给它。 以下是一个示例，展示了如何使用 <code>__missing__</code> 方法自定义字典中访问不存在的键的行为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyDict</span>(<span class="title class_ inherited__">dict</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__missing__</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;Key &#x27;<span class="subst">&#123;key&#125;</span>&#x27; is missing!&quot;</span></span><br><span class="line"></span><br><span class="line">d = MyDict()</span><br><span class="line">d[<span class="string">&#x27;a&#x27;</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(d[<span class="string">&#x27;a&#x27;</span>])  <span class="comment"># 输出: 1</span></span><br><span class="line"><span class="built_in">print</span>(d[<span class="string">&#x27;b&#x27;</span>])  <span class="comment"># 输出: Key &#x27;b&#x27; is missing!</span></span><br></pre></td></tr></table></figure>
<p>collections.ChainMap 是 Python 中的一个类，它用于将多个字典或映射对象链接在一起，形成一个逻辑上的单一映射。 ChainMap 提供了一种方便的方式来处理多个字典或映射对象，并将它们作为一个整体来操作。它在逻辑上将这些字典或映射对象链接在一起，形成一个查找链。当我们在 ChainMap 对象上进行键的查找时，它会按照链接顺序依次在各个字典或映射对象中查找。 </p>
<p>collections.ChainMap的好处是他不会真的合并对象，而只是形成一个链接，因此他不会占用额外的空间。具体可看源码:<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_37780776/article/details/123777723">https://blog.csdn.net/weixin_37780776/article/details/123777723</a></p>
<p>collections.Counter 是 Python 中的一个类，它用于计数可哈希对象的出现次数。它是一个无序的集合，其中元素存储为键，其计数存储为值。 Counter 类提供了一些有用的方法，用于对计数器进行操作，如增加、减少元素的计数、获取最常见的元素、计算元素的总数等。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line">counter = Counter(<span class="string">&#x27;abcda&#x27;</span>)</span><br><span class="line">counter</span><br><span class="line">counter.values()</span><br></pre></td></tr></table></figure>
<p>在 Python 中，创建子类时，可以选择继承内置的 dict 类或 collections.UserDict 类来实现自定义字典类的功能。 尽管 dict 类是 Python 内置的字典类，但在某些情况下，继承 collections.UserDict 类可能更适合。collections.UserDict 是一个可变字典类的包装器，它提供了更简单和安全的方式来创建自定义字典类。 以下是一个示例，展示了如何使用 collections.UserDict 来创建自定义字典类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> UserDict</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyDict</span>(<span class="title class_ inherited__">UserDict</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setitem__</span>(<span class="params">self, key, value</span>):</span><br><span class="line">        <span class="comment"># 自定义设置键值的行为</span></span><br><span class="line">        <span class="keyword">if</span> key == <span class="string">&#x27;special_key&#x27;</span>:</span><br><span class="line">            value += <span class="number">10</span></span><br><span class="line">        <span class="built_in">super</span>().__setitem__(key, value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="comment"># 自定义获取键值的行为</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().__getitem__(key)</span><br><span class="line"></span><br><span class="line">my_dict = MyDict()</span><br><span class="line">my_dict[<span class="string">&#x27;special_key&#x27;</span>] = <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(my_dict[<span class="string">&#x27;special_key&#x27;</span>])  <span class="comment"># 输出: 15</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们创建了一个名为 MyDict 的自定义字典类，并继承了 UserDict 类。通过重写 <code>__setitem__</code> 和 <code>__getitem__</code> 方法，我们可以自定义设置和获取键值的行为。 继承 UserDict 类可以帮助我们避免直接修改 dict 对象的内部结构，从而更安全地创建自定义字典类。 当然，如果你只需要创建一个简单的字典类，而不需要自定义特定的行为，那么继承 dict 类也是可行的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bytes_data = <span class="string">b&#x27;\xe4\xbd\xa0\xe5\xa5\xbd&#x27;</span></span><br><span class="line">decoded_text = bytes_data.decode(<span class="string">&#x27;utf-8&#x27;</span>)  </span><br><span class="line">decoded_text</span><br></pre></td></tr></table></figure>
<p>在 Python 中，具名元组（NamedTuple）是一种特殊类型的元组，它允许你给每个元素命名，并通过名称访问元素，而不仅仅是通过索引。 具名元组是通过 collections 模块中的 namedtuple 函数创建的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建具名元组类</span></span><br><span class="line">Person = namedtuple(<span class="string">&#x27;Person&#x27;</span>, [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建具名元组实例</span></span><br><span class="line">person1 = Person(<span class="string">&#x27;Alice&#x27;</span>, <span class="number">25</span>, <span class="string">&#x27;female&#x27;</span>)</span><br><span class="line">person2 = Person(<span class="string">&#x27;Bob&#x27;</span>, <span class="number">30</span>, <span class="string">&#x27;male&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问元素</span></span><br><span class="line"><span class="built_in">print</span>(person1.name)      <span class="comment"># 输出：Alice</span></span><br><span class="line"><span class="built_in">print</span>(person2.age)       <span class="comment"># 输出：30</span></span><br><span class="line"><span class="built_in">print</span>(person1.gender)    <span class="comment"># 输出：female</span></span><br></pre></td></tr></table></figure>
<p>@dataclass 是 Python 3.7 引入的一个装饰器，用于简化创建和使用数据类（data class）的过程。数据类是一种用于存储数据的特殊类，它自动为我们生成一些常见的方法，如 <code>__init__</code>、<code>__repr__</code>、<code>__eq__</code> 等，使得我们可以更方便地创建和操作数据对象。 使用 @dataclass 装饰器，我们可以在类定义中省略一些繁琐的代码。以下是一个使用 @dataclass 装饰器创建数据类的示例</p>
<p>在 Python 中，垃圾回收是自动进行的，它是通过引用计数和循环垃圾收集机制来实现的。下面是对这两种机制的简要说明：</p>
<ol>
<li>引用计数（Reference Counting）：Python 使用引用计数来追踪每个对象的引用数。当对象的引用数变为 0 时，说明没有任何引用指向该对象，Python 会立即回收该对象的内存空间。这是一种高效的垃圾回收机制，可以立即回收不再使用的对象。</li>
</ol>
<p>然而，引用计数机制无法处理循环引用的情况，即两个或多个对象彼此引用，但没有其他引用指向它们。这种情况下，引用计数无法将对象的引用数降为 0，导致内存泄漏。为了解决这个问题，Python 提供了循环垃圾收集机制。</p>
<ol>
<li>循环垃圾收集（Cycle Garbage Collection）：Python 使用循环垃圾收集机制来检测和回收循环引用的对象。循环垃圾收集器会定期运行，它会检查所有对象的引用关系，并标记那些可以被回收的对象。然后，它会释放这些对象所占用的内存空间。</li>
</ol>
<p>循环垃圾收集器使用了更复杂的算法，如标记-清除（mark and sweep）和分代回收（generational collection），以提高垃圾回收的效率和性能。</p>
<p>需要注意的是，Python 的垃圾回收机制是自动的，开发者无需手动管理内存。然而，对于一些特殊情况，如大型数据结构或循环引用的对象，可能需要注意内存的使用和释放，以避免潜在的内存泄漏问题。</p>
<p>在 Python 中，函数的参数传递方式是通过引用传递（pass-by-reference），也可以称为对象的引用传递。这意味着函数参数在传递过程中，实际上是将对象的引用传递给函数，而不是对象本身的副本。 </p>
<p>总结起来，当函数参数是引用传递时，函数内部对参数对象的修改会影响到原始对象，但是对参数进行重新赋值则不会影响到原始对象。</p>
<p>del是一个关键字，常见用法：</p>
<ol>
<li>删除对象</li>
<li>删除对象的属性</li>
<li>删除列表中的元素</li>
<li>删除字典中的键值对</li>
</ol>
<p>python中函数是一等公民：</p>
<ol>
<li>将函数赋值给变量</li>
<li>函数可以作为参数</li>
<li>函数作为另一个函数的返回值</li>
<li>嵌套函数</li>
</ol>
<p>在 Python 中，高阶函数（Higher-order functions）是指能够接受函数作为参数，或者返回一个函数的函数。高阶函数是函数式编程的重要概念，它可以让代码更加简洁、灵活和可复用。 以下是一些常见的高阶函数的示例：</p>
<ul>
<li>map</li>
<li>filter</li>
<li>sorted</li>
<li>lambda函数：lambda 函数通常只适用于简单的、单行的函数逻辑。如果你需要编写复杂的函数逻辑，还是建议使用常规的函数定义方式。</li>
</ul>
<p>用户可以通过自定义类来创建可调用对象。为了使一个类的实例可以像函数一样被调用，需要在类中定义 <code>__call__</code>() 方法</p>
<p><strong>总结py中星号的用法</strong></p>
<p>在 Python 中，有一些流行的包和库支持函数式编程范式。以下是其中一些常用的包：</p>
<ol>
<li><p>functools：<code>functools</code> 是 Python 内置的一个模块，提供了一些函数式编程的工具函数。它包含了一些用于函数操作的高阶函数，如 <code>map()</code>、<code>filter()</code>、<code>reduce()</code>，以及一些用于函数组合和函数装饰器的工具函数。</p>
</li>
<li><p>itertools：<code>itertools</code> 也是 Python 内置的一个模块，提供了一些用于迭代和组合的工具函数。它包含了一些常见的函数式编程模式，如生成无限迭代器、组合迭代器、过滤迭代器等。</p>
</li>
<li><p>operator：<code>operator</code> 是 Python 内置的一个模块，提供了一些常见的运算符的函数形式。它提供了一种函数式的方式来执行常见的算术、比较和逻辑运算。</p>
</li>
<li><p>toolz：<code>toolz</code> 是一个功能强大的函数式编程工具包，提供了一些高阶函数和工具，用于处理集合、迭代和函数组合。它提供了一些函数式编程的常见模式，如 <code>curry()</code>、<code>compose()</code>、<code>pipe()</code> 等。</p>
</li>
<li><p>fn：<code>fn</code> 是一个专注于函数式编程的库，提供了一些函数式编程的工具函数和数据类型。它支持函数组合、柯里化、惰性求值等函数式编程的特性。</p>
</li>
</ol>
<p>这些包和库提供了丰富的工具和函数，帮助开发者更方便地应用函数式编程的思想和模式。无论是在函数组合、迭代操作、惰性求值还是其他函数式编程的场景中，它们都能提供很多便利。</p>
<p>在 Python 中，类型注解是一种可选的语法，用于提供变量、函数参数、函数返回值等的类型信息。类型注解可以帮助开发者和工具在静态类型检查时发现潜在的类型错误，提高代码的可读性和可维护性。</p>
<p>以下是一些常用的类型注解，可以在 Python 的注解中使用：</p>
<ol>
<li><p>基本类型：int、float、bool、str 等基本数据类型。</p>
</li>
<li><p>容器类型：list、tuple、dict、set 等容器类型。可以使用方括号 <code>[]</code> 表示列表，圆括号 <code>()</code> 表示元组，大括号 <code>&#123;&#125;</code> 表示字典和集合。</p>
</li>
<li><p>自定义类型：自定义的类、枚举类、命名元组等。</p>
</li>
<li><p>Union 类型：使用 <code>Union</code> 或 <code>|</code> 符号表示多个类型中的一个，表示一个变量可以是多种类型之一。</p>
</li>
<li><p>Optional 类型：使用 <code>Optional</code> 表示一个变量可以是指定类型或者 <code>None</code>。</p>
</li>
<li><p>Callable 类型：使用 <code>Callable</code> 表示一个变量是可调用对象，如函数、方法等。</p>
</li>
<li><p>类型变量：使用 <code>TypeVar</code> 表示一个类型变量，用于泛型编程或表示复杂类型。</p>
</li>
<li><p>Any 类型：使用 <code>Any</code> 表示任意类型，相当于取消了类型检查。</p>
</li>
</ol>
<p>需要注意的是，类型注解在 Python 中是可选的，不会影响代码的运行。它们只是提供了一种给开发者和工具更多类型信息的方式，以提高代码的可读性和可维护性。Python 解释器在运行时不会对类型注解进行验证，类型检查需要通过静态类型检查工具（如 <code>mypy</code>）进行。</p>
<p><strong>装饰器和闭包总结和使用装饰器改进策略模式</strong></p>
<p>实例方法、静态方法、类方法比较</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    cls_var = <span class="string">&#x27;cls_var&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, ins_var</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.ins_var = ins_var</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cls_method</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;This is a cls method&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(cls.cls_var)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">ins_method</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;This is a ins method&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(self.ins_var)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">static_method</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;This is a static method&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(MyClass.cls_var)</span><br><span class="line"></span><br><span class="line">MyClass.static_method()</span><br></pre></td></tr></table></figure>
<p>在Python中，有两种方式可以限制对类属性的访问：私有属性和受保护的属性。 </p>
<ol>
<li>私有属性： 私有属性是以双下划线 __ 开头的属性，它们只能在类的内部访问，无法从外部直接访问。私有属性的目的是防止意外的修改或访问，以保护类的内部实现细节。</li>
</ol>
<p>尽管无法直接访问私有属性和方法，但可以通过使用 <code>实例变量._类名__属性名</code>的方式来间接访问私有属性和方法。</p>
<p>请注意，这种方式只是一个约定，不是真正的访问控制机制。在Python中，没有真正的私有性，它只是一种约定，用于指示这些属性和方法应该被视为私有的。 </p>
<ol>
<li>受保护的属性： 受保护的属性是以单下划线 _ 开头的属性，它们建议在类的外部不直接访问，但可以从子类中访问。受保护的属性是一种更宽松的访问限制，用于指示这些属性应该被视为受保护的。</li>
</ol>
<p><code>__slots__</code> 是一个特殊的类属性，用于限制类的实例可以拥有的属性。 通过使用 <code>__slots__</code>，你可以告诉Python仅为类的实例分配指定的属性，从而节省了内存空间。当你知道类的实例只需要固定的一组属性时，使用 <code>__slots__</code> 可以提高性能。 下面是一个示例，演示了如何使用 <code>__slots__</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    __slots__ = (<span class="string">&quot;attribute1&quot;</span>, <span class="string">&quot;attribute2&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value1, value2</span>):</span><br><span class="line">        self.attribute1 = value1</span><br><span class="line">        self.attribute2 = value2</span><br><span class="line"></span><br><span class="line">obj = MyClass(<span class="string">&quot;Value 1&quot;</span>, <span class="string">&quot;Value 2&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(obj.attribute1)</span><br><span class="line"><span class="built_in">print</span>(obj.attribute2)</span><br><span class="line"></span><br><span class="line">obj.attribute3 = <span class="string">&quot;Value 3&quot;</span>  <span class="comment"># 无法为属性3分配内存，会引发 AttributeError</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们定义了一个名为 MyClass 的类，并使用 <code>__slots__</code> 属性指定了类的实例只能拥有 attribute1 和 attribute2 这两个属性。 在类的 <code>__init__</code>方法中，我们为这两个属性赋予了初始值。 创建 MyClass 的实例 obj 后，我们可以访问这两个属性的值。 然而，当我们尝试为 obj 的 attribute3 属性赋值时，会引发 AttributeError 异常。这是因为 <code>__slots__</code> 属性限制了实例只能拥有 attribute1 和 attribute2 这两个属性，无法为其他属性分配内存。 需要注意的是，<code>__slots__</code> 是一个类属性，而不是实例属性。它仅对类的实例起作用，不对类本身起作用。 使用 <code>__slots__</code> 可以有效地减少实例所占用的内存空间，但需要注意选择适当的属性列表，确保不会限制过多或过少的属性。</p>
<p>动态存取属性</p>
<ol>
<li>点号赋值</li>
<li>getattr()、 setattr()</li>
<li>使用字典： <code>obj.__dict__[&#39;name&#39;] = &#39;John&#39;</code></li>
</ol>
<p>zip函数 拉链</p>
<p>鸭子类型是一种动态类型系统的概念，它强调在编程中关注对象的行为而不是具体的类型。根据鸭子类型的原则，只要一个对象具有特定的方法或属性，那么它就可以被视为具有相同的行为，而不需要显式地指定相同的类型。 在Python中，鸭子类型编程可以通过以下方式实现： 1. 不依赖具体的类型：编写代码时，不需要关注对象的具体类型，而是关注对象是否具有所需的方法或属性。例如，如果一个对象具有read()和write()方法，那么它可以被当作文件对象来使用，而不需要是file类型的实例。 2. 使用try-except语句：在使用某个方法或属性之前，可以使用try-except语句来捕获可能的异常。如果对象具有所需的方法或属性，那么代码将正常执行；如果对象没有所需的方法或属性，那么会抛出异常，可以在except块中处理该异常。 以下是一个简单的示例，演示了鸭子类型编程的概念</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">process_data</span>(<span class="params">obj</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        obj.read()</span><br><span class="line">        obj.process()</span><br><span class="line">        obj.write()</span><br><span class="line">    <span class="keyword">except</span> AttributeError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;对象不具有所需的方法或属性&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileObject</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">read</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;读取文件&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;处理数据&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">write</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;写入文件&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DatabaseObject</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">read</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;读取数据库&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;处理数据&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">write</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;写入数据库&quot;</span>)</span><br><span class="line"></span><br><span class="line">file_obj = FileObject()</span><br><span class="line">database_obj = DatabaseObject()</span><br><span class="line"></span><br><span class="line">process_data(file_obj)  <span class="comment"># 输出: 读取文件、处理数据、写入文件</span></span><br><span class="line">process_data(database_obj)  <span class="comment"># 输出: 读取数据库、处理数据、写入数据库</span></span><br><span class="line">process_data(<span class="string">&quot;Hello&quot;</span>)  <span class="comment"># 输出: 对象不具有所需的方法或属性</span></span><br></pre></td></tr></table></figure>
<p>在Python中，可以通过子类化内置类型来创建自定义的数据类型。内置类型，如list、dict、str等，可以作为基类来定义子类，从而扩展或定制其行为。 以下是一个简单的示例，演示了如何子类化内置类型list：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyList</span>(<span class="title class_ inherited__">list</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, *args</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(*args)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">append</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Appending item:&quot;</span>, item)</span><br><span class="line">        <span class="built_in">super</span>().append(item)</span><br><span class="line"></span><br><span class="line">my_list = MyList([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(my_list)  <span class="comment"># 输出: [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line">my_list.append(<span class="number">4</span>)  <span class="comment"># 输出: Appending item: 4</span></span><br><span class="line"><span class="built_in">print</span>(my_list)  <span class="comment"># 输出: [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，子类化内置类型有一些限制和注意事项。例如，某些内置类型的行为可能是通过C语言实现的，因此无法直接覆盖。此外，一些内置类型具有特殊的方法和行为，需要进行特殊处理。</p>
<p>多重继承、混入类：略。</p>
<p>在Python中，TypedDict是一种用于定义具有特定键和值类型的字典的类型提示工具。它是Python 3.8版本中引入的，并且需要使用typing模块进行导入。 TypedDict允许我们为字典的键和值指定类型注解，以提供更严格的类型检查和类型提示。以下是一个示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> TypedDict</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">TypedDict</span>):</span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    age: <span class="built_in">int</span></span><br><span class="line"></span><br><span class="line">person: Person = &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>: <span class="number">30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们定义了一个名为Person的TypedDict，它具有两个键：name和age。我们在键后面使用冒号（:）指定了键的类型注解，以及值的类型注解。 然后，我们可以使用Person类型来注解一个字典变量person，并确保该字典的键和值类型与Person类型定义匹配。 TypedDict提供了更强的类型约束，可以在静态类型检查工具（如mypy）或IDE中提供更准确的类型提示。它适用于需要对字典的结构和类型进行严格控制的情况。 需要注意的是，TypedDict只在运行时对字典进行类型检查，而不是在编译时。因此，它不能完全替代编写健壮的输入验证和数据校验代码。</p>
<p>typing.cast是Python中的一个类型提示工具函数，它用于显式地指定一个对象的类型，并返回该对象的类型转换后的结果。 cast函数的签名如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cast</span>(<span class="params"><span class="built_in">type</span>, value</span>) -&gt; <span class="built_in">type</span>:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>其中，type参数是目标类型，value参数是要进行类型转换的对象。cast函数会将value对象转换为type类型，并返回转换后的结果。 以下是一个示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> cast</span><br><span class="line"></span><br><span class="line">num_str = <span class="string">&quot;123&quot;</span></span><br><span class="line">num_int = cast(<span class="built_in">int</span>, num_str)</span><br><span class="line"><span class="built_in">print</span>(num_int)  <span class="comment"># 输出: 123</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(num_int))  <span class="comment"># 输出: &lt;class &#x27;int&#x27;&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们将字符串num_str通过cast函数转换为整数类型int。尽管num_str的类型是字符串，但我们使用cast函数显式地指定了目标类型为整数，并得到了转换后的结果。 需要注意的是，cast函数并不会进行实际的类型检查或类型转换。它仅仅是一个类型提示工具，用于向静态类型检查器（如mypy）提供额外的信息，以便进行更准确的类型推断和类型检查。 在使用cast函数时，应该谨慎使用，并确保对象的实际类型与指定的目标类型是兼容的，以避免运行时错误。</p>
<p>在Python中，我们可以使用泛化类（Generic Class）来实现具有通用性的类，以便在不同的类型上使用相同的代码。泛化类可以与类型参数一起使用，这样我们就可以在类定义中使用这些参数来表示不确定的类型。 以下是一个示例，展示如何使用泛化类来实现一个通用的堆栈类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> TypeVar, <span class="type">Generic</span></span><br><span class="line"></span><br><span class="line">T = TypeVar(<span class="string">&#x27;T&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span>(<span class="type">Generic</span>[T]):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.items = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, item: T</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.items.append(item)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; T:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.is_empty():</span><br><span class="line">            <span class="keyword">return</span> self.items.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> IndexError(<span class="string">&quot;Stack is empty&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.items) == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.items)</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们使用typing模块中的TypeVar来定义一个类型变量T。然后，在类定义中使用Generic[T]来表示这是一个泛化类，并且T是一个类型参数。 在类的方法中，我们可以使用类型参数T来表示不确定的类型。例如，在push方法中，我们接受一个类型为T的参数，并将其添加到堆栈中。在pop方法中，我们使用类型参数T来指定返回值的类型。 使用泛化类时，我们可以在实例化类时指定具体的类型，或者让类型推断机制自动推断类型。以下是一些示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stack = Stack[<span class="built_in">int</span>]()  <span class="comment"># 实例化一个整数类型的堆栈</span></span><br><span class="line">stack.push(<span class="number">1</span>)</span><br><span class="line">stack.push(<span class="number">2</span>)</span><br><span class="line">stack.push(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(stack.pop())  <span class="comment"># 输出: 3</span></span><br><span class="line"><span class="built_in">print</span>(stack.size())  <span class="comment"># 输出: 2</span></span><br><span class="line"></span><br><span class="line">stack2 = Stack[<span class="built_in">str</span>]()  <span class="comment"># 实例化一个字符串类型的堆栈</span></span><br><span class="line">stack2.push(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">stack2.push(<span class="string">&quot;World&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(stack2.pop())  <span class="comment"># 输出: &quot;World&quot;</span></span><br><span class="line"><span class="built_in">print</span>(stack2.size())  <span class="comment"># 输出: 1</span></span><br></pre></td></tr></table></figure>
<p>通过使用泛化类，我们可以在不同的类型上使用相同的代码逻辑，从而实现更通用、可重用的类。</p>
<p>在Python中，运算符重载（Operator Overloading）是指通过特殊的方法（也称为魔术方法或双下划线方法）来定义自定义类型的行为，使其支持标准的运算符操作。 以下是一些常用的运算符重载方法及其对应的运算符：</p>
<p><code>__add__</code>(self, other): 运算符 + 的重载方法，用于实现两个对象相加的操作。</p>
<p><code>__sub__</code>(self, other): 运算符 - 的重载方法，用于实现两个对象相减的操作。</p>
<p><code>__mul__</code>(self, other): 运算符 * 的重载方法，用于实现两个对象相乘的操作。</p>
<p><code>__div__</code>(self, other): 运算符 / 的重载方法，用于实现两个对象相除的操作。</p>
<p><code>__eq__</code>(self, other): 运算符 == 的重载方法，用于实现两个对象相等比较的操作。</p>
<p><code>__lt__</code>(self, other): 运算符 &lt; 的重载方法，用于实现两个对象小于比较的操作。</p>
<p><code>__gt__</code>(self, other): 运算符 &gt; 的重载方法，用于实现两个对象大于比较的操作。 以下是一个示例，展示如何在自定义类中重载运算符：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(other, Point):</span><br><span class="line">            <span class="keyword">return</span> Point(self.x + other.x, self.y + other.y)</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">isinstance</span>(other, <span class="built_in">int</span>) <span class="keyword">or</span> <span class="built_in">isinstance</span>(other, <span class="built_in">float</span>):</span><br><span class="line">            <span class="keyword">return</span> Point(self.x + other, self.y + other)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&quot;Unsupported operand type for +&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(other, Point):</span><br><span class="line">            <span class="keyword">return</span> self.x == other.x <span class="keyword">and</span> self.y == other.y</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;(<span class="subst">&#123;self.x&#125;</span>, <span class="subst">&#123;self.y&#125;</span>)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用运算符重载</span></span><br><span class="line">p1 = Point(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">p2 = Point(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">p3 = p1 + p2</span><br><span class="line"><span class="built_in">print</span>(p3)  <span class="comment"># 输出: (4, 6)</span></span><br><span class="line"></span><br><span class="line">p4 = p1 + <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(p4)  <span class="comment"># 输出: (6, 7)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(p1 == p2)  <span class="comment"># 输出: False</span></span><br><span class="line"><span class="built_in">print</span>(p1 == Point(<span class="number">1</span>, <span class="number">2</span>))  <span class="comment"># 输出: True</span></span><br></pre></td></tr></table></figure>
<p>在Python中，iter()是一个内置函数，用于返回一个可迭代对象的迭代器。 可迭代对象是指实现了<code>__iter__</code>()方法或<code>__getitem__</code>()方法的对象。迭代器是一个实现了<code>__iter__</code>()方法和<code>__next__</code>()方法的对象。iter()函数接受一个可迭代对象作为参数，并返回该可迭代对象的迭代器。 以下是iter()函数的语法：</p>
<p>可迭代对象（Iterable）和迭代器（Iterator）是Python中用于迭代操作的两个重要概念，它们之间有一些区别： </p>
<ol>
<li><p>可迭代对象（Iterable）：   </p>
<ul>
<li>可迭代对象是指实现了<strong>iter</strong>()方法或<strong>getitem</strong>()方法的对象。</li>
<li>可迭代对象可以使用for循环进行迭代，也可以使用内置函数iter()将其转换为迭代器。   - 可迭代对象每次迭代都会返回一个新的迭代器。 </li>
</ul>
</li>
<li><p>迭代器（Iterator）：   </p>
<ul>
<li>迭代器是指实现了<strong>iter</strong>()方法和<strong>next</strong>()方法的对象。   </li>
<li>迭代器用于从可迭代对象中逐个获取元素，每次调用<strong>next</strong>()方法返回迭代对象中的下一个元素。   </li>
<li>迭代器具有内部状态，可以记住当前迭代的位置。   </li>
<li>当迭代器中没有更多的元素可供获取时，调用<strong>next</strong>()方法会引发StopIteration异常。<br>下面是一个示例，展示可迭代对象和迭代器的区别：</li>
</ul>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SentenceIterator</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, words</span>):</span><br><span class="line">        self.words = words</span><br><span class="line">        self.index = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 有了这个函数才是迭代器</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            word =  self.words[self.index]</span><br><span class="line">        <span class="keyword">except</span> IndexError:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration()</span><br><span class="line">        self.index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> word</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sentence</span>:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;实现一个类，传入一个句子，在使用for迭代的时候，每次返回这个句子的单词（空格划分）&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val:<span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.words = val.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;每次迭代都返回新的返回迭代器，有了这个方法才是可迭代对象&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> SentenceIterator(self.words)</span><br><span class="line">    </span><br><span class="line">sentence = Sentence(<span class="string">&quot;I&#x27;m a Person.&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> sentence:</span><br><span class="line">    <span class="built_in">print</span>(word)</span><br></pre></td></tr></table></figure>
<p>生成器（Generator）是一种特殊的迭代器，它可以使用函数和yield语句来定义。生成器函数可以逐个产生元素，而不需要一次性生成所有元素。 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">countdown</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">yield</span> n</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建生成器对象</span></span><br><span class="line">generator = countdown(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用生成器逐个获取元素</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(generator))  <span class="comment"># 输出: 5</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(generator))  <span class="comment"># 输出: 4</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(generator))  <span class="comment"># 输出: 3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(generator))  <span class="comment"># 输出: 2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(generator))  <span class="comment"># 输出: 1</span></span><br><span class="line"><span class="comment"># print(next(generator))  # 引发 StopIteration 异常</span></span><br></pre></td></tr></table></figure>
<p>在上述示例中，我们定义了一个生成器函数countdown()，它使用while循环和yield语句逐个产生元素。我们通过调用生成器函数来创建一个生成器对象generator。 然后，我们使用next()函数逐个获取生成器中的元素。每次调用next()函数时，生成器函数会从上次暂停的位置继续执行，直到遇到下一个yield语句。 需要注意的是，当生成器中没有更多的元素可供获取时，再次调用next()函数会引发StopIteration异常。 生成器的一个重要特点是它们在迭代过程中保持状态，而不是一次性生成所有元素。这使得生成器非常适合处理大量数据或无限序列，因为它们只在需要时产生元素，从而节省了内存和计算资源。 除了使用生成器函数创建生成器之外，还可以使用生成器表达式来创建生成器。生成器表达式与列表推导式类似，但使用圆括号而不是方括号。 以下是使用生成器表达式创建生成器的示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用生成器表达式创建生成器对象</span></span><br><span class="line">generator = (num <span class="keyword">for</span> num <span class="keyword">in</span> numbers <span class="keyword">if</span> num % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用生成器逐个获取元素</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(generator))  <span class="comment"># 输出: 2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(generator))  <span class="comment"># 输出: 4</span></span><br><span class="line"><span class="comment"># print(next(generator))  # 引发 StopIteration 异常</span></span><br></pre></td></tr></table></figure>
<p>在上述示例中，我们使用生成器表达式(num for num in numbers if num % 2 == 0)创建了一个生成器对象generator。该生成器对象会逐个产生列表numbers中满足条件的偶数。</p>
<p>在Python中，上下文管理器（Context Manager）是一种用于管理资源的对象，它定义了在进入和退出特定代码块时要执行的操作。上下文管理器通常用于确保资源的正确分配和释放，例如打开和关闭文件、获取和释放锁等。 上下文管理器可以使用两种方式来实现：通过类实现和通过装饰器实现。 1. 类实现上下文管理器：   - 通过定义一个类，并在类中实现<code>__enter__</code>()和<code>__exit__</code>()方法来创建上下文管理器。   - <code>__enter__</code>()方法在进入代码块前执行，通常用于获取资源或执行必要的准备工作，并将资源返回给调用者。   - <code>__exit__</code>()方法在退出代码块时执行，通常用于释放资源或执行清理操作。   - 如果在代码块中发生异常，异常会被传递给<code>__exit__</code>()方法处理，可以在<code>__exit__</code>()方法中进行异常处理和日志记录等操作。 以下是一个使用类实现上下文管理器的示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 模拟 Python 的打开文件、关闭文件操作</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Filemanager</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, mode</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;calling __init__ method&#x27;</span>)</span><br><span class="line">        self.name = name</span><br><span class="line">        self.mode = mode</span><br><span class="line">        self.file = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;caling __enter__ method&#x27;</span>)</span><br><span class="line">        self.file = <span class="built_in">open</span>(self.name, self.mode)</span><br><span class="line">        <span class="keyword">return</span> self.file</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, exc_type, exc_val, exc_tb</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;caling __exit__ method&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> self.file:</span><br><span class="line">            self.file.close</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Filemanager为上下文管理器</span></span><br><span class="line"><span class="comment"># with Filemanager(&#x27;test.txt&#x27;, &#x27;w&#x27;) as f 是上下文表达式，f为资源对象 </span></span><br><span class="line"><span class="keyword">with</span> Filemanager(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;ready to write to file&#x27;</span>)</span><br><span class="line">    f.write(<span class="string">&#x27;Hello World&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>exit方法中的参数exc_type、exc_val、exc_tb分别表示exception type、exception value、traceback。</p>
<p>装饰器实现上下文管理器：</p>
<ul>
<li>通过使用@contextlib.contextmanager装饰器和生成器函数来创建上下文管理器。   </li>
<li>在生成器函数内部，使用yield语句将控制权暂时交给调用者，并在yield语句前后执行进入和退出代码块的操作。   </li>
<li>调用者可以使用with语句来使用上下文管理器，而不需要手动调用<strong>enter</strong>()和<strong>exit</strong>()方法。 以下是一个使用装饰器实现上下文管理器的示例：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> contextmanager</span><br><span class="line"></span><br><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">file_manager</span>(<span class="params">name, mode</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        f = <span class="built_in">open</span>(name, mode)</span><br><span class="line">        <span class="keyword">yield</span> f</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        f.close()</span><br><span class="line">        </span><br><span class="line"><span class="keyword">with</span> file_manager(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">&#x27;hello world&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>在上述示例中，我们使用@contextmanager装饰器将生成器函数my<em>context<em>manager()转换为上下文管理器。在生成器函数内部，我们使用yield语句将控制权交给调用者，并在yield语句前后执行进入和退出代码块的操作。 然后，我们使用with语句来使用上下文管理器。在with代码块中，我们可以执行需要的操作，而不需要手动调用<strong>enter</strong>()和__exit</em></em>()方法。如果在代码块中发生异常，异常会被传递给生成器函数中的except块处理。 上下文管理器是一种非常有用的编程模式，它可以确保资源的正确分配和释放，提高代码的可读性和健壮性。</p>
<p>GIL（Global Interpreter Lock）是Python解释器中的一个机制，它是为了保证解释器在多线程环境下的安全性而引入的。GIL的存在导致了Python解释器在同一时间只能执行一个线程的字节码，从而限制了多线程并行执行的能力。</p>
<p>GIL的作用是在解释器级别上保护Python对象免受并发访问的影响。由于Python的内存管理不是线程安全的，GIL可以确保同一时间只有一个线程能够操作Python对象，从而避免了多线程访问同一对象时可能引发的竞态条件和数据不一致问题。</p>
<p>由于GIL的存在，Python的多线程并不能真正发挥多核处理器的并行计算能力。在CPU密集型任务中，多线程的性能可能比单线程还要差。然而，在I/O密集型任务中，多线程仍然可以提供一定的性能优势，因为线程可以在等待I/O操作完成时释放GIL，允许其他线程执行。</p>
<p>需要注意的是，GIL只存在于CPython解释器中，它是Python的参考实现。其他一些Python解释器，如Jython和IronPython，没有GIL，可以实现真正的并行执行。</p>
<p>为了充分利用多核处理器的并行计算能力，可以考虑使用多进程、异步编程或使用其他语言编写CPU密集型任务的模块。</p>
<p>下面是几个使用Python实现并发的示例： 1. 多线程并发下载文件：   使用threading模块创建多个线程，每个线程负责下载一个文件。  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">download_file</span>(<span class="params">url, filename</span>):</span><br><span class="line">    response = requests.get(url)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        file.write(response.content)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件下载链接列表</span></span><br><span class="line">urls = [</span><br><span class="line">    <span class="string">&#x27;http://example.com/file1.txt&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;http://example.com/file2.txt&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;http://example.com/file3.txt&#x27;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建多个线程进行文件下载</span></span><br><span class="line">threads = []</span><br><span class="line"><span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">    filename = url.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">    thread = threading.Thread(target=download_file, args=(url, filename))</span><br><span class="line">    thread.start()</span><br><span class="line">    threads.append(thread)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待所有线程执行完毕</span></span><br><span class="line"><span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">    thread.join()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>多进程并发处理任务：使用multiprocessing模块创建多个进程，每个进程负责处理一个任务。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_task</span>(<span class="params">task</span>):</span><br><span class="line">    <span class="comment"># 处理任务</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Processing task: <span class="subst">&#123;task&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 任务列表</span></span><br><span class="line">tasks = [<span class="string">&#x27;task1&#x27;</span>, <span class="string">&#x27;task2&#x27;</span>, <span class="string">&#x27;task3&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建多个进程处理任务</span></span><br><span class="line">processes = []</span><br><span class="line"><span class="keyword">for</span> task <span class="keyword">in</span> tasks:</span><br><span class="line">    process = multiprocessing.Process(target=process_task, args=(task,))</span><br><span class="line">    process.start()</span><br><span class="line">    processes.append(process)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待所有进程执行完毕</span></span><br><span class="line"><span class="keyword">for</span> process <span class="keyword">in</span> processes:</span><br><span class="line">    process.join()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>异步并发执行网络请求： 使用asyncio模块和aiohttp库进行异步编程，实现并发执行多个网络请求。     </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">fetch</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> response:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">await</span> response.text()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 网络请求链接列表</span></span><br><span class="line">urls = [</span><br><span class="line">    <span class="string">&#x27;http://example.com/page1&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;http://example.com/page2&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;http://example.com/page3&#x27;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    tasks = [fetch(url) <span class="keyword">for</span> url <span class="keyword">in</span> urls]</span><br><span class="line">    results = <span class="keyword">await</span> asyncio.gather(*tasks)</span><br><span class="line">    <span class="keyword">for</span> result <span class="keyword">in</span> results:</span><br><span class="line">        <span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在Python中，可以使用multiprocessing.Pool类来自建进程池，以实现并发执行多个任务的目的。进程池可以提高任务的执行效率，减少创建和销毁进程的开销。 下面是一个使用multiprocessing.Pool自建进程池的示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_task</span>(<span class="params">task</span>):</span><br><span class="line">    <span class="comment"># 处理任务</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Processing task: <span class="subst">&#123;task&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建进程池，指定进程数量</span></span><br><span class="line">pool = multiprocessing.Pool(processes=<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 任务列表</span></span><br><span class="line">tasks = [<span class="string">&#x27;task1&#x27;</span>, <span class="string">&#x27;task2&#x27;</span>, <span class="string">&#x27;task3&#x27;</span>, <span class="string">&#x27;task4&#x27;</span>, <span class="string">&#x27;task5&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用进程池执行任务</span></span><br><span class="line">pool.<span class="built_in">map</span>(process_task, tasks)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭进程池，阻止新的任务提交</span></span><br><span class="line">pool.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待所有任务执行完毕</span></span><br><span class="line">pool.join()</span><br></pre></td></tr></table></figure>
<p>在上述示例中，我们首先创建了一个进程池对象pool，通过指定processes参数来设置进程的数量。然后，我们定义了一个任务处理函数process_task，该函数用于处理每个任务。 接着，我们创建了一个任务列表tasks，其中包含了需要处理的多个任务。使用pool.map()方法，我们将任务列表和任务处理函数作为参数传递给进程池，进程池会自动将任务分配给空闲的进程进行处理。 最后，我们关闭进程池并调用pool.join()方法，以等待所有任务执行完毕。 需要注意的是，进程池在执行任务时会自动管理进程的创建和销毁，因此不需要手动创建和销毁进程。进程池内部会维护一个进程队列，根据任务的数量和进程池的大小来动态分配任务给进程</p>
<p>concurrent.futures是Python标准库中的一个模块，提供了高级的并发编程接口，用于管理并发任务的执行和结果的获取。它建立在threading和multiprocessing模块之上，提供了线程池和进程池的实现。 concurrent.futures模块主要包含以下两个类： 1. ThreadPoolExecutor：线程池执行器，用于管理线程池并发执行任务。 2. ProcessPoolExecutor：进程池执行器，用于管理进程池并发执行任务。 这两个执行器类都实现了Executor接口，提供了一系列方法来提交任务、获取结果、关闭执行器等。 下面是一个使用concurrent.futures模块的示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor, as_completed</span><br><span class="line"><span class="keyword">from</span> concurrent <span class="keyword">import</span> futures </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_task</span>(<span class="params">task</span>):</span><br><span class="line">    <span class="comment"># 处理任务</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Processing task: <span class="subst">&#123;task&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;Result: <span class="subst">&#123;task&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建线程池执行器，指定线程数量</span></span><br><span class="line"><span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">4</span>) <span class="keyword">as</span> executor:</span><br><span class="line">    <span class="comment"># 任务列表</span></span><br><span class="line">    tasks = [<span class="string">&#x27;task1&#x27;</span>, <span class="string">&#x27;task2&#x27;</span>, <span class="string">&#x27;task3&#x27;</span>, <span class="string">&#x27;task4&#x27;</span>, <span class="string">&#x27;task5&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 提交任务到线程池</span></span><br><span class="line">    futures = [executor.submit(process_task, task) <span class="keyword">for</span> task <span class="keyword">in</span> tasks]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取任务结果</span></span><br><span class="line">    <span class="keyword">for</span> future <span class="keyword">in</span> as_completed(futures):</span><br><span class="line">        result = future.result()</span><br><span class="line">        <span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>
<p>下面是一个使用ThreadPoolExecutor来并发下载文件的示例代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> concurrent.futures</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">download_file</span>(<span class="params">url</span>):</span><br><span class="line">    response = requests.get(url)</span><br><span class="line">    filename = url.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        file.write(response.content)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Downloaded file: <span class="subst">&#123;filename&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件下载链接列表</span></span><br><span class="line">urls = [</span><br><span class="line">    <span class="string">&#x27;http://example.com/file1.txt&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;http://example.com/file2.txt&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;http://example.com/file3.txt&#x27;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建线程池执行器，指定线程数量</span></span><br><span class="line"><span class="keyword">with</span> concurrent.futures.ThreadPoolExecutor() <span class="keyword">as</span> executor:</span><br><span class="line">    <span class="comment"># 提交下载任务到线程池</span></span><br><span class="line">    futures = [executor.submit(download_file, url) <span class="keyword">for</span> url <span class="keyword">in</span> urls]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取任务结果</span></span><br><span class="line">    <span class="keyword">for</span> future <span class="keyword">in</span> concurrent.futures.as_completed(futures):</span><br><span class="line">        result = future.result()</span><br></pre></td></tr></table></figure>
<p>在上述示例中，我们首先定义了一个download_file函数，用于下载指定URL的文件。该函数使用requests库发送HTTP请求并将响应内容写入本地文件。 然后，我们创建了一个文件下载链接列表urls，其中包含了需要下载的文件的URL。 接下来，我们创建了一个线程池执行器executor，并使用executor.submit()方法将下载任务提交给线程池执行器。submit()方法返回一个Future对象，表示任务的执行结果。 最后，我们使用concurrent.futures.as_completed()函数来迭代Future对象，获取下载任务的结果。as_completed()函数会返回一个迭代器，按照任务的完成顺序返回Future对象。我们通过调用future.result()方法获取每个任务的结果。 需要注意的是，在使用ThreadPoolExecutor时，我们使用了with语句来自动管理执行器的创建和关闭。在with代码块中，我们可以提交任务、获取结果等操作。执行器会在代码块结束时自动关闭，释放资源。</p>
<p>Python asyncio（异步I/O）是一种基于事件循环的异步编程库，用于编写高效的并发代码。它提供了一种协程（coroutine）的方式，使得编写异步代码更加简洁和可读。 下面是一个简单的示例，展示如何使用asyncio来执行异步任务：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">hello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;World&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(</span><br><span class="line">        hello(),</span><br><span class="line">        hello(),</span><br><span class="line">        hello()</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>
<p>在上述示例中，我们定义了一个hello协程函数，其中包含了一个异步的打印任务和一个异步的等待任务。通过使用await关键字，我们可以在协程中等待其他协程的完成。 然后，我们定义了一个main协程函数，它使用asyncio.gather函数来并发执行多个协程任务。 最后，我们使用asyncio.run函数来运行main协程函数，从而启动整个异步程序。 需要注意的是，asyncio在Python 3.7及以上版本中是一个内置的标准库，可以直接使用。在旧版本的Python中，你可能需要通过pip来安装asyncio库。</p>
<p>21.2.可异步调用对象<br>在Python中，可以使用asyncio.ensure_future或asyncio.create_task来将可调用对象转换为可异步调用的对象。这样可以在异步程序中并发地执行多个可调用对象。 下面是一个示例代码，展示如何使用asyncio.ensure_future来异步调用可调用对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">hello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">world</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;World&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    task1 = asyncio.ensure_future(hello())</span><br><span class="line">    task2 = asyncio.ensure_future(world())</span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(task1, task2)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>
<p>在上述示例中，我们定义了两个异步函数hello和world，它们分别打印”Hello”和”World”。 然后，在main函数中，我们使用asyncio.ensure_future将这两个异步函数转换为可异步调用的对象task1和task2。 最后，我们使用asyncio.gather来并发地执行这两个任务。 另外，从Python 3.7开始，可以使用asyncio.create_task来实现相同的效果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">hello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">world</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;World&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    task1 = asyncio.create_task(hello())</span><br><span class="line">    task2 = asyncio.create_task(world())</span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(task1, task2)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>
<p>这两种方法都可以将可调用对象转换为可异步调用的对象，以便在异步程序中并发地执行多个任务。</p>
<p>在Python中，从Python 3.7开始，我们可以使用asyncio库来创建异步上下文管理器。异步上下文管理器是一种特殊的对象，它可以在异步代码中使用async with语法来管理资源的获取和释放。 下面是一个示例代码，展示如何创建和使用异步上下文管理器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AsyncContextManager</span>:</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">__aenter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Entering async context&quot;</span>)</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Resource&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">__aexit__</span>(<span class="params">self, exc_type, exc_val, exc_tb</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Exiting async context&quot;</span>)</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> AsyncContextManager() <span class="keyword">as</span> resource:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Using resource: <span class="subst">&#123;resource&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>
<p>在上述示例中，我们定义了一个AsyncContextManager类，它实现了<strong>aenter</strong>和<strong>aexit</strong>方法。这两个方法分别在进入和退出异步上下文时被调用。 在<strong>aenter</strong>方法中，我们可以执行一些异步操作来获取资源。在这个示例中，我们使用await asyncio.sleep(1)模拟获取资源的耗时操作，并返回一个表示资源的字符串。 在<strong>aexit</strong>方法中，我们可以执行一些异步操作来释放资源。在这个示例中，我们同样使用await asyncio.sleep(1)模拟释放资源的耗时操作。 然后，在main协程函数中，我们使用async with语法来使用异步上下文管理器。在进入上下文时，会调用<strong>aenter</strong>方法，获取资源并将其赋值给resource变量。然后，在退出上下文时，会调用<strong>aexit</strong>方法，释放资源。 需要注意的是，这个示例使用asyncio.run来运行main协程函数，从而启动整个异步程序。</p>
<p>在Python中，从Python 3.6开始，我们可以使用<strong>async for</strong>语法来进行异步迭代，以及使用异步可迭代对象来支持异步迭代操作。 异步迭代是指在迭代过程中可以暂停和恢复执行，以便在等待异步操作完成时不阻塞事件循环。 下面是一个示例代码，展示如何进行异步迭代和使用异步可迭代对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AsyncIterable</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, data</span>):</span><br><span class="line">        self.data = data</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__aiter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">__anext__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.data:</span><br><span class="line">            <span class="keyword">raise</span> StopAsyncIteration</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)  <span class="comment"># 模拟异步操作</span></span><br><span class="line">        item = self.data.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">for</span> item <span class="keyword">in</span> AsyncIterable([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]):</span><br><span class="line">        <span class="built_in">print</span>(item)</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>
<p>在上述示例中，我们定义了一个AsyncIterable类，它实现了<strong>aiter</strong>和<strong>anext</strong>方法。<strong>aiter</strong>方法返回一个异步迭代器对象，而<strong>anext</strong>方法定义了异步迭代的行为。 在<strong>anext</strong>方法中，我们使用await asyncio.sleep(1)模拟异步操作的等待时间。然后，我们从数据列表中取出一个元素并返回。 然后，在main协程函数中，我们使用async for语法来进行异步迭代。在每次迭代时，会调用<strong>anext</strong>方法来获取下一个元素，并在等待异步操作完成时暂停执行。 需要注意的是，这个示例使用asyncio.run来运行main协程函数，从而启动整个异步程序。</p>
<p>异步对象的类型提示<br>在Python中，可以使用类型提示来指定异步对象的类型。从Python 3.5开始，引入了typing模块，其中包含了一些用于异步编程的类型提示工具。 下面是一些常用的用于异步对象类型提示的工具： 1. typing.Coroutine: 用于指定协程函数的返回类型。 2. typing.Awaitable: 用于指定一个对象是可等待的，可以使用await关键字来等待其完成。 3. typing.AsyncIterable: 用于指定异步可迭代对象的类型。 4. typing.AsyncIterator: 用于指定异步迭代器的类型。 5. typing.AsyncContextManager: 用于指定异步上下文管理器的类型。 下面是一个示例代码，展示如何使用这些类型提示工具：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Coroutine</span>, Awaitable, AsyncIterable, AsyncIterator, AsyncContextManager</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">foo</span>() -&gt; <span class="type">Coroutine</span>:</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">bar</span>() -&gt; Awaitable[<span class="built_in">int</span>]:</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">baz</span>() -&gt; AsyncIterable[<span class="built_in">int</span>]:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">qux</span>() -&gt; AsyncIterator[<span class="built_in">int</span>]:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">spam</span>() -&gt; AsyncContextManager[<span class="built_in">str</span>]:</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;file.txt&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        content = <span class="keyword">await</span> file.read()</span><br><span class="line">        <span class="keyword">return</span> content</span><br><span class="line"></span><br><span class="line">asyncio.run(foo())</span><br><span class="line">asyncio.run(bar())</span><br><span class="line">asyncio.run(baz())</span><br><span class="line">asyncio.run(qux())</span><br><span class="line">asyncio.run(spam())</span><br></pre></td></tr></table></figure>
<p>在上述示例中，我们定义了几个异步函数，每个函数使用不同的类型提示来指定返回类型。 在foo函数中，我们使用Coroutine类型提示来指定返回的协程对象的类型。 在bar函数中，我们使用Awaitable类型提示来指定返回的对象是可等待的。 在baz函数中，我们使用AsyncIterable类型提示来指定返回的对象是异步可迭代的。 在qux函数中，我们使用AsyncIterator类型提示来指定返回的对象是异步迭代器。 在spam函数中，我们使用AsyncContextManager类型提示来指定返回的对象是异步上下文管理器。 需要注意的是，这个示例使用asyncio.run来运行每个异步函数，从而启动相应的异步程序。</p>
<p>使用动态属性访问json数据</p>
<p>在Python中，可以使用动态属性来访问JSON数据。动态属性允许我们在对象上创建或修改属性，从而实现对JSON数据的灵活访问。 下面是一个示例代码，展示如何使用动态属性访问JSON数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JSONData</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, json_str</span>):</span><br><span class="line">        self.data = json.loads(json_str)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">in</span> self.data:</span><br><span class="line">            value = self.data[name]</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(value, <span class="built_in">dict</span>):</span><br><span class="line">                <span class="keyword">return</span> JSONData(json.dumps(value))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(<span class="string">f&quot;&#x27;JSONData&#x27; object has no attribute &#x27;<span class="subst">&#123;name&#125;</span>&#x27;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用动态属性访问JSON数据</span></span><br><span class="line">json_str = <span class="string">&#x27;&#123;&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 30, &quot;address&quot;: &#123;&quot;city&quot;: &quot;New York&quot;, &quot;country&quot;: &quot;USA&quot;&#125;&#125;&#x27;</span></span><br><span class="line">data = JSONData(json_str)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(data.name)                <span class="comment"># 输出: John</span></span><br><span class="line"><span class="built_in">print</span>(data.age)                 <span class="comment"># 输出: 30</span></span><br><span class="line"><span class="built_in">print</span>(data.address)             <span class="comment"># 输出: &lt;__main__.JSONData object at 0x...&gt;</span></span><br><span class="line"><span class="built_in">print</span>(data.address.city)        <span class="comment"># 输出: New York</span></span><br><span class="line"><span class="built_in">print</span>(data.address.country)     <span class="comment"># 输出: USA</span></span><br></pre></td></tr></table></figure>
<p>后面的略</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Met Guo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://guoyujian.github.io/2024/03/08/Fluent-Python%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%95%B4%E7%90%86/">https://guoyujian.github.io/2024/03/08/Fluent-Python%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%95%B4%E7%90%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://guoyujian.github.io">Gmet's Blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Python/">Python</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2024/03/08/Python-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%B0%8F%E7%BB%931/"><i class="fa fa-chevron-left">  </i><span>Python 并发编程小结1</span></a></div><div class="next-post pull-right"><a href="/2024/03/06/Python%E6%98%9F%E5%8F%B7%E7%94%A8%E6%B3%95%E5%B0%8F%E7%BB%93/"><span>Python星号用法小结</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://images7.alphacoders.com/550/thumb-1920-550739.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2021 - 2024 By Met Guo</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.8.2"></script><script src="/js/fancybox.js?version=1.8.2"></script><script src="/js/sidebar.js?version=1.8.2"></script><script src="/js/copy.js?version=1.8.2"></script><script src="/js/fireworks.js?version=1.8.2"></script><script src="/js/transition.js?version=1.8.2"></script><script src="/js/scroll.js?version=1.8.2"></script><script src="/js/head.js?version=1.8.2"></script><script src="/js/search/algolia.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>