<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Python 并发编程小结1"><meta name="keywords" content="Python"><meta name="author" content="Met Guo"><meta name="copyright" content="Met Guo"><title>Python 并发编程小结1 | Gmet's Blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.8.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.8.2"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"LEZCUKXOU8","apiKey":"43c226e390cd280e256d1d7cc0e6cce4","indexName":"blogs","hits":{"per_page":10,"input_placeholder":"Search for Posts","hits_empty":"û���ҵ�����Ҫ�Ľ��: ${query}","hits_stats":"�ҵ�${hits}���������ʱ${time}���룩"},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.2'
} </script><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Gmet's Blog" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E5%92%8C%E5%81%9C%E6%AD%A2%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">启动和停止线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A8%E8%AE%BA"><span class="toc-number">1.1.</span> <span class="toc-text">讨论</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%A6%E5%90%AF%E5%8A%A8"><span class="toc-number">2.</span> <span class="toc-text">判断线程是否启动</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A8%E8%AE%BA-1"><span class="toc-number">2.1.</span> <span class="toc-text">讨论</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-number">3.</span> <span class="toc-text">线程间通信</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A8%E8%AE%BA-2"><span class="toc-number">3.1.</span> <span class="toc-text">讨论</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A0%E9%94%81"><span class="toc-number">4.</span> <span class="toc-text">加锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A8%E8%AE%BA-3"><span class="toc-number">4.1.</span> <span class="toc-text">讨论</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%98%B2%E6%AD%A2%E6%AD%BB%E9%94%81%E7%9A%84%E5%8A%A0%E9%94%81%E6%9C%BA%E5%88%B6"><span class="toc-number">5.</span> <span class="toc-text">防止死锁的加锁机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A8%E8%AE%BA-4"><span class="toc-number">5.1.</span> <span class="toc-text">讨论</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BF%9D%E5%AD%98%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%BF%A1%E6%81%AF"><span class="toc-number">6.</span> <span class="toc-text">保存线程的状态信息</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98"><span class="toc-number">6.1.</span> <span class="toc-text">问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">6.2.</span> <span class="toc-text">解决方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A8%E8%AE%BA-5"><span class="toc-number">6.3.</span> <span class="toc-text">讨论</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">7.</span> <span class="toc-text">创建线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A8%E8%AE%BA-6"><span class="toc-number">7.1.</span> <span class="toc-text">讨论</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B"><span class="toc-number">8.</span> <span class="toc-text">简单并行编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-1"><span class="toc-number">8.1.</span> <span class="toc-text">解决方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A8%E8%AE%BA-7"><span class="toc-number">8.2.</span> <span class="toc-text">讨论</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Py%E7%9A%84%E5%85%A8%E5%B1%80%E9%94%81%E9%97%AE%E9%A2%98"><span class="toc-number">9.</span> <span class="toc-text">Py的全局锁问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A8%E8%AE%BA-8"><span class="toc-number">9.1.</span> <span class="toc-text">讨论</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Actor%E6%A8%A1%E5%BC%8F"><span class="toc-number">10.</span> <span class="toc-text">Actor模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A8%E8%AE%BA-9"><span class="toc-number">10.1.</span> <span class="toc-text">讨论</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%9E%8B"><span class="toc-number">11.</span> <span class="toc-text">实现消息发布&#x2F;订阅模型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%94%9F%E6%88%90%E5%99%A8%E4%BB%A3%E6%9B%BF%E7%BA%BF%E7%A8%8B"><span class="toc-number">12.</span> <span class="toc-text">使用生成器代替线程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E9%98%9F%E5%88%97%E8%BD%AE%E8%AF%A2"><span class="toc-number">13.</span> <span class="toc-text">多个线程队列轮询</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9C%A8Unix%E7%B3%BB%E7%BB%9F%E4%B8%8A%E9%9D%A2%E5%90%AF%E5%8A%A8%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="toc-number">14.</span> <span class="toc-text">在Unix系统上面启动守护线程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Ref"><span class="toc-number">15.</span> <span class="toc-text">Ref</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Met Guo</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">96</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">78</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">51</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://images7.alphacoders.com/550/thumb-1920-550739.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Gmet's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/slides">Slides</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">Python 并发编程小结1</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2024-03-08</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Python/">Python</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Python/%E5%B9%B6%E5%8F%91/">并发</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">13.3k</span><span class="post-meta__separator">|</span><span>阅读时长: 50 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><blockquote>
<p>KeyWords:</p>
<ul>
<li>threading.Thread</li>
<li>threading.Event</li>
<li>使用队列queue.Queue，task_down()、join()实现线程通信</li>
<li>Lock的上下文管理、RLock、信号量Semaphore</li>
<li>死锁</li>
<li>创建对其他线程不可见的线程状态：threading.local()</li>
<li>线程池: concurrent.futures.ThreadPoolExecutor</li>
<li>并行编程：concurrent.futures.ProcessPoolExecutor、multiprocessing</li>
<li>GIL全局解释器的影响和解决方案</li>
<li>Actor模式</li>
<li>（本文未提到的）生成器、协程与asyncio</li>
<li>（本文未提到的）消息发布/订阅模型、多线程轮询</li>
</ul>
</blockquote>
<h1 id="启动和停止线程"><a href="#启动和停止线程" class="headerlink" title="启动和停止线程"></a>启动和停止线程</h1><p><code>threading</code>​ 库可以在单独的线程中执行任何的在 Python 中可以调用的对象。你可以创建一个 <code>Thread</code>​ 对象并将你要执行的对象以 target 参数的形式提供给该对象。 下面是一个简单的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Code to execute in an independent thread</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">countdown</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;T-minus&#x27;</span>, n)</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line">        time.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create and launch a thread</span></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line">t = Thread(target=countdown, args=(<span class="number">10</span>,))</span><br><span class="line">t.start()</span><br></pre></td></tr></table></figure>
<p>当你创建好一个线程对象后，该对象并不会立即执行，除非你调用它的 <code>&lt;span class=&quot;pre&quot;&gt;start()&lt;/span&gt;</code>​ 方法（当你调用 <code>&lt;span class=&quot;pre&quot;&gt;start()&lt;/span&gt;</code>​ 方法时，它会调用你传递进来的函数，并把你传递进来的参数传递给该函数）。Python中的线程会在一个单独的系统级线程中执行（比如说一个 POSIX 线程或者一个 Windows 线程），这些线程将由操作系统来全权管理。线程一旦启动，将独立执行直到目标函数返回。你可以查询一个线程对象的状态，看它是否还在执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if t.is_alive():</span><br><span class="line">    print(&#x27;Still running&#x27;)</span><br><span class="line">else:</span><br><span class="line">    print(&#x27;Completed&#x27;)</span><br></pre></td></tr></table></figure>
<p>你也可以将一个线程加入到当前线程，并等待它终止：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">t.join()</span><br></pre></td></tr></table></figure>
<p>Python解释器直到所有线程都终止前仍保持运行。对于需要长时间运行的线程或者需要一直运行的后台任务，你应当考虑使用后台线程。 例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">t = Thread(target=countdown, args=(10,), daemon=True)</span><br><span class="line">t.start()</span><br></pre></td></tr></table></figure>
<p>后台线程无法等待，不过，这些线程会在主线程终止时自动销毁。 除了如上所示的两个操作，并没有太多可以对线程做的事情。你无法结束一个线程，无法给它发送信号，无法调整它的调度，也无法执行其他高级操作。如果需要这些特性，你需要自己添加。比如说，如果你需要终止线程，那么这个线程必须通过编程在某个特定点轮询来退出。你可以像下边这样把线程放入一个类中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CountdownTask</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._running = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">terminate</span>(<span class="params">self</span>):</span><br><span class="line">        self._running = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self, n</span>):</span><br><span class="line">        <span class="keyword">while</span> self._running <span class="keyword">and</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;T-minus&#x27;</span>, n)</span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line">            time.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">c = CountdownTask()</span><br><span class="line">t = Thread(target=c.run, args=(<span class="number">10</span>,))</span><br><span class="line">t.start()</span><br><span class="line">c.terminate() <span class="comment"># Signal termination</span></span><br><span class="line">t.join()      <span class="comment"># Wait for actual termination (if needed)</span></span><br></pre></td></tr></table></figure>
<p>如果线程执行一些像I/O这样的阻塞操作，那么通过轮询来终止线程将使得线程之间的协调变得非常棘手。比如，如果一个线程一直阻塞在一个I/O操作上，它就永远无法返回，也就无法检查自己是否已经被结束了。要正确处理这些问题，你需要利用超时循环来小心操作线程。 例子如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IOTask</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">terminate</span>(<span class="params">self</span>):</span><br><span class="line">        self._running = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self, sock</span>):</span><br><span class="line">        <span class="comment"># sock is a socket</span></span><br><span class="line">        sock.settimeout(<span class="number">5</span>)        <span class="comment"># Set timeout period</span></span><br><span class="line">        <span class="keyword">while</span> self._running:</span><br><span class="line">            <span class="comment"># Perform a blocking I/O operation w/ timeout</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                data = sock.recv(<span class="number">8192</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">except</span> socket.timeout:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># Continued processing</span></span><br><span class="line">            ...</span><br><span class="line">        <span class="comment"># Terminated</span></span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<h2 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h2><p>由于全局解释锁（GIL）的原因，Python 的线程被限制到同一时刻只允许一个线程执行这样一个执行模型。所以，Python 的线程更适用于处理I/O和其他需要并发执行的阻塞操作（比如等待I/O、等待从数据库获取数据等等），而不是需要多处理器并行的计算密集型任务。</p>
<p>有时你会看到下边这种通过继承 <code>Thread</code>​ 类来实现的线程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from threading import Thread</span><br><span class="line"></span><br><span class="line">class CountdownThread(Thread):</span><br><span class="line">    def __init__(self, n):</span><br><span class="line">        super().__init__()</span><br><span class="line">        self.n = n</span><br><span class="line">    def run(self):</span><br><span class="line">        while self.n &gt; 0:</span><br><span class="line"></span><br><span class="line">            print(&#x27;T-minus&#x27;, self.n)</span><br><span class="line">            self.n -= 1</span><br><span class="line">            time.sleep(5)</span><br><span class="line"></span><br><span class="line">c = CountdownThread(5)</span><br><span class="line">c.start()</span><br></pre></td></tr></table></figure>
<p>尽管这样也可以工作，但这使得你的代码依赖于 <code>threading</code>​ 库，所以你的这些代码只能在线程上下文中使用。上文所写的那些代码、函数都是与 <code>threading</code>​ 库无关的，这样就使得这些代码可以被用在其他的上下文中，可能与线程有关，也可能与线程无关。比如，你可以通过 <code>multiprocessing</code>​ 模块在一个单独的进程中执行你的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import multiprocessing</span><br><span class="line">c = CountdownTask(5)</span><br><span class="line">p = multiprocessing.Process(target=c.run)</span><br><span class="line">p.start()</span><br></pre></td></tr></table></figure>
<p>再次重申，这段代码仅适用于 CountdownTask 类是以独立于实际的并发手段（多线程、多进程等等）实现的情况。</p>
<h1 id="判断线程是否启动"><a href="#判断线程是否启动" class="headerlink" title="判断线程是否启动"></a>判断线程是否启动</h1><p>你已经启动了一个线程，但是你想知道它是不是真的已经开始运行了。</p>
<p>线程的一个关键特性是每个线程都是独立运行且状态不可预测。如果程序中的其他线程需要通过判断某个线程的状态来确定自己下一步的操作，这时线程同步问题就会变得非常棘手。为了解决这些问题，我们需要使用 <code>threading</code>​ 库中的 <code>Event</code>​ 对象。 <code>Event</code>​ 对象包含一个可由线程设置的信号标志，它允许线程等待某些事件的发生。在初始情况下，event 对象中的信号标志被设置为假。如果有线程等待一个 event 对象，而这个 event 对象的标志为假，那么这个线程将会被一直阻塞直至该标志为真。一个线程如果将一个 event 对象的信号标志设置为真，它将唤醒所有等待这个 event 对象的线程。如果一个线程等待一个已经被设置为真的 event 对象，那么它将忽略这个事件，继续执行。 下边的代码展示了如何使用 <code>Event</code>​ 来协调线程的启动：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Event</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># Code to execute in an independent thread</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">countdown</span>(<span class="params">n, started_evt</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;countdown starting&#x27;</span>)</span><br><span class="line">    started_evt.<span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;T-minus&#x27;</span>, n)</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line">        time.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create the event object that will be used to signal startup</span></span><br><span class="line">started_evt = Event()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Launch the thread and pass the startup event</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Launching countdown&#x27;</span>)</span><br><span class="line">t = Thread(target=countdown, args=(<span class="number">10</span>,started_evt))</span><br><span class="line">t.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Wait for the thread to start</span></span><br><span class="line">started_evt.wait()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;countdown is running&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>当你执行这段代码，“countdown is running” 总是显示在 “countdown starting” 之后显示。这是由于使用 event 来协调线程，使得主线程要等到 <code>countdown()</code>​ 函数输出启动信息后，才能继续执行。</p>
<h2 id="讨论-1"><a href="#讨论-1" class="headerlink" title="讨论"></a>讨论</h2><p>event 对象最好单次使用，就是说，你创建一个 event 对象，让某个线程等待这个对象，一旦这个对象被设置为真，你就应该丢弃它。尽管可以通过 <code>clear()</code>​ 方法来重置 event 对象，但是很难确保安全地清理 event 对象并对它重新赋值。很可能会发生错过事件、死锁或者其他问题（特别是，你无法保证重置 event 对象的代码会在线程再次等待这个 event 对象之前执行）。如果一个线程需要不停地重复使用 event 对象，你最好使用 <code>Condition</code>​ 对象来代替。下面的代码使用 <code>Condition</code>​ 对象实现了一个周期定时器，每当定时器超时的时候，其他线程都可以监测到：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PeriodicTimer</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, interval</span>):</span><br><span class="line">        self._interval = interval</span><br><span class="line">        self._flag = <span class="number">0</span></span><br><span class="line">        self._cv = threading.Condition()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start</span>(<span class="params">self</span>):</span><br><span class="line">        t = threading.Thread(target=self.run)</span><br><span class="line">        t.daemon = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        Run the timer and notify waiting threads after each interval</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            time.sleep(self._interval)</span><br><span class="line">            <span class="keyword">with</span> self._cv:</span><br><span class="line">                 self._flag ^= <span class="number">1</span></span><br><span class="line">                 self._cv.notify_all()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wait_for_tick</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        Wait for the next tick of the timer</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">with</span> self._cv:</span><br><span class="line">            last_flag = self._flag</span><br><span class="line">            <span class="keyword">while</span> last_flag == self._flag:</span><br><span class="line">                self._cv.wait()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example use of the timer</span></span><br><span class="line">ptimer = PeriodicTimer(<span class="number">5</span>)</span><br><span class="line">ptimer.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Two threads that synchronize on the timer</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">countdown</span>(<span class="params">nticks</span>):</span><br><span class="line">    <span class="keyword">while</span> nticks &gt; <span class="number">0</span>:</span><br><span class="line">        ptimer.wait_for_tick()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;T-minus&#x27;</span>, nticks)</span><br><span class="line">        nticks -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">countup</span>(<span class="params">last</span>):</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; last:</span><br><span class="line">        ptimer.wait_for_tick()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Counting&#x27;</span>, n)</span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">threading.Thread(target=countdown, args=(<span class="number">10</span>,)).start()</span><br><span class="line">threading.Thread(target=countup, args=(<span class="number">5</span>,)).start()</span><br></pre></td></tr></table></figure>
<p>event对象的一个重要特点是当它被设置为真时会唤醒所有等待它的线程。如果你只想唤醒单个线程，最好是使用信号量或者 <code>Condition</code>​ 对象来替代。考虑一下这段使用信号量实现的代码：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Worker thread</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">worker</span>(<span class="params">n, sema</span>):</span><br><span class="line">    <span class="comment"># Wait to be signaled</span></span><br><span class="line">    sema.acquire()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Do some work</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Working&#x27;</span>, n)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create some threads</span></span><br><span class="line">sema = threading.Semaphore(<span class="number">0</span>)</span><br><span class="line">nworkers = <span class="number">10</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(nworkers):</span><br><span class="line">    t = threading.Thread(target=worker, args=(n, sema,))</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure>
<p>运行上边的代码将会启动一个线程池，但是并没有什么事情发生。这是因为所有的线程都在等待获取信号量。每次信号量被释放，只有一个线程会被唤醒并执行，示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; sema.release()</span><br><span class="line">Working 0</span><br><span class="line">&gt;&gt;&gt; sema.release()</span><br><span class="line">Working 1</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>编写涉及到大量的线程间同步问题的代码会让你痛不欲生。比较合适的方式是使用队列来进行线程间通信或者每个把线程当作一个Actor，利用Actor模型来控制并发。下一节将会介绍到队列，而Actor模型将在12.10节介绍。</p>
<h1 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h1><p>从一个线程向另一个线程发送数据最安全的方式可能就是使用 <code>queue</code>​ 库中的队列了。创建一个被多个线程共享的 <code>Queue</code>​ 对象，这些线程通过使用 <code>put()</code>​ 和 <code>get()</code>​ 操作来向队列中添加或者删除元素。 例如：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="comment"># A thread that produces data</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">producer</span>(<span class="params">out_q</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># Produce some data</span></span><br><span class="line">        ...</span><br><span class="line">        out_q.put(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># A thread that consumes data</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">consumer</span>(<span class="params">in_q</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="comment"># Get some data</span></span><br><span class="line">        data = in_q.get()</span><br><span class="line">        <span class="comment"># Process the data</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create the shared queue and launch both threads</span></span><br><span class="line">q = Queue()</span><br><span class="line">t1 = Thread(target=consumer, args=(q,))</span><br><span class="line">t2 = Thread(target=producer, args=(q,))</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br></pre></td></tr></table></figure>
<p><code>Queue</code>​ 对象已经包含了必要的锁，所以你可以通过它在多个线程间多安全地共享数据。 当使用队列时，协调生产者和消费者的关闭问题可能会有一些麻烦。一个通用的解决方法是在队列中放置一个特殊的值，当消费者读到这个值的时候，终止执行。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="comment"># Object that signals shutdown</span></span><br><span class="line">_sentinel = <span class="built_in">object</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># A thread that produces data</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">producer</span>(<span class="params">out_q</span>):</span><br><span class="line">    <span class="keyword">while</span> running:</span><br><span class="line">        <span class="comment"># Produce some data</span></span><br><span class="line">        ...</span><br><span class="line">        out_q.put(data)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Put the sentinel on the queue to indicate completion</span></span><br><span class="line">    out_q.put(_sentinel)</span><br><span class="line"></span><br><span class="line"><span class="comment"># A thread that consumes data</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">consumer</span>(<span class="params">in_q</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># Get some data</span></span><br><span class="line">        data = in_q.get()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Check for termination</span></span><br><span class="line">        <span class="keyword">if</span> data <span class="keyword">is</span> _sentinel:</span><br><span class="line">            in_q.put(_sentinel)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Process the data</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>
<p>本例中有一个特殊的地方：消费者在读到这个特殊值之后立即又把它放回到队列中，将之传递下去。这样，所有监听这个队列的消费者线程就可以全部关闭了。 尽管队列是最常见的线程间通信机制，但是仍然可以自己通过创建自己的数据结构并添加所需的锁和同步机制来实现线程间通信。最常见的方法是使用 <code>Condition</code>​ 变量来包装你的数据结构。下边这个例子演示了如何创建一个线程安全的优先级队列，如同1.5节中介绍的那样。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PriorityQueue</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._queue = []</span><br><span class="line">        self._count = <span class="number">0</span></span><br><span class="line">        self._cv = threading.Condition()</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">put</span>(<span class="params">self, item, priority</span>):</span><br><span class="line">        <span class="keyword">with</span> self._cv:</span><br><span class="line">            heapq.heappush(self._queue, (-priority, self._count, item))</span><br><span class="line">            self._count += <span class="number">1</span></span><br><span class="line">            self._cv.notify()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">with</span> self._cv:</span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(self._queue) == <span class="number">0</span>:</span><br><span class="line">                self._cv.wait()</span><br><span class="line">            <span class="keyword">return</span> heapq.heappop(self._queue)[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>使用队列来进行线程间通信是一个单向、不确定的过程。通常情况下，你没有办法知道接收数据的线程是什么时候接收到的数据并开始工作的。不过队列对象提供一些基本完成的特性，比如下边这个例子中的 <code>**task_done()**</code> ​ 和 <code>**join()**</code> ​ ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from queue import Queue</span><br><span class="line">from threading import Thread</span><br><span class="line"></span><br><span class="line"># A thread that produces data</span><br><span class="line">def producer(out_q):</span><br><span class="line">    while running:</span><br><span class="line">        # Produce some data</span><br><span class="line">        ...</span><br><span class="line">        out_q.put(data)</span><br><span class="line"></span><br><span class="line"># A thread that consumes data</span><br><span class="line">def consumer(in_q):</span><br><span class="line">    while True:</span><br><span class="line">        # Get some data</span><br><span class="line">        data = in_q.get()</span><br><span class="line"></span><br><span class="line">        # Process the data</span><br><span class="line">        ...</span><br><span class="line">        # Indicate completion</span><br><span class="line">        in_q.task_done()</span><br><span class="line"></span><br><span class="line"># Create the shared queue and launch both threads</span><br><span class="line">q = Queue()</span><br><span class="line">t1 = Thread(target=consumer, args=(q,))</span><br><span class="line">t2 = Thread(target=producer, args=(q,))</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line"></span><br><span class="line"># Wait for all produced items to be consumed</span><br><span class="line">q.join()</span><br></pre></td></tr></table></figure>
<p>如果一个线程需要在一个“消费者”线程处理完特定的数据项时立即得到通知，你可以把要发送的数据和一个 <code>Event</code>​ 放到一起使用，这样“生产者”就可以通过这个Event对象来监测处理的过程了。示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from queue import Queue</span><br><span class="line">from threading import Thread, Event</span><br><span class="line"></span><br><span class="line"># A thread that produces data</span><br><span class="line">def producer(out_q):</span><br><span class="line">    while running:</span><br><span class="line">        # Produce some data</span><br><span class="line">        ...</span><br><span class="line">        # Make an (data, event) pair and hand it to the consumer</span><br><span class="line">        evt = Event()</span><br><span class="line">        out_q.put((data, evt))</span><br><span class="line">        ...</span><br><span class="line">        # Wait for the consumer to process the item</span><br><span class="line">        evt.wait()</span><br><span class="line"></span><br><span class="line"># A thread that consumes data</span><br><span class="line">def consumer(in_q):</span><br><span class="line">    while True:</span><br><span class="line">        # Get some data</span><br><span class="line">        data, evt = in_q.get()</span><br><span class="line">        # Process the data</span><br><span class="line">        ...</span><br><span class="line">        # Indicate completion</span><br><span class="line">        evt.set()</span><br></pre></td></tr></table></figure>
<h2 id="讨论-2"><a href="#讨论-2" class="headerlink" title="讨论"></a>讨论</h2><p>基于简单队列编写多线程程序在多数情况下是一个比较明智的选择。从线程安全队列的底层实现来看，你无需在你的代码中使用锁和其他底层的同步机制，这些只会把你的程序弄得乱七八糟。此外，使用队列这种基于消息的通信机制可以被扩展到更大的应用范畴，比如，你可以把你的程序放入多个进程甚至是分布式系统而无需改变底层的队列结构。 使用线程队列有一个要注意的问题是，向队列中添加数据项时并不会复制此数据项，线程间通信实际上是在线程间传递对象引用。如果你担心对象的共享状态，那你最好只传递不可修改的数据结构（如：整型、字符串或者元组）或者一个对象的深拷贝。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from queue import Queue</span><br><span class="line">from threading import Thread</span><br><span class="line">import copy</span><br><span class="line"></span><br><span class="line"># A thread that produces data</span><br><span class="line">def producer(out_q):</span><br><span class="line">    while True:</span><br><span class="line">        # Produce some data</span><br><span class="line">        ...</span><br><span class="line">        out_q.put(copy.deepcopy(data))</span><br><span class="line"></span><br><span class="line"># A thread that consumes data</span><br><span class="line">def consumer(in_q):</span><br><span class="line">    while True:</span><br><span class="line">        # Get some data</span><br><span class="line">        data = in_q.get()</span><br><span class="line">        # Process the data</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>
<p><code>Queue</code>​ 对象提供一些在当前上下文很有用的附加特性。比如在创建 Queue 对象时提供可选的 <code>size</code>​ 参数来限制可以添加到队列中的元素数量。对于“生产者”与“消费者”速度有差异的情况，为队列中的元素数量添加上限是有意义的。比如，一个“生产者”产生项目的速度比“消费者” “消费”的速度快，那么使用固定大小的队列就可以在队列已满的时候阻塞队列，以免未预期的连锁效应扩散整个程序造成死锁或者程序运行失常。在通信的线程之间进行“流量控制”是一个看起来容易实现起来困难的问题。如果你发现自己曾经试图通过摆弄队列大小来解决一个问题，这也许就标志着你的程序可能存在脆弱设计或者固有的可伸缩问题。 <code>get()</code>​ 和 <code>put()</code>​ 方法都支持非阻塞方式和设定超时，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import queue</span><br><span class="line">q = queue.Queue()</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    data = q.get(block=False)</span><br><span class="line">except queue.Empty:</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    q.put(item, block=False)</span><br><span class="line">except queue.Full:</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    data = q.get(timeout=5.0)</span><br><span class="line">except queue.Empty:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>这些操作都可以用来避免当执行某些特定队列操作时发生无限阻塞的情况，比如，一个非阻塞的 <code>put()</code>​ 方法和一个固定大小的队列一起使用，这样当队列已满时就可以执行不同的代码。比如输出一条日志信息并丢弃。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def producer(q):</span><br><span class="line">    ...</span><br><span class="line">    try:</span><br><span class="line">        q.put(item, block=False)</span><br><span class="line">    except queue.Full:</span><br><span class="line">        log.warning(&#x27;queued item %r discarded!&#x27;, item)</span><br></pre></td></tr></table></figure>
<p>如果你试图让消费者线程在执行像 <code>q.get()</code>​ 这样的操作时，超时自动终止以便检查终止标志，你应该使用 <code>q.get()</code>​ 的可选参数 <code>timeout</code>​ ，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_running = True</span><br><span class="line"></span><br><span class="line">def consumer(q):</span><br><span class="line">    while _running:</span><br><span class="line">        try:</span><br><span class="line">            item = q.get(timeout=5.0)</span><br><span class="line">            # Process item</span><br><span class="line">            ...</span><br><span class="line">        except queue.Empty:</span><br><span class="line">            pass</span><br></pre></td></tr></table></figure>
<p>最后，有 <code>q.qsize()</code>​ ， <code>q.full()</code>​ ， <code>q.empty()</code>​ 等实用方法可以获取一个队列的当前大小和状态。但要注意，这些方法都不是线程安全的。可能你对一个队列使用 <code>empty()</code>​ 判断出这个队列为空，但同时另外一个线程可能已经向这个队列中插入一个数据项。所以，你最好不要在你的代码中使用这些方法。</p>
<h1 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h1><p>要在多线程程序中安全使用可变对象，你需要使用 threading 库中的 <code>&lt;span class=&quot;pre&quot;&gt;Lock&lt;/span&gt;</code>​ 对象，就像下边这个例子这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line"></span><br><span class="line">class SharedCounter:</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    A counter object that can be shared by multiple threads.</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    def __init__(self, initial_value = 0):</span><br><span class="line">        self._value = initial_value</span><br><span class="line">        self._value_lock = threading.Lock()</span><br><span class="line"></span><br><span class="line">    def incr(self,delta=1):</span><br><span class="line">        &#x27;&#x27;&#x27;</span><br><span class="line">        Increment the counter with locking</span><br><span class="line">        &#x27;&#x27;&#x27;</span><br><span class="line">        with self._value_lock:</span><br><span class="line">             self._value += delta</span><br><span class="line"></span><br><span class="line">    def decr(self,delta=1):</span><br><span class="line">        &#x27;&#x27;&#x27;</span><br><span class="line">        Decrement the counter with locking</span><br><span class="line">        &#x27;&#x27;&#x27;</span><br><span class="line">        with self._value_lock:</span><br><span class="line">             self._value -= delta</span><br></pre></td></tr></table></figure>
<p><code>&lt;span class=&quot;pre&quot;&gt;Lock&lt;/span&gt;</code>​ 对象和 <code>&lt;span class=&quot;pre&quot;&gt;with&lt;/span&gt;</code>​ 语句块一起使用可以保证互斥执行，就是每次只有一个线程可以执行 with 语句包含的代码块。with 语句会在这个代码块执行前自动获取锁，在执行结束后自动释放锁。</p>
<h2 id="讨论-3"><a href="#讨论-3" class="headerlink" title="讨论"></a>讨论</h2><p>线程调度本质上是不确定的，因此，在多线程程序中错误地使用锁机制可能会导致随机数据损坏或者其他的异常行为，我们称之为竞争条件。为了避免竞争条件，最好只在临界区（对临界资源进行操作的那部分代码）使用锁。 在一些“老的” Python 代码中，显式获取和释放锁是很常见的。下边是一个上一个例子的变种：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line"></span><br><span class="line">class SharedCounter:</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    A counter object that can be shared by multiple threads.</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    def __init__(self, initial_value = 0):</span><br><span class="line">        self._value = initial_value</span><br><span class="line">        self._value_lock = threading.Lock()</span><br><span class="line"></span><br><span class="line">    def incr(self,delta=1):</span><br><span class="line">        &#x27;&#x27;&#x27;</span><br><span class="line">        Increment the counter with locking</span><br><span class="line">        &#x27;&#x27;&#x27;</span><br><span class="line">        self._value_lock.acquire()</span><br><span class="line">        self._value += delta</span><br><span class="line">        self._value_lock.release()</span><br><span class="line"></span><br><span class="line">    def decr(self,delta=1):</span><br><span class="line">        &#x27;&#x27;&#x27;</span><br><span class="line">        Decrement the counter with locking</span><br><span class="line">        &#x27;&#x27;&#x27;</span><br><span class="line">        self._value_lock.acquire()</span><br><span class="line">        self._value -= delta</span><br><span class="line">        self._value_lock.release()</span><br></pre></td></tr></table></figure>
<p><strong>相比于这种显式调用的方法，with 语句更加优雅，也更不容易出错</strong>，特别是程序员可能会忘记调用 release() 方法或者程序在获得锁之后产生异常这两种情况（使用 with 语句可以保证在这两种情况下仍能正确释放锁）。 为了避免出现死锁的情况，使用锁机制的程序应该设定为每个线程一次只允许获取一个锁。如果不能这样做的话，你就需要更高级的死锁避免机制，我们将在12.5节介绍。 在 <code>threading</code>​ 库中还提供了其他的同步原语，比如 <code>RLock</code>​ 和 <code>Semaphore</code>​ 对象。但是根据以往经验，这些原语是用于一些特殊的情况，如果你只是需要简单地对可变对象进行锁定，那就不应该使用它们。一个 <code>RLock</code>​ （可重入锁）可以被同一个线程多次获取，主要用来实现基于监测对象模式的锁定和同步。在使用这种锁的情况下，当锁被持有时，只有一个线程可以使用完整的函数或者类中的方法。比如，你可以实现一个这样的 SharedCounter 类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line"></span><br><span class="line">class SharedCounter:</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    A counter object that can be shared by multiple threads.</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    _lock = threading.RLock()</span><br><span class="line">    def __init__(self, initial_value = 0):</span><br><span class="line">        self._value = initial_value</span><br><span class="line"></span><br><span class="line">    def incr(self,delta=1):</span><br><span class="line">        &#x27;&#x27;&#x27;</span><br><span class="line">        Increment the counter with locking</span><br><span class="line">        &#x27;&#x27;&#x27;</span><br><span class="line">        with SharedCounter._lock:</span><br><span class="line">            self._value += delta</span><br><span class="line"></span><br><span class="line">    def decr(self,delta=1):</span><br><span class="line">        &#x27;&#x27;&#x27;</span><br><span class="line">        Decrement the counter with locking</span><br><span class="line">        &#x27;&#x27;&#x27;</span><br><span class="line">        with SharedCounter._lock:</span><br><span class="line">             self.incr(-delta)</span><br></pre></td></tr></table></figure>
<p>在上边这个例子中，没有对每一个实例中的可变对象加锁，取而代之的是一个被所有实例共享的类级锁。这个锁用来同步类方法，具体来说就是，这个锁可以保证一次只有一个线程可以调用这个类方法。不过，与一个标准的锁不同的是，已经持有这个锁的方法在调用同样使用这个锁的方法时，无需再次获取锁。比如 decr 方法。 这种实现方式的一个特点是，无论这个类有多少个实例都只用一个锁。因此在需要大量使用计数器的情况下内存效率更高。不过这样做也有缺点，就是在程序中使用大量线程并频繁更新计数器时会有争用锁的问题。 信号量对象是一个建立在共享计数器基础上的同步原语。如果计数器不为0，with 语句将计数器减1，线程被允许执行。with 语句执行结束后，计数器加１。如果计数器为0，线程将被阻塞，直到其他线程结束将计数器加1。尽管你可以在程序中像标准锁一样使用信号量来做线程同步，但是这种方式并不被推荐，<strong>因为使用信号量为程序增加的复杂性会影响程序性能。</strong> 相对于简单地作为锁使用，信号量更适用于那些需要在线程之间引入信号或者限制的程序。比如，你需要限制一段代码的并发访问量，你就可以像下面这样使用信号量完成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from threading import Semaphore</span><br><span class="line">import urllib.request</span><br><span class="line"></span><br><span class="line"># At most, five threads allowed to run at once</span><br><span class="line">_fetch_url_sema = Semaphore(5)</span><br><span class="line"></span><br><span class="line">def fetch_url(url):</span><br><span class="line">    with _fetch_url_sema:</span><br><span class="line">        return urllib.request.urlopen(url)</span><br></pre></td></tr></table></figure>
<p>如果你对线程同步原语的底层理论和实现感兴趣，可以参考操作系统相关书籍，绝大多数都有提及。</p>
<h1 id="防止死锁的加锁机制"><a href="#防止死锁的加锁机制" class="headerlink" title="防止死锁的加锁机制"></a>防止死锁的加锁机制</h1><p>（这一章节我没看）</p>
<p>在多线程程序中，死锁问题很大一部分是由于线程同时获取多个锁造成的。举个例子：一个线程获取了第一个锁，然后在获取第二个锁的 时候发生阻塞，那么这个线程就可能阻塞其他线程的执行，从而导致整个程序假死。 解决死锁问题的一种方案是为程序中的每一个锁分配一个唯一的id，然后只允许按照升序规则来使用多个锁，这个规则使用上下文管理器 是非常容易实现的，示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line">from contextlib import contextmanager</span><br><span class="line"></span><br><span class="line"># Thread-local state to stored information on locks already acquired</span><br><span class="line">_local = threading.local()</span><br><span class="line"></span><br><span class="line">@contextmanager</span><br><span class="line">def acquire(*locks):</span><br><span class="line">    # Sort locks by object identifier</span><br><span class="line">    locks = sorted(locks, key=lambda x: id(x))</span><br><span class="line"></span><br><span class="line">    # Make sure lock order of previously acquired locks is not violated</span><br><span class="line">    acquired = getattr(_local,&#x27;acquired&#x27;,[])</span><br><span class="line">    if acquired and max(id(lock) for lock in acquired) &gt;= id(locks[0]):</span><br><span class="line">        raise RuntimeError(&#x27;Lock Order Violation&#x27;)</span><br><span class="line"></span><br><span class="line">    # Acquire all of the locks</span><br><span class="line">    acquired.extend(locks)</span><br><span class="line">    _local.acquired = acquired</span><br><span class="line"></span><br><span class="line">    try:</span><br><span class="line">        for lock in locks:</span><br><span class="line">            lock.acquire()</span><br><span class="line">        yield</span><br><span class="line">    finally:</span><br><span class="line">        # Release locks in reverse order of acquisition</span><br><span class="line">        for lock in reversed(locks):</span><br><span class="line">            lock.release()</span><br><span class="line">        del acquired[-len(locks):]</span><br></pre></td></tr></table></figure>
<p>如何使用这个上下文管理器呢？你可以按照正常途径创建一个锁对象，但不论是单个锁还是多个锁中都使用 <code>&lt;span class=&quot;pre&quot;&gt;acquire()&lt;/span&gt;</code>​ 函数来申请锁， 示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line">x_lock = threading.Lock()</span><br><span class="line">y_lock = threading.Lock()</span><br><span class="line"></span><br><span class="line">def thread_1():</span><br><span class="line">    while True:</span><br><span class="line">        with acquire(x_lock, y_lock):</span><br><span class="line">            print(&#x27;Thread-1&#x27;)</span><br><span class="line"></span><br><span class="line">def thread_2():</span><br><span class="line">    while True:</span><br><span class="line">        with acquire(y_lock, x_lock):</span><br><span class="line">            print(&#x27;Thread-2&#x27;)</span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target=thread_1)</span><br><span class="line">t1.daemon = True</span><br><span class="line">t1.start()</span><br><span class="line"></span><br><span class="line">t2 = threading.Thread(target=thread_2)</span><br><span class="line">t2.daemon = True</span><br><span class="line">t2.start()</span><br></pre></td></tr></table></figure>
<p>如果你执行这段代码，你会发现它即使在不同的函数中以不同的顺序获取锁也没有发生死锁。 其关键在于，在第一段代码中，我们对这些锁进行了排序。通过排序，使得不管用户以什么样的顺序来请求锁，这些锁都会按照固定的顺序被获取。 如果有多个 <code>&lt;span class=&quot;pre&quot;&gt;acquire()&lt;/span&gt;</code>​ 操作被嵌套调用，可以通过线程本地存储（TLS）来检测潜在的死锁问题。 假设你的代码是这样写的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line">x_lock = threading.Lock()</span><br><span class="line">y_lock = threading.Lock()</span><br><span class="line"></span><br><span class="line">def thread_1():</span><br><span class="line"></span><br><span class="line">    while True:</span><br><span class="line">        with acquire(x_lock):</span><br><span class="line">            with acquire(y_lock):</span><br><span class="line">                print(&#x27;Thread-1&#x27;)</span><br><span class="line"></span><br><span class="line">def thread_2():</span><br><span class="line">    while True:</span><br><span class="line">        with acquire(y_lock):</span><br><span class="line">            with acquire(x_lock):</span><br><span class="line">                print(&#x27;Thread-2&#x27;)</span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target=thread_1)</span><br><span class="line">t1.daemon = True</span><br><span class="line">t1.start()</span><br><span class="line"></span><br><span class="line">t2 = threading.Thread(target=thread_2)</span><br><span class="line">t2.daemon = True</span><br><span class="line">t2.start()</span><br></pre></td></tr></table></figure>
<p>如果你运行这个版本的代码，必定会有一个线程发生崩溃，异常信息可能像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Exception in thread Thread-1:</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/usr/local/lib/python3.3/threading.py&quot;, line 639, in _bootstrap_inner</span><br><span class="line">    self.run()</span><br><span class="line">  File &quot;/usr/local/lib/python3.3/threading.py&quot;, line 596, in run</span><br><span class="line">    self._target(*self._args, **self._kwargs)</span><br><span class="line">  File &quot;deadlock.py&quot;, line 49, in thread_1</span><br><span class="line">    with acquire(y_lock):</span><br><span class="line">  File &quot;/usr/local/lib/python3.3/contextlib.py&quot;, line 48, in __enter__</span><br><span class="line">    return next(self.gen)</span><br><span class="line">  File &quot;deadlock.py&quot;, line 15, in acquire</span><br><span class="line">    raise RuntimeError(&quot;Lock Order Violation&quot;)</span><br><span class="line">RuntimeError: Lock Order Violation</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>发生崩溃的原因在于，每个线程都记录着自己已经获取到的锁。 <code>&lt;span class=&quot;pre&quot;&gt;acquire()&lt;/span&gt;</code>​ 函数会检查之前已经获取的锁列表， 由于锁是按照升序排列获取的，所以函数会认为之前已获取的锁的id必定小于新申请到的锁，这时就会触发异常。</p>
<h2 id="讨论-4"><a href="#讨论-4" class="headerlink" title="讨论"></a>讨论</h2><p>死锁是每一个多线程程序都会面临的一个问题（就像它是每一本操作系统课本的共同话题一样）。根据经验来讲，尽可能保证每一个 线程只能同时保持一个锁，这样程序就不会被死锁问题所困扰。一旦有线程同时申请多个锁，一切就不可预料了。</p>
<p>死锁的检测与恢复是一个几乎没有优雅的解决方案的扩展话题。一个比较常用的死锁检测与恢复的方案是引入看门狗计数器。当线程正常 运行的时候会每隔一段时间重置计数器，在没有发生死锁的情况下，一切都正常进行。一旦发生死锁，由于无法重置计数器导致定时器 超时，这时程序会通过重启自身恢复到正常状态。</p>
<p>避免死锁是另外一种解决死锁问题的方式，在进程获取锁的时候会严格按照对象id升序排列获取，经过数学证明，这样保证程序不会进入 死锁状态。证明就留给读者作为练习了。避免死锁的主要思想是，单纯地按照对象id递增的顺序加锁不会产生循环依赖，而循环依赖是 死锁的一个必要条件，从而避免程序进入死锁状态。</p>
<p>下面以一个关于线程死锁的经典问题：“哲学家就餐问题”，作为本节最后一个例子。题目是这样的：五位哲学家围坐在一张桌子前，每个人 面前有一碗饭和一只筷子。在这里每个哲学家可以看做是一个独立的线程，而每只筷子可以看做是一个锁。每个哲学家可以处在静坐、 思考、吃饭三种状态中的一个。需要注意的是，每个哲学家吃饭是需要两只筷子的，这样问题就来了：如果每个哲学家都拿起自己左边的筷子， 那么他们五个都只能拿着一只筷子坐在那儿，直到饿死。此时他们就进入了死锁状态。 下面是一个简单的使用死锁避免机制解决“哲学家就餐问题”的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line"></span><br><span class="line"># The philosopher thread</span><br><span class="line">def philosopher(left, right):</span><br><span class="line">    while True:</span><br><span class="line">        with acquire(left,right):</span><br><span class="line">             print(threading.currentThread(), &#x27;eating&#x27;)</span><br><span class="line"></span><br><span class="line"># The chopsticks (represented by locks)</span><br><span class="line">NSTICKS = 5</span><br><span class="line">chopsticks = [threading.Lock() for n in range(NSTICKS)]</span><br><span class="line"></span><br><span class="line"># Create all of the philosophers</span><br><span class="line">for n in range(NSTICKS):</span><br><span class="line">    t = threading.Thread(target=philosopher,</span><br><span class="line">                         args=(chopsticks[n],chopsticks[(n+1) % NSTICKS]))</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure>
<p>最后，要特别注意到，为了避免死锁，所有的加锁操作必须使用 <code>&lt;span class=&quot;pre&quot;&gt;acquire()&lt;/span&gt;</code>​ 函数。如果代码中的某部分绕过acquire 函数直接申请锁，那么整个死锁避免机制就不起作用了。</p>
<p>‍</p>
<h1 id="保存线程的状态信息"><a href="#保存线程的状态信息" class="headerlink" title="保存线程的状态信息"></a>保存线程的状态信息</h1><blockquote>
<p>和Java ThreadLocal类似，介绍了怎么用</p>
</blockquote>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>你需要保存正在运行线程的状态，这个状态对于其他的线程是不可见的。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>有时在多线程编程中，你需要只保存当前运行线程的状态。 要这么做，可使用 <code>&lt;span class=&quot;pre&quot;&gt;thread.local()&lt;/span&gt;</code>​ 创建一个本地线程存储对象。 对这个对象的属性的保存和读取操作都只会对执行线程可见，而其他线程并不可见。</p>
<p>作为使用本地存储的一个有趣的实际例子， 考虑在8.3小节定义过的 <code>&lt;span class=&quot;pre&quot;&gt;LazyConnection&lt;/span&gt;</code>​ 上下文管理器类。 下面我们对它进行一些小的修改使得它可以适用于多线程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from socket import socket, AF_INET, SOCK_STREAM</span><br><span class="line">import threading</span><br><span class="line"></span><br><span class="line">class LazyConnection:</span><br><span class="line">    def __init__(self, address, family=AF_INET, type=SOCK_STREAM):</span><br><span class="line">        self.address = address</span><br><span class="line">        self.family = AF_INET</span><br><span class="line">        self.type = SOCK_STREAM</span><br><span class="line">        self.local = threading.local()</span><br><span class="line"></span><br><span class="line">    def __enter__(self):</span><br><span class="line">        if hasattr(self.local, &#x27;sock&#x27;):</span><br><span class="line">            raise RuntimeError(&#x27;Already connected&#x27;)</span><br><span class="line">        self.local.sock = socket(self.family, self.type)</span><br><span class="line">        self.local.sock.connect(self.address)</span><br><span class="line">        return self.local.sock</span><br><span class="line"></span><br><span class="line">    def __exit__(self, exc_ty, exc_val, tb):</span><br><span class="line">        self.local.sock.close()</span><br><span class="line">        del self.local.sock</span><br></pre></td></tr></table></figure>
<p>代码中，自己观察对于 <code>&lt;span class=&quot;pre&quot;&gt;self.local&lt;/span&gt;</code>​ 属性的使用。 它被初始化为一个 <code>&lt;span class=&quot;pre&quot;&gt;threading.local()&lt;/span&gt;</code>​ 实例。 其他方法操作被存储为 <code>&lt;span class=&quot;pre&quot;&gt;self.local.sock&lt;/span&gt;</code>​ 的套接字对象。 有了这些就可以在多线程中安全的使用 <code>&lt;span class=&quot;pre&quot;&gt;LazyConnection&lt;/span&gt;</code>​ 实例了。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from functools import partial</span><br><span class="line">def test(conn):</span><br><span class="line">    with conn as s:</span><br><span class="line">        s.send(b&#x27;GET /index.html HTTP/1.0\r\n&#x27;)</span><br><span class="line">        s.send(b&#x27;Host: www.python.org\r\n&#x27;)</span><br><span class="line"></span><br><span class="line">        s.send(b&#x27;\r\n&#x27;)</span><br><span class="line">        resp = b&#x27;&#x27;.join(iter(partial(s.recv, 8192), b&#x27;&#x27;))</span><br><span class="line"></span><br><span class="line">    print(&#x27;Got &#123;&#125; bytes&#x27;.format(len(resp)))</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    conn = LazyConnection((&#x27;www.python.org&#x27;, 80))</span><br><span class="line"></span><br><span class="line">    t1 = threading.Thread(target=test, args=(conn,))</span><br><span class="line">    t2 = threading.Thread(target=test, args=(conn,))</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    t1.join()</span><br><span class="line">    t2.join()</span><br></pre></td></tr></table></figure>
<p>它之所以行得通的原因是每个线程会创建一个自己专属的套接字连接（存储为self.local.sock）。 因此，当不同的线程执行套接字操作时，由于操作的是不同的套接字，因此它们不会相互影响。</p>
<h2 id="讨论-5"><a href="#讨论-5" class="headerlink" title="讨论"></a>讨论</h2><p>在大部分程序中创建和操作线程特定状态并不会有什么问题。 不过，当出了问题的时候，通常是因为某个对象被多个线程使用到，用来操作一些专用的系统资源， 比如一个套接字或文件。你不能让所有线程共享一个单独对象， 因为多个线程同时读和写的时候会产生混乱。 本地线程存储通过让这些资源只能在被使用的线程中可见来解决这个问题。</p>
<p>本节中，使用 <code>&lt;span class=&quot;pre&quot;&gt;thread.local()&lt;/span&gt;</code>​ 可以让 <code>&lt;span class=&quot;pre&quot;&gt;LazyConnection&lt;/span&gt;</code>​ 类支持一个线程一个连接， 而不是对于所有的进程都只有一个连接。</p>
<p>其原理是，每个 <code>&lt;span class=&quot;pre&quot;&gt;threading.local()&lt;/span&gt;</code>​ 实例为每个线程维护着一个单独的实例字典。 所有普通实例操作比如获取、修改和删除值仅仅操作这个字典。 每个线程使用一个独立的字典就可以保证数据的隔离了。</p>
<p>‍</p>
<h1 id="创建线程池"><a href="#创建线程池" class="headerlink" title="创建线程池"></a>创建线程池</h1><p><code>concurrent.futures</code>​ 函数库有一个 <code>ThreadPoolExecutor</code>​ 类可以被用来完成这个任务。 下面是一个简单的TCP服务器，使用了一个线程池来响应客户端：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from socket import AF_INET, SOCK_STREAM, socket</span><br><span class="line">from concurrent.futures import ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line">def echo_client(sock, client_addr):</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    Handle a client connection</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    print(&#x27;Got connection from&#x27;, client_addr)</span><br><span class="line">    while True:</span><br><span class="line">        msg = sock.recv(65536)</span><br><span class="line">        if not msg:</span><br><span class="line">            break</span><br><span class="line">        sock.sendall(msg)</span><br><span class="line">    print(&#x27;Client closed connection&#x27;)</span><br><span class="line">    sock.close()</span><br><span class="line"></span><br><span class="line">def echo_server(addr):</span><br><span class="line">    pool = ThreadPoolExecutor(128)</span><br><span class="line">    sock = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">    sock.bind(addr)</span><br><span class="line">    sock.listen(5)</span><br><span class="line">    while True:</span><br><span class="line">        client_sock, client_addr = sock.accept()</span><br><span class="line">        pool.submit(echo_client, client_sock, client_addr)</span><br><span class="line"></span><br><span class="line">echo_server((&#x27;&#x27;,15000))</span><br></pre></td></tr></table></figure>
<p>如果你想手动创建你自己的线程池， 通常可以使用一个Queue来轻松实现。下面是一个稍微不同但是手动实现的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from socket import socket, AF_INET, SOCK_STREAM</span><br><span class="line">from threading import Thread</span><br><span class="line">from queue import Queue</span><br><span class="line"></span><br><span class="line">def echo_client(q):</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    Handle a client connection</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    sock, client_addr = q.get()</span><br><span class="line">    print(&#x27;Got connection from&#x27;, client_addr)</span><br><span class="line">    while True:</span><br><span class="line">        msg = sock.recv(65536)</span><br><span class="line">        if not msg:</span><br><span class="line">            break</span><br><span class="line">        sock.sendall(msg)</span><br><span class="line">    print(&#x27;Client closed connection&#x27;)</span><br><span class="line"></span><br><span class="line">    sock.close()</span><br><span class="line"></span><br><span class="line">def echo_server(addr, nworkers):</span><br><span class="line">    # Launch the client workers</span><br><span class="line">    q = Queue()</span><br><span class="line">    for n in range(nworkers):</span><br><span class="line">        t = Thread(target=echo_client, args=(q,))</span><br><span class="line">        t.daemon = True</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line">    # Run the server</span><br><span class="line">    sock = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">    sock.bind(addr)</span><br><span class="line">    sock.listen(5)</span><br><span class="line">    while True:</span><br><span class="line">        client_sock, client_addr = sock.accept()</span><br><span class="line">        q.put((client_sock, client_addr))</span><br><span class="line"></span><br><span class="line">echo_server((&#x27;&#x27;,15000), 128)</span><br></pre></td></tr></table></figure>
<p>使用 <code>&lt;span class=&quot;pre&quot;&gt;ThreadPoolExecutor&lt;/span&gt;</code>​ 相对于手动实现的一个好处在于它使得 任务提交者更方便的从被调用函数中获取返回值。例如，你可能会像下面这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from concurrent.futures import ThreadPoolExecutor</span><br><span class="line">import urllib.request</span><br><span class="line"></span><br><span class="line">def fetch_url(url):</span><br><span class="line">    u = urllib.request.urlopen(url)</span><br><span class="line">    data = u.read()</span><br><span class="line">    return data</span><br><span class="line"></span><br><span class="line">pool = ThreadPoolExecutor(10)</span><br><span class="line"># Submit work to the pool</span><br><span class="line">a = pool.submit(fetch_url, &#x27;http://www.python.org&#x27;)</span><br><span class="line">b = pool.submit(fetch_url, &#x27;http://www.pypy.org&#x27;)</span><br><span class="line"></span><br><span class="line"># Get the results back</span><br><span class="line">x = a.result()</span><br><span class="line">y = b.result()</span><br></pre></td></tr></table></figure>
<p>例子中返回的handle对象会帮你处理所有的阻塞与协作，然后从工作线程中返回数据给你。 特别的，<code>&lt;span class=&quot;pre&quot;&gt;a.result()&lt;/span&gt;</code>​ 操作会阻塞进程直到对应的函数执行完成并返回一个结果。</p>
<h2 id="讨论-6"><a href="#讨论-6" class="headerlink" title="讨论"></a>讨论</h2><p>通常来讲，你应该避免编写线程数量可以无限制增长的程序。例如，看看下面这个服务器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from threading import Thread</span><br><span class="line">from socket import socket, AF_INET, SOCK_STREAM</span><br><span class="line"></span><br><span class="line">def echo_client(sock, client_addr):</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    Handle a client connection</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    print(&#x27;Got connection from&#x27;, client_addr)</span><br><span class="line">    while True:</span><br><span class="line">        msg = sock.recv(65536)</span><br><span class="line">        if not msg:</span><br><span class="line">            break</span><br><span class="line">        sock.sendall(msg)</span><br><span class="line">    print(&#x27;Client closed connection&#x27;)</span><br><span class="line">    sock.close()</span><br><span class="line"></span><br><span class="line">def echo_server(addr, nworkers):</span><br><span class="line">    # Run the server</span><br><span class="line">    sock = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">    sock.bind(addr)</span><br><span class="line">    sock.listen(5)</span><br><span class="line">    while True:</span><br><span class="line">        client_sock, client_addr = sock.accept()</span><br><span class="line">        t = Thread(target=echo_client, args=(client_sock, client_addr))</span><br><span class="line">        t.daemon = True</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line">echo_server((&#x27;&#x27;,15000))</span><br></pre></td></tr></table></figure>
<p>尽管这个也可以工作， 但是它不能抵御有人试图通过创建大量线程让你服务器资源枯竭而崩溃的攻击行为。 通过使用预先初始化的线程池，你可以设置同时运行线程的上限数量。</p>
<p>你可能会关心创建大量线程会有什么后果。 现代操作系统可以很轻松的创建几千个线程的线程池。 甚至，同时几千个线程等待工作并不会对其他代码产生性能影响。 当然了，如果所有线程同时被唤醒并立即在CPU上执行，那就不同了——特别是有了全局解释器锁GIL。 通常，你应该只在I/O处理相关代码中使用线程池。</p>
<p>创建大的线程池的一个可能需要关注的问题是内存的使用。 例如，如果你在OS X系统上面创建2000个线程，系统显示Python进程使用了超过9GB的虚拟内存。 不过，这个计算通常是有误差的。当创建一个线程时，操作系统会预留一个虚拟内存区域来 放置线程的执行栈（通常是8MB大小）。但是这个内存只有一小片段被实际映射到真实内存中。 因此，Python进程使用到的真实内存其实很小 （比如，对于2000个线程来讲，只使用到了70MB的真实内存，而不是9GB）。 如果你担心虚拟内存大小，可以使用 <code>&lt;span class=&quot;pre&quot;&gt;threading.stack_size()&lt;/span&gt;</code>​ 函数来降低它。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line">threading.stack_size(65536)</span><br></pre></td></tr></table></figure>
<p>如果你加上这条语句并再次运行前面的创建2000个线程试验， 你会发现Python进程只使用到了大概210MB的虚拟内存，而真实内存使用量没有变。 注意线程栈大小必须至少为32768字节，通常是系统内存页大小（4096、8192等）的整数倍。</p>
<p>‍</p>
<h1 id="简单并行编程"><a href="#简单并行编程" class="headerlink" title="简单并行编程"></a>简单并行编程</h1><p>你有个程序要执行CPU密集型工作，你想让他利用多核CPU的优势来运行的快一点。</p>
<h2 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h2><p><code>concurrent.futures</code>​ 库提供了一个 <code>ProcessPoolExecutor</code>​ 类， 可被用来在一个单独的Python解释器中执行计算密集型函数。 不过，要使用它，你首先要有一些计算密集型的任务。 我们通过一个简单而实际的例子来演示它。假定你有个Apache web服务器日志目录的gzip压缩包：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">logs/</span><br><span class="line">   20120701.log.gz</span><br><span class="line">   20120702.log.gz</span><br><span class="line">   20120703.log.gz</span><br><span class="line">   20120704.log.gz</span><br><span class="line">   20120705.log.gz</span><br><span class="line">   20120706.log.gz</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>
<p>进一步假设每个日志文件内容类似下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">124.115.6.12 - - [10/Jul/2012:00:18:50 -0500] &quot;GET /robots.txt ...&quot; 200 71</span><br><span class="line">210.212.209.67 - - [10/Jul/2012:00:18:51 -0500] &quot;GET /ply/ ...&quot; 200 11875</span><br><span class="line">210.212.209.67 - - [10/Jul/2012:00:18:51 -0500] &quot;GET /favicon.ico ...&quot; 404 369</span><br><span class="line">61.135.216.105 - - [10/Jul/2012:00:20:04 -0500] &quot;GET /blog/atom.xml ...&quot; 304 -</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>下面是一个脚本，在这些日志文件中查找出所有访问过robots.txt文件的主机：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># findrobots.py</span><br><span class="line"></span><br><span class="line">import gzip</span><br><span class="line">import io</span><br><span class="line">import glob</span><br><span class="line"></span><br><span class="line">def find_robots(filename):</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    Find all of the hosts that access robots.txt in a single log file</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    robots = set()</span><br><span class="line">    with gzip.open(filename) as f:</span><br><span class="line">        for line in io.TextIOWrapper(f,encoding=&#x27;ascii&#x27;):</span><br><span class="line">            fields = line.split()</span><br><span class="line">            if fields[6] == &#x27;/robots.txt&#x27;:</span><br><span class="line">                robots.add(fields[0])</span><br><span class="line">    return robots</span><br><span class="line"></span><br><span class="line">def find_all_robots(logdir):</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    Find all hosts across and entire sequence of files</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    files = glob.glob(logdir+&#x27;/*.log.gz&#x27;)</span><br><span class="line">    all_robots = set()</span><br><span class="line">    for robots in map(find_robots, files):</span><br><span class="line">        all_robots.update(robots)</span><br><span class="line">    return all_robots</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    robots = find_all_robots(&#x27;logs&#x27;)</span><br><span class="line">    for ipaddr in robots:</span><br><span class="line">        print(ipaddr)</span><br></pre></td></tr></table></figure>
<p>前面的程序使用了通常的map-reduce风格来编写。 函数 <code>&lt;span class=&quot;pre&quot;&gt;find_robots()&lt;/span&gt;</code>​ 在一个文件名集合上做map操作，并将结果汇总为一个单独的结果， 也就是 <code>&lt;span class=&quot;pre&quot;&gt;find_all_robots()&lt;/span&gt;</code>​ 函数中的 <code>&lt;span class=&quot;pre&quot;&gt;all_robots&lt;/span&gt;</code>​ 集合。 现在，假设你想要修改这个程序让它使用多核CPU。 很简单——只需要将map()操作替换为一个 <code>&lt;span class=&quot;pre&quot;&gt;concurrent.futures&lt;/span&gt;</code>​ 库中生成的类似操作即可。 下面是一个简单修改版本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># findrobots.py</span><br><span class="line"></span><br><span class="line">import gzip</span><br><span class="line">import io</span><br><span class="line">import glob</span><br><span class="line">from concurrent import futures</span><br><span class="line"></span><br><span class="line">def find_robots(filename):</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    Find all of the hosts that access robots.txt in a single log file</span><br><span class="line"></span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    robots = set()</span><br><span class="line">    with gzip.open(filename) as f:</span><br><span class="line">        for line in io.TextIOWrapper(f,encoding=&#x27;ascii&#x27;):</span><br><span class="line">            fields = line.split()</span><br><span class="line">            if fields[6] == &#x27;/robots.txt&#x27;:</span><br><span class="line">                robots.add(fields[0])</span><br><span class="line">    return robots</span><br><span class="line"></span><br><span class="line">def find_all_robots(logdir):</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    Find all hosts across and entire sequence of files</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    files = glob.glob(logdir+&#x27;/*.log.gz&#x27;)</span><br><span class="line">    all_robots = set()</span><br><span class="line">    with futures.ProcessPoolExecutor() as pool:</span><br><span class="line">        for robots in pool.map(find_robots, files):</span><br><span class="line">            all_robots.update(robots)</span><br><span class="line">    return all_robots</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    robots = find_all_robots(&#x27;logs&#x27;)</span><br><span class="line">    for ipaddr in robots:</span><br><span class="line">        print(ipaddr)</span><br></pre></td></tr></table></figure>
<p>通过这个修改后，运行这个脚本产生同样的结果，但是在四核机器上面比之前快了3.5倍。 实际的性能优化效果根据你的机器CPU数量的不同而不同。</p>
<h2 id="讨论-7"><a href="#讨论-7" class="headerlink" title="讨论"></a>讨论</h2><p><code>&lt;span class=&quot;pre&quot;&gt;ProcessPoolExecutor&lt;/span&gt;</code>​ 的典型用法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from concurrent.futures import ProcessPoolExecutor</span><br><span class="line"></span><br><span class="line">with ProcessPoolExecutor() as pool:</span><br><span class="line">    ...</span><br><span class="line">    do work in parallel using pool</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>其原理是，一个 <code>&lt;span class=&quot;pre&quot;&gt;ProcessPoolExecutor&lt;/span&gt;</code>​ 创建N个独立的Python解释器， N是系统上面可用CPU的个数。你可以通过提供可选参数给 <code>&lt;span class=&quot;pre&quot;&gt;ProcessPoolExecutor(N)&lt;/span&gt;</code>​ 来修改 处理器数量。这个处理池会一直运行到with块中最后一个语句执行完成， 然后处理池被关闭。不过，程序会一直等待直到所有提交的工作被处理完成。</p>
<p>被提交到池中的工作必须被定义为一个函数。有两种方法去提交。 如果你想让一个列表推导或一个 <code>&lt;span class=&quot;pre&quot;&gt;map()&lt;/span&gt;</code>​ 操作并行执行的话，可使用 <code>&lt;span class=&quot;pre&quot;&gt;pool.map()&lt;/span&gt;</code>​ :</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># A function that performs a lot of work</span><br><span class="line">def work(x):</span><br><span class="line">    ...</span><br><span class="line">    return result</span><br><span class="line"></span><br><span class="line"># Nonparallel code</span><br><span class="line">results = map(work, data)</span><br><span class="line"></span><br><span class="line"># Parallel implementation</span><br><span class="line">with ProcessPoolExecutor() as pool:</span><br><span class="line">    results = pool.map(work, data)</span><br></pre></td></tr></table></figure>
<p>另外，你可以使用 <code>&lt;span class=&quot;pre&quot;&gt;pool.submit()&lt;/span&gt;</code>​ 来手动的提交单个任务：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Some function</span><br><span class="line">def work(x):</span><br><span class="line">    ...</span><br><span class="line">    return result</span><br><span class="line"></span><br><span class="line">with ProcessPoolExecutor() as pool:</span><br><span class="line">    ...</span><br><span class="line">    # Example of submitting work to the pool</span><br><span class="line">    future_result = pool.submit(work, arg)</span><br><span class="line"></span><br><span class="line">    # Obtaining the result (blocks until done)</span><br><span class="line">    r = future_result.result()</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>如果你手动提交一个任务，结果是一个 <code>&lt;span class=&quot;pre&quot;&gt;Future&lt;/span&gt;</code>​ 实例。 要获取最终结果，你需要调用它的 <code>&lt;span class=&quot;pre&quot;&gt;result()&lt;/span&gt;</code>​ 方法。 它会阻塞进程直到结果被返回来。</p>
<p>如果不想阻塞，你还可以使用一个回调函数，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def when_done(r):</span><br><span class="line">    print(&#x27;Got:&#x27;, r.result())</span><br><span class="line"></span><br><span class="line">with ProcessPoolExecutor() as pool:</span><br><span class="line">     future_result = pool.submit(work, arg)</span><br><span class="line">     future_result.add_done_callback(when_done)</span><br></pre></td></tr></table></figure>
<p>回调函数接受一个 <code>&lt;span class=&quot;pre&quot;&gt;Future&lt;/span&gt;</code>​ 实例，被用来获取最终的结果（比如通过调用它的result()方法）。 尽管处理池很容易使用，在设计大程序的时候还是有很多需要注意的地方，如下几点：</p>
<ul>
<li>这种并行处理技术只适用于那些可以被分解为互相独立部分的问题。</li>
<li>被提交的任务必须是简单函数形式。对于方法、闭包和其他类型的并行执行还不支持。</li>
<li>函数参数和返回值必须兼容pickle，因为要使用到进程间的通信，所有解释器之间的交换数据必须被序列化</li>
<li>被提交的任务函数不应保留状态或有副作用。除了打印日志之类简单的事情，</li>
</ul>
<p>一旦启动你不能控制子进程的任何行为，因此最好保持简单和纯洁——函数不要去修改环境。</p>
<ul>
<li>在Unix上进程池通过调用 <code>&lt;span class=&quot;pre&quot;&gt;fork()&lt;/span&gt;</code>​ 系统调用被创建，</li>
</ul>
<p>它会克隆Python解释器，包括fork时的所有程序状态。 而在Windows上，克隆解释器时不会克隆状态。 实际的fork操作会在第一次调用 <code>&lt;span class=&quot;pre&quot;&gt;pool.map()&lt;/span&gt;</code>​ 或 <code>&lt;span class=&quot;pre&quot;&gt;pool.submit()&lt;/span&gt;</code>​ 后发生。</p>
<ul>
<li>当你混合使用进程池和多线程的时候要特别小心。</li>
</ul>
<p>你应该在创建任何线程之前先创建并激活进程池（比如在程序启动的main线程中创建进程池）。</p>
<h1 id="Py的全局锁问题"><a href="#Py的全局锁问题" class="headerlink" title="Py的全局锁问题"></a>Py的全局锁问题</h1><p>尽管Python完全支持多线程编程， 但是解释器的C语言实现部分在完全并行执行时并不是线程安全的。 实际上，解释器被一个全局解释器锁保护着，它确保任何时候都只有一个Python线程执行。 GIL最大的问题就是Python的多线程程序并不能利用多核CPU的优势 （比如一个使用了多个线程的计算密集型程序只会在一个单CPU上面运行）。</p>
<p>在讨论普通的GIL之前，<strong>有一点要强调的是GIL只会影响到那些严重依赖CPU的程序</strong>（比如计算型的）。 如果你的程序大部分只会涉及到I/O，比如网络交互，那么使用多线程就很合适， 因为它们大部分时间都在等待。实际上，你完全可以放心的创建几千个Python线程， 现代操作系统运行这么多线程没有任何压力，没啥可担心的。</p>
<p>而对于依赖CPU的程序，你需要弄清楚执行的计算的特点。 例如，优化底层算法要比使用多线程运行快得多。 类似的，由于Python是解释执行的，如果你将那些性能瓶颈代码移到一个C语言扩展模块中， 速度也会提升的很快。如果你要操作数组，那么使用NumPy这样的扩展会非常的高效。 最后，你还可以考虑下其他可选实现方案，比如PyPy，它通过一个JIT编译器来优化执行效率 （不过在写这本书的时候它还不能支持Python 3）。</p>
<p>还有一点要注意的是，线程不是专门用来优化性能的。 一个CPU依赖型程序可能会使用线程来管理一个图形用户界面、一个网络连接或其他服务。 这时候，GIL会产生一些问题，因为如果一个线程长期持有GIL的话会导致其他非CPU型线程一直等待。 事实上，一个写的不好的C语言扩展会导致这个问题更加严重， 尽管代码的计算部分会比之前运行的更快些。</p>
<p>说了这么多，现在想说的是我们有两种策略来解决GIL的缺点。 首先，如果你完全工作于Python环境中，你可以使用 <code>&lt;span class=&quot;pre&quot;&gt;multiprocessing&lt;/span&gt;</code>​ 模块来创建一个进程池， 并像协同处理器一样的使用它。例如，假如你有如下的线程代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Performs a large calculation (CPU bound)</span><br><span class="line">def some_work(args):</span><br><span class="line">    ...</span><br><span class="line">    return result</span><br><span class="line"></span><br><span class="line"># A thread that calls the above function</span><br><span class="line">def some_thread():</span><br><span class="line">    while True:</span><br><span class="line">        ...</span><br><span class="line">        r = some_work(args)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>修改代码，使用进程池：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Processing pool (see below for initiazation)</span><br><span class="line">pool = None</span><br><span class="line"></span><br><span class="line"># Performs a large calculation (CPU bound)</span><br><span class="line">def some_work(args):</span><br><span class="line">    ...</span><br><span class="line">    return result</span><br><span class="line"></span><br><span class="line"># A thread that calls the above function</span><br><span class="line">def some_thread():</span><br><span class="line">    while True:</span><br><span class="line">        ...</span><br><span class="line">        r = pool.apply(some_work, (args))</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line"># Initiaze the pool</span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    import multiprocessing</span><br><span class="line">    pool = multiprocessing.Pool()</span><br></pre></td></tr></table></figure>
<p>这个通过使用一个技巧利用进程池解决了GIL的问题。 当一个线程想要执行CPU密集型工作时，会将任务发给进程池。 然后进程池会在另外一个进程中启动一个单独的Python解释器来工作。 当线程等待结果的时候会释放GIL。 并且，由于计算任务在单独解释器中执行，那么就不会受限于GIL了。 在一个多核系统上面，你会发现这个技术可以让你很好的利用多CPU的优势。</p>
<p>另外一个解决GIL的策略是使用<strong>C扩展编程技术</strong>。 主要思想是将计算密集型任务转移给C，跟Python独立，在工作的时候在C代码中释放GIL。 这可以通过在C代码中插入下面这样的特殊宏来完成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;Python.h&quot;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">PyObject *pyfunc(PyObject *self, PyObject *args) &#123;</span><br><span class="line">   ...</span><br><span class="line">   Py_BEGIN_ALLOW_THREADS</span><br><span class="line">   // Threaded C code</span><br><span class="line">   ...</span><br><span class="line">   Py_END_ALLOW_THREADS</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你使用其他工具访问C语言，比如对于Cython的ctypes库，你不需要做任何事。 例如，ctypes在调用C时会自动释放GIL。</p>
<h2 id="讨论-8"><a href="#讨论-8" class="headerlink" title="讨论"></a>讨论</h2><p>许多程序员在面对线程性能问题的时候，马上就会怪罪GIL，什么都是它的问题。 其实这样子太不厚道也太天真了点。 作为一个真实的例子，在多线程的网络编程中神秘的 <code>&lt;span class=&quot;pre&quot;&gt;stalls&lt;/span&gt;</code>​ 可能是因为其他原因比如一个DNS查找延时，而跟GIL毫无关系。 最后你真的需要先去搞懂你的代码是否真的被GIL影响到。 同时还要明白GIL大部分都应该只关注CPU的处理而不是I/O.</p>
<p>如果你准备使用一个处理器池，注意的是这样做涉及到数据序列化和在不同Python解释器通信。 被执行的操作需要放在一个通过def语句定义的Python函数中，不能是lambda、闭包可调用实例等， 并且函数参数和返回值必须要兼容pickle。 同样，要执行的任务量必须足够大以弥补额外的通信开销。</p>
<p>另外一个难点是当混合使用线程和进程池的时候会让你很头疼。 如果你要同时使用两者，最好在程序启动时，创建任何线程之前先创建一个单例的进程池。 然后线程使用同样的进程池来进行它们的计算密集型工作。</p>
<p>C扩展最重要的特征是它们和Python解释器是保持独立的。 也就是说，如果你准备将Python中的任务分配到C中去执行， 你需要确保C代码的操作跟Python保持独立， 这就意味着不要使用Python数据结构以及不要调用Python的C API。 另外一个就是你要确保C扩展所做的工作是足够的，值得你这样做。 也就是说C扩展担负起了大量的计算任务，而不是少数几个计算。</p>
<p>这些解决GIL的方案并不能适用于所有问题。 例如，某些类型的应用程序如果被分解为多个进程处理的话并不能很好的工作， 也不能将它的部分代码改成C语言执行。 对于这些应用程序，你就要自己需求解决方案了 （比如多进程访问共享内存区，多解析器运行于同一个进程等）。 或者，你还可以考虑下其他的解释器实现，比如PyPy。</p>
<p>了解更多关于在C扩展中释放GIL，请参考15.7和15.10小节。</p>
<p>‍</p>
<h1 id="Actor模式"><a href="#Actor模式" class="headerlink" title="Actor模式"></a>Actor模式</h1><p><strong>actor模式是一种最古老的也是最简单的并行和分布式计算解决方案。</strong>  事实上，它天生的简单性是它如此受欢迎的重要原因之一。 简单来讲，一个actor就是一个并发执行的任务，只是简单的执行发送给它的消息任务。 响应这些消息时，它可能还会给其他actor发送更进一步的消息。 actor之间的通信是单向和异步的。因此，消息发送者不知道消息是什么时候被发送， 也不会接收到一个消息已被处理的回应或通知。</p>
<p>结合使用一个线程和一个队列可以很容易的定义actor，例如：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Event</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sentinel used for shutdown</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ActorExit</span>(<span class="title class_ inherited__">Exception</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Actor</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._mailbox = Queue()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">send</span>(<span class="params">self, msg</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        Send a message to the actor</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        self._mailbox.put(msg)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recv</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        Receive an incoming message</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        msg = self._mailbox.get()</span><br><span class="line">        <span class="keyword">if</span> msg <span class="keyword">is</span> ActorExit:</span><br><span class="line">            <span class="keyword">raise</span> ActorExit()</span><br><span class="line">        <span class="keyword">return</span> msg</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">close</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        Close the actor, thus shutting it down</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        self.send(ActorExit)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        Start concurrent execution</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        self._terminated = Event()</span><br><span class="line">        t = Thread(target=self._bootstrap)</span><br><span class="line"></span><br><span class="line">        t.daemon = <span class="literal">True</span></span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_bootstrap</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.run()</span><br><span class="line">        <span class="keyword">except</span> ActorExit:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            self._terminated.<span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">join</span>(<span class="params">self</span>):</span><br><span class="line">        self._terminated.wait()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        Run method to be implemented by the user</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            msg = self.recv()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sample ActorTask</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PrintActor</span>(<span class="title class_ inherited__">Actor</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            msg = self.recv()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Got:&#x27;</span>, msg)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sample use</span></span><br><span class="line">p = PrintActor()</span><br><span class="line">p.start()</span><br><span class="line">p.send(<span class="string">&#x27;Hello&#x27;</span>)</span><br><span class="line">p.send(<span class="string">&#x27;World&#x27;</span>)</span><br><span class="line">p.close()</span><br><span class="line">p.join()</span><br></pre></td></tr></table></figure>
<p>这个例子中，你使用actor实例的 <code>&lt;span class=&quot;pre&quot;&gt;send()&lt;/span&gt;</code>​ 方法发送消息给它们。 其机制是，这个方法会将消息放入一个队里中， 然后将其转交给处理被接受消息的一个内部线程。 <code>&lt;span class=&quot;pre&quot;&gt;close()&lt;/span&gt;</code>​ 方法通过在队列中放入一个特殊的哨兵值（ActorExit）来关闭这个actor。 用户可以通过继承Actor并定义实现自己处理逻辑run()方法来定义新的actor。 <code>&lt;span class=&quot;pre&quot;&gt;ActorExit&lt;/span&gt;</code>​ 异常的使用就是用户自定义代码可以在需要的时候来捕获终止请求 （异常被get()方法抛出并传播出去）。</p>
<p>如果你放宽对于同步和异步消息发送的要求， 类actor对象还可以通过生成器来简化定义。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def print_actor():</span><br><span class="line">    while True:</span><br><span class="line"></span><br><span class="line">        try:</span><br><span class="line">            msg = yield      # Get a message</span><br><span class="line">            print(&#x27;Got:&#x27;, msg)</span><br><span class="line">        except GeneratorExit:</span><br><span class="line">            print(&#x27;Actor terminating&#x27;)</span><br><span class="line"></span><br><span class="line"># Sample use</span><br><span class="line">p = print_actor()</span><br><span class="line">next(p)     # Advance to the yield (ready to receive)</span><br><span class="line">p.send(&#x27;Hello&#x27;)</span><br><span class="line">p.send(&#x27;World&#x27;)</span><br><span class="line">p.close()</span><br></pre></td></tr></table></figure>
<h2 id="讨论-9"><a href="#讨论-9" class="headerlink" title="讨论"></a>讨论</h2><p>actor模式的魅力就在于它的简单性。 实际上，这里仅仅只有一个核心操作 <code>&lt;span class=&quot;pre&quot;&gt;send()&lt;/span&gt;</code>​ . 甚至，对于在基于actor系统中的“消息”的泛化概念可以已多种方式被扩展。 例如，你可以以元组形式传递标签消息，让actor执行不同的操作，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class TaggedActor(Actor):</span><br><span class="line">    def run(self):</span><br><span class="line">        while True:</span><br><span class="line">             tag, *payload = self.recv()</span><br><span class="line">             getattr(self,&#x27;do_&#x27;+tag)(*payload)</span><br><span class="line"></span><br><span class="line">    # Methods correponding to different message tags</span><br><span class="line">    def do_A(self, x):</span><br><span class="line">        print(&#x27;Running A&#x27;, x)</span><br><span class="line"></span><br><span class="line">    def do_B(self, x, y):</span><br><span class="line">        print(&#x27;Running B&#x27;, x, y)</span><br><span class="line"></span><br><span class="line"># Example</span><br><span class="line">a = TaggedActor()</span><br><span class="line">a.start()</span><br><span class="line">a.send((&#x27;A&#x27;, 1))      # Invokes do_A(1)</span><br><span class="line">a.send((&#x27;B&#x27;, 2, 3))   # Invokes do_B(2,3)</span><br><span class="line">a.close()</span><br><span class="line">a.join()</span><br></pre></td></tr></table></figure>
<p>作为另外一个例子，下面的actor允许在一个工作者中运行任意的函数， 并且通过一个特殊的Result对象返回结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from threading import Event</span><br><span class="line">class Result:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self._evt = Event()</span><br><span class="line">        self._result = None</span><br><span class="line"></span><br><span class="line">    def set_result(self, value):</span><br><span class="line">        self._result = value</span><br><span class="line"></span><br><span class="line">        self._evt.set()</span><br><span class="line"></span><br><span class="line">    def result(self):</span><br><span class="line">        self._evt.wait()</span><br><span class="line">        return self._result</span><br><span class="line"></span><br><span class="line">class Worker(Actor):</span><br><span class="line">    def submit(self, func, *args, **kwargs):</span><br><span class="line">        r = Result()</span><br><span class="line">        self.send((func, args, kwargs, r))</span><br><span class="line">        return r</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        while True:</span><br><span class="line">            func, args, kwargs, r = self.recv()</span><br><span class="line">            r.set_result(func(*args, **kwargs))</span><br><span class="line"></span><br><span class="line"># Example use</span><br><span class="line">worker = Worker()</span><br><span class="line">worker.start()</span><br><span class="line">r = worker.submit(pow, 2, 3)</span><br><span class="line">worker.close()</span><br><span class="line">worker.join()</span><br><span class="line">print(r.result())</span><br></pre></td></tr></table></figure>
<p>最后，“发送”一个任务消息的概念可以被扩展到多进程甚至是大型分布式系统中去。 例如，一个类actor对象的 <code>send()</code>​ 方法可以被编程让它能在一个套接字连接上传输数据 或通过某些消息中间件（比如AMQP、ZMQ等）来发送。</p>
<h1 id="实现消息发布-订阅模型"><a href="#实现消息发布-订阅模型" class="headerlink" title="实现消息发布/订阅模型"></a>实现消息发布/订阅模型</h1><p>TODO</p>
<h1 id="使用生成器代替线程"><a href="#使用生成器代替线程" class="headerlink" title="使用生成器代替线程"></a>使用生成器代替线程</h1><p>TODO</p>
<h1 id="多个线程队列轮询"><a href="#多个线程队列轮询" class="headerlink" title="多个线程队列轮询"></a>多个线程队列轮询</h1><p>TODO</p>
<h1 id="在Unix系统上面启动守护线程"><a href="#在Unix系统上面启动守护线程" class="headerlink" title="在Unix系统上面启动守护线程"></a>在Unix系统上面启动守护线程</h1><p>TODO</p>
<h1 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h1><p><a target="_blank" rel="noopener" href="https://python3-cookbook.readthedocs.io/zh-cn/latest/chapters/p12_concurrency.html">Python CookBook</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Met Guo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://guoyujian.github.io/2024/03/08/Python-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%B0%8F%E7%BB%931/">https://guoyujian.github.io/2024/03/08/Python-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%B0%8F%E7%BB%931/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://guoyujian.github.io">Gmet's Blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Python/">Python</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2024/03/14/%E5%8D%8F%E7%A8%8B%EF%BC%8C%E4%BB%8Eyield%E8%AF%B4%E8%B5%B7/"><i class="fa fa-chevron-left">  </i><span>协程，从yield说起</span></a></div><div class="next-post pull-right"><a href="/2024/03/08/Fluent-Python%E7%AC%94%E8%AE%B0%E6%8C%81%E7%BB%AD%E6%95%B4%E7%90%86/"><span>Fluent Python笔记持续整理</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://images7.alphacoders.com/550/thumb-1920-550739.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2021 - 2025 By Met Guo</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.8.2"></script><script src="/js/fancybox.js?version=1.8.2"></script><script src="/js/sidebar.js?version=1.8.2"></script><script src="/js/copy.js?version=1.8.2"></script><script src="/js/fireworks.js?version=1.8.2"></script><script src="/js/transition.js?version=1.8.2"></script><script src="/js/scroll.js?version=1.8.2"></script><script src="/js/head.js?version=1.8.2"></script><script src="/js/search/algolia.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>